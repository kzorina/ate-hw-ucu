Distributed States Logic  Carlo Montangero  Laura Semini  Dipartimento di Informatica, UniversitaÄšÂ€ di Pisa, monta,semini @di.unipi.it    Abstract  example is the computation below, where the oblique arrow  denotes a communication.  We introduce a temporal logic to reason on global applications. First, we define a modal logic for localities that  embeds the local theories of each component into a theory  of the distributed states of the system. We provide the logic  with a sound and complete axiomatization. Then, we extend the logic with a temporal operator. The contribution  is that it is possible to reason about properties that involve  several components in a natural way, even in the absence of  a global clock, as required in an asynchronous setting.  1. Introduction  The current trend towards global computing needs software that works in an open, concurrent, distributed, highÃ¢Â€Â“  latency, securityÃ¢Â€Â“sensitive environment. Besides, this software must be reliable, scalable, and Ã¢Â€Âœshipped todayÃ¢Â€Â. In  response to the challenges posed by so demanding requirements, there is an increasing interest in the seamless integration of asynchronous communication in programming, coordination, and specification languages. Indeed, messageÃ¢Â€Â“  passing, eventÃ¢Â€Â“based programming, callÃ¢Â€Â“backs, continuations, dataflow models, workflow models etc. are ubiquitous in global computing. Notable examples in this direction are the delegateÃ¢Â€Â“based asynchronous calling model  of the Microsoft .NET Common Language Runtime liin Polyphonic C#. As another example,  braries, and  Oikos tl [14] deals with asynchronous communications in  coordination and specification languages.  As a contribution to the response to the new challenges,  we are developing YALL [10], an extension of temporal  logic to deal with distributed systems. YALL has operators to name system components and to relate, causally,  properties holding in distinguished components, in an asynchronous setting. A typical YALL formula might be:  m  (1)  m LT n                                              We proceed in two steps. First, we define DSL (Distributed  States Logic), a modal logic for localities that embeds the  theories describing the local states of each component into  a theory of the distributed states of the system. There is no  notion of time or state transition at this stage. DSL has a  sound and complete axiom system. Then, we define YALL  by adding temporal operators. Since DSL carries over all  meaningful propositional rules, like and simplification, in  such a way that they can be exploited orthogonally to temporal operators, the exploitation of the local theories becomes smooth and robust, while proving distributed properties. The final contribution is that in YALL it is easy to reason about properties that involve several components, even  in absence of a global clock, as required in an asynchronous  setting.  The major problem with DSL is the frame structure. The  usual choices to build a Kripke model for formulae like (1)  to be:  are to consider the set of worlds  ) the set of the states of a computation, i.e. the union of all  the states of the system components, like the circles in the  following figure. This approach was taken in [11, 5].              "  #          where operator LT is similar to UnityÃ¢Â€Â™s (leads to) [2], and  m and n express locality. Formula (1) says that a property  holding in component , causes properties and to hold  in future states of components and , respectively. An                  !              The problem of this choice is that it is not possible to reason  on logical relations between formulae like the premises or  the consequences of (1). In particular, a formula like  n  m  n  (2)                which would permit to weaken the consequences of (1)  would not be a legal formula, since no world can satisfy  m .  the conjunction n        ) the set of global states, or snapshots, of the system,  where each world is a set of states, one for each component.  These sets must satisfy some constraints to be coherent with  the communications between the subsystems.  Proceedings of the Ninth International Symposium on Temporal Representation and Reasoning (TIMEÃ¢Â€Â™02)  1530-1311/02 $17.00 Ã‚Å  2002 IEEE      Let be the set of states of component , with  for  ,  ,  , and  . The  frame  , where  if and only  if  is a singleton set  , with  , satisfies the  conditions (4)Ã¢Â€Â“(6) above. We call these frames, frames on  , and call  the set of distributed states, from which  play a central  the name of the logic DSL. The frames on  role in the paper, since they are used to build the models for  YALL formulae. Some examples follow.  x          ) +  +    ,  +-  .  0+    x  7  x  7  7  M  y  z  ;  ^    7    /  M  q  G  x  M  ?  ,  A  ~    x  x  M  Ã‚Â  Ã‚Â‚  p    x  9  T      7  ^        )    1  1    ,      -1  2  01  1  3  5    T  x  9  g  9  P  P  P  9      p  9  g  g  7  ,  ^  Examples of worlds are  , while  would not be a legal world.  This choice is not well suited in the case of asynchronous  communication. Think of the case of property holding  and holding only in states , for  only in state  . The following formula would be valid in the model  m  n  (3)  7  6  7+  ?  )  ,  ,  6  1  -+  ;  B  B  ,  9  =  )  +  A  ;  9  1  =  -  ;    D  1  E  G  E  J      6  p  x  =  7    x    y  x    x  be built on  and  Examples. Let the set  , then the frame on  can be represented as:  ^    x  x  M  6  9  =  ,  ^  inferring a remote knowledge which is meaningless in an  asynchronous setting. Moreover, it would be natural to say  follows  . In this case, one  that world  could assert that n LT m holds, if and hold in  and  , respectively, even though no causal relationship exists  between these two states. Similar problems arise if we use  most logics for distributed systems (see, for instance [8, 15,  13, 3]), where components communicate via some form of  synchronization and, therefore, it is not possible to express  the asymmetric nature of causality we are interested in.  6  -+  6  01  9  +  ,  M  6    -  Ã‚Â†  Ã‚Â    Ã‚Â‡  Ã‚Âˆ  Ã‚Â‡  Ã‚Â‹  Ã‚Â‹  Ã‚ÂŒ  Ã‚Â  Ã‚Â  Ã‚Â“  Ã‚Â–  Ã‚Â’  Ã‚Â’  Ã‚Â–  Ã‚Â—  Ã‚Â—  Ã‚Â’  Ã‚Â˜  Ã‚Â–  Ã‚Â˜  =    x  =  -1  9  =  x  ^  Ã‚Â’  Ã‚Â  Ã‚Â  Ã‚Â  Ã‚Â“  Ã‚Â”  Ã‚Â•  Ã‚ÂÃ‚Â‘  Ã‚Â†  Ã‚Â‡  Ã‚Â–  Ã‚Â’  Ã‚ÂŒ  Ã‚Â†  Ã‚Â‡  Ã‚Â‹  Ã‚Â‹  Ã‚ÂŒ  -1  Ã‚Â  Ã‚Â  Ã‚Â  Ã‚Â“  Ã‚Ä½  Ã‚Â§Ã‚Â¨  Ã‚Ä„  Ã‚Å   Ã‚Ë˜  Ã‚Åš  Ã‚Å   Ã‚Ë˜  Ã‚Åš  Ã‚Âœ  Ã‚Ë˜  Ã‚Å   -+  As shown in the next sections, we can get the desired properties by using the powerÃ¢Â€Â“set of the set of all system states  as the semantic domain of DSL. This choice, together with  an appropriate nextÃ¢Â€Â“state relation, makes YALL a very expressive language, that fully meets the pragmatic expectations of a designer.  Ã‚Å  Ã‚Âœ  Ã‚Âœ  Ã‚Åš  Ã‚Âœ  Ã‚Ë˜  Ã‚Å   Ã‚Ë˜  Ã‚Âœ  Ã‚Åš  Ã‚Å   Ã‚Â  Ã‚Â†  Ã‚Â‡  Ã‚Âˆ  Ã‚Â‡  Ã‚Â‹  Ã‚Â  Ã‚Âš  Ã‚Â  Ã‚Â›  Ã‚ÂŒ  Ã‚Â†  Ã‚Â‡  Ã‚Âˆ  Ã‚Â‡  Ã‚Âˆ  Ã‚Â‹  Ã‚Â‡  Ã‚Â‹  Ã‚Â“  Ã‚Â†  Ã‚ÂŒ  Ã‚Â‹  Ã‚Â‡  Ã‚Âˆ  Ã‚Â‹  Ã‚Â‡  Ã‚Â‹  Ã‚ÂŒ  Ã‚Â‹  Ã‚Å¹  Ã‚Â  Ã‚Å¹  Ã‚Â  Ã‚Å¹  Ã‚Â  Ã‚Å¹  Ã‚Â  Ã‚Å¹  Ã‚Â  Ã‚Â  Ã‚Â  Ã‚Â  Ã‚Å¹  Ã‚Â  Ã‚Å¹  Ã‚Â  Ã‚Å¹  Ã‚Â  Ã‚Â  Ã‚Â  Ã‚Â  Ã‚Â  Ã‚Å¹  Ã‚Â  Ã‚Å¹  Ã‚Â  Ã‚ÂŸ  Ã‚Å¹  Ã‚Â  Ã‚Å¹  Ã‚Â  Ã‚Å¹  !  Ã‚Â  Ã‚ÅÃ‚Å¤  Ã‚Â†  Ã‚Â‡  Ã‚Â  Ã‚Å¹  Ã‚ÂŒ  Ã‚Â‹  Ã‚Â  Ã‚Â­Ã‚Å½  For the sake of readability, we often let , range over ,  with  , and use  , , m and n .  ,  ,  ,  If we take  , then the distributed state  satisfies m  n .  m  m holds, while  The implication m  the converse does not. Indeed, for  , and  ,  , we have  m  m ,  but not  m  . In YALL, this nonÃ¢Â€Â“equivalence  is useful to specify that an event can have different future  effects in a component, without constraining them to occur  m  m .  in the same state. Finally, m  mn if and  The formula mn is false. In fact,  only if there exists an  such that  ,  but  and  are disjoint. Conversely, mm is satisfiable,  and it is equivalent to m . The formula m is satisfied by  all the distributed states such that  .    +    M  q      Q  1  x  x      ^  ^  +  p  1  x  p  x  6    i  M  6  6  =    i  =  M  =  ^  6    6    9  =  V    =  V  V  V  ^  ^        ^  +  M  6  x  9  2. DSL    =  Ã‚Â´    ^  6    i  M  6  6  =    i  =  M  6  t    =  M      =    t  We assume a countable set of propositional letters  . The DSL formulae over a finite set of compoare defined by:  nents  L  6  M    9  9  P  P  Q  P  =  M  6        9  9  ,  P  P  P  T  9  =  -    M      V  Ã‚Å¥  V  V  ^  Ã‚Å¥  V  Ã‚Åº  ^  V  V  t  V  W  W  V  M  Y  V  Y  Y  [  V  Y  Y  \  mi  ^    Y  Y  V  V  +  1  p  x  6  x  is the propositional constant false, and m i for  are unary location operators. With mi we denote the  dual of mi , i.e., mi  mi  . With we denote true.  where  M  `  [  b  P  P  a  V  c  V  b  +  \  for DSL formulae is a tuple  A model  , with  ranging over . The  satisfy the following conditions:  reachability relations  Semantics.  x  V  e  +  x  T  P  P  M  q  z  y  Axiom system. DSL has the following axiomatization.  f  9  M  V  1  x  Ã‚Å¼  Ä‚Â€    g  y  e  \  9  t  =  Y  y  P  M  P  9  g    9  k  i  9  l  9  n  axioms of the propositional calculus  m  m  m  mm  mn      V  Ä‚Â  V  V  V  ^  ,  ^    b  g      b    b      Ä‚Âƒ  Ä‚Â„  Ä‚  Ä‚Â†  V  V  Ã‚Åº  7  b      k    9  p    l    g  l  9  (4)  p  l  g  Ä‚Âƒ  Ä‚Â„  Ä‚  Ä‚Â‡  b  7    b  b  7  Ã‚Â‹      k    9  p    l    g  l  9  p    n  l  7  (5)  (6)  M  g  n  7      k    9  p    l  q  r    g  n  P  l  9  n  for  p  g  7  G  M  q  [  Ä‚ÂŠ  Ä‚Âˆ  Ã‚Å¼  Ä‚ÂŠ  Ä‚ÂŠ  Ä‚Â‹  Ä‚ÂŠ  Ã‚Â‹  Ä‚ÂŒ  Ä‚Â  m  Ä‚Â  Ä‚Â  Ä‚ÂŠ  Example. Some examples of formulae that can be demm (axiom 4),  rived from the axioms follow: m  mm  m ,m  m  m ,m m  .  The semantics of DSL formulae is given by:  V  V    b      V  V  k    t  M  e  b    V  V  V  V  V  ^  ^    9    b    V  Ã‚Åº  f  Ä‚ÂŠ  ;        Ã‚Åº      b    f  k    t  iff  M  9  p  k  Soundness is easy to see. We prove completeness.    i      V  f  k    t  M  9    V  V  iff not  iff  iff  V  f  k    t  M  9      V  and  and  ^  \  f  k    t  M    9    f  k  9    t  M  mi  V  f  r  l  k    t  M  9    k  P    9  l  p  g    V  ^  f  k    t  M  Completeness. Let  be  the canonical model for DSL. We recall that worlds in  9  Ä‚Â‘  Ã‚Â‚  Ä‚Â“  Ä‚Â‘  9  Ã‚Â‚  g  Ä‚Â“  Ä‚Â‘  9  P  P  P  9  Ã‚Â‚  g  V  ,  f    9  l  t  M  7  Proceedings of the Ninth International Symposium on Temporal Representation and Reasoning (TIMEÃ¢Â€Â™02)  1530-1311/02 $17.00 Ã‚Å  2002 IEEE  Ä‚Â“  Ä‚Â‘  9  T    i  Ã‚Â‚  Ä‚Â“    Ä‚Â§  are maximal consistent sets of DSL formulae (DSL Ã¢Â€Â“  MCS in the following), and that  if and only  . We need to show that, for all ,  if mi  satisfies conditions (4)Ã¢Â€Â“(6).  Cond (4). We prove:  Suppose mi  . is a DSL Ã¢Â€Â“ MCS and hence (see DSL1)  mi mi  . But  , hence mi  . Thus, by modus ponens,  .  Cond (5). We prove that  and  imply  .  It is sufficient to prove that  . In fact, and are  DSL Ã¢Â€Â“ MCS and it is not the case that  , thus  . Let  . is a DSL Ã¢Â€Â“ MCS and hence (see DSL1) it includes  mi  mi . But  , hence  mi  .  . As  , we  Thus, by modus ponens, mi  conclude that  .  Cond (6). We prove that  implies  , for  .  . As is a DSL Ã¢Â€Â“ MCS, it includes  Assume  mi mj (DSL2). As  , then mj  . As  Ä‚Â‘  Ã‚Â‚  Ä‚Â¨  Ä‚Å  Ä‚Å¤  Ä‚Å¹  Ä‚Â­  Ã‚Â‹  Ä‚ÂŠ  Ä‚Â‹  LT  Ä‚Å½  Ä‚ÂŠ  Ä‚Å½  Ä‚Â‹  Ä‚ÂŠ  Ä‚ÂŠ  Ã‚Â‹  Ä‚ÂŠ  Ã‚Â‹  Ä‚ÂŠ  Ä‚Â‹  Ä‚Å½  Ä‚Â“    k    9  V  p  Ä‚Â‘  l  Ã‚Â‚  Ã‚Â‹  Ä‚Â“  g  Ä‚ÂŠ  Ä‚ÂŠ  LT  LT  Ä‚Å½  Ä‚Å½  Ä‚Å½  V  7  p  b  k    p  l  Ä‚Â‘  Ã‚Â‚  Ä‚Â“  Ä‚ÂŠ  LT  Ä‚Å½  LT  Ä‚Å½  LT  Ä‚Â°  Ä‚ÂŠ  LT  Ä‚Â°  Ä‚Å½  Ä‚Å½  LT  Ä‚ÂŠ  Ä‚Å½  LT  Ä‚ÂŠ  Ä‚Â°  g      7  k    9  p  Ä‚Â‘  l  Ã‚Â‚  Ä‚Â“      g  l  9  p  Ä‚Â‘  l  Ã‚Â‚  LT  Ä‚Â“  g  Ä‚ÂŠ  Ä‚Â°  Ä‚Â°  Ä‚ÂŠ  Ä‚Ä…  LT  Ä‚Å½  Ä‚ÂŠ  LT  Ä‚Â°  Ä‚Å½  Ä‚Ë›  V  7  p  b  7  k  l      V  b  b    V  V      p  k  k    9  p  Ä‚Â‘  l  Ã‚Â‚  Ä‚Â“  b    g  V  V  7    p  p  l  l      k    9  p  Ä‚Â‘  l  Ã‚Â‚    Ä‚Â“  l  g  9  p  n  7  Ä‚Â‘  Ã‚Â‚  Ä‚Â“  M  g  l  n  7  l  n  Ã‚Â´  l  n  M  l  Ä‚Â—  n  l  n  V  p  Discussion, examples, and comparison with related work  (e.g. [1, 4, 6, 7, 9, 12]) can be found in [10].  Acknowledgments We gratefully thank Massimo  Franceschet, Angelo Montanari, and Francesca Scozzari for interesting discussions on a draft of the paper. The  work was supported by Projects Sahara and Degas.  k  l      V  V    b  V  b  k      9  p  Ä‚Â‘  l  Ã‚Â‚  V  Ä‚Â“    b  p  l  g    7  V    p  b  l  l  9  p  Ä‚Â‘  n  Ã‚Â‚  References  Ä‚Â“  g  V  7  p  n    k    9  p  Ä‚Â‘  l  Ã‚Â‚  Ä‚Â“  q  r  g  n  P    7    l  9  Ä‚Â‘  p  n  Ã‚Â‚  Ä‚Â“  G  M  q  g    ;    l  9  Ä‚Â‘  p  n  Ã‚Â‚  Ä‚Â“  k  g    ;  b  k  b    9  p  Ä‚Â‘  l  Ã‚Â‚  Ä‚Â“  b  p  g  l  [  [  7    Ä‚Â‘    l  9  Ã‚Â‚  , then  Ä‚Â“  p  n  g  , which is an absurd.  p  n  [  ;  3. Adding time: a fragment of YALL  YALL extends DSL adding temporal operators. We consider here only operator LT, that expresses a liveness condition, and is similar to UnityÃ¢Â€Â™s (leads to).    Ä‚Â™  W  W  V  V  V  where  ^  LT  M  Y  V  V  ^  p    x  Ä‚Âš  9  P  Y  Semantics. YALL models are built on structures like the  one at point ) above. The arrows between states denote  transitions and communications, and define a causal dependency relationship. We introduce a partial order rela, where  if and only if  causally  tion  depends on . For example, in the named structure,  .    ^  ^    g    g    )  +  +  9  p  9  Ä‚Âœ      ,  Ä‚Âœ  )  9  +  01  9    +  9  ,    01  9  p  g  Ä‚Âœ    A model  is a tuple  f    T  x  9  g  9  P  P  P  9  E  g  , where    9  9  i  ,    ^  ^  Ä‚Â  Ä‚ÂŸ  Ä‚Ä„  ^  ^  Ä‚Ë˜  p  r  p    9  P  p  9  g  Ä‚Âœ    ^  ^  ^  E  Ä‚Ë˜  p  r  p    9  P  p  9  g  Ä‚Âœ  [1] C. Areces. Logic Engineering. The Case of Description and  Hybrid Logics. PhD thesis, Univ. of Amsterdam, 2000.  [2] K. Chandy and J. Misra. Parallel Program Design: A Foundation. Addison-Wesley, Reading Mass., 1988.  [3] H.-D. Ehrich, C. Caleiro, A. Sernadas, and G. Denker. Logics for specifying concurrent information systems. In Logic  for Databases and Information Systems, pages 167Ã¢Â€Â“198.  Kluver Academic Publishers, 1998.  [4] R. Fagin, J. Halpern, Y. Moses, and M. Vardi. Reasoning  About Knowledge. MIT Press, 1995.  [5] G. Ferrari, C. Montangero, L. Semini, and S. Semprini.  Mark, a reasoning kit for mobility. Automated Software Engineering, 9(2):137Ã¢Â€Â“150, Apr 2002.  [6] S. Katz and D. Peled. Interleaving set temporal logic. Theoretical Computer Science, 75(3):263Ã¢Â€Â“287, 1990.  [7] Lodaya, Ramanujam, and Thiagarajan. Temporal logics for  communicating sequential agents: I. Int. Journal of Found.  of Computer Science, 3(2):117Ã¢Â€Â“159, Ã¢Â€Â™92.  [8] A. Masini and A. Maggiolo-Schettini. TTL: A formalism to  describe local and global properties of distributed systems.  Theor. Informatics and Applic., 26(2):115Ã¢Â€Â“149, 1992.  [9] A. Montanari. Metric and Layered Temporal Logic for Time  Granularity. PhD thesis, University of Amsterdam, 1996.  [10] C. Montangero and L. Semini. Distributed states logic.  Technical Report TR-02-05, Dipartimento di Informatica,  2002. At www.di.unipi.it/ricerca/TR/tr.htmlÃ¢Â€Â.  [11] C. Montangero and L. Semini. Composing Specifications  for Coordination. In Proc. COORDINATION 99, LNCS  1594, pages 118Ã¢Â€Â“133, 1999.  [12] Pinter and Wolper. A temporal logic for reasoning about partially ordered specifications. In Proc. 3 ACM Principles of  Distributed Computing, pages 28Ã¢Â€Â“37, 1984.  [13] R. Ramanujam. Locally linear time temporal logic. In Proc.  IEEE Symp. on Logic In Computer Science, pages 118Ã¢Â€Â“  127. IEEE Computer Society, 1996.  [14] L. Semini and C. Montangero. A Refinement Calculus for  Tuple Spaces. Science of Computer Programming, 34:79Ã¢Â€Â“  140, 1999.  [15] P. S. Thiagarajan and J. G. Henriksen. Distributed versions  of linear time temporal logic: A trace perspective. In Lectures on Petri Nets I: Basic Models, Advances in Petri Nets,  LNCS 1491, pages 643Ã¢Â€Â“681, 1998.  Ä‚Å‚  Let  be a model, and  f  the set of its initial states:  Ä‚Å›  )  Ä‚Å›  Ä‚Å‚  V  Ä‚Â  V  Ä‚ÂŸ  Ä‚Ë˜  f  t  M  Ä‚Â¤  t  Ä‚Ä½  M  P  V  V  Ä‚Â  )  Ä‚ÂŸ  ^  f  t  M  Ä‚Â¤  LT  Ä‚Ë˜  Ä‚Ä½  P  V  t  where  t  M  M  implies  )  V  ^  ^  ^  r  Ä‚Ä½  t  M  P  is the DSL satisfiability relation.  Rules. We present the most useful rules of the logic. In  the first rule (necessitation) we use  for the sake of  comprehension.  Ä‚Åš  Ä‚Â‘  Ã‚Â‚  Ä‚Â´  Ä‚Â“  Proceedings of the Ninth International Symposium on Temporal Representation and Reasoning (TIMEÃ¢Â€Â™02)  1530-1311/02 $17.00 Ã‚Å  2002 IEEE  Ä‚Â´ 