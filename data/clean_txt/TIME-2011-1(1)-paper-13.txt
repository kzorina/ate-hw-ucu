Annals of Mathematics and Artificial Intelligence manuscript No.  (will be inserted by the editor)  The Light Side of Interval Temporal Logic: the  Bernays-Schönfinkel fragment of CDT  Davide Bresolin · Dario Della Monica · Angelo  Montanari · Guido Sciavicco  Received: date / Accepted: date  Abstract Decidability and complexity of the satisfiability problem for the logics of time  intervals have been extensively studied in the recent years. Even though most interval logics turn out to be undecidable, meaningful exceptions exist, such as the logics of temporal  neighborhood and (some of) the logics of the subinterval relation. In this paper, we explore  a different path to decidability: instead of restricting the set of modalities or imposing severe semantic restrictions, we take the most expressive interval temporal logic studied so  far, namely, Venema’s CDT, and we suitably limit the negation depth of modalities. The  decidability of the satisfiability problem for the resulting fragment, called CDTBS , over the  class of all linear orders, is proved by embedding it into a well-known decidable quantifier  prefix class of first-order logic, namely, Bernays-Schönfinkel class. In addition, we show  that CDTBS is in fact NP-complete (Bernays-Schönfinkel class is NEXPTIME-complete),  and we prove its expressive completeness with respect to a suitable fragment of BernaysSchönfinkel class. Finally, we show that any increase in the negation depth of CDTBS modalities immediately yields undecidability.  Keywords Interval temporal logic · Tableau methods · Decidability · Complexity  1 Introduction  In the recent years, the study of temporal reasoning via interval-based (logical) approaches  has been very intensive. Since the seminal work by Halpern and Shoham [18] and VenD. Bresolin  Dept. of Computer Science, University of Verona, Italy  E-mail: davide.bresolin@univr.it  D. Della Monica  ICE-TCS, School of Computer Science, Reykjavik University, Iceland  E-mail: dariodm@ru.is  A. Montanari  Dept. of Mathematics and Computer Science, University of Udine, Italy  E-mail: angelo.montanari@uniud.it  G. Sciavicco  Dept. of Information and Communication Engineering, University of Murcia, Spain  E-mail: guido@um.es  2  Davide Bresolin et al  ema [33], a series of papers on interval temporal logics has been published, e.g., [5, 6, 9–11,  23, 24, 29]. As an effect, the problem of classifying all “natural”, genuinely interval-based  (that is, all intervals over a linear order are considered, and no projection principle is applied [17]) logics with respect to their expressive and computational power has been extensively studied and almost completely solved.  Propositional interval temporal logics are modal logics, interpreted over linearly- or  partially-ordered sets, whose proposition letters are evaluated over intervals instead of over  points. They differ from each other in the number and type of basic relations between intervals that are captured by their modalities, by the linear order(s) over which they are interpreted, and by the inclusion or exclusion of point-intervals (intervals with coincident endpoints). In the hierarchy of existing interval temporal logics based on their expressive power,  the top element is Venema’s CDT [33], whose language features three binary modalities,  corresponding to the three possible ways to place a point with respect to the two endpoints  of a given interval, and a modal constant, that identifies point-intervals. The second-highest  logic in the hierarchy is Halpern and Shoham’s HS [19], which features one unary modality  for each Allen’s relation between pairs of intervals [1]. Both in CDT and in HS, satisfiability turns out to be undecidable, no matters what class of linear orders is considered (all,  discrete, dense, finite, the linear order of natural numbers, and so on) [19].  In the recent years, some fragments of HS with a better computational behavior have  been identified. Meaningful examples include, but are not limited to, AA (a.k.a. Propositional Neighborhood Logic, PNL), which features two modalities for Allen’s relations meets  and met by, and is decidable over all meaningful classes of linear orders [8, 16]; its extension AABB [28], that includes modalities for Allen’s relation’s starts and started by, and its  mirror image AAEE, with additional modalities for Allen’s relations finishes and finished  by, which are decidable over the class of finite linear orders and undecidable everywhere  else; and BBDDLL (and its mirror image EEDDLL), with modalities for Allen’s relations  starts, started by, during, contains, before, and after, which is decidable over dense linear  orders [27] and undecidable over finite and (weakly) discrete linear orders (as a matter of  fact, one-modality logics D and D are already undecidable over the classes of finite and  discrete linear orders [23])1 .  The situation with classical first-order logic is somehow similar. Since it has been shown  that satisfiability for the full language is undecidable, a great effort has been made in order  to identify more and more expressive decidable fragments. At least three different strategies  have been pursued: (i) limiting the number of variables of the language, (ii) limiting the type  of formulas allowed by relativizing quantification (guarded fragments), and (iii) limiting the  structure and the shape of the quantifier prefix.  First-order logics with a restriction on the number of variables have been already studied in connection with interval temporal logics. Most notably, AA has been proved to be  expressively equivalent to the two-variable fragment of first-order logic over linear orders.  Such a fragment of first-order logic has been shown to be NEXPTIME-complete over various classes of linear orders in [30]. Decidability of AA over the same classes of orders  immediately follows. Guarded fragments of first-order logic (see [2] for an introduction)  have been shown to be quite useful to explain the good computational properties of modal  logics, but, to the best of our knowledge, they have never been considered in the framework of interval temporal logics. As a matter of fact, mapping interval temporal logics into  guarded fragments of first-order logic would require (i) the use of a relation in the guards  1  In all these cases, including or excluding point-intervals makes no difference.  The Light Side of Interval Temporal Logic: the Bernays-Schönfinkel fragment of CDT  3  which is (or can be forced to behave as) a linear order, (ii) at least three distinct variables,  (iii) uninterpreted predicates which are at least binary, and (iv) quantifications with Boolean  combinations of atomic formulas as guards. Such requirements are not met by known decidable guarded fragments of first-order logic2 .  In this paper, we explore an original path to decidability of interval temporal logics,  which follows the third strategy: we look for meaningful interval temporal logics that can  be embedded into decidable quantifier prefix classes of first-order logics. The decidability  of the latter family of logics does not depend on the shape of the quantifier prefix only, but  also on the number and the arity of predicate and function symbols that are allowed in the  formulas, and on the presence/absence of equality. Seven different decidable classes have  been identified in the literature (a survey on quantifier prefix classes of first-order logic can  be found in [4]).  We focus our attention on the prefix vocabulary class identified by Bernays and Schönfinkel in 1928 (a.k.a. Bernays, Schönfinkel, and Ramsey class, as Ramsey proved that decidability is preserved even when equality is included) [4]. It consists of all and only formulas  in prenex form whose quantifier prefix is of the form ∃x1 . . . ∃xn ∀y1 . . .∀ym and whose matrix may include predicate symbols of any arity (but no function symbols) and, possibly,  equality. It is well known that Bernays-Schönfinkel fragment of first-order logic is expressive enough to model a linear order devoid of specific properties such as discreteness or  density. Moreover, it can express simple frame properties, commonly studied in the interval  temporal logic literature, like, for instance, boundedness.  We identify a syntactic fragment of CDT [33], called CDTBS , whose standard translation fits into Bernays-Schönfinkel class, by limiting the negation depth of the modalities to  one, that is, by constraining temporal operators to occur in the scope of at most one negation. Decidability of CDTBS , over the class of all linear orders, immediately follows. Then,  a precise characterization of CDTBS expressive power is given by showing that it is expressively complete with respect to a suitable fragment of Bernays and Schönfinkel class.  A decision procedure for CDTBS is then obtained by tailoring the non-terminating tableaubased deduction system for CDT developed in [15] to it. As a by-product, we prove that the  satisfiability problem for CDTBS is NP-complete, in sharp contrast with that of BernaysSchönfinkel class, which is NEXPTIME-complete, when relation symbols of unbounded  arity are allowed, and PSPACE, when relation symbols have bounded arity, e.g., only binary  relations are allowed, as it is the case for interval logics. Finally, we show that any increase  in the negation depth of CDTBS modalities immediately yields undecidability.  The paper is structured as follows. In Section 2, we provide background knowledge  about Bernays and Schönfinkel fragment of first-order logic. In Section 3, we define syntax  and semantics of CDTBS , and we define its standard translation. Decidability immediately  follows from the inclusion of the resulting set of formulas in Bernays and Schönfinkel class.  Next, in Section 4, we prove the expressive completeness of CDTBS with respect to a suitable  fragment of such a class. In Section 5, we devise a sound, complete, and terminating tableau  method for CDTBS . Finally, in Section 6, we show that fairly natural extensions of CDTBS  do not preserve decidability. An assessment of the work done and possible future research  directions are given in Section 7.  2 Extended guarded fragments includes loosely guarded fragments, which allow guards to be more complex than simple atoms [3], and guarded fragments with transitive guards (in general, transitivity cannot be  expressed as a guarded formula) [31].  4  Davide Bresolin et al  2 Bernays-Schönfinkel class  Bernays-Schönfinkel prefix vocabulary class, denoted here by FOBS , consists of all and  only those first-order formulas, making use of any relational symbol of any arity, including  equality, that can be put in prenex form by using a quantifier prefix of the form ∃x ∀y,  where x = x1 . . . xn and y = y1 . . . ym are (possibly empty) vectors of first-order variables. It is  well known that the satisfiability problem for FOBS is NEXPTIME-complete [4]. Moreover,  FOBS is closed under conjunction and disjunction, since all its formulas can be thought of as  sentences (free variables can be existentially quantified), but it is not closed under negation.  To simplify the proofs of the results given in the paper, we introduce an alternative  definition of FOBS via the following abstract grammar:  α ::= α∃ | α ∧ α | α ∨ α | ∃x.α | ¬α∃ for α∃ of the form ∃x.α∃  α∃ ::= A(x) | ¬A(x) | α∃ ∧ α∃ | α∃ ∨ α∃ | ∃x.α∃  A(x) ::= any relational symbol of arbitrary arity, including equality  (1)  (2)  (3)  Grammar (1) generates a fragment of first-order logic consisting of all and only those formulas where existential quantifiers can occur in the scope of at most one negation. While  any prenex formula of the form ∃x ∀y β can be generated by grammar (1), the converse is not  true, since grammar (1) can generate also formulas which are not in prenex form. However,  it is not difficult to show that any formula generated by grammar (1) can be transformed into  an equivalent prenex formula of the correct form, as shown by the following proposition.  Proposition 1 Any formula generated by grammar (1) can be transformed into a prenex  formula of the form ∃x∀yβ , with β quantifier-free.  Proof Let α be a formula generated by grammar (1). We show that there exists an equivalent  formula τ (α ) of the required form by structural induction. We start with the set of formulas  generated by the sub-grammar for α∃ , and we show that each of them can be transformed  into a formula of the form ∃xβ , with β quantifier-free. The case in which α is a relation  or the negation of a relation is trivial. Consider now the case of formulas α = α∃ ∧ α∃′ .  By inductive hypothesis, τ (α∃ ) = ∃zβ and τ (α∃′ ) = ∃wβ ′ , for some quantifier-free β and  β ′ . Without loss of generality, we can assume z ∩ w = 0/ (if this is not the case, we can  apply a suitable variable substitution), and thus α is equivalent to ∃zw(β ∧ β ′ ). The case of  disjunction is similar, and thus omitted. Consider now the case of formulas α = ∃x.α∃ . By  inductive hypothesis, τ (α∃ ) = ∃wβ , for some quantifier-free β , with x 6∈ w, and thus α is  equivalent to ∃x∃wβ . Let us consider now an arbitrary formula generated by grammar (1).  The only interesting case is the one for the negation of existential quantifiers. Let α =  ¬∃x.α∃ . By inductive hypothesis, τ (∃x.α∃ ) = ∃x∃wβ , for some quantifier-free β , with x 6∈  w. Hence, α is equivalent to the formula (in prenex form) ∀x∀w¬β .  ⊔  ⊓  Thanks to the above result, from now on we will assume that any FOBS -formula has been  generated by grammar (1).  3 Decidability of the logic CDTBS over the class of all linear orders  Interval temporal logics are usually interpreted over a linearly ordered set D = hD, <i. In  this setting, an interval on D is an ordered pair [di , d j ] with di ≤ d j (we refer to such a case as  The Light Side of Interval Temporal Logic: the Bernays-Schönfinkel fragment of CDT  5  C  di  dk  dj  Fig. 1 The ternary relation chop, splitting the interval [di ,d j ] into the subintervals [di ,dk ] and [dk ,d j ].  the non-strict semantics, in contrast with the strict one, that excludes degenerate intervals of  the form [di , di ]). The set of all intervals on D is denoted by I(D). The variety of all possible  relations between any two intervals has been studied by Allen [1], who identified 12 distinct  binary relations plus the equality relation. Halpern and Shoham modal logic of intervals,  abbreviated HS, can be viewed as the modal logic of Allen’s relations as it features one  modality for each such relation. As we already mentioned, HS turns out to be undecidable  over any meaningful class of linear orders [19]. In [33], the ternary relation chop, depicted in  Figure 1, has been taken into consideration. The corresponding binary modality C, together  with the two conjugated modalities D (done) and T (to do), and the modal constant π for  point-intervals define the interval temporal logic CDT. It can be easily shown that CDT  subsumes HS (in fact, it is strictly more expressive than HS), and thus it is undecidable  whenever HS is. In [20], Hodkinson et al systematically investigate the three fragments  of CDT with only one binary modality each (C, D, or T ), showing that each of them is  undecidable.  Formulas of CDT are built on a set of proposition letters A P = {p, q, . . . }, the Boolean  connectives ¬ and ∨, the three binary modalities C, D, and T , and the modal constant π , by  the following abstract grammar [33]:  ϕ ::= p | π | ¬ϕ | ϕ ∨ ϕ | ϕ C ϕ | ϕ D ϕ | ϕ T ϕ .  The other Boolean connectives can be viewed as suitable short forms, as usual. Similarly,  universal counterparts of the existential modalities C, D, and T can be defined by means of  negation in the standard way; CDT has not any special notation for them.  The semantics of CDT-formulas can be given in terms of concrete models of the form  M = hI(D),Vi, where V : A P → 2I(D) is a valuation function, as follows:  M, [di , d j ] p if and only if [di , d j ] ∈ V (p),  M, [di , d j ] π if and only if di = d j ,  M, [di , d j ] ¬ϕ if and only if M, [di , d j ] 6 ϕ ,  M, [di , d j ] ϕ ∨ ψ if and only if M, [di , d j ] ϕ or M, [di , d j ] ψ ,  M, [di , d j ] ϕ C ψ if and only if there exists di ≤ dk ≤ d j such that M, [di , dk ] ϕ and  that M, [dk , d j ] ψ ,  – M, [di , d j ] ϕ D ψ if and only if there exists dk ≤ di such that M, [dk , di ] ϕ and that  M, [dk , d j ] ψ ,  – M, [di , d j ] ϕ T ψ if and only if there exists dk ≥ d j such that M, [d j , dk ] ϕ and that  M, [di , dk ] ψ .  –  –  –  –  –  The standard translation is the usual way to express the semantics of a modal or temporal formula in first-order logic. Let ϕ be a CDT-formula and, for every p ∈ A P, let us  denote by the same symbol p the corresponding binary relation. The standard translation  function ST (ϕ )[x, y] is defined as follows:  – ST (ϕ )[x, y] = x ≤ y ∧ ST ′ (ϕ )[x, y],  where x, y are two first-order variables and ST ′ (ϕ )[x, y] is inductively defined as follows:  – ST ′ (p)[x, y] = p(x, y),  6  Davide Bresolin et al  –  –  –  –  –  –  ST ′ (π )[x, y] = (x = y),  ST ′ (¬ϕ )[x, y] = ¬ST ′ (ϕ )[x, y],  ST ′ (ϕ ∨ ψ )[x, y] = ST ′ (ϕ )[x, y] ∨ ST ′ (ψ )[x, y],  ST ′ (ϕ C ψ )[x, y] = ∃z(x ≤ z ≤ y ∧ ST ′ (ϕ )[x, z] ∧ ST ′ (ψ )[z, y]),  ST ′ (ϕ D ψ )[x, y] = ∃z(z ≤ x ∧ ST ′ (ϕ )[z, x] ∧ ST ′ (ψ )[z, y]),  ST ′ (ϕ T ψ )[x, y] = ∃z(y ≤ z ∧ ST ′ (ϕ )[y, z] ∧ ST ′ (ψ )[x, z]).  As a general rule, the standard translation makes it possible to reduce the satisfiability problem for a modal logic to a first-order satisfiability problem: a modal formula ϕ is satisfiable  if and only if its standard translation, evaluated on a pair of points x, y, is (first-order) satisfiable. Now, we ask ourselves the following question: which CDT-formulas are such that  their satisfiability problem can be reduced to a first-order satisfiability problem in BernaysSchönfinkel class? To answer this question, we define an abstract grammar that generates  only CDT-formulas suitably limited in the negation depth of modalities:  ϕ ::= ϕ∃ | ϕ ∧ ϕ | ϕ ∨ ϕ | ϕ C ϕ | ϕ D ϕ | ϕ T ϕ |  ¬(ϕ∃ C ϕ∃ ) | ¬(ϕ∃ D ϕ∃ ) | ¬(ϕ∃ T ϕ∃ )  ϕ∃ ::= π | ¬π | p | ¬p | ϕ∃ ∧ ϕ∃ | ϕ∃ ∨ ϕ∃ | ϕ∃ C ϕ∃ | ϕ∃ D ϕ∃ | ϕ∃ T ϕ∃  (4)  (5)  The above grammar generates a fragment of CDT, that we call CDTBS , which consists  of all and only those formulas where the modalities C, D, and T can occur in the scope of  at most one negation. The next lemma shows that the above-defined standard translation  maps CDTBS -formulas into Bernays-Schönfinkel class. It is easy to check that the syntactic  limitations of CDTBS do not prevent it from expressing all HS modalities (it only constrains  the way in which they can be composed). As an example, hBiϕ is captured by ϕ C ¬π .  Similar encodings can be given for the other HS modalities [33].  Lemma 1 For every CDTBS -formula ϕ , its standard translation ST (ϕ )[x, y] is an FOBS formula, with free variables x and y.  Proof The proof is by structural induction. We start with the set of formulas generated by  the sub-grammar for ϕ∃ , and we show that the standard translation of each of these formulas  belongs to the sub-grammar for α∃ and it has x, y as its free variables.  As for the base case, let ϕ∃ = p, for some proposition letter p. By definition, ST (p)[x, y]  = x ≤ y ∧ p(x, y); the thesis immediately follows. The cases ¬p, π , and ¬π are similar,  and thus omitted. As for the case of conjunction, let ϕ∃ = ϕ∃′ ∧ ϕ∃′′ . By definition, ST (ϕ∃′ ∧  ϕ∃′′ )[x, y] = x ≤ y ∧ ST ′ (ϕ∃′ )[x, y] ∧ ST ′ (ϕ∃′′ )[x, y]. By inductive hypothesis, both ST (ϕ∃′ )[x, y]  and ST (ϕ∃′′ )[x, y], and thus ST ′ (ϕ∃′ )[x, y] and ST ′ (ϕ∃′′ )[x, y], belong to the sub-grammar for  α∃ and have x, y as their free variables. It immediately follows that ST (ϕ∃′ ∧ ϕ∃′′ )[x, y] has the  required form. The case of disjunction is similar, and thus omitted.  Now, let ϕ∃ = ϕ∃′ C ϕ∃′′ . By definition, ST (ϕ∃′ C ϕ∃′′ )[x, y] = x ≤ y ∧ ∃z(x ≤ z ≤ y ∧ ST ′ (ϕ∃′ )  [x, z] ∧ ST ′ (ϕ∃′′ )[z, y]). By inductive hypothesis, ST ′ (ϕ∃′ )[x, z] is an α∃ -formula with x, z as its  free variables, and ST ′ (ϕ∃′′ )[z, y] is an α∃ -formula with z, y as its free variables. Hence, the  formula x ≤ y ∧ ∃z(x ≤ z ≤ y ∧ ST ′ (ϕ∃′ )[x, z] ∧ ST ′ (ϕ∃′′ )[z, y]) is an α∃ -formula with x, y as its  free variables. The other two cases for D and T can be dealt with in a similar way.  Let us consider now an arbitrary formula generated by the grammar. The only interesting cases are those for the negation of modalities. Let ϕ = ¬(ϕ∃′ C ϕ∃′′ ). By definition, ST (¬(ϕ∃′ C ϕ∃′′ ))[x, y] = x ≤ y ∧ ¬ST ′ (ϕ∃′ C ϕ∃′′ )[x, y], and ST ′ (ϕ∃′ C ϕ∃′′ )[x, y] = ∃z(x ≤  z ≤ y ∧ ST ′ (ϕ∃′ )[x, z] ∧ ST ′ (ϕ∃′′ )[z, y]). We have already shown that both ST ′ (ϕ∃′ )[x, z] and  ST ′ (ϕ∃′′ )[z, y] are α∃ -formulas with x, z and z, y as their free variables, respectively. Hence,  The Light Side of Interval Temporal Logic: the Bernays-Schönfinkel fragment of CDT  7  ∃z(x ≤ z ≤ y ∧ ST ′ (ϕ∃′ )[x, z] ∧ ST ′ (ϕ∃′′ )[z, y]) is an α∃ -formula with x, y as its free variables. It  immediately follows that ¬ST ′ (ϕ∃′ C ϕ∃′′ )[x, y] is an α -formula with x, y as its free variables,  and thus the thesis, as the conjunction of two α -formulas is an α -formula. The other two  cases can be dealt with in a similar way.  ⊔  ⊓  In order to prove the main theorem, it suffices to observe that the linear order < is captured  by the following axioms [4], whose conjunction Φ belongs to FOBS :  1.  2.  3.  4.  ∀x¬(x < x);  ∀x, y(x < y → ¬y < x);  ∀x, y, z(x < y ∧ y < z → x < z);  ∀x, y(x = y ∨ x < y ∨ y < x).  Theorem 1 The satisfiability problem for CDTBS over the class of all linear orders is decidable.  Proof By Lemma 1, if ϕ is a CDTBS -formula, then ∃x, yST (ϕ )[x, y] (the existential closure  of ST (ϕ )[x, y]) belongs to Bernays-Schönfinkel class. Satisfiability of ϕ can thus be reduced  to satisfiability of the FOBS -formula Φ ∧ ∃x, yST (ϕ )[x, y]. Since the satisfiability problem  for FOBS is decidable, decidability of CDTBS immediately follows.  ⊔  ⊓  The satisfiability problem for FOBS has been shown to be NEXPTIME-complete. The  proof relies on the observation that an FOBS -formula is satisfiable if and only if it has a  model with a number of elements bounded by the number of existential quantifiers [4, Proposition 6.2.17]. This immediately leads to a nondeterministic exponential-time procedure for  satisfiability checking. However, when we restrict our attention to formulas where the arity  of relational symbols is bounded (to two, in our case), the complexity of such a procedure  becomes PSPACE, since in this case a candidate model for the formula can be represented  using only a polynomial amount of memory. Hence, Theorem 1 gives us a PSPACE upperbound to the complexity of CDTBS . In Section 5, we will show that this bound is not tight,  by providing an NP decision procedure for the satisfiability of CDTBS .  4 Expressive completeness of CDTBS  In Section 3, we showed that CDTBS formulas can be translated into Bernays-Schönfinkel class FOBS of first-order logic with equality, thanks to the fact that the linear order  < can be expressed in this fragment. Inspired by the observation that the translation uses  only binary predicates, we now ask ourselves the following question: for every formula in  Bernays-Schönfinkel class of first-order logic, interpreted over the linear order < and limited  to binary predicates, is there an expressively equivalent CDTBS -formula? Similar expressivity comparison issues have been already investigated for various point- and interval-based  logics. A partial list includes basic results about the completeness of LTL with respect to  the first-order fragment of monadic second-order logic over Dedekind-complete linear orders and generalizations (Kamp’s Theorem and its extensions [12–14, 21, 22, 25]), the completeness of CDT with respect to the three-variable fragment of first-order logic over linear  orders, where at most two variables are free [33], the completeness of AA with respect to  two-variable first-order logic over linear orders [8], and the completeness of its metric extension, called MPNL, with respect to a fragment of two-variable first-order logic extended  with a successor function over N [7].  8  Davide Bresolin et al  We focus our attention on first-order logic interpreted over the linear order < and limited  to binary predicates, denoted by FO[<]. We will denote by FOn,m [<] the n-variable fragment  of FO[<], where at most m variables are free, and by FOω ,m [<] the fragment of FO[<] with  a denumerable set of variables, where at most m are free. Since interval logics are interpreted  over intervals (represented as pairs of points), the standard translation of any interval logic  formula is a formula with two free variables, and thus it belongs to FOω ,2 [<]. By analogy  with the case of other interval logics, e.g., [8, 33], to establish an expressive completeness  result for CDTBS , we will limit the number of variables of the corresponding first-order fragω ,m  n,m  [<]) the n-variable fragment (resp., the fragment  ment. We denote by FOBS  [<] (resp., FOBS  with a denumerable set of variables) of the language defined by grammar (1), where at most  m variables occur free.  In the following, we compare interval and first-order logics with respect to their ability  of expressing properties of a given interval in a model. We distinguish three cases: (i) the  comparison of two interval logics, (ii) the comparison of two fragments of first-order logic,  and (iii) the comparison of an interval logic and a fragment of first-order logic.  Given two interval logics (resp., fragments of first-order logic) L and L’, we say that  L’ is at least as expressive as L, denoted by L  L′ , if there is an (effective) translation  τ from L to L’ such that for every model M, interval [di , d j ] (resp., pair of points di , d j )  in M, and formula ϕ of L, M, [di , d j ] ϕ iff M, [di , d j ] τ (ϕ ) (resp., M |= ϕ (di , d j ) iff  M |= τ (ϕ )(di, d j )). Furthermore, we say that L’ is as expressive as L, denoted by L′ ≡ L, if  both L′  L and L  L′ , and we say that L’ is strictly more expressive than L, denoted by  L ≺ L′ , if L  L′ and L′ 6 L.  To compare the expressive power of an interval logic and a fragment of first-order logic,  we must cope with a technical problem: interval models constrain interval logic formulas  to be evaluated on ordered pairs [di , d j ], with di ≤ d j , only, while relational models do not  impose such a constraint. To solve it, we map each binary relation p of the considered  fragment of first-order logic into two distinct proposition letters p≤ and p≥ of the interval  logic. From [8], we borrow the following definition.  Definition 1 Let M = hI(D),VM i be an interval model. The corresponding relational model  η (M) is the pair hD,Vη (M)i, where, for every proposition letter p, Vη (M)(p) = {(a, b) ∈ D ×  D : [a, b] ∈ VM (p)}. Conversely, let M = hD,VM i be a relational model. The corresponding  interval model ζ (M) is the pair hI(D), Vζ (M) i, where, for every binary relation p and interval  [di , d j ], [di , d j ] ∈ Vζ (M) (p≤ ) iff (di , d j ) ∈ VM (p) and [di , d j ] ∈ Vζ (M) (p≥ ) iff (d j , di ) ∈ VM (p).  Given an interval logic LI and a fragment of first-order logic LFO , we say that LFO is at least  as expressive as LI , denoted by LI  LFO , if there exists an effective translation τ from LI to  LFO such that for any interval model M, interval [di , d j ], and LI -formula ϕ , M, [di , d j ] ϕ iff  η (M) |= τ (ϕ )(di, d j ). Conversely, we say that LI is at least as expressive as LFO , denoted  by LFO  LI , if there exists an effective translation τ ′ from LFO to LI such that, for any  relational model M, pair of points (di , d j ), and LFO -formula ϕ , M |= ϕ (di , d j ) if and only if  ζ (M), [di , d j ] τ ′ (ϕ ), if di ≤ d j , or ζ (M), [d j , di ] τ ′ (ϕ ), otherwise. LI ≡ LFO , LI ≺ LFO ,  and LFO ≺ LI are defined as usual.  In [32], Venema shows that the hierarchy of fragments FOn,2 [<], for n ≥ 2, is strict.  Theorem 2 For every n ≥ 2, FOn,2 [<] ≺ FOn+1,2 [<] (over the class of all linear orders).  The expressive completeness of the interval logic of temporal neighborhood AA with respect  to FO2,2 [<] and of CDT with respect to FO3,2 [<] have been proved by Bresolin et al in [8]  and by Venema in [33], respectively.  The Light Side of Interval Temporal Logic: the Bernays-Schönfinkel fragment of CDT  τ i, j (xi = x j )  τ i, j (x j = xi )  τ i, j (xi = xi )  τ i, j (x j = x j )  τ i, j (xi < x j )  τ i, j (x j < xi )  τ i, j (xi < xi )  τ i, j (x j < x j )  τ i, j (p(xi ,x j ))  τ i, j (p(x j ,xi ))  τ i, j (p(xi ,xi ))  τ i, j (p(x j ,x j ))  =  =  =  =  =  =  =  =  =  =  =  =  π  τ i, j (¬α (xi ,x j ))  π  ⊤  τ i, j (α (xi ,x j ) ∧ β (xi ,x j ))  ⊤  ¬π  τ i, j (α (xi ,x j ) ∨ β (xi ,x j ))  ⊥  τ i, j (∃xk (α (xi ,xk ) ∧ β (xk ,x j )))  ⊥  ⊥  p≤  p≥  (π ∧ p≤ )C ⊤  ⊤C (π ∧ p≤ )  9  = ¬τ i, j (α (xi ,x j ))  = τ i, j (α (xi ,x j )) ∧ τ i, j (β (xi ,x j ))  = τ i, j (α (xi ,x j )) ∨ τ i, j (β (xi ,x j ))  = τ k,i (α (xi ,xk )) D τ k, j (β (xk ,x j ))∨  τ i,k (α (xi ,xk ))C τ k, j (β (xk ,x j ))∨  τ j,k (β (xk ,x j )) T τ i,k (α (xi ,xk ))  Table 1 The mapping of FO3,2  sp [<] into CDTBS : translation rules.  Theorem 3 AA ≡ FO2,2 [<].  Theorem 4 CDT ≡ FO3,2 [<].  The proof of Theorem 2 shows that for any given n ≥ 2, there exist two models M1 and  M2 such that M1 and M2 satisfy the same set of FOn,2 [<]-formulas, and there exists an  FOn+1,2 [<]-formula which is satisfied by M1 and not by M2 . Equivalence of M1 and M2  with respect to FOn,2 [<]-formulas is established by a game-theoretic argument, while the  FOn+1,2 [<]-formula that differentiates the two models is the following one:  ^    ∃x1 ∃x2 . . . ∃xn ∃xn+1  ¬p(xi , x j ) .  (6)  xi 6=x j  Since such a formula belongs to Bernays-Schönfinkel fragment of first-order logic, the very  n+1,2  same argument can be used to prove that FOn,2  BS [<] ≺ FOBS [<], for any n ≥ 2. Moreover,  n,2  by Theorem 4, it holds that FOBS [<] ≺ FOn,2 [<], for every n ≥ 3: on the one hand, it  ω ,2  n,2  trivially holds that FOn,2  BS [<]  FO [<]; on the other hand, decidability of FOBS [<] and  n,2  n,2  undecidability of CDT imply that FO [<] 6 FOBS [<]. Finally, we have that, for every  n+1,2  n+1,2  n ≥ 3, FOn,2 [<] and FOBS  [<] are incomparable: on the one hand, FOBS  [<] 6 FOn,2 [<],  n+1,2  as formula (6) belongs to FOBS [<] and there is not an equivalent formula in FOn,2 [<];  n+1,2  on the other hand, FOBS  [<] is decidable, while FOn,2 [<] is not, and thus FOn,2 [<] 6  n+1,2  FOBS [<]. Hence, the following theorem holds.  Theorem 5 For every n ≥ 3, it holds that:  n−1,2  n,2  1. FOBS  [<] ≺ FOBS  [<];  n,2  n,2  2. FOBS [<] ≺ FO [<];  n+1,2  3. FOn,2 [<] and FOBS  [<] are incomparable  (over the class of all linear orders).  We conclude the section by showing that CDTBS is expressively complete with respect  to FO3,2  BS [<]. One direction is straightforward: since the standard translation of CDTBS formulas given in Section 3 makes use of 3 variables only, it holds that CDTBS  FO3,2  BS [<].  We now show that the converse holds as well, that is, FO3,2  [<]    CDT  .  By  analogy  BS  BS  to the case of the mapping from FO3,2 [<] to CDT defined by Venema [33], as a preliminary  step, we provide a suitable characterization of FO3,2  BS [<]-formulas.  10  Davide Bresolin et al  Definition 2 Let {i, j, k} ⊆ {1, 2, 3}. The language FO3,2  sp [<] is defined by the following  abstract grammar:  β (xi , x j ) ::= β∃ (xi , x j ) | β (xi , x j ) ∧ β (xi , x j ) | β (xi , x j ) ∨ β (xi , x j ) |  ∃xk (β (xi , xk ) ∧ β (xk , x j )) | ¬β∃ (xi , x j ) for β∃ (xi , x j )  (7)  of the form ∃xk (β∃ (xi , xk ) ∧ β∃ (xk , x j ))  β∃ (xi , x j ) ::= A(xi , x j ) | ¬A(xi , x j ) | β∃ (xi , x j ) ∧ β∃ (xi , x j ) | β∃ (xi , x j ) ∨ β∃ (xi , x j ) |  ∃xk (β∃ (xi , xk ) ∧ β∃ (xk , x j ))  A(xi , x j ) ::= xi = x j | x j = xi | xi = xi | x j = x j | xi < x j | x j < xi | xi < xi | x j < x j |  p(xi , x j ) | p(x j , xi ) | p(xi , xi ) | p(x j , x j )  (8)  (9)  3,2  Lemma 2 For every formula in FO3,2  BS [<], there is an equivalent formula in FOsp [<].  3,3  Proof We prove the following stronger claim on the 3-variable fragment FOBS  [<], which  includes formulas where all three variables occur free:  for every formula α in FO3,3  BS [<] there is equivalent formula τ (α ), which is a  3,2  Boolean combination of FOsp  [<]-formulas, with the same free variables as α .  The proof is by structural induction.  The base cases (α is an atomic formula or α is the negation of an atomic formula)  and the case of logical connectives (α is a conjunction or a disjunction of formulas) are  straightforward. In particular, as for the base case, it suffices to remind that we restricted our  attention to fragments of first-order logic with binary predicates only.  Let α be of the form ∃xk γ (xi , x j , xk ). By the inductive hypothesis, γ (xi , x j , xk ) is equivalent to a formula τ (γ (xi , x j , xk )), that we may assume, without loss of generality, to be a  disjunction of conjunctions of formulas in FO3,2  the existential quansp [<]. By distributing  W  tifier ∃xk over disjunctions, we obtain a formula of the form m  h=1 ∃xk γh (xi , x j , xk ), where  each γh (xi , x j , xk ) is a conjunction of formulas. Since only binary predicates are allowed,  we can rewrite each γh (xi , x j , xk ) as ξh (xi , x j ) ∧ ξh (xi , xk ) ∧ ξh (x j , xk ). Since variable xk does  not occur free in ξh (xi , x j ), we can rewrite ∃xk γh (xi , x j , xk ) as ξh (xi , x j ) ∧ ∃xk (ξh (xi , xk ) ∧  3,2  ξh (x j , xk )). This latter formula is a conjunction of FOsp  [<]-formulas with the same free  variables as α .  The case in which α is of the form ¬∃xk γ (xi , x j , xk ) can be dealt with in a very similar  way.  ⊔  ⊓  We are now ready to define the translation τ from FO3,2  sp [<] to CDTBS . For the sake of  brevity, we write τ i, j for τ [xi , x j ], with xi ≤ x j . Translation rules for atomic and complex  formulas are given in Table 1.  Lemma 3 Let α (xi , x j ) be an FO3,2  sp [<]-formula. Then, for every pair of points (di , d j ),  M |= α (di , d j ) if and only if di ≤ d j and ζ (M), [di , d j ] τ i, j (α (xi , x j )), or d j ≤ di and  ζ (M), [d j , di ] τ j,i (α (xi , x j )).  Proof The proof is by induction on the structure of α (xi , x j ). The cases of atomic formulas  and Boolean connectives are straightforward.  Once more, the only interesting case is the one of existential quantifiers. Let α (xi , x j ) be  the formula ∃xk (β (xi , xk ) ∧ γ (xk , x j )) and di ≤ d j . By the semantic clauses for FO3,2  sp [<], it  The Light Side of Interval Temporal Logic: the Bernays-Schönfinkel fragment of CDT  11  FOω ,2 [<]  ,2  FOω  BS [<]  ...  FO4,2 [<]  CDT ≡ FO3,2 [<]  PNL ≡ FO2,2 [<]  ...  FO4,2  BS [<]  ≡ CDTBS  FO3,2  BS [<]  Fig. 2 A classification of the considered interval logics and fragments of first-order logic with respect to their  expressive power.  holds that M |= ∃xk (β (di , xk ) ∧ γ (xk , d j )) if and only if there exists a point dk such that M |=  β (di , dk ) and M |= γ (dk , d j ). Since we are interpreting our formulas over a linear order, there  are three possible ways to place dk with respect to di and d j : either dk ≤ di , or di ≤ dk ≤ d j ,  or d j ≤ dk . By the inductive hypothesis, we have that M |= α (di , d j ) if and only if:      ζ (M), [dk , di ] τ k,i (β (xi , xk )) and ζ (M), [dk , d j ] τ k, j (γ (xk , x j ))      or ζ (M), [di , dk ] τ i,k (β (xi , xk )) and ζ (M), [dk , d j ] τ k, j (γ (xk , x j ))      or ζ (M), [d j , dk ] τ j,k (γ (xk , x j )) and ζ (M), [di , dk ] τ i,k (β (xi , xk )) .  By the semantics of the C, D, and T operators, we can conclude that M |= α (di , d j ) if and  only if ζ (M), [di , d j ] τ i, j (α (xi , x j )), as required.  ⊔  ⊓  Theorem 6 CDTBS is as expressive as FO3,2  BS [<].  3,2  Proof By Lemma 2 and Lemma 3, FO3,2  BS [<]  FOsp [<]  CDTBS . Moreover, by Lemma  3,2  1, CDTBS  FO3,2  ⊔  ⊓  BS [<]. Hence, CDTBS ≡ FOBS [<].  Figure 2 gives a graphical account of the relationships among the considered logics  (interval logics and fragments of first-order logic) in terms of their expressive power (the  contributions of the present work are in boldface).  5 A tableau method for CDTBS  In [15], Goranko et al propose a tableau method for CDT interpreted over partial orders with  the linear interval property, that is, partial orders in which every interval is linear (BCDT+  for short). The method provides a semi-decision procedure for BCDT+ (it is not guaranteed  to terminate). This does not come as a surprise as BCDT+ is undecidable. In this section,  we show how to turn the method into an NP decision procedure CDTBS . In particular, we  show how to exploit BCDT+ syntactic restrictions to guarantee termination.  Let us start with some basic terminology. A finite tree is a finite directed acyclic graph  in which every node, apart from one (the root), has exactly one incoming edge. A successor  of a node n is a node n′ such that there is an edge from n to n′ . A leaf is a node with no  12  Davide Bresolin et al  successors. A path is a sequence of nodes n0 , . . . , nk such that, for all i = 0 . . . k − 1, ni+1 is  a successor of ni ; a branch is a path from the root to a leaf. The height of a node n is the  maximum length (number of edges) of a path from n to a leaf, while its depth is the length  of the (unique) path from the root to it. If two nodes n and n′ belong to the same branch  and the height of n is less than (resp., less than or equal to) the height of n′ , we write n ≺ n′  (resp., n  n′ ).  Definition 3 Let D be a finite linear order. A labeled formula over D is a pair (ψ , [di , d j ]),  where ψ ∈ CDTBS and [di , d j ] ∈ I(D).  Definition 4 Let T be a (finite) tree and let n be a node of T . The decoration ν (n) of n is  a tuple hψ , [di , d j ], D, p, ui, where D is a finite linear order, (ψ , [di , d j ]) is a labeled formula  over D, p ∈ {0, 1}, and u is a local flag function which associates the values 0 or 1 with  every branch B containing n.  Definition 5 A decorated tree is a finite tree T enriched with a decoration ν (n) for each  node n of T , apart from the root.  The tableau construction described below generates a decorated tree T . Given a branch B  and a node n belonging to it, with decoration ν (n), u(B) = 1 means that n can be expanded on  B. Given a branch B, B · (n1 · . . . · nh ) is the result of the expansion of B with the sequence of  nodes n1 ·. . .·nh (for h = 1, we simply write B·n), while B·(n1,1 ·. . .·n1,h )| . . .|(nk,1 ·. . .·nk,h )  is the result of the expansion of B with k sequences of h nodes (for h = 1, we simply write  B · n1 | . . .|nk ). The auxiliary flag p has been added to simplify termination and complexity  proofs. It records the nature of formula ψ : if ψ is a ϕ∃ -formula, then p = 0; otherwise, p = 1.  Finally, if n is the leaf of a branch B, we denote by DB the finite linear order in ν (n).  Since in CDTBS negation can occur only in front of proposition letters or modalities, we  need to introduce the notion of dual formula of a formula ϕ , denoted by ϕ . It is inductively  defined as follows:  –  –  –  –  –  p = ¬p and ¬p = p, for every p ∈ A P ∪ {π };  ϕ ∨ ψ = ϕ ∧ ψ;  ϕ ∧ ψ = ϕ ∨ ψ;  ϕ R ψ = ¬(ϕ R ψ ), for R ∈ {C, D, T };  ¬(ϕ R ψ ) = ϕ R ψ , for R ∈ {C, D, T }.  Notice that the dual of a generic CDTBS -formula does not necessarily belong to CDTBS .  This is the case, for instance, with the formula pC ¬(qC r). However, the following lemma  guarantees that dual formulas of ϕ∃ -formulas are CDTBS -formulas. Such a lemma will play  a crucial role in the proof of correctness of the tableau method.  Lemma 4 Let ϕ be a ϕ∃ -formula. Then, ϕ is a CDTBS -formula.  Proof The cases of proposition letters and Boolean connectives can be proved by a straightforward structural induction. To prove that the thesis holds also for modalities, let us assume  ϕ = ψ C τ to be a ϕ∃ -formula. By definition, the dual formula ϕ is ¬(ψ C τ ). Since ψ , τ are  ϕ∃ -formulas, we can conclude that ϕ is a CDTBS -formula. The other cases can be dealt with  in a similar way.  ⊔  ⊓  The construction of a tableau for a CDTBS -formula ϕ to be checked for satisfiability starts  from a three-node tree (initial tableau) consisting of a root and two leaves with decorations  hϕ , [d0 , d0 ], {d0 }, 1, 1i and hϕ , [d0 , d1 ], {d0 < d1 }, 1, 1i, respectively. The procedure exploits  The Light Side of Interval Temporal Logic: the Bernays-Schönfinkel fragment of CDT  13  a set of expansion rules, adapted from those given in [15], to add new nodes to the tree.  In particular, the original rules for modalities have been revised to restrict the search for  possible models to linear orders only.  Definition 6 Given a tree T , a branch B in T , and a node n ∈ B with decoration hψ , [di , d j ],  D, pn , un i such that un (B) = 1, the branch-expansion rule for B and n is defined as follows  (in all considered cases, un′ (B′ ) = 1 for all new nodes n′ and branches B′ ).  R1 If ψ = ξ0 ∧ ξ1 , then expand B to B·n0 ·n1 , where n0 is decorated with hξ0 , [di , d j ], DB , pn ,  un0 i and n1 is decorated with hξ1 , [di , d j ], DB , pn , un1 i.  R2 If ψ = ξ0 ∨ ξ1 , then expand B to B·n0 | n1 , where n0 is decorated with hξ0 , [di , d j ], DB , pn ,  un0 i and n1 is decorated with hξ1 , [di , d j ], DB , pn , un1 i.  R3 If ψ = ¬(ξ0 C ξ1 ) and d is a point in DB , with di ≤ d ≤ d j , which has not been  used yet to expand n in B, then expand B to B · n0 |n1 , where n0 is decorated with  hξ0 , [di , d], DB , 0, un0 i and n1 is decorated with hξ1 , [d, d j ], DB , 0, un1 i.  R4 If ψ = ¬(ξ0 D ξ1 ), and d is a point in DB , with d ≤ di , which has not been used yet to expand n in B, then expand B to B · n0 |n1 , where n0 is decorated with hξ0 , [d, di ], DB , 0, un0 i  and n1 is decorated with hξ1 , [d, d j ], DB , 0, un1 i.  R5 If ψ = ¬(ξ0 T ξ1 ), and d is a point in DB , with d j ≤ d, which has not been used yet to expand n in B, then expand B to B· n0 |n1 , where n0 is decorated with hξ0 , [d j , d], DB , 0, un0 i  and n1 is decorated with hξ1 , [di , d], DB , 0, un1 i.  R6 If ψ = ξ0 C ξ1 , then expand B to B · (ni · mi )| . . .|(n j · m j )|(n′i · m′i )| . . .|(n′j−1 · m′j−1 ),  where:  (a) for all i ≤ k ≤ j, nk is decorated with hξ0 , [di , dk ], DB , pn , unk i and mk is decorated  with hξ1 , [dk , d j ], DB , pn , umk i;  (b) for all i ≤ k ≤ j − 1, Dk is the linear ordering obtained from DB by inserting a new  point d between dk and dk+1 , n′k is decorated with hξ0 , [di , d], Dk , pn , un′ i and m′k is  k  decorated with hξ1 , [d, d j ], Dk , pn , um′ i.  k  R7 If ψ = ξ0 D ξ1 and d0 is the least point of DB , then expand B to B · (n0 · m0 )| . . .|(ni ·  mi )|(n′0 · m′0 )| . . .|(n′i · m′i ), where:  (a) for all 0 ≤ k ≤ i, nk is decorated with hξ0 , [dk , di ], DB , pn , unk i and mk is decorated  with hξ1 , [dk , d j ], DB , pn , umk i;  (b) for all 0 ≤ k ≤ i, Dk is the linear ordering obtained from DB by inserting a new point  d between dk−1 and dk (for k = 0, d is placed immediately before d0 ), n′k is decorated  with hξ0 , [d, di ], Dk , pn , un′ i and m′k is decorated with hξ1 , [d, d j ], Dk , pn , um′ i.  k  k  R8 If ψ = ξ0 T ξ1 and dN is the greatest point of DB , then expand B to B · (n j · m j )| . . .|(nN ·  mN )|(n′j · m′j )| . . .|(n′N · m′N ), where:  (a) for all j ≤ k ≤ N, nk is decorated with hξ0 , [d j , dk ], DB , pn , unk i and mk is decorated  with hξ1 , [di , dk ], DB , pn , umk i;  (b) for all j ≤ k ≤ N, Dk is the linear ordering obtained from DB by inserting a new point  d between dk and dk+1 (for k = N, d is placed immediately after dN ), n′k is decorated  with hξ0 , [d j , d], Dk , pn , un′ i and m′k is decorated with hξ1 , [di , d], Dk , pn , um′ i.  k  k  Finally, for each branch B′ extending B, let um (B′ ) = um (B), for each node m 6= n in B,  and let un (B′ ) = 0, unless ψ = ¬(ξ0C ξ1 ), ψ = ¬(ξ0 Dξ1 ), or ψ = ¬(ξ0 T ξ1 ) (in such cases  un (B′ ) = 1).  14  Davide Bresolin et al  We briefly explain the behavior of the branch-expansion rule in cases R6 (ξ0 C ξ1 ) and R3  (¬(ξ0C ξ1 )). The corresponding cases for modalities D and T are similar. R6 deals with two  possible scenarios: either there exists dk ∈ DB such that ξ0 holds over [di , dk ] and ξ1 holds  over [dk , d j ], or such a point must be added to DB . The successors (ni · mi )| . . .|(n j · m j )  created by the rule cover the former case, while the successors (n′i · m′i )| . . .|(n′j−1 · m′j−1 )  cover the latter case. As for R3, the formula ¬(ξ0 C ξ1 ) states that, for all di ≤ d ≤ d j ,  either ξ0 holds over [di , d] or ξ1 holds over [d, d j ]. R3 imposes such a condition for a single  point d ∈ DB and keeps the flag equal to 1. In such a way, all points in DB are eventually  considered, including those points that will be added in subsequent steps of the tableau  construction.  Definition 7 A branch B is closed if one of the following conditions holds:  1. there are two nodes n, n′ in B such that ν (n) = hψ , [di , d j ], D, p, ui and ν (n′ ) =  hψ , [di , d j ], D′ , p′ , u′ i for some formula ψ and di , d j ∈ D;  2. there is a node n such that ν (n) = hπ , [di , d j ], D, p, ui and di 6= d j ;  3. there is a node n such that ν (n) = h¬π , [di , d j ], D, p, ui and di = d j ;  If none of the above conditions hold, the branch is open.  Definition 8 The branch-expansion strategy for a branch B in a decorated tree T is defined  as follows:  1. apply the branch-expansion rule to a branch B only if it is open;  2. if B is open, apply the branch-expansion rule to the closest to the root node n such  that un (B) = 1 and the application of the rule generates at least one node with a new  decoration (if any).  Definition 9 A tableau T is any decorated tree obtained from the initial tableau by the  application of the branch-expansion strategy.  We say that a tableau T is closed if and only if all its branches are closed, otherwise it is  open.  We conclude the section by giving a couple of examples of the application of the proposed method. As a first example, we consider the satisfiable formula ϕ = (¬π D ¬π )C ¬π .  A portion of a tableau for ϕ is given in Figure 3, where thick edges highlights an open  branch representing a four-point model for the formula. As a second example, let ψ be the  unsatisfiable formula p T ¬(⊤C p). A closed tableau for ψ is given in Figure 4. It is worth  pointing out that there is an abuse of notation in the last component of the node decorations:  while it is formally defined as a function from a set of branches to {0, 1}, in the pictures it  is represented as a constant (either 0 or 1). The reason is that in the proposed examples the  function is constant for each node, that is, for each n we have that the value of the function  un (B) is the same for every branch B containing n.  In the following, we will show that to establish the satisfiability of a CDTBS -formula  ϕ it is sufficient to start with the initial tableau for ϕ , and keep expanding it for as long  as it is possible: if the resulting tableau is open, then ϕ is satisfiable, otherwise it is not.  Moreover, we will prove that this expansion procedure terminates and it can be executed by  a nondeterministic machine that uses only a polynomial amount of time.  The Light Side of Interval Temporal Logic: the Bernays-Schönfinkel fragment of CDT  15  root  (¬π D ¬π )C ¬π , [d0 , d0 ], {d0 }, 1, 0  (¬π D ¬π )C ¬π , [d0 , d1 ], {d0 < d1 }, 1, 0  ¬π D ¬π , [d0 , d0 ], {d0 }, 1, 1  ¬π , [d0 , d0 ], {d0 }, 1, 1  ×  ¬π D ¬π , [d0 , d1 ], {d0 < d1 }, 1, 1  ¬π D ¬π , [d0 , d2 ], {d0 < d2 < d1 }, 1, 0  ¬π D ¬π , [d0 , d0 ], {d0 < d1 }, 1, 1  ¬π , [d1 , d1 ], {d0 < d1 }, 1, 1  ¬π , [d2 , d1 ], {d0 < d2 < d1 }, 1, 1  ¬π , [d0 , d1 ], {d0 < d1 }, 1, 1  ×  ···  ¬π , [d0 , d2 ], {d0 < d2 < d1 }, 1, 1  ¬π , [d3 , d0 ], {d3 < d0 < d2 < d1 }, 1, 1  ¬π , [d0 , d0 ], {d0 < d2 < d1 }, 1, 1  ¬π , [d3 , d2 ], {d3 < d0 < d2 < d1 }, 1, 1  ×  Fig. 3 A portion of an open tableau for the formula (¬π D ¬π )C ¬π .  5.1 Soundness  In this subsection, we prove that the proposed tableau method is sound, that is, given a  formula ϕ and a tableau T for it, if T is closed, then ϕ is not satisfiable. In the next  subsection, we will show that the method is also complete.  Lemma 5 (Soundness) Let ϕ be a CDTBS -formula and T be a tableau for it. If T is  closed, then ϕ is not satisfiable.  Proof Let n be a node in the tableau T , and let Dn = {d0 < . . . < ds } be the linear ordering  from ν (n). We will prove the following claim by induction on the height h of the node:  if every branch including n is closed, then the set S(n) of all labeled formulas in the  decorations of the nodes between n and the root is neither satisfiable in I(Dn ) nor  in any extension of it.  If h = 0, then n is a leaf and the unique branch B containing n is closed. Then, either  S(n) contains both the labeled formulas (ψ , [dk , dl ]) and (¬ψ , [dk , dl ]), for some CDTBS formula ψ and dk , dl ∈ Dn , or the labeled formula (π , [dk , dl ]), for some dk 6= dl , or the  labeled formula (¬π , [dk , dl ]), for some dk = dl . Take any model M = hI(D′ ),V i, where  D′ extends Dn . It holds that M, [dk , dl ] ψ if and only if M, [dk , dl ] 6 ¬ψ , and, therefore,  (ψ , [dk , dl ]) and (¬ψ , [dk , dl ]) cannot be jointly satisfied. Similarly, M, [dk , dl ] π (resp.,  M, [dk , dl ] ¬π ) if and only if dk = dl (resp., dk 6= dl ), and therefore (π , [dk , dl ]) (resp.,  (¬π , [dk , dl ])) cannot be satisfied when dk 6= dl (resp., dk = dl ).  Now, suppose that h > 0. Then, either n has been generated as one of the successors,  but not the last one, when applying cases R1, R6, R7, or R8 of the branch-expansion rule,  or the branch-expansion rule has been applied to some labeled formula (ψ , [dk , dl ]) ∈ S(n)  \{τ }, where τ is the labeled formula in the decoration ν (n), to extend the branch at n. We  16  Davide Bresolin et al  root  p T ¬(⊤C p),[d0 ,d0 ],{d0 },1,0  p,[d0 ,d0 ],{d0 },1,1  ¬(⊤C p),[d0 ,d0 ],{d0 },1,1  ⊥,[d0 ,d0 ],{d0 },0,1  ¬p,[d0 ,d0 ],{d0 },0,1  p,[d0 ,d1 ],{d0 < d1 },1,1  ×  ×  ¬(⊤C p),[d0 ,d1 ],{d0 < d1 },1,1  ⊥,[d0 ,d1 ],{d0 < d1 },0,1  ¬p,[d0 ,d1 ],{d0 < d1 },0,1  ×  ×  p T ¬(⊤C p),[d0 ,d1 ],{d0 < d1 },1,0  p,[d1 ,d1 ],{d0 < d1 },1,1  ¬(⊤C p),[d0 ,d1 ],{d0 < d1 },1,1  ⊥,[d0 ,d1 ],{d0 < d1 },0,1  ¬p,[d1 ,d1 ],{d0 < d1 },0,1  p,[d1 ,d2 ],{d0 < d1 < d2 },1,1  ×  ×  ¬(⊤C p),[d0 ,d2 ],{d0 < d1 < d2 },1,1  ⊥,[d0 ,d1 ],{d0 < d1 < d2 },0,1  ¬p,[d1 ,d2 ],{d0 < d1 < d2 },0,1  ×  ×  Fig. 4 A closed tableau for the formula p T ¬(⊤C p).  detail the latter case; the former one can be dealt with in the same way, and thus its analysis  is omitted. First, we observe that every branch passing through any successor of n must be  closed. It immediately follows that the inductive hypothesis applies to all successors of n.  We consider the possible cases for the application of the branch-expansion rule to extend the  branch at n, restricting our attention to the conceptually different ones only (the other cases  can be dealt with in a similar way):  – If ψ = ξ0 ∧ ξ1 , R1 has been applied. Then, there are two nodes n0 , n1 such that ν (n0 )  = hξ0 , [dk , dl ], D, p0 , u0 i, ν (n1 ) = hξ1 , [dk , dl ], D, p1 , u1 i. Without loss of generality, we  can assume n0 to be the successor of n and n1 to be the successor of n0 . Since each branch  containing n is closed, then each branch containing n1 is closed as well. By the inductive  hypothesis (n1 ≺ n), S(n1 ) is not satisfiable. Since every model satisfying S(n) must, in  particular, satisfy (ξ0 ∧ ξ1 , [dk , dl ]), and hence (ξ0 , [dk , dl ]) and (ξ1 , dk , dl ]), it follows  that S(n), S(n0 ), and S(n1 ) are equi-satisfiable. Therefore, S(n) is not satisfiable.  – If ψ = ξ1 ∨ ξ2 , R2 has been applied. Then, there exist two successor nodes n0 and n1  of n such that ν (n0 ) = hξ0 , [dk , dl ], D, p0 , u0 i, ν (n1 ) = hξ1 , [dk , dl ], D, p1 , u1 i, and both  The Light Side of Interval Temporal Logic: the Bernays-Schönfinkel fragment of CDT  17  n0 ≺ n and n1 ≺ n. Since each branch containing n is closed, then each branch containing  n0 or n1 is closed as well. By the inductive hypothesis, S(n0 ) and S(n1 ) are not satisfiable. Since every model satisfying S(n) must also satisfy (ξ0 , [dk , dl ]) or (ξ1 , [dk , dl ]), it  follows that S(n) is not satisfiable.  – If ψ = ¬(ξ0 C ξ1 ), R3 has been applied. For the sake of contradiction, let us assume  S(n) to be satisfiable. Then, since (¬(ξ0 C ξ1 ), [dk , dl ]) ∈ S(n), there is a model M =  hI(D′ ),V i such that D′ extends Dn and M, [dk , dl ] ¬(ξ0C ξ1 ). Hence, for each dt such  that dk ≤ dt ≤ dl , M, [dk , dt ] 6 ξ0 or M, [dt , dl ] 6 ξ1 . By construction, the two immediate  successors of n are two nodes n0 and n1 and there exists a point dt , with dk ≤ dt ≤ dl , such  that (ξ 0 , [dk , dt ]) is in ν (n0 ) and (ξ 1 , [dt , dl ]) is in ν (n1 ). By the inductive hypothesis  (both n0 ≺ n and n1 ≺ n), S(n0 ) and S(n1 ) are not satisfiable. But, from the hypothesis  of our reductio-ad-absurdum argument, there is a model M = hI(D′ ),V i, where D′ is an  extension of Dn , such that M, [dk , dt ] ¬ξ0 or M, [dt , dl ] ¬ξ1 . Thus, either S(n0 ) or  S(n1 ) is satisfiable (by model M), leading to a contradiction.  – If ψ = ξ0 C ξ1 , R6 has been applied. For the sake of contradiction, let us assume S(n)  to be satisfiable. Then, there is a model M = hI(D′ ),V i such that D′ extends Dn and  M, [dk , dl ] ξ0 C ξ1 . Hence, M, [dk , d] ξ0 and M, [d, dl ] ξ1 for some dk ≤ d ≤ dl .  Two cases are possible:  1. If d ∈ Dn , then d = dt for some dk ≤ dt ≤ dl . By R6, n has a successor, say it nt ,  which, in turn, has a successor, say it nt′ , with ν (nt ) = hξ0 , [dk , dt ], Dn , pt , ut i and  ν (nt′ ) = hξ1 , [dt , dl ], Dn , pt′ , ut′ i. By the inductive hypothesis (nt ≺ n and nt′ ≺ nt ),  S(nt′ ) = S(n) ∪{(ξ0 , [dk , dt ]), (ξ1 , [dt , dl ])} is not satisfiable. But, from the hypothesis  of our reductio-ad-absurdum argument, there is a model M = hI(D′ ),V i, where D′  is an extension of Dn , such that M, [dk , dt ] ξ0 and M, [dt , dl ] ξ1 . Thus, S(nt′ ) is  satisfiable (by model M), leading to a contradiction.  2. If d ∈  / Dn , then there exists t such that k ≤ t ≤ l − 1 and dt < d < dt+1 . By R6,  n has a successor, say it nt , which, in turn, has a successor, say it nt′ , with ν (nt )  = hξ0 , [dk , d], Dn ∪ {d}, pt , ut i, ν (nt′ ) = hξ1 , [d, dl ], Dn ∪ {d}, pt′ , ut′ i. By the inductive hypothesis (nt ≺ n and nt′ ≺ nt ), S(nt′ ) = S(n) ∪{(ξ0 , [dk , d]), (ξ1 , [d, dl ])} is not  satisfiable, which, as in the previous case, leads to a contradiction.  ⊔  ⊓  5.2 Completeness  In this subsection, we prove that the proposed tableau method is complete, that is, whenever  ϕ ∈ CDTBS is valid, every tableau T for ¬ϕ must be closed. To this end, we need to  preliminary prove some partial results.  Definition 10 Let ϕ be a CDTBS -formula and T0 be the initial tableau for it. The limit  tableau T for φ is the decorated tree generated as follows. For all i ≥ 0, let Ti+1 be the  tableau generated by the simultaneous application of the branch-expansion strategy to each  branch in Ti . If we ignore all flags from the decorations of the nodes in every Ti , we obtain  a chain of decorated trees ordered by inclusion: T1 ⊆ T2 ⊆ . . . ⊆ Tk ⊆ . . .. The limit tableau  T is equal to  ω  S  Ti .  i=0  Notice that the above definition does not prelude the limit tableau from being infinite. Later  on, we will prove that it cannot be the case, that is, the limit tableau is always finite. Nevertheless, finiteness (of the limit tableau) is not necessary to prove that the tableau method is  complete.  18  Davide Bresolin et al  The definitions of open and closed branch and tableau directly apply to the limit tableau  as well. In addition, we introduce the notion of saturated branch and tableau.  Definition 11 A branch in a (limit) tableau is saturated if there are no nodes on that branch  to which the branch-expansion rule is applicable on the branch. A (limit) tableau is saturated  if every open branch in it is saturated.  We now show that the set of all labeled formulas on an open branch in a limit tableau  has the saturation properties of a Hintikka set in first-order logic.  Lemma 6 Every limit tableau is saturated.  Proof Let B be a branch B in the limit tableau T and n be a node in B. We prove that  after every step of the expansion of that branch at which the branch-expansion rule becomes  applicable to n (because n has just been introduced or a new point has been added) and the  application of the rule generates at least a new node, then that rule is subsequently applied  on B to that node. The proof is by induction on depth(n) (the depth of node n).  Let us assume that depth(n) = l and the branch-expansion rule has become applicable to n. By the inductive hypothesis, the thesis holds for all nodes with depth(n) < l.  If there are no nodes between the root (including the root) and n (excluding n) to which  the branch-expansion rule is applicable at that moment, the next application of the branchexpansion rule on B is necessarily to n. Otherwise, let n∗ be the closest-to-n node between  the root and n to which the branch-expansion rule is applicable, or will become applicable, on B at least once thereafter. (Such a node exists because there are only finitely many  nodes between n and the root.) Since depth(n∗ ) < depth(n), by the inductive hypothesis,  the branch-expansion rule has been subsequently applied to n∗ . Then, the next application  of the branch-expansion rule on B must have been to n and that completes the induction.  Suppose now that there exists a branch B in a limit tableau which is not saturated. Let  n be the closest-to-the-root node on B to which the branch-expansion rule is applicable. If  the case applicable to n is different from R3, R4, and R5, then the branch-expansion rule  has become applicable to n at the step when n is introduced, and by the claim above, it  has been subsequently applied. Hence, the node has become unavailable thereafter, which  contradicts the assumption. Let us consider now the case of R3, that is, the formula in ν (n) is  ¬(ξ0 C ξ1 ) (cases R4 and R5 are similar, and thus they are omitted). An application of R3 on  B would create two immediate successors with labeled formulas (ξ 0 , [di , d]) and (ξ 1 , [d, d j ]),  at least one of them new on B. For R3 to be applicable, points di , d j , and d must have been  already introduced at some step of the construction of B. Hence, at the moment when the  three of them, and n, have appeared on the branch, the branch-expansion rule has become  applicable to n. By the above claim, the rule has been subsequently applied on B and such  an application must have introduced the labeled formulas (ξ0 , [di , d]) and (ξ1 , [d, d j ]) on B,  which again contradicts the assumption.  ⊔  ⊓  Corollary 1 Let ϕ be a CDTBS -formula and T be the limit tableau for ϕ . For every open  branch B in T , the following closure properties hold:  – If there is a node n ∈ B such that ν (n) = (ξ0 ∧ ξ1 , [di , d j ], D, pn , un ), then there are a  node n0 ∈ B such that ν (n0 ) = (ξ0 , [di , d j ], D, pn0 , un0 ) and a node n1 ∈ B such that  ν (n1 ) = (ξ1 , [di , d j ], D, pn1 , un1 ).  – If there is a node n ∈ B such that ν (n) = (ξ0 ∨ ξ1 , [di , d j ], D, pn , un ), then there are a  node n0 ∈ B such that ν (n0 ) = (ξ0 , [di , d j ], D, pn0 , un0 ) or a node n1 ∈ B such that ν (n1 )  = (ξ1 , [di , d j ], D, pn1 , un1 ).  The Light Side of Interval Temporal Logic: the Bernays-Schönfinkel fragment of CDT  19  – If there is a node n ∈ B such that ν (n) = (ξ0 C ξ1 , [di , d j ], D, pn , un ), then there are two  nodes n0 , n1 ∈ B such that ν (n0 ) = (ξ0 , [di , d], D′ , pn0 , un0 ) and ν (n1 ) = (ξ1 , [d, d j ], D′ ,  pn0 , un0 ), for some d ∈ DB , with di ≤ d ≤ d j , .  – If there is a node n ∈ B such that ν (n) = (ξ0 D ξ1 , [di , d j ], D, pn , un ), then there are two  nodes n0 , n1 ∈ B such that ν (n0 ) = (ξ0 , [d, di ], D′ , pn0 , un0 ) and ν (n1 ) = (ξ1 , [d, d j ], D′ ,  pn0 , un0 ), for some d ∈ DB , with d ≤ di .  – If there is a node n ∈ B such that ν (n) = (ξ0 T ξ1 , [di , d j ], D, pn , un ), then there are two  nodes n0 , n1 ∈ B such that ν (n0 ) = (ξ0 , [di , d], D′ , pn0 , un0 ) and ν (n1 ) = (ξ1 , [d j , d], D′ ,  pn0 , un0 ), for some d ∈ DB , with d ≥ d j , .  – If there is a node n ∈ B such that ν (n) = (¬(ξ0 C ξ1 ), [di , d j ], D, pn , un ), then, for each  d ∈ DB , with di ≤ d ≤ d j , there is a node n′ ∈ B such that ν (n′ ) = (ξ 0 , [di , d], D′ , pn′ ,  un′ ) or a node n′ ∈ B such that ν (n′ ) = (ξ 1 , [d, d j ], D′ , pn′ , un′ ).  – If there is a node n ∈ B such that ν (n) = (¬(ξ0 D ξ1 ), [di , d j ], D, pn , un ), then for each  d ∈ DB , with d ≤ di , there is a node n′ ∈ B such that ν (n′ ) = (ξ 0 , [d, di ], D′ , pn′ , un′ ) or  a node n′ ∈ B such that ν (n′ ) = (ξ 1 , [d, d j ], D′ , pn′ , un′ ).  – If there is a node n ∈ B such that ν (n) = (¬(ξ0 T ξ1 ), [di , d j ], D, pn , un ), then, for each  d ∈ DB , with d ≥ d j , there is a node n′ ∈ B such that ν (n′ ) = (ξ 0 , [di , d], D′ , pn′ , un′ ) or  a node n′ ∈ B such that ν (n′ ) = (ξ 1 , [d j , d], D′ , pn′ , un′ ).  The proof of Corollary 1 is straightforward, and thus it is omitted.  Lemma 7 (Completeness) If the limit tableau for some formula ϕ ∈ CDTBS is closed, then  some finite tableau for ϕ is closed.  Proof Let us assume the limit tableau for ϕ to be closed. Then, every branch closes at some  finite step of the construction, and then it is not further expanded (it remains finite). Since  the branch-expansion rule always produces finitely many successors, every finite tableau  is finitely branching, and hence so is the limit tableau. Then, by König’s lemma, the limit  tableau, being a finitely branching tree with no infinite branches, must be finite. This allows  us to conclude that its construction stabilizes at some finite stage. At that stage, a closed  ⊔  ⊓  tableau for ϕ is constructed.  5.3 Termination and Complexity  In this last subsection, we prove that the proposed tableau method is terminating, and we  determine its computational complexity. The proof rests on a pair of basic lemmas.  As a preliminary step, we define a counting function Count on B as follows:  Count(B) =  ∑ |ψn | · pn · un (B),  n∈B  where ψn and pn are the formula and the p-flag in the decoration of n, respectively. The  following lemma proves that Count is non-increasing with respect to branch expansions.  Lemma 8 Let ϕ be a CDTBS -formula, B be a branch in a tableau for ϕ , and B′ be an  expansion of B generated by the application of the branch-expansion strategy of Definition  8. Then, Count(B′ ) ≤ Count(B). Moreover, if B′ is obtained from B by the application of R1,  R2, R6, R7, or R8 to a node n with pn in ν (n) equal to 1, then Count(B′ ) < Count(B).  20  Davide Bresolin et al  Proof Let T be a tableau for ϕ , B be a branch on it, and n be the closest-to-the-root node for  which the branch-expansion rule is applicable. Moreover, let B′ be a branch obtained by the  application of the branch-expansion strategy on B. We consider the cases of the application  of R1, R3, and R6 to n. The missing cases are similar to the considered ones (R2 is similar  to R1, R4 and R5 to R3, R7 and R8 to R6), and thus they are omitted.  – R1 is applied to n. Then, ν (n) = hξ0 ∧ ξ1 , [di , d j ], D, pn , un i and B′ = B · n′ · m′ , with ξ0  belonging to ν (n′ ) and ξ1 belonging to ν (m′ ). Since pn′ = pm′ = pn , un′ (B′ ) = um′ (B′ ) =  1, un (B′ ) = 0, and um (B′ ) = um (B) for each m 6∈ {n, n′ , m′ }, Count(B′ ) = Count(B) −  |ξ0 ∧ ξ1 |+|ξ0 |+|ξ1 | < Count(B), when pn = 1, and Count(B′ ) = Count(B) when pn = 0.  – R3 is applied to B. Then, ν (n) = h¬(ξ0 C ξ1 ), [di , d j ], D, pn , un i and B′ = B · n′ , with ξ0  or ξ1 belonging to ν (n′ ). In both cases, pn′ in ν (n′ ) is equal to 0, and thus Count(B′ ) =  Count(B).  – R6 is applied to B. Then, ν (n) = hξ0 C ξ1 , [di , d j ], D, pn , un i and B′ = B · n′ · m′ , with ξ0  belonging to ν (n′ ) and ξ1 belonging to ν (m′ ). Since pn′ = pm′ = pn , un′ (B′ ) = um′ (B′ ) =  1, un (B′ ) = 0, and um (B′ ) = um (B) for each m 6∈ {n, n′ , m′ }, Count(B′ ) = Count(B) −  |ξ0 C ξ1 | +|ξ0 | +|ξ1 | < Count(B) when pn = 1, and Count(B′ ) = Count(B) when pn = 0.  Summing up, whatever Ri one applies, Count(B′ ) ≤ Count(B). Moreover, when R1, R2, R6,  R7, or R8 are applied to a node n with pn in ν (n) equal to 1, Count(B′ ) < Count(B).  ⊔  ⊓  Lemma 9 Let ϕ be a CDTBS -formula, T be a tableau for ϕ , and n be a node in T with  decoration ν (n) = hψ , [di , d j ], D, pn , un i. It holds that if pn = 0, then ψ ∈ ϕ∃ .  Proof Let n be a node on a branch B in T with decoration ν (n) = hψ , [di , d j ], D, pn , un i. We  prove the claim by induction on depth(n).  Base case. If depth(n) ≤ 2, then n is either the root or one of the leaves of the initial  tableau. In both cases, the claim follows trivially.  Inductive step. Let depth(n) > 2. By the inductive hypothesis, the claim holds for each  ancestor of n in B. Let n′ be the node to which the branch-expansion rule has been applied  during the construction of T to obtain node n. As in the proof of Lemma 8, we restrict our  attention to R1, R3, and R6. The other cases can be dealt with in a similar way.  – Rule R1 has been applied to n′ . Then, ν (n′ ) = hξ0 ∧ ξ1 , [di , d j ], D, pn′ , un′ i and either ξ0  or ξ1 belong to ν (n). Let us assume that ξ0 belongs to ν (n) (the case in which ξ1 belongs  to ν (n) is analogous) and pn = 0. By definition of R1, pn′ = pn = 0. By the inductive  hypothesis, ξ0 ∧ ξ1 = ξ0 ∨ ξ1 ∈ ϕ∃ . From the grammar rules for CDTBS , it follows that  ξ0 ∈ ϕ ∃ .  – Rule R3 has been applied to B. Then, ν (n′ ) = h¬(ξ0 C ξ1 ), [di , d j ], D, pn′ , un′ i and either  ξ0 or ξ1 belong to ν (n). Let us assume that ξ0 belongs to ν (n) (the case in which ξ1  belongs to ν (n) is analogous). By definition of R3, pn = 0. By the grammar rules for  CDTBS , it holds that ξ0 ∈ ϕ∃ . The thesis immediately follows from ξ0 = ξ0 .  – Rule R6 has been applied to B. Then, ν (n′ ) = hξ0 C ξ1 , [di , d j ], D, pn′ , un′ i and either ξ0  or ξ1 belong to ν (n). Let us assume pn′ = 0. By the inductive hypothesis, it follows that  ξ0Cξ1 = ¬(ξ0Cξ1 ) ∈ ϕ∃ (contradiction). Hence, it holds that pn′ = 1, and thus, by R6,  pn = 1.  ⊔  ⊓  By exploiting Lemma 8 and Lemma 9, we now prove that the length of any branch B of  any tableau for ϕ is polynomially bounded by the length of the formula.  Lemma 10 (Termination) Let ϕ be a CDTBS -formula, T be a tableau for ϕ , and B be a  branch in T . Then, |B| ≤ 2 · |ϕ |3 + 8 · |ϕ |2 + 8 · |ϕ |.  The Light Side of Interval Temporal Logic: the Bernays-Schönfinkel fragment of CDT  21  Proof Let B be a branch in a tableau T for ϕ . Given the branch-expansion rule and the  branch-expansion strategy, there cannot be two nodes n, n′ in B such that the same formula  and the same interval belong to both ν (n) and ν (n′ ). Since for any node n in B, the formula  in ν (n) is either a subformula of ϕ or the dual of a subformula of ϕ , it holds that |B| ≤  2 · |ϕ | · |DB|2 .  To give a bound on the number of points in DB , it suffices to observe that:  1. only the application of R6, R7, and R8 add new points to DB ;  2. by Lemma 9, they can be applied only to nodes where the flag p is equal to 1;  3. by Lemma 8, every application of them strictly decreases the value of Count(B).  Now, let B0 be the two-node prefix of B consisting of the root and one of its successors  labeled with ϕ . Since |DB0 | ≤ 2 and Count(B0 ) = |ϕ |, |DB | ≤ |ϕ | + 2, and thus |B| ≤ 2 · |ϕ | ·  (|ϕ | + 2)2 ≤ 2 · |ϕ |3 + 8 · |ϕ |2 + 8 · |ϕ |.  ⊔  ⊓  Theorem 7 The proposed tableau method for CDTBS is sound and complete, and the satisfiability problem for CDTBS is NP-complete.  Proof By Lemma 5 (soundness) and Lemma 7 (completeness), it holds that satisfiability of a  formula ϕ can be reduced to the search for an open limit tableau for it. A direct consequence  of Lemma 10 is that this search can be performed by a nondeterministic algorithm that  guesses an open and saturated branch of the limit tableau, using only a polynomial amount  of time. NP-hardness immediately follows from that of propositional logic.  ⊔  ⊓  6 Undecidable extensions of CDTBS  In the previous section, we have proved that the satisfiability problem for CDTBS is NPcomplete. Since the full logic CDT is undecidable, one may wonder whether CDTBS can be  extended preserving decidability. In this section, we show that the most natural extension of  CDTBS is already undecidable.  In CDTBS -formulas, modalities can occur in the scope of at most one negation. We  slightly extend CDTBS by allowing one more nesting of negations and modalities. The resulting logic includes formulas like ¬(¬(pCq)Cq) or ¬(pC¬(qCr)). In [20], Hodkinson et  al. have shown that CDT is undecidable over the class of all linearly-ordered domains even if  we restrict ourselves to formulas where only one modality occurs. Undecidability has been  proved by reducing the problem of finding a solution to the octant tiling problem to the satisfiability problem for the logic. The undecidability proof below is based on the observation  that the entire construction given in [20] exploits formulas where modalities occur in the  scope of at most two negations.  Given a set of tiles T = {t1 , . . ., tk }, the octant tiling problem is the problem of establishing whether T can tile an octant of the Cartesian plane over the integers. Let us  consider the second octant O = {(p, q) | p, q ∈ N, p ≤ q}. Each tile ti has four colors,  namely, right(ti ), le f t(ti ), up(ti ), and down(ti ). Neighboring tiles must have matching  colors. Formally, we say that a set T can tile O if there exists a function f : O 7→ T such  that right( f (p, q)) = le f t( f (p + 1, q)) and up( f (p, q)) = down( f (p, q + 1)), where f (p, q)  represents the tile to be placed in the position (p, q), provided that all relevant coordinates  ((p, q), (p + 1, q), etc.) lie in O. Using König’s lemma, one can prove that a tiling system  tiles the second octant if and only if it tiles arbitrarily large squares if and only if it tiles  N × N if and only if it tiles Z × Z. Undecidability of the first problem immediately follows  from that of the last one [4].  22  Davide Bresolin et al  Let T = {t1 , . . ., tk } be an instance of the octant tiling problem. We will assume that  A P contains at least the propositional letters u,t1 , . . .,tk . CDTBS makes it possible to define  the “somewhere in the future” operator F (we assume future to be non-strict) as follows:  F ϕ ::= ⊤ T (ϕ T ⊤).  (10)  The universal operator G can be defined as the dual of F, that is:  Gϕ ::= ¬F¬ϕ .  (11)  Making use of G, we set our framework by forcing the existence of unit-intervals (or uintervals) working like atomic elements. Such intervals will be denoted by the proposition  letter u. We force u-intervals to be disposed in an unbounded unique (uninterrupted) sequence by means of the following formula:  uT ⊤ ∧ G(u → uT ¬u).  Lemma 11 Let M be a model such that M, [d, d ′ ]  quence of points d0 < d1 < . . ., such that  1. d ′ = d0 ;  2. for every l ∈ N, M, [dl , dl+1 ]  (12)  (12). Then, there exists an infinite se-  u.  The following formulas associate a unique tile with every u-interval; moreover, they guarantee that tiles are placed in such a way that they respect conditions on colors (a graphical  account of the encoding is given in Figure 5):  |T |  _  G(u →  ti ),  (13)  ¬(ti ∧ t j ),  (14)  i=1  |T |  G  ^  i, j=1,i6= j  G  |T |  |T |  ^  _  (ti → ¬(uT ¬  i=1    G u→  t j )),  (15)    ¬(ti T t j ) .  (16)  j=1,up(ti )=down(tj )  |T |  ^  i, j=1,right(tj )6=left(ti )  It is easy to check that, in (12), (13), and (14), modalities occur in the scope of at most  two negations. Moreover, formulas (15) and (16) can be easily rewritten in such a way that  modalities occur in the scope of at most two negations as well. Now, let ϕT be the following  formula:  (12) ∧ (13) ∧ (14) ∧ (15) ∧ (16).  (17)  We prove that the encoding is sound and complete.  Lemma 12 Let T = {t1 , . . . , tk } be a set of tiles. It holds that ϕT is satisfiable if and only  if T tiles the second octant O.  The Light Side of Interval Temporal Logic: the Bernays-Schönfinkel fragment of CDT  23  NN  t2 ◦  ◦ t3  t3  u  t1 ◦  t2  99K  t1  u  ◮  N  Fig. 5 A pictorial representation of the encoding.  Proof (Soundness) Let M, [d, d ′ ] |= ϕT . We show that there exists a tiling function f : O 7→  T . By Lemma 11, we know that there exists an infinite sequence of points d0 < d1 < . . .  such that d ′ = d0 and, for every i ∈ N, M, [yl , yl+1 ] |= u. Now, for each l, m ∈ N, with l ≤ m,  we put:  f (l, m) = t whenever M, [dl , dm+1 ] |= t.  First, we have to show that f is well-defined, that is, that each f (l, m) is a tile. We proceed  by induction on (m − l). If (m − l) = 0, then, by Lemma 11, we are on a u-interval and thus,  by (13), there exists a tile associated with it. Since by (14) such a tile is unique, f is welldefined. Suppose now that f (l, m) is a tile whenever m − l ≤ p, and consider m − l = p + 1.  Since (m − 1) − l ≤ p, by the inductive hypothesis f (l, m − 1) is a tile, say ti , which means  W|T |  that M, [dl , dm ] |= ti . By (15), M, [dl , dm ] |= ¬(uT ¬ j=1,up(ti )=down(tj ) t j ). Hence, for every  d ≥ dm , if M, [dm , d] |= u, then it must be the case that M, [dl , d] |=  W|T |  j=1,up(ti )=down(tj ) t j .  Since M, [dm , dm+1 ] |= u, this applies to the particular case d = dm+1 . Thus, we have that  M, [dl , dm+1 ] |= t j , that is, f (l, m) = tj , for some j such that down(tj ) = up(ti ) (again,  since by (14) such a tile is unique, f is well-defined). This not only guarantees us that  f is well-defined, but also that it respects the ‘vertical’ condition of a tiling function. To  conclude the proof, we need to show that the ‘horizontal’ condition is respected as well. To  this end, let us consider f (l, m) and f (l + 1, m). By definition, the corresponding tiles are  those associated with [dl , dm+1 ] and [dl+1 , dm+1 ]. Since, by definition, the interval [dl , dl+1 ]  is a u-interval, by (16) it cannot be the case that le f t( f (l + 1, m)) 6= right( f (l, m)), which  implies that le f t( f (l + 1, m)) = right( f (l, m)).  ⊔  ⊓  (Completeness) For simplicity, let us assume the linearly ordered set to be (N, <). One can  force the truth of ϕT over [0, 0] by letting u be true over all intervals of length 1 and each ti  be true over all intervals of the form [l, m + 1], where f (l, m) = ti .  ⊔  ⊓  Theorem 8 The satisfiability problem for any syntactic extension of CDTBS where modal  operators occur in the scope of two negations is undecidable.  Proof The thesis directly follows from Lemma 12.  It is worth noticing that only modality T occurs in ϕT . An alternative proof of Lemma  12 can be given by making use of modality C or of modality D only. This shows that any  fragment of CDT containing at least one modality among C, D, and T , where modalities are  allowed to occur in the scope of two negations, is undecidable.  24  Davide Bresolin et al  7 Conclusions and future work  In this paper, we studied a syntactic fragment of Venema’s CDT logic, that we called  CDTBS , whose standard translation to first-order logic fits into Bernays-Schönfinkel class  of quantifier prefix formulas. Decidability of CDTBS directly follows from that of BernaysSchönfinkel class.  We first focused our attention on expressiveness issues. We considered the following  question: “can every formula in Bernays-Schönfinkel class of first-order logic over the linear  order <, limited to binary predicates, be turned into a CDTBS -formula?”. We proved that this  is not the case. In [33], Venema showed that CDT is expressively complete with respect to  FO3,2 [<]. In this paper, we showed that CDTBS is expressively complete with respect to  3,2  the corresponding fragment of Bernays-Schönfinkel class FOBS  [<]. Next, we developed a  tableau-based decision procedure for CDTBS , and we proved that the satisfiability problem  for CDTBS is NP-complete. Finally, we showed that any natural relaxation of the syntactic  restrictions we imposed on CDTBS yields undecidability, as it makes the resulting logic  expressive enough to encode the (undecidable) octant tiling problem.  The present work can be developed in a number of future research directions. From a  theoretical point of view, one can think of the possibility of identifying the interval temporal logic counterparts of other decidable classes of first-order formulas. Moreover, the  relationships between interval temporal logics and (extended) guarded fragments are still  unexplored. For instance, It would be interesting to give an account of the good computational properties of decidable fragments of CDT and HS (including CDTBS ) in terms of  suitable guarded fragments. From a more practical point of view, we expect CDTBS to be applicable in a variety of areas such as, for instance, planning and synthesis of plan controllers,  temporal description logics, and sequencing problems in computational genetics.  Acknowledgements This work has been partially supported by the following research projects: EU project  FP7-ICT-223844 CON4COORD (D. Bresolin), Italian PRIN project Innovative and multi-disciplinary approaches for constraint and preference reasoning (A. Montanari and D. Della Monica), Spanish MEC  projects TIN2009-14372-C03-01 and RYC-2011-07821 (G. Sciavicco), and project Processes and Modal  Logics (project nr. 100048021) of the Icelandic Research Fund (D. Della Monica).  References  1. Allen, J.: Maintaining knowledge about temporal intervals. Communications of the ACM 26(11), 832–  843 (1983)  2. Andréka, H., van Benthem, J., Németi, I.: Back and forth between modal logic and classical logic. Logic  Journal of the IGPL 3(5), 685–720 (1995)  3. Benthem, J.V., Thomason, S.K. : Dynamic bits and pieces (1997)  4. Börger, E., Grädel, E., Gurevich, Y.: The Classical Decision Problem. Springer (1999)  5. Bresolin, D., Della Monica, D., Goranko, V., Montanari, A., Sciavicco, G.: Decidable and undecidable  fragments of Halpern and Shoham’s interval temporal logic: towards a complete classification. In: Proc.  of LPAR’08, LNCS, vol. 5330, pp. 590–604. Springer (2008)  6. Bresolin, D., Della Monica, D., Goranko, V., Montanari, A., Sciavicco, G.: Undecidability of interval  temporal logics with the overlap modality. In: Proc. of TIME’09, pp. 88–95. IEEE Comp. Society  (2009)  7. Bresolin, D., Della Monica, D., Goranko, V., Montanari, A., Sciavicco, G.: Metric Propositional Neighborhood Logics. Journal of Software and System Modeling (2012). DOI: 10.1007/s10270-011-0195-y  8. Bresolin, D., Goranko, V., Montanari, A., Sciavicco, G.: Propositional interval neighborhood logics:  expressiveness, decidability, and undecidable extensions. Annals of Pure and Applied Logic 161(3),  289–304 (2009)  The Light Side of Interval Temporal Logic: the Bernays-Schönfinkel fragment of CDT  25  9. Bresolin, D., Montanari, A., Sala, P., Sciavicco, G.: Optimal tableaux for right propositional neighborhood logic over linear orders. In: Proc. of JELIA’08, LNAI, vol. 5293, pp. 62–75. Springer (2008)  10. Bresolin, D., Montanari, A., Sala, P., Sciavicco, G.: What’s decidable about Halpern and Shoham’s interval logic? The maximal fragment ABBL. In: Proc. of LICS’11, pp. 387–396. IEEE Comp. Society  Press (2011)  11. Della Monica, D., Goranko, V., Montanari, A., Sciavicco, G.: Expressiveness of the interval logics of  allen’s relations on the class of all linear orders: Complete classification. In: Proc. of IJCAI’11, pp.  845–850 (2011)  12. Etessami, K., Vardi, M.Y., Wilke, T.: First-order logic with two variables and unary temporal logic.  Information and Computation 179(2), 279–295 (2002)  13. Gabbay, D., Hodkinson, I., Reynolds, M.: Temporal Logic: mathematical foundations and computational  aspects. Oxford University Press (1994)  14. Gabbay, D., Pnueli, A., Shelah, S., Stavi, J.: On the temporal analysis of fairness. In: Proc. of POPL’80,  pp. 163–173. ACM Press (1980)  15. Goranko, V., Montanari, A., Sala, P., Sciavicco, G.: A general tableau method for propositional interval  temporal logics: theory and implementation. Journal of Applied Logic 4(3), 305–330 (2006)  16. Goranko, V., Montanari, A., Sciavicco, G.: Propositional interval neighborhood temporal logics. Journal  of Universal Computer Science 9(9), 1137–1167 (2003)  17. Goranko, V., Montanari, A., Sciavicco, G.: A road map of interval temporal logics and duration calculi.  Applied Non-classical Logics 14(1-2), 9–54 (2004)  18. Halpern, J., Shoham, Y.: A propositional modal logic of time intervals (short version). In: Proc. of  LICS’86, pp. 279–292. IEEE Comp. Society (1986)  19. Halpern, J.Y., Shoham, Y.: A propositional modal logic of time intervals. J. ACM 38, 935–962 (1991)  20. Hodkinson, I., Montanari, A., Sciavicco, G.: Non-finite axiomatizability and undecidability of interval  temporal logics with C, D, and T. In: Proc. of CSL’08, LNCS, vol. 5213, pp. 308–322. Springer (2008)  21. Immerman, N., Kozen, D.: Definability with bounded number of bound variables. Information and  Computation 83(2), 121–139 (1989)  22. Kamp, H.: Events, instants and temporal reference. In: Semantics from different points of view, pp.  27–54. Springer (1979)  23. Marcinkowski, J., Michaliszyn, J.: The ultimate undecidability result for the Halpern-Shoham logic. In:  Proc. of LICS’11, pp. 377–386. IEEE Comp. Society Press (2011)  24. Marcinkowski, J., Michaliszyn, J., Kieronski, E.: B and D are enough to make the Halpern-Shoham logic  undecidable. In: Proc. of ICALP’10 - Part II, LNCS, vol. 6199, pp. 357–368. Springer (2010)  25. Montanari, A., Peron, A., Policriti, A.: Extending Kamp’s theorem to model time granularity. Journal of  Logic and Computation 12(4), 641–678 (2002)  26. Montanari, A., Puppis, G., Sala, P.: A decidable spatial logic with cone-shaped cardinal directions. In:  Proc. of CSL’09, LNCS, vol. 5771, pp. 394–408. Springer (2009)  27. Montanari, A., Puppis, G., Sala, P.: A decidable spatial logic with cone-shape cardinal directions (extended version of [26]). Research Report 3, Dipartimento di Matematica ed Informatica, Università di  Udine (2010)  28. Montanari, A., Puppis, G., Sala, P.: Maximal decidable fragments of Halpern and Shoham’s modal logic  of intervals. In: Proc. of ICALP’10 - Part II, LNCS, vol. 6199, pp. 345–356. Springer (2010)  29. Montanari, A., Puppis, G., Sala, P., Sciavicco, G.: Decidability of the interval temporal logic ABB̄ on  natural numbers. In: Proc. of STACS’10, pp. 597–608 (2010)  30. Otto, M.: Two variable first-order logic over ordered domains. Journal of Symbolic Logic 66(2), 685–702  (2001)  31. Szwast, W., Tendera, L.: The guarded fragment with transitive guards. Annals of Pure and Applied  Logics 128(1-3), 227–276 (2004)  32. Venema, Y.: Expressiveness and completeness of an interval tense logic. Notre Dame Journal of Formal  Logic 31(4), 529–547 (1990)  33. Venema, Y.: A modal logic for chopping intervals. Journal of Logic and Computation 1(4), 453–476  (1991) 