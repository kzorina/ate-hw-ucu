Compositional Temporal Logic  Based on Partial Order  Adrianna Alexander  Wolfgang Reisig  Humboldt-UniversitÄ‚Â¤t zu Berlin  Unter den Linden 6  10099 Berlin, Germany  alexander@informatik.hu-berlin.de  Abstract  The Temporal Logic of Distributed Actions (TLDA) is a  new temporal logic designed for the speciÄÅ¹Âcation and veriÄÅ¹Âcation of distributed systems. The logic supports a compositional design of systems: subsystems can be speciÄÅ¹Âed  separately and then be integrated into one system. TLDA  can be syntactically viewed as an extension of TLA. We propose a different semantical model based on partial order  which increases the expressiveness of the logic.  1. Introduction  Temporal logic has established itself as an appropriate  tool for describing and proving properties of distributed systems. The idea of specifying a system as a logical formula  was ÄÅ¹Ârst proposed by Pnueli [16]. This means that all the  possible courses of actions (or states) of the a system are  exactly the models of the formula.  A property of a system will also be represented as a logical formula. Thus, no formal distinction will be made between a system and a property. Hence, proving that a system  possess a property is reduced to proving a logical implication. This is a fundamental beneÄÅ¹Ât of this approach.  There are also some other considerable advantages:  Compositional reasoning will be eased signiÄÅ¹Âcantly: Large  systems are composed of smaller components. Properties  of the composed system should be derivable from the properties of its components. The components are represented  as logical formulas. It can be shown that parallel composition of the components can basically be represented by  conjunction of the formulas representing the components.  Furthermore, it is often desirable to express that a higherlevel system is implemented by a lower-level one. This can  simply be represented in logical terms by implication.  However, on the other hand, to describe composition of  concurrent systems in temporal logic is not a simple task  reisig@informatik.hu-berlin.de  (cp. [6]):  A system is usually described by help of variables: A  variable updates its value in the course of time. To represent a possible system execution, one usually assumes temporal snapshots of the actual values of the variables in a  system. Such a snapshot is most often called a global state,  Val, with Var the set of  formally a mapping state : Var  variables and Val the set of (potential) values of the system.  A sequence s0 s1 s2 s3  of global states is called a state  sequence of a system. Each pair s i si1 of adjacent global  states forms a step.  We specify such a system S with a temporal formula, ÃÅš,  whose models are exactly the state sequences of S. ÃÅš will  be called a speciÄÅ¹Âcation of S. Suppose now that we wish  to use the system S as a part of some modular systems in  which other components are working in parallel. A state  sequence of the composed system might possibly involve  steps at much more frequent intervals than a state sequence  of S. Hence, the values of the variables under the control  of S are not updated during these intermediate steps (for the  sake of simplicity suppose that the variables of S are unaffected by the other components). Thus, there is no guarantee that the state sequences of the composed system will  still be models of ÃÅš. Consequently, the composed system  cannot be speciÄÅ¹Âed by conjunction of ÃÅš and the formulas  representing the other components.  A similar problem arises with implementation.  There are several solutions to these problems [6, 8, 9,  15, 12]. In this paper, we are considering one of them: stuttering invariance. LamportÃ¢Â€Â™s Temporal Logic of Actions  (TLA, [12, 3]) is based on this idea (another example is the  Modular Temporal Logic, MTL [15]).  In this approach a temporal formula representing a system will be forced to be stuttering invariant, i.e. its truth is  preserved under addition or removal of a ÄÅ¹Ânite number of  repetitions of the same state in a state sequence. As a result  of this syntactic restriction a speciÄÅ¹Âcation formula of S remains true even though another system is running in parallel  Proceedings of the 11th International Symposium on Temporal Representation and Reasoning (TIMEÃ¢Â€Â™04)  1530-1311/04 $20.00 Ã‚Å  2004 IEEE  with S. This makes it actually possible to specify composition of concurrent systems as conjunction. On the other  hand, however, stuttering causes some undesirable effects  which will be described in more detail in Section 2.  As a solution for the composition (and implementation) problem described above we suggest a new temporal logic, called Temporal Logic of Distributed Actions  (TLDA). TLDA is syntactically similar to TLA, but has a  semantic model different from that of TLA, called a run,  which is based on a partial order. A run consists of two  components: Firstly, the history of each variable, i.e. the sequence of its updates, secondly, the synchronization of updates. This extends the information provided by sequences  of global states.  Hence, the composition and implementation between  systems can be speciÄÅ¹Âed in our logic as conjunction and implication, respectively (Section 5). Furthermore, due to the  partial order based semantic model we can explicitly distinguish between concurrent and the nondeterministic variable  updates (see [5]). Moreover, it can be determined, whether  an update of a variable does not change the value of the variable or whether the variable is not updated at all (Section 4).  is intuitively unfair and is therefore to be excluded from  the set of sequences representing the system M. Hence, (1)  and (2) should be distinguishable in a formalism used for  specifying M.  Unfortunately, they can not be distinguished in a formalism based on stuttering sequences like TLA, since sequences, in which a ÄÅ¹Ânite number of iterations of the same  global state is added or removed, are equivalent. Consequently, an action changing no variable values, like A 1 in  the above example, can not be described. This implies that  we cannot detect whether or not such an action is treated  fair in a computation. Note, that we could detect this for the  action A1 in case the initial values of x and y happened not  to be equal.  This type of actions, however, is quite common in programming languages and it seems reasonable to expect that  they could be described in a speciÄÅ¹Âcation formalism. [17]  addresses this problem as causing troubles when specifying  semantics of rewriting languages.  2. Motivation  We suggest a different model instead. We represent a  (distributed) system not as a set of sequences of global  states, but as a set of partially ordered sets of local updates, called runs. The updates of a single variable are obviously totally ordered. Updates of different variables are  partially ordered: They occur in a run either concurrently  or are sometime enforced to occur coincidently. This principle depicts reality more faithfully than stuttering. We will  depict each update of a variable explicitly as a box. In our  example, the action A 1 coincidently updates the variables x  and y and the action A 2 coincidently updates the variables y  and z. Hence,  We start with a simple example, which demonstrates a  problem arising from stuttering and justiÄÅ¹Âes our approach.  2.1. A Problem with Stuttering  Let M be a system with three variables x, y and z. There  are two actions in M, A 1 and A2 , which are performed nondeterministically: A1 swaps the values of x and y, A 2 reads  the (current) value of y and assigns to z the value z  y  1.  The variables x, y and z have initially the values 1, 1 and 0,  respectively.  Additionally, assume a (weak) fairness requirement for  M stating that every action eventually continuously enabled  in the system would also be inÄÅ¹Ânitely often executed. Both  actions, A1 and A2 , are continuously enabled in M. Thus,  both of them have to be executed inÄÅ¹Ânitely often.  is an execution of M  As an example, A 1 A2 A1 A1 A2  satisfying the fairness requirement. This execution generates the following fair state sequence of M:  x:  y:  z:  1 1 1 1 1 1  1 1 1 1 1 1  0 0 2 2 2 4  (1)  violates the fairness  In contrast, the execution A 2 A2 A2  requirement, since the action A 1 is not performed at all.  Thus, the generated state sequence  x: 1 1 1  y: 1 1 1  z: 0 2 4  (2)  2.2. A Partial Order Solution  ÄÂƒ1 :  x: 1  y: 1  z: 0  C0 C1  t1  1  t3  1  1  t2  1  1 ...  1  1  2  1 ...  4 ...  C2  (3)  is the run representing the execution A 1 ; A2 ; A1 ; A1 ; A2  (the labels C0 C2 and t1 t3 will be explained in Section 3.1) and  ÄÂƒ2 :  x:  y:  1  1  1  1  z:  0  2  4  ...  (4)  the run representing A 2 ; A2 ; A2 . Obviously, there are no  concurrent updates in the system M. An example of a run of  another system, in which all y-updates would be concurrent  Proceedings of the 11th International Symposium on Temporal Representation and Reasoning (TIMEÃ¢Â€Â™04)  1530-1311/04 $20.00 Ã‚Å  2004 IEEE  to the z-updates is shown in (5).  ÄÂƒ3 :  y:  z:  update of one variable or a synchronized update of several  variables; technically a mapping:  1  t11  1  1  ...  0  t22  2  4  ...  (5)  For the sake of compositionality, we assume, as TLA  does, that the set of variables Var of a system as well as  the set of values Val are inÄÅ¹Ânite. Hence, we will explicitly describe updates of a ÄÅ¹Ânite subset of the variables only.  These variables will be called system variables. Thus, a run  consists of inÄÅ¹Ânitely many variables and we always graphically outline only the ÄÅ¹Ânite part of it concerning updates  of the system variables, called the restriction of the run to  the system variables. We assume that the values of all other  variables change arbitrarily. Therefore, the set of all runs of  a system will always be inÄÅ¹Ânite. This set will be called the  behavior of the system.  The next section provides the foundations of our formalism, in which we are able to specify such behaviors. The  speciÄÅ¹Âcation of the sample system M will be presented in  Section 4.  3. The Logic TLDA  In this section we introduce the representation of the semantic model of TLDA, followed by its syntax and semantics.  3.1. The Semantic Model  The semantic model of a TLDA formula is a run as already intuitively introduced and exempliÄÅ¹Âed above in (3)Ã¢Â€Â“  (5). The notation of a run resembles that of an occurrence  net known from Petri netÃ¢Â€Â™s theory (see [7] for instance). A  run consists of a history of each variable and a set of transitions.  History In a run ÄÂƒ of a system each variable x Var  evolves its history. A history of x is a ÄÅ¹Ânite or inÄÅ¹Ânite  sequence H x  x0 x1 x2  of values xi Val. xi is  the local state of x at index i. We abbreviate H x to H x .  l Hx  denotes the length of a sequence H x . As an example,  Hz  0 2 4 is the history of the variable z, and H z 0  0,  Hz 1  2 etc. The histories of the variables constitute the  history of the run:  Let Val and ValÄÂ‰ denote the set of all non-empty, ÄÅ¹Ânite  and inÄÅ¹Ânite sequences of values, respectively, and let Val Ã¢ÂˆÂ   Val  ValÄÂ‰ . Then  H : Var  ValÃ¢ÂˆÂ  is a history.  Transitions Updates of different variables in a history  may synchronize, i.e. occur coincidently. A transition is an  t :V   0  where 0/  V  Var is ÄÅ¹Ânite. V  dom t  includes all variables that are involved in the transition t. t x  i denotes  that the ith value in the history of x is updated by t.  In the run ÄÂƒ 1 in (3) the transition t 1 depicts a synchronized update of the variables x and y. Hence x and y are  involved in t 1 . The transition t11 of the run ÄÂƒ 3 in (5) is an  update of the variable y. Thus, y is the only variable involved in t11 .  Transitions in a run are (partially) ordered. We deÄÅ¹Âne an  immediate successor relation  for t u T by  t  u  iff there exists a variable x  with : t x  u x  1  dom t   dom u  For example, t 1  t2  t3     holds in ÄÂƒ1 , t11  t22 does  not hold in ÄÂƒ 3 . Let  denote the transitive closure of .  Transitions in a run which are not related by  are called  concurrent. For instance, t 11 and t22 are concurrent in ÄÂƒ 3 .  We require that for every transition t there is a ÄÅ¹Ânite number of transitions t i with ti  t. This completes the notions  required for the deÄÅ¹Ânition of a run:  Runs Let H be a history and let T be a set of transitions.  ÄÂƒ  H T  is a run iff  For every variable x Var and for all i with 0 i   l Hx   1, there exists exactly one transition t T with  t x  i.  For all t T and for all variables x dom t  holds:  0 t x  l Hx   1.  The relation  on T is irreÄÅ¹Â‚exive.  The runs ÄÂƒ1 Ã¢Â€Â“ÄÂƒ3 fulÄÅ¹Âll these properties. In the rest of this  section we assume a run ÄÂƒ  H T  with a history H and a  set of transitions T .  Since in a run ÄÂƒ the relation  on T is transitive (by definition of a transitive closure) and irreÄÅ¹Â‚exive (by deÄÅ¹Ânition  of the run),  constitutes a partial order on the transition  set of ÄÂƒ .  Cuts and Steps  can canonically be generalized to the  local states of variables. A set of local states which are not  related by  forms a cut.  Formally, a mapping  C : Var   0  is called a cut in ÄÂƒ iff for each t  holds:  T and all x y  dom t   if t x  C x then t y  C y  For instance, C0 with C0 x  C0 y  C0 z  0, as well  as C2 with C2 y  2 and C2 x  C2 z  1 are cuts in ÄÂƒ1 .  Proceedings of the 11th International Symposium on Temporal Representation and Reasoning (TIMEÃ¢Â€Â™04)  1530-1311/04 $20.00 Ã‚Å  2004 IEEE  C0 : Var  0 is obviously a cut in every run ÄÂƒ and will be  called the initial cut in ÄÂƒ .  We say that a transition t  T occurs at C if t updates  variables at the local states belonging to C, i.e. if t x   C x for each x  dom t .  From the deÄÅ¹Ânition of a cut arises an important observation: Any two transitions that occur at C are concurrent in  ÄÂƒ.  When one or more transitions occur, another cut will be  reached. For example, from C 0 in ÄÂƒ1 the cut C1 is reached  by the occurrence of t 1 .  Let UC be the set of transitions that occur at C. For each  cut C, the successor cut C Ã‚Åº of C will be reached by occurrence of all transitions from UC . CÃ‚Åº is for each x  Var deÄÅ¹Âned by:  C Ã‚Åº x   C x  1  C x  if x  dom t  for some t  UC  otherwise  It is quite easy to prove that C Ã‚Åº is a cut in ÄÂƒ , too.  A cut C and its successor cut C Ã‚Åº , together with the transition set UC form a step SC . Thus, SC will canonically be  deÄÅ¹Âned by the cut C. Note that not every cut of a run ÄÂƒ can  be reached by taking such maximal steps from C 0 . Hence,  the cuts do not constitute the run; they rather may be conceived as observations of the run.  3.2. Syntax of TLDA  Vocabulary A vocabulary of TLDA is given by the following sets: a set of function symbols , a set of predicate  symbols  (the symbol for equality  is one of them in  particular), a set of special symbols and a set of variables.  Additionally, TLDA expressions can include brackets,  which we use in order to overwrite the binding priorities  or just to increase readability.  Each predicate symbol and each function symbol has an  arity. Constants can be thought of as 0-arity functions.  The set of special symbols consists of the standard  boolean connectives  and , the quantiÄÅ¹Âer  and the temporal operator Ã‚Å¾. The sets ,  and the set of special  symbols should be pairwise disjoint.  An inÄÅ¹Ânite set of variables Var all is partitioned into inÄÅ¹Ânite disjoint sets of:       rigid variables Var rigid       ,   ÄÅ¹Â‚exible variables Var  x y    ,   primed ÄÅ¹Â‚exible variables Var Ã‚Åº  xÃ‚Åº  x  Var  x Ã‚Åº y Ã‚Åº    ,    a  0/  a Var   and -variables Var      x y x y    .    x and  x y are abbreviated to x and xy,   respectively.      Terms The terms of our logic, like in the classical predicate logic, are made up of variables and functions applied  to them:   Any variable from Var rigid Var VarÃ‚Åº is a term.   If t1 t2    tn are terms, f   has arity n, then  f t1 t2    tn  is a term.  Formulas Based on the terms we can continue to deÄÅ¹Âne  the formulas of our logic in the common way. The formulas  are divided into two classes: the step formulas and the run  formulas.  The set of step formulas over  and  is inductively  deÄÅ¹Âned as follows:     If P is a predicate taking n arguments, n 1, and if  t1 t2    tn are terms over , then P t 1 t2    tn  is a  step formula.   is a step formula.   Any variable from the set Var   If F and G are step formulas, then so are F and F  G.   If x  Varrigid and if F is a step formula, then so is x F.  (We omit here the quantiÄÅ¹Âcation over ÄÅ¹Â‚exible and variables, which is also deÄÅ¹Âned in TLDA, since this would  extend the scope of this paper.)  and  is inductively  The set of run formulas over  deÄÅ¹Âned as follows:     Any step formula F is a run formula.   If F and G are run formulas, then so are F, F  G and  Ã‚Å¾F.   If x  Varrigid and if F is a run formula, then so is x F.  We use some conventional arithmetical and logical abbreviations in TLDA, including boolean abbreviations true  (for P P), false,  and , as well as Ã‚Å¼ (for Ã‚Å¾).  xÃ‚Åº  x  1,   z   0  z  15    x2 ,  where  is a rigid variable, are examples of step formulas   Ã‚Å¾ z  xÃ‚Åº  x  5 are  in our logic. Ã‚Å¾ z   Ã‚Å¾xy  examples of run formulas,  is a rigid variable.  3.3. Semantics of TLDA  Now we explain brieÄÅ¹Â‚y the difference between the sets  of variables introduced above.  Rigid variables stand for an unknown but ÄÅ¹Âxed value.  Flexible variables will be mostly called program variables.  They are intended to describe changes in our systems: Every program variable has a value in a particular cut C of  a system run. A value of any given program variable in  the successor cut C Ã‚Åº will be described by a corresponding  primed program variable.  The partition of variables into rigid and ÄÅ¹Â‚exible variables  is a well known idea (see for example [14]) and primed variables have also been used before for describing values of  variables in a successor state ([12, 14]).  Proceedings of the 11th International Symposium on Temporal Representation and Reasoning (TIMEÃ¢Â€Â™04)  1530-1311/04 $20.00 Ã‚Å  2004 IEEE  The -variables are new. They are independent from the  values assigned to the program variables in a cut of a system run: The -variables can only take boolean values and  provide information about the synchronization of variable  updates. Some subsequent examples will clarify this concept.  The semantics of the logic resembles those for other temporal logics. We assume a non-empty set Val of concrete  values, called the universe, we interpret each function symas a concrete function on Val, and each predicate  bol in  symbol in  as a predicate over Val. Formally, the inter consists of the following set of data:  pretation I of            a non-empty set Val,  for each n-ary f   a function f I : Valn  Val, and  for each P   with n arguments a subset P I  Valn .    Evaluating terms Let r be a mapping r : Var rigid  Val  which associates with every rigid variable m a value r m  of the universe. The values of all program variables and  primed program variables depend on a run.  Terms will be evaluated in steps of a run as follows: Let  ÄÂƒ  H T  be a run and let SC be a step of ÄÂƒ taken from the  cut C. To each rigid variable we assign its value according  to the mapping r. To each program variable x  Var we  assign the value Hx C x, i.e. the value assigned to x at the  C xth index in its history Hx . This is intuitively the value  of x in the global state C. To each primed program variable  xÃ‚Åº  VarÃ‚Åº we assign the value Hx CÃ‚Åº x. Intuitively, each  variable xÃ‚Åº gets the value of x in the succeeding global state  CÃ‚Åº .  Formally, to compute the value of a term in S C under the  interpretation I and with respect to r we inductively deÄÅ¹Âne  a mapping rC as follows:  rC  rC m  r m  if m  Varrigid  rC x  Hx C x  if x  Var  rC xÃ‚Åº   Hx CÃ‚Åº x  if xÃ‚Åº  VarÃ‚Åº and  f t1    tn   f I rC t1     rC tn   if t1    tn are terms  Evaluating step formulas A model of a step formula  consists of a step SC of a run ÄÂƒ and an interpretation I of   (for convenience, we will write simply S C in place  of SC I  when a model of a step formula is concerned). Let  r be a valuation mapping of rigid variables.  We deÄÅ¹Âne the notion SC r ÄÂˆ of ÄÂˆ holding in SC with  respect to r for each step formula ÄÂˆ by structural induction  on ÄÂˆ :        SC r P t1    tn  iff rC t1     rC tn   PI .  SC r a iff a  dom t  for any t  UC ,  i.e. we replace a by the boolean value true, if a is a subset of the variables involved in a transition t occurring  at C, and by false otherwise.    SC r F, SC r F  G and SC  Varrigid are standard.  r x F  for x    Examples Let SC0 and SC1 be steps of ÄÂƒ1 as given in (3).  In SC0 holds z because no transition of S C0 involves z. In  SC1 holds yz, since there is a transition t 2 in which both y and  z are involved. This implies in particular that z is involved  in this transition, so z is true in SC1 too. The same holds for  the variable y.  In contrast, in the initial step of the run ÄÂƒ 3 in (5) holds y  and z, because there are apparently transitions t 11 and t22 , in  which y and z are involved, respectively. But in this step yz  does not hold.  Evaluating run formulas Now we extend the semantics  to run formulas. A model of a run formula is a pair ÄÂƒ C  consisting of a run ÄÂƒ and a cut C of ÄÂƒ , and an interpretation  I for   (we will write for convenience simply ÄÂƒ C   instead of ÄÂƒ C I ). Analogously to step formulas, we deÄÅ¹Âne now the notion ÄÂƒ C  r ÄÂˆ of ÄÂˆ holding in ÄÂƒ C with  respect to a valuation mapping r of rigid variables for each  run formula ÄÂˆ by structural induction on ÄÂˆ :          ÄÂƒ C r F iff SC r F.  ÄÂƒ C r F, as well as F  G and xF for x  Var rigid  are standard.  ÄÂƒ C r Ã‚Å¾F iff ÄÂƒ CÃ‚Å   F for every cut C Ã‚Å of ÄÂƒ  with CÃ‚Å x C x for all x  Var.  Notations We usually omit an explicit denotation of the  mapping r and write simply ÄÂƒ C  ÃÅš for ÄÂƒ C  r ÃÅš.  Furthermore, if a run formula ÃÅš holds in ÄÂƒ at the initial cut  C0 , i.e. ÄÂƒ C0   ÃÅš, we write ÄÂƒ  ÃÅš. The set of all models  of ÃÅš will be denoted by ÃÅ ÃÅš. Hence, ÃÅ ÃÅš is the behavior  of the system speciÄÅ¹Âed by ÃÅš. Finally,  V ÃÅš  x  Var x xÃ‚Åº occurs in ÃÅš or a occurs in ÃÅš  and x  a  denotes the set of Var-variables occurring in ÃÅš.  4. Specifying Systems in TLDA  With the logic of Section 3 we are now ready to specify  systems. In this section we revise our motivating example  and describe the behavior of the system M based on the informal description from Section 2. We describe the initial  values of the system variables x, y and z of M by the formula:  Minit   x  1y  1z  0  Recall that there are two actions in the system M which are  performed nondeterministically: The action A 1 swaps the  values of x and y, the action A 2 reads y and changes z according to the current value of y. Each occurrence of A 1 or  A2 will be represented in a run of M by a transition involving  Proceedings of the 11th International Symposium on Temporal Representation and Reasoning (TIMEÃ¢Â€Â™04)  1530-1311/04 $20.00 Ã‚Å  2004 IEEE  both x and y or y and z, respectively. We describe an update  of a variable in case this variable is involved in a transition:  x is involved only together with y, and the value of x will be  set on the previous value of y. This will be expressed by the  xy x Ã‚Åº  y. We likewise describe what hapformula x  pens if y and z are involved in a transition. Additionally, we  claim that x and z are never involved in the same transition.  Hence, the following formula speciÄÅ¹Âes the updates of M:    Mnext  Ã‚Å¾             x  xy xÃ‚Åº  y  y  xy yÃ‚Åº  x yz yÃ‚Åº  y  z  yz zÃ‚Åº  z  y  1  xz        HRinit  HRnext  Ã‚Å¼  Ã‚Å¾Ã‚Å¼z  LÃ‚Å¾ x      For simplicity we omit here the general deÄÅ¹Ânition of fairness. Hence, the system M is speciÄÅ¹Âed by Minit Mnext L.  Note that the runs ÄÂƒ 1 and ÄÂƒ2 can now be well distinguished: The run ÄÂƒ 1 is a model of this speciÄÅ¹Âcation, while  ÄÂƒ2 is not, since  x does not hold in ÄÂƒ 2 . Consequently, ÄÂƒ 2  is excluded from the behavior of M.  Ã‚Å¾Ã‚Å¼  In this section, we focus on parallel composition of systems and their speciÄÅ¹Âcation in TLDA. Let S 1 and S2 be systems speciÄÅ¹Âed by formulas ÃÅš 1 and ÃÅš2 , respectively. Parallel composition of S 1 and S2 is deÄÅ¹Âned as the intersection of their behaviors ÃÅ ÃÅš 1  ÃÅ ÃÅš2 . From this deÄÅ¹Ânition  follows immediately by logical reasoning that the speciÄÅ¹Âcation formula of the composed system is the conjunction  ÃÅš1 ÃÅš2 of the speciÄÅ¹Âcation formulas of the components.  The idea of composition as conjunction has been suggested  in [4, 1, 2, 13]. Works on compositional semantics based on  partial order are [10, 11].  We introduce the basic concepts with a simple version of  a clock composition. We borrow this example from [13].  An hour clock displays the hours; for this purpose  we assume the variable hr to display sequences such as  22 23 00 01 . Likewise, a minute clock with the variable  min displays sequences such as 58 59 00 01 .      23  00    Ã‚Åº    Since the hour clock is a detached component which should  later work as a part of a bigger system, we specify it in a  way allowing arbitrary synchronization with any other subsystem. Such speciÄÅ¹Âcation will be called environment invariant.  Formally, a formula ÃÅš will be called environment invariant iff for all runs ÄÂƒ with ÄÂƒ  ÃÅš holds: ÄÂƒ  ÃÅš for all runs  ÄÂƒ such that the restrictions of ÄÂƒ and of ÄÂƒ to the variables  V ÃÅš are identical.  We give here a sufÄÅ¹Âcient syntactical condition for environment invariance: A formula ÃÅš is environment invariant  if either ÃÅš false, or one of the cases 1Ã¢Â€Â“3 holds:  1. no primed or -variables occur in ÃÅš.  2. ÃÅš has the form a ÃÂ¨ where ÃÂ¨ is a step formula such  that either  ÃÂ¨ false (i.e. ÃÅš is equivalent to a), or  if v or vÃ‚Åº occurs in ÃÂ¨ then v a and if v occurs in  ÃÂ¨ then v a  0.  /  3. ÃÅš has the form ÃÂ¨ a where ÃÂ¨ is a step formula such  that  no -variables occur in ÃÂ¨, and  V ÃÂ¨  v for a variable v Var and v a.       5. Composing SpeciÄÅ¹Âcations  22   hr  0 23   hr  suchr hr  with suchr 23  0 suchr n  n  1 if n  23  We focused so far on the safety part of the speciÄÅ¹Âcation  of M only. Now we consider the liveness condition for M,  stating that each of the actions A 1 and A2 should be executed inÄÅ¹Ânitely often. In order to satisfy this condition it  sufÄÅ¹Âces to require that both x and z are inÄÅ¹Ânitely often involved in a transition of a run (such requirement for y would  be redundant):  hr:  hr, including min, may change arbitrarily. These variables  constitute the environment of hr. A run of the minute clock  resembles (6) with some obvious modiÄÅ¹Âcations.  We start with specifying the hour clock: The formula  HRinit speciÄÅ¹Âes the clockÃ¢Â€Â™s initial state, viz the initial value  of the variable hr to vary between 0 and 23. HR next speciÄÅ¹Âes  the clockÃ¢Â€Â™s updates: Each update increases hr by one, with  the exception that 23 is followed by 0.  01  ...  (6)  is a run of the hour clock. Recall that this run actually consists of inÄÅ¹Ânitely many variables. All variables other than          Lemma 1 Let ÃÅš and ÃÂ¨ be formulas. If ÃÅš and ÃÂ  are environment invariant, then so are ÃÅš ÃÂ  and ÃÅš.    Ã‚Å¾  These properties are very useful for writing system speciÄÅ¹Âcations.  Observe that the formula Mnext in Section 4 is environment invariant while  x x Ã‚Åº  x  1 and  xy xÃ‚Åº  y  are not.  Now, we come back to the clock example. To allow hr an  arbitrary synchronization with its environment, we require  that the formula HR next is to be applied only in system steps  which involve the variable hr. Observe that this fulÄÅ¹Âlls the  syntactical condition given above. Hence, the speciÄÅ¹Âcation  of the hour clock is  Ã‚Å¾    HR  HRinit   Ã‚Å¾ hr  Ã‚Å¾    HRnext   The speciÄÅ¹Âcation of the minute clock strongly resembles the  Proceedings of the 11th International Symposium on Temporal Representation and Reasoning (TIMEÃ¢Â€Â™04)  1530-1311/04 $20.00 Ã‚Å  2004 IEEE  speciÄÅ¹Âcation of the hour clock:  MIN init  min 0    59  MIN next  minÃ‚Åº sucmin min  with sucmin 59 0 sucmin n n  1 if n  59   MIN init  Ã‚Å¾ min  MIN next   MIN  One easily observes that every run of the hour-minute clock,  such as (7), is a model of the conjunction HR  MIN. This  conjunction, however, speciÄÅ¹Âes the hour and the minute  clock working really in parallel. Thus, it additionally admits models that are not proper runs of the hour-minute  clock.  hr: 22  23  00 ...  59  00  01  ...  59  00 ...  min: 58  (7)  The unwanted models do not properly synchronize the  updates of hr and min. Hence we strive for an additional formula, SYNC, to express additional constraints on the models. SYNC talks about synchronized updates of hr and min  by help of the variable hrmin. Two properties are required:  Firstly, the variables hr and min synchronize their updates  iff min 59. Secondly, each update of hr is synchronized  with an update of min:  SYNC  Ã‚Å¾hrmin  min    59  Ã‚Å¾hr  hrmin  Note that the formula SYNC is environment invariant, too.  (But this is not always necessary.) It can easily be shown  by transforming hrmin  min 59 into an equivalent formula hrmin  min 59  min 59  hrmin fulÄÅ¹Âlling  the syntactical condition given above, and then by applying  Lemma 1.  Hence, the hour-minute clock will be speciÄÅ¹Âed by  HR  MIN  SYNC  Since this speciÄÅ¹Âcation is by Lemma 1 also environment  invariant, the hour-minute clock can effortless be used as a  component for a further system.  The above clock example shows how a system composed of independent interacting components will be usually speciÄÅ¹Âed: Firstly, an environment invariant speciÄÅ¹Âcation will be given for each component. Since the components are independent they always have disjoint system  variables. Secondly, a synchronization formula employing  primarily -variables will be added to deÄÅ¹Âne the interactions between the components.  6. Conclusion  We suggest a new temporal logic, TLDA, for specifying  and verifying distributed systems. The logic can syntactically be conceived as a variant of TLA. TLDA, however,  is interpreted on partial order semantics. This renders the  logic more expressive. Furthermore, we have shown that  TLDA supports a compositional system design: subsystems  can be speciÄÅ¹Âed separately and then be integrated into one  system.  References  [1] M. Abadi and L. Lamport. Decomposing speciÄÅ¹Âcations of  concurrent systems. In E.-R. Olderog, editor, Proc. of the  Working Conference on Programming Concepts, Methods  and Calculi (PROCOMET Ã¢Â€Â™94), volume A-56 of IFIP Transactions, pages 327Ã¢Â€Â“340. North-Holland, 1994.  [2] M. Abadi and L. Lamport. Conjoining speciÄÅ¹Âcations.  ACM Transactions on Programming Languages and Systems, 17(3):507Ã¢Â€Â“534, May 1995.  [3] M. Abadi and S. Merz. On TLA as a logic. In M.Broy,  editor, Deductive Program Design, NATO ASI series F.  Springer-Verlag, 1996.  [4] M. Abadi and G. Plotkin. A logical view of composition.  Theoretical Computer Science, 114(1):3Ã¢Â€Â“30, 1993.  [5] A. Alexander and W. Reisig. Logic of involved variables system speciÄÅ¹Âcation with Temporal Logic of Distributed Actions. In Proc. of the 3rd International Conference on Aplication of Concurrency to System Design (ACSDÃ¢Â€Â™03), pages  167Ã¢Â€Â“176, Guimaraes, Portugal, 2003.  [6] H. Barringer, R. Kuiper, and A. Pnueli. Now you may compose temporal logic speciÄÅ¹Âcations. In Proc. of the 16th Annual ACM Aymposium on Theory of Computing, pages 51Ã¢Â€Â“  63, 1984.  [7] E. Best and C. Fernandez. Nonsequential processes Ã¢Â€Â“ a Petri  net view. In W. Brauer, G. Rozenberg, and A. Salomaa, editors, EATCS Monographs on Theoretical Computer Science,  volume 13. Springer-Verlag, 1988.  [8] A. Cau and W.-P. d. Roever. A dense-time temporal logic  with nice compositionality properties. In Proc. of the 6th  International Workshop on Computer Aided Systems Theory EUROCASTÃ¢Â€Â™97, Las Palmas de Gran Canaria, Spain,  volume 1331 of LNCS, pages 123Ã¢Â€Â“145. Springer, February  1997.  [9] J. Fiadeiro and T. Maibaum. Sometimes Ã¢Â€ÂœtomorrowÃ¢Â€Â is  Ã¢Â€ÂœsometimeÃ¢Â€Â: Action reÄÅ¹Ânement in a temporal logic of objects. In D. Gabbay and H. Ohlbach, editors, Proc. of the  1st International Conference on Temporal Logic ICTLÃ¢Â€Â™94,  volume 827 of LNAI, pages 48Ã¢Â€Â“66. Springer-Verlag, 1994.  [10] D. Gomm, E. Kindler, B. Paech, and R. Walter. Compositional liveness properties of EN-systems. In M. Marsan, editor, Applications and Theory of Petri Nets 1993, 14th International Conference, volume 691 of LNCS, pages 262Ã¢Â€Â“281.  Springer-Verlag, June 1993.  [11] E. Kindler. A compositional partial order semantics for Petri  net components. In P. AzÄ‚Å ma and G. Balbo, editors, Application and Theory of Petri Nets 1997, 18th International Conference, volume 1248 of LNCS, pages 235Ã¢Â€Â“252. SpringerVerlag, June 1997.  [12] L. Lamport. The Temporal Logic of Actions. ACM Transactions on Programming Languages and Systems, 16(3):872Ã¢Â€Â“  923, May 1994.  Proceedings of the 11th International Symposium on Temporal Representation and Reasoning (TIMEÃ¢Â€Â™04)  1530-1311/04 $20.00 Ã‚Å  2004 IEEE  [13] L. Lamport. Composition: A way to make proofs harder. In  A. W.P.de Roever, H.Langmaack, editor, Compositionality:  The SigniÄÅ¹Âcant Difference, International Symposium, COMPOSÃ¢Â€Â™97, volume 1536 of LNCS, pages 402Ã¢Â€Â“423, September  1997.  [14] Z. Manna and A. Pnueli. The temporal logic of Reactive and  Concurrent Systems: SpeciÄÅ¹Âcation. Springer, 1992.  [15] A. Mokkedem and D. Mery. A stuttering closed temporal logic for modular reasoning about concurrent programs.  In D. Gabbay and H. Ohlbach, editors, Temporal Logic,  Proc. of the 1st International Conference on Temporal Logic  ICTLÃ¢Â€Â™94, volume 827 of LNAI, pages 382Ã¢Â€Â“397. SpringerVerlag, 1994.  [16] A. Pnueli. The temporal semantics of concurrent programs.  Theoretical Computer Science, 13(1):45Ã¢Â€Â“61, 1981.  [17] M. Reynolds.  Changing nothing is sometimes doing  something: Fairness in extensonal semantics. ulr: citeseer.nj.nec.com/ reynolds96changing. html, 1996.  Proceedings of the 11th International Symposium on Temporal Representation and Reasoning (TIMEÃ¢Â€Â™04)  1530-1311/04 $20.00 Ã‚Å  2004 IEEE 