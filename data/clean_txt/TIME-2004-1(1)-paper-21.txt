Compositional Temporal Logic  Based on Partial Order  Adrianna Alexander  Wolfgang Reisig  Humboldt-UniversitĂ¤t zu Berlin  Unter den Linden 6  10099 Berlin, Germany  alexander@informatik.hu-berlin.de  Abstract  The Temporal Logic of Distributed Actions (TLDA) is a  new temporal logic designed for the speciďŹcation and veriďŹcation of distributed systems. The logic supports a compositional design of systems: subsystems can be speciďŹed  separately and then be integrated into one system. TLDA  can be syntactically viewed as an extension of TLA. We propose a different semantical model based on partial order  which increases the expressiveness of the logic.  1. Introduction  Temporal logic has established itself as an appropriate  tool for describing and proving properties of distributed systems. The idea of specifying a system as a logical formula  was ďŹrst proposed by Pnueli [16]. This means that all the  possible courses of actions (or states) of the a system are  exactly the models of the formula.  A property of a system will also be represented as a logical formula. Thus, no formal distinction will be made between a system and a property. Hence, proving that a system  possess a property is reduced to proving a logical implication. This is a fundamental beneďŹt of this approach.  There are also some other considerable advantages:  Compositional reasoning will be eased signiďŹcantly: Large  systems are composed of smaller components. Properties  of the composed system should be derivable from the properties of its components. The components are represented  as logical formulas. It can be shown that parallel composition of the components can basically be represented by  conjunction of the formulas representing the components.  Furthermore, it is often desirable to express that a higherlevel system is implemented by a lower-level one. This can  simply be represented in logical terms by implication.  However, on the other hand, to describe composition of  concurrent systems in temporal logic is not a simple task  reisig@informatik.hu-berlin.de  (cp. [6]):  A system is usually described by help of variables: A  variable updates its value in the course of time. To represent a possible system execution, one usually assumes temporal snapshots of the actual values of the variables in a  system. Such a snapshot is most often called a global state,  Val, with Var the set of  formally a mapping state : Var  variables and Val the set of (potential) values of the system.  A sequence s0 s1 s2 s3  of global states is called a state  sequence of a system. Each pair s i si1 of adjacent global  states forms a step.  We specify such a system S with a temporal formula, ÎŚ,  whose models are exactly the state sequences of S. ÎŚ will  be called a speciďŹcation of S. Suppose now that we wish  to use the system S as a part of some modular systems in  which other components are working in parallel. A state  sequence of the composed system might possibly involve  steps at much more frequent intervals than a state sequence  of S. Hence, the values of the variables under the control  of S are not updated during these intermediate steps (for the  sake of simplicity suppose that the variables of S are unaffected by the other components). Thus, there is no guarantee that the state sequences of the composed system will  still be models of ÎŚ. Consequently, the composed system  cannot be speciďŹed by conjunction of ÎŚ and the formulas  representing the other components.  A similar problem arises with implementation.  There are several solutions to these problems [6, 8, 9,  15, 12]. In this paper, we are considering one of them: stuttering invariance. Lamportâs Temporal Logic of Actions  (TLA, [12, 3]) is based on this idea (another example is the  Modular Temporal Logic, MTL [15]).  In this approach a temporal formula representing a system will be forced to be stuttering invariant, i.e. its truth is  preserved under addition or removal of a ďŹnite number of  repetitions of the same state in a state sequence. As a result  of this syntactic restriction a speciďŹcation formula of S remains true even though another system is running in parallel  Proceedings of the 11th International Symposium on Temporal Representation and Reasoning (TIMEâ04)  1530-1311/04 $20.00 ÂŠ 2004 IEEE  with S. This makes it actually possible to specify composition of concurrent systems as conjunction. On the other  hand, however, stuttering causes some undesirable effects  which will be described in more detail in Section 2.  As a solution for the composition (and implementation) problem described above we suggest a new temporal logic, called Temporal Logic of Distributed Actions  (TLDA). TLDA is syntactically similar to TLA, but has a  semantic model different from that of TLA, called a run,  which is based on a partial order. A run consists of two  components: Firstly, the history of each variable, i.e. the sequence of its updates, secondly, the synchronization of updates. This extends the information provided by sequences  of global states.  Hence, the composition and implementation between  systems can be speciďŹed in our logic as conjunction and implication, respectively (Section 5). Furthermore, due to the  partial order based semantic model we can explicitly distinguish between concurrent and the nondeterministic variable  updates (see [5]). Moreover, it can be determined, whether  an update of a variable does not change the value of the variable or whether the variable is not updated at all (Section 4).  is intuitively unfair and is therefore to be excluded from  the set of sequences representing the system M. Hence, (1)  and (2) should be distinguishable in a formalism used for  specifying M.  Unfortunately, they can not be distinguished in a formalism based on stuttering sequences like TLA, since sequences, in which a ďŹnite number of iterations of the same  global state is added or removed, are equivalent. Consequently, an action changing no variable values, like A 1 in  the above example, can not be described. This implies that  we cannot detect whether or not such an action is treated  fair in a computation. Note, that we could detect this for the  action A1 in case the initial values of x and y happened not  to be equal.  This type of actions, however, is quite common in programming languages and it seems reasonable to expect that  they could be described in a speciďŹcation formalism. [17]  addresses this problem as causing troubles when specifying  semantics of rewriting languages.  2. Motivation  We suggest a different model instead. We represent a  (distributed) system not as a set of sequences of global  states, but as a set of partially ordered sets of local updates, called runs. The updates of a single variable are obviously totally ordered. Updates of different variables are  partially ordered: They occur in a run either concurrently  or are sometime enforced to occur coincidently. This principle depicts reality more faithfully than stuttering. We will  depict each update of a variable explicitly as a box. In our  example, the action A 1 coincidently updates the variables x  and y and the action A 2 coincidently updates the variables y  and z. Hence,  We start with a simple example, which demonstrates a  problem arising from stuttering and justiďŹes our approach.  2.1. A Problem with Stuttering  Let M be a system with three variables x, y and z. There  are two actions in M, A 1 and A2 , which are performed nondeterministically: A1 swaps the values of x and y, A 2 reads  the (current) value of y and assigns to z the value z  y  1.  The variables x, y and z have initially the values 1, 1 and 0,  respectively.  Additionally, assume a (weak) fairness requirement for  M stating that every action eventually continuously enabled  in the system would also be inďŹnitely often executed. Both  actions, A1 and A2 , are continuously enabled in M. Thus,  both of them have to be executed inďŹnitely often.  is an execution of M  As an example, A 1 A2 A1 A1 A2  satisfying the fairness requirement. This execution generates the following fair state sequence of M:  x:  y:  z:  1 1 1 1 1 1  1 1 1 1 1 1  0 0 2 2 2 4  (1)  violates the fairness  In contrast, the execution A 2 A2 A2  requirement, since the action A 1 is not performed at all.  Thus, the generated state sequence  x: 1 1 1  y: 1 1 1  z: 0 2 4  (2)  2.2. A Partial Order Solution  Ď1 :  x: 1  y: 1  z: 0  C0 C1  t1  1  t3  1  1  t2  1  1 ...  1  1  2  1 ...  4 ...  C2  (3)  is the run representing the execution A 1 ; A2 ; A1 ; A1 ; A2  (the labels C0 C2 and t1 t3 will be explained in Section 3.1) and  Ď2 :  x:  y:  1  1  1  1  z:  0  2  4  ...  (4)  the run representing A 2 ; A2 ; A2 . Obviously, there are no  concurrent updates in the system M. An example of a run of  another system, in which all y-updates would be concurrent  Proceedings of the 11th International Symposium on Temporal Representation and Reasoning (TIMEâ04)  1530-1311/04 $20.00 ÂŠ 2004 IEEE  to the z-updates is shown in (5).  Ď3 :  y:  z:  update of one variable or a synchronized update of several  variables; technically a mapping:  1  t11  1  1  ...  0  t22  2  4  ...  (5)  For the sake of compositionality, we assume, as TLA  does, that the set of variables Var of a system as well as  the set of values Val are inďŹnite. Hence, we will explicitly describe updates of a ďŹnite subset of the variables only.  These variables will be called system variables. Thus, a run  consists of inďŹnitely many variables and we always graphically outline only the ďŹnite part of it concerning updates  of the system variables, called the restriction of the run to  the system variables. We assume that the values of all other  variables change arbitrarily. Therefore, the set of all runs of  a system will always be inďŹnite. This set will be called the  behavior of the system.  The next section provides the foundations of our formalism, in which we are able to specify such behaviors. The  speciďŹcation of the sample system M will be presented in  Section 4.  3. The Logic TLDA  In this section we introduce the representation of the semantic model of TLDA, followed by its syntax and semantics.  3.1. The Semantic Model  The semantic model of a TLDA formula is a run as already intuitively introduced and exempliďŹed above in (3)â  (5). The notation of a run resembles that of an occurrence  net known from Petri netâs theory (see [7] for instance). A  run consists of a history of each variable and a set of transitions.  History In a run Ď of a system each variable x Var  evolves its history. A history of x is a ďŹnite or inďŹnite  sequence H x  x0 x1 x2  of values xi Val. xi is  the local state of x at index i. We abbreviate H x to H x .  l Hx  denotes the length of a sequence H x . As an example,  Hz  0 2 4 is the history of the variable z, and H z 0  0,  Hz 1  2 etc. The histories of the variables constitute the  history of the run:  Let Val and ValĎ denote the set of all non-empty, ďŹnite  and inďŹnite sequences of values, respectively, and let Val â   Val  ValĎ . Then  H : Var  Valâ  is a history.  Transitions Updates of different variables in a history  may synchronize, i.e. occur coincidently. A transition is an  t :V   0  where 0/  V  Var is ďŹnite. V  dom t  includes all variables that are involved in the transition t. t x  i denotes  that the ith value in the history of x is updated by t.  In the run Ď 1 in (3) the transition t 1 depicts a synchronized update of the variables x and y. Hence x and y are  involved in t 1 . The transition t11 of the run Ď 3 in (5) is an  update of the variable y. Thus, y is the only variable involved in t11 .  Transitions in a run are (partially) ordered. We deďŹne an  immediate successor relation  for t u T by  t  u  iff there exists a variable x  with : t x  u x  1  dom t   dom u  For example, t 1  t2  t3     holds in Ď1 , t11  t22 does  not hold in Ď 3 . Let  denote the transitive closure of .  Transitions in a run which are not related by  are called  concurrent. For instance, t 11 and t22 are concurrent in Ď 3 .  We require that for every transition t there is a ďŹnite number of transitions t i with ti  t. This completes the notions  required for the deďŹnition of a run:  Runs Let H be a history and let T be a set of transitions.  Ď  H T  is a run iff  For every variable x Var and for all i with 0 i   l Hx   1, there exists exactly one transition t T with  t x  i.  For all t T and for all variables x dom t  holds:  0 t x  l Hx   1.  The relation  on T is irreďŹexive.  The runs Ď1 âĎ3 fulďŹll these properties. In the rest of this  section we assume a run Ď  H T  with a history H and a  set of transitions T .  Since in a run Ď the relation  on T is transitive (by definition of a transitive closure) and irreďŹexive (by deďŹnition  of the run),  constitutes a partial order on the transition  set of Ď .  Cuts and Steps  can canonically be generalized to the  local states of variables. A set of local states which are not  related by  forms a cut.  Formally, a mapping  C : Var   0  is called a cut in Ď iff for each t  holds:  T and all x y  dom t   if t x  C x then t y  C y  For instance, C0 with C0 x  C0 y  C0 z  0, as well  as C2 with C2 y  2 and C2 x  C2 z  1 are cuts in Ď1 .  Proceedings of the 11th International Symposium on Temporal Representation and Reasoning (TIMEâ04)  1530-1311/04 $20.00 ÂŠ 2004 IEEE  C0 : Var  0 is obviously a cut in every run Ď and will be  called the initial cut in Ď .  We say that a transition t  T occurs at C if t updates  variables at the local states belonging to C, i.e. if t x   C x for each x  dom t .  From the deďŹnition of a cut arises an important observation: Any two transitions that occur at C are concurrent in  Ď.  When one or more transitions occur, another cut will be  reached. For example, from C 0 in Ď1 the cut C1 is reached  by the occurrence of t 1 .  Let UC be the set of transitions that occur at C. For each  cut C, the successor cut C Âź of C will be reached by occurrence of all transitions from UC . CÂź is for each x  Var deďŹned by:  C Âź x   C x  1  C x  if x  dom t  for some t  UC  otherwise  It is quite easy to prove that C Âź is a cut in Ď , too.  A cut C and its successor cut C Âź , together with the transition set UC form a step SC . Thus, SC will canonically be  deďŹned by the cut C. Note that not every cut of a run Ď can  be reached by taking such maximal steps from C 0 . Hence,  the cuts do not constitute the run; they rather may be conceived as observations of the run.  3.2. Syntax of TLDA  Vocabulary A vocabulary of TLDA is given by the following sets: a set of function symbols , a set of predicate  symbols  (the symbol for equality  is one of them in  particular), a set of special symbols and a set of variables.  Additionally, TLDA expressions can include brackets,  which we use in order to overwrite the binding priorities  or just to increase readability.  Each predicate symbol and each function symbol has an  arity. Constants can be thought of as 0-arity functions.  The set of special symbols consists of the standard  boolean connectives  and , the quantiďŹer  and the temporal operator Âž. The sets ,  and the set of special  symbols should be pairwise disjoint.  An inďŹnite set of variables Var all is partitioned into inďŹnite disjoint sets of:       rigid variables Var rigid       ,   ďŹexible variables Var  x y    ,   primed ďŹexible variables Var Âź  xÂź  x  Var  x Âź y Âź    ,    a  0/  a Var   and -variables Var      x y x y    .    x and  x y are abbreviated to x and xy,   respectively.      Terms The terms of our logic, like in the classical predicate logic, are made up of variables and functions applied  to them:   Any variable from Var rigid Var VarÂź is a term.   If t1 t2    tn are terms, f   has arity n, then  f t1 t2    tn  is a term.  Formulas Based on the terms we can continue to deďŹne  the formulas of our logic in the common way. The formulas  are divided into two classes: the step formulas and the run  formulas.  The set of step formulas over  and  is inductively  deďŹned as follows:     If P is a predicate taking n arguments, n 1, and if  t1 t2    tn are terms over , then P t 1 t2    tn  is a  step formula.   is a step formula.   Any variable from the set Var   If F and G are step formulas, then so are F and F  G.   If x  Varrigid and if F is a step formula, then so is x F.  (We omit here the quantiďŹcation over ďŹexible and variables, which is also deďŹned in TLDA, since this would  extend the scope of this paper.)  and  is inductively  The set of run formulas over  deďŹned as follows:     Any step formula F is a run formula.   If F and G are run formulas, then so are F, F  G and  ÂžF.   If x  Varrigid and if F is a run formula, then so is x F.  We use some conventional arithmetical and logical abbreviations in TLDA, including boolean abbreviations true  (for P P), false,  and , as well as Âż (for Âž).  xÂź  x  1,   z   0  z  15    x2 ,  where  is a rigid variable, are examples of step formulas   Âž z  xÂź  x  5 are  in our logic. Âž z   Âžxy  examples of run formulas,  is a rigid variable.  3.3. Semantics of TLDA  Now we explain brieďŹy the difference between the sets  of variables introduced above.  Rigid variables stand for an unknown but ďŹxed value.  Flexible variables will be mostly called program variables.  They are intended to describe changes in our systems: Every program variable has a value in a particular cut C of  a system run. A value of any given program variable in  the successor cut C Âź will be described by a corresponding  primed program variable.  The partition of variables into rigid and ďŹexible variables  is a well known idea (see for example [14]) and primed variables have also been used before for describing values of  variables in a successor state ([12, 14]).  Proceedings of the 11th International Symposium on Temporal Representation and Reasoning (TIMEâ04)  1530-1311/04 $20.00 ÂŠ 2004 IEEE  The -variables are new. They are independent from the  values assigned to the program variables in a cut of a system run: The -variables can only take boolean values and  provide information about the synchronization of variable  updates. Some subsequent examples will clarify this concept.  The semantics of the logic resembles those for other temporal logics. We assume a non-empty set Val of concrete  values, called the universe, we interpret each function symas a concrete function on Val, and each predicate  bol in  symbol in  as a predicate over Val. Formally, the inter consists of the following set of data:  pretation I of            a non-empty set Val,  for each n-ary f   a function f I : Valn  Val, and  for each P   with n arguments a subset P I  Valn .    Evaluating terms Let r be a mapping r : Var rigid  Val  which associates with every rigid variable m a value r m  of the universe. The values of all program variables and  primed program variables depend on a run.  Terms will be evaluated in steps of a run as follows: Let  Ď  H T  be a run and let SC be a step of Ď taken from the  cut C. To each rigid variable we assign its value according  to the mapping r. To each program variable x  Var we  assign the value Hx C x, i.e. the value assigned to x at the  C xth index in its history Hx . This is intuitively the value  of x in the global state C. To each primed program variable  xÂź  VarÂź we assign the value Hx CÂź x. Intuitively, each  variable xÂź gets the value of x in the succeeding global state  CÂź .  Formally, to compute the value of a term in S C under the  interpretation I and with respect to r we inductively deďŹne  a mapping rC as follows:  rC  rC m  r m  if m  Varrigid  rC x  Hx C x  if x  Var  rC xÂź   Hx CÂź x  if xÂź  VarÂź and  f t1    tn   f I rC t1     rC tn   if t1    tn are terms  Evaluating step formulas A model of a step formula  consists of a step SC of a run Ď and an interpretation I of   (for convenience, we will write simply S C in place  of SC I  when a model of a step formula is concerned). Let  r be a valuation mapping of rigid variables.  We deďŹne the notion SC r Ď of Ď holding in SC with  respect to r for each step formula Ď by structural induction  on Ď :        SC r P t1    tn  iff rC t1     rC tn   PI .  SC r a iff a  dom t  for any t  UC ,  i.e. we replace a by the boolean value true, if a is a subset of the variables involved in a transition t occurring  at C, and by false otherwise.    SC r F, SC r F  G and SC  Varrigid are standard.  r x F  for x    Examples Let SC0 and SC1 be steps of Ď1 as given in (3).  In SC0 holds z because no transition of S C0 involves z. In  SC1 holds yz, since there is a transition t 2 in which both y and  z are involved. This implies in particular that z is involved  in this transition, so z is true in SC1 too. The same holds for  the variable y.  In contrast, in the initial step of the run Ď 3 in (5) holds y  and z, because there are apparently transitions t 11 and t22 , in  which y and z are involved, respectively. But in this step yz  does not hold.  Evaluating run formulas Now we extend the semantics  to run formulas. A model of a run formula is a pair Ď C  consisting of a run Ď and a cut C of Ď , and an interpretation  I for   (we will write for convenience simply Ď C   instead of Ď C I ). Analogously to step formulas, we deďŹne now the notion Ď C  r Ď of Ď holding in Ď C with  respect to a valuation mapping r of rigid variables for each  run formula Ď by structural induction on Ď :          Ď C r F iff SC r F.  Ď C r F, as well as F  G and xF for x  Var rigid  are standard.  Ď C r ÂžF iff Ď CÂŁ   F for every cut C ÂŁ of Ď  with CÂŁ x C x for all x  Var.  Notations We usually omit an explicit denotation of the  mapping r and write simply Ď C  ÎŚ for Ď C  r ÎŚ.  Furthermore, if a run formula ÎŚ holds in Ď at the initial cut  C0 , i.e. Ď C0   ÎŚ, we write Ď  ÎŚ. The set of all models  of ÎŚ will be denoted by ÎŁ ÎŚ. Hence, ÎŁ ÎŚ is the behavior  of the system speciďŹed by ÎŚ. Finally,  V ÎŚ  x  Var x xÂź occurs in ÎŚ or a occurs in ÎŚ  and x  a  denotes the set of Var-variables occurring in ÎŚ.  4. Specifying Systems in TLDA  With the logic of Section 3 we are now ready to specify  systems. In this section we revise our motivating example  and describe the behavior of the system M based on the informal description from Section 2. We describe the initial  values of the system variables x, y and z of M by the formula:  Minit   x  1y  1z  0  Recall that there are two actions in the system M which are  performed nondeterministically: The action A 1 swaps the  values of x and y, the action A 2 reads y and changes z according to the current value of y. Each occurrence of A 1 or  A2 will be represented in a run of M by a transition involving  Proceedings of the 11th International Symposium on Temporal Representation and Reasoning (TIMEâ04)  1530-1311/04 $20.00 ÂŠ 2004 IEEE  both x and y or y and z, respectively. We describe an update  of a variable in case this variable is involved in a transition:  x is involved only together with y, and the value of x will be  set on the previous value of y. This will be expressed by the  xy x Âź  y. We likewise describe what hapformula x  pens if y and z are involved in a transition. Additionally, we  claim that x and z are never involved in the same transition.  Hence, the following formula speciďŹes the updates of M:    Mnext  Âž             x  xy xÂź  y  y  xy yÂź  x yz yÂź  y  z  yz zÂź  z  y  1  xz        HRinit  HRnext  Âż  ÂžÂżz  LÂž x      For simplicity we omit here the general deďŹnition of fairness. Hence, the system M is speciďŹed by Minit Mnext L.  Note that the runs Ď 1 and Ď2 can now be well distinguished: The run Ď 1 is a model of this speciďŹcation, while  Ď2 is not, since  x does not hold in Ď 2 . Consequently, Ď 2  is excluded from the behavior of M.  ÂžÂż  In this section, we focus on parallel composition of systems and their speciďŹcation in TLDA. Let S 1 and S2 be systems speciďŹed by formulas ÎŚ 1 and ÎŚ2 , respectively. Parallel composition of S 1 and S2 is deďŹned as the intersection of their behaviors ÎŁ ÎŚ 1  ÎŁ ÎŚ2 . From this deďŹnition  follows immediately by logical reasoning that the speciďŹcation formula of the composed system is the conjunction  ÎŚ1 ÎŚ2 of the speciďŹcation formulas of the components.  The idea of composition as conjunction has been suggested  in [4, 1, 2, 13]. Works on compositional semantics based on  partial order are [10, 11].  We introduce the basic concepts with a simple version of  a clock composition. We borrow this example from [13].  An hour clock displays the hours; for this purpose  we assume the variable hr to display sequences such as  22 23 00 01 . Likewise, a minute clock with the variable  min displays sequences such as 58 59 00 01 .      23  00    Âź    Since the hour clock is a detached component which should  later work as a part of a bigger system, we specify it in a  way allowing arbitrary synchronization with any other subsystem. Such speciďŹcation will be called environment invariant.  Formally, a formula ÎŚ will be called environment invariant iff for all runs Ď with Ď  ÎŚ holds: Ď  ÎŚ for all runs  Ď such that the restrictions of Ď and of Ď to the variables  V ÎŚ are identical.  We give here a sufďŹcient syntactical condition for environment invariance: A formula ÎŚ is environment invariant  if either ÎŚ false, or one of the cases 1â3 holds:  1. no primed or -variables occur in ÎŚ.  2. ÎŚ has the form a Î¨ where Î¨ is a step formula such  that either  Î¨ false (i.e. ÎŚ is equivalent to a), or  if v or vÂź occurs in Î¨ then v a and if v occurs in  Î¨ then v a  0.  /  3. ÎŚ has the form Î¨ a where Î¨ is a step formula such  that  no -variables occur in Î¨, and  V Î¨  v for a variable v Var and v a.       5. Composing SpeciďŹcations  22   hr  0 23   hr  suchr hr  with suchr 23  0 suchr n  n  1 if n  23  We focused so far on the safety part of the speciďŹcation  of M only. Now we consider the liveness condition for M,  stating that each of the actions A 1 and A2 should be executed inďŹnitely often. In order to satisfy this condition it  sufďŹces to require that both x and z are inďŹnitely often involved in a transition of a run (such requirement for y would  be redundant):  hr:  hr, including min, may change arbitrarily. These variables  constitute the environment of hr. A run of the minute clock  resembles (6) with some obvious modiďŹcations.  We start with specifying the hour clock: The formula  HRinit speciďŹes the clockâs initial state, viz the initial value  of the variable hr to vary between 0 and 23. HR next speciďŹes  the clockâs updates: Each update increases hr by one, with  the exception that 23 is followed by 0.  01  ...  (6)  is a run of the hour clock. Recall that this run actually consists of inďŹnitely many variables. All variables other than          Lemma 1 Let ÎŚ and Î¨ be formulas. If ÎŚ and Î  are environment invariant, then so are ÎŚ Î  and ÎŚ.    Âž  These properties are very useful for writing system speciďŹcations.  Observe that the formula Mnext in Section 4 is environment invariant while  x x Âź  x  1 and  xy xÂź  y  are not.  Now, we come back to the clock example. To allow hr an  arbitrary synchronization with its environment, we require  that the formula HR next is to be applied only in system steps  which involve the variable hr. Observe that this fulďŹlls the  syntactical condition given above. Hence, the speciďŹcation  of the hour clock is  Âž    HR  HRinit   Âž hr  Âž    HRnext   The speciďŹcation of the minute clock strongly resembles the  Proceedings of the 11th International Symposium on Temporal Representation and Reasoning (TIMEâ04)  1530-1311/04 $20.00 ÂŠ 2004 IEEE  speciďŹcation of the hour clock:  MIN init  min 0    59  MIN next  minÂź sucmin min  with sucmin 59 0 sucmin n n  1 if n  59   MIN init  Âž min  MIN next   MIN  One easily observes that every run of the hour-minute clock,  such as (7), is a model of the conjunction HR  MIN. This  conjunction, however, speciďŹes the hour and the minute  clock working really in parallel. Thus, it additionally admits models that are not proper runs of the hour-minute  clock.  hr: 22  23  00 ...  59  00  01  ...  59  00 ...  min: 58  (7)  The unwanted models do not properly synchronize the  updates of hr and min. Hence we strive for an additional formula, SYNC, to express additional constraints on the models. SYNC talks about synchronized updates of hr and min  by help of the variable hrmin. Two properties are required:  Firstly, the variables hr and min synchronize their updates  iff min 59. Secondly, each update of hr is synchronized  with an update of min:  SYNC  Âžhrmin  min    59  Âžhr  hrmin  Note that the formula SYNC is environment invariant, too.  (But this is not always necessary.) It can easily be shown  by transforming hrmin  min 59 into an equivalent formula hrmin  min 59  min 59  hrmin fulďŹlling  the syntactical condition given above, and then by applying  Lemma 1.  Hence, the hour-minute clock will be speciďŹed by  HR  MIN  SYNC  Since this speciďŹcation is by Lemma 1 also environment  invariant, the hour-minute clock can effortless be used as a  component for a further system.  The above clock example shows how a system composed of independent interacting components will be usually speciďŹed: Firstly, an environment invariant speciďŹcation will be given for each component. Since the components are independent they always have disjoint system  variables. Secondly, a synchronization formula employing  primarily -variables will be added to deďŹne the interactions between the components.  6. Conclusion  We suggest a new temporal logic, TLDA, for specifying  and verifying distributed systems. The logic can syntactically be conceived as a variant of TLA. TLDA, however,  is interpreted on partial order semantics. This renders the  logic more expressive. Furthermore, we have shown that  TLDA supports a compositional system design: subsystems  can be speciďŹed separately and then be integrated into one  system.  References  [1] M. Abadi and L. Lamport. Decomposing speciďŹcations of  concurrent systems. In E.-R. Olderog, editor, Proc. of the  Working Conference on Programming Concepts, Methods  and Calculi (PROCOMET â94), volume A-56 of IFIP Transactions, pages 327â340. North-Holland, 1994.  [2] M. Abadi and L. Lamport. Conjoining speciďŹcations.  ACM Transactions on Programming Languages and Systems, 17(3):507â534, May 1995.  [3] M. Abadi and S. Merz. On TLA as a logic. In M.Broy,  editor, Deductive Program Design, NATO ASI series F.  Springer-Verlag, 1996.  [4] M. Abadi and G. Plotkin. A logical view of composition.  Theoretical Computer Science, 114(1):3â30, 1993.  [5] A. Alexander and W. Reisig. Logic of involved variables system speciďŹcation with Temporal Logic of Distributed Actions. In Proc. of the 3rd International Conference on Aplication of Concurrency to System Design (ACSDâ03), pages  167â176, Guimaraes, Portugal, 2003.  [6] H. Barringer, R. Kuiper, and A. Pnueli. Now you may compose temporal logic speciďŹcations. In Proc. of the 16th Annual ACM Aymposium on Theory of Computing, pages 51â  63, 1984.  [7] E. Best and C. Fernandez. Nonsequential processes â a Petri  net view. In W. Brauer, G. Rozenberg, and A. Salomaa, editors, EATCS Monographs on Theoretical Computer Science,  volume 13. Springer-Verlag, 1988.  [8] A. Cau and W.-P. d. Roever. A dense-time temporal logic  with nice compositionality properties. In Proc. of the 6th  International Workshop on Computer Aided Systems Theory EUROCASTâ97, Las Palmas de Gran Canaria, Spain,  volume 1331 of LNCS, pages 123â145. Springer, February  1997.  [9] J. Fiadeiro and T. Maibaum. Sometimes âtomorrowâ is  âsometimeâ: Action reďŹnement in a temporal logic of objects. In D. Gabbay and H. Ohlbach, editors, Proc. of the  1st International Conference on Temporal Logic ICTLâ94,  volume 827 of LNAI, pages 48â66. Springer-Verlag, 1994.  [10] D. Gomm, E. Kindler, B. Paech, and R. Walter. Compositional liveness properties of EN-systems. In M. Marsan, editor, Applications and Theory of Petri Nets 1993, 14th International Conference, volume 691 of LNCS, pages 262â281.  Springer-Verlag, June 1993.  [11] E. Kindler. A compositional partial order semantics for Petri  net components. In P. AzĂŠma and G. Balbo, editors, Application and Theory of Petri Nets 1997, 18th International Conference, volume 1248 of LNCS, pages 235â252. SpringerVerlag, June 1997.  [12] L. Lamport. The Temporal Logic of Actions. ACM Transactions on Programming Languages and Systems, 16(3):872â  923, May 1994.  Proceedings of the 11th International Symposium on Temporal Representation and Reasoning (TIMEâ04)  1530-1311/04 $20.00 ÂŠ 2004 IEEE  [13] L. Lamport. Composition: A way to make proofs harder. In  A. W.P.de Roever, H.Langmaack, editor, Compositionality:  The SigniďŹcant Difference, International Symposium, COMPOSâ97, volume 1536 of LNCS, pages 402â423, September  1997.  [14] Z. Manna and A. Pnueli. The temporal logic of Reactive and  Concurrent Systems: SpeciďŹcation. Springer, 1992.  [15] A. Mokkedem and D. Mery. A stuttering closed temporal logic for modular reasoning about concurrent programs.  In D. Gabbay and H. Ohlbach, editors, Temporal Logic,  Proc. of the 1st International Conference on Temporal Logic  ICTLâ94, volume 827 of LNAI, pages 382â397. SpringerVerlag, 1994.  [16] A. Pnueli. The temporal semantics of concurrent programs.  Theoretical Computer Science, 13(1):45â61, 1981.  [17] M. Reynolds.  Changing nothing is sometimes doing  something: Fairness in extensonal semantics. ulr: citeseer.nj.nec.com/ reynolds96changing. html, 1996.  Proceedings of the 11th International Symposium on Temporal Representation and Reasoning (TIMEâ04)  1530-1311/04 $20.00 ÂŠ 2004 IEEE 