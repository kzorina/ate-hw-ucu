Resolution for Branching Time Temporal Logics: Applying the Temporal  Resolution Rule  Alexander Bolotov and Clare Dixon  Department of Computing and Mathematics  Manchester Metropolitan University  Manchester M1 5GD, UK.  A.Bolotov,C.Dixon@doc.mmu.ac.uk  Abstract  In this paper we propose algorithms to implement a  branching time temporal resolution theorem prover. The  branching time temporal logic considered is Computation  Tree Logic (CTL), often regarded as the simplest useful logic of this class. Unlike the majority of the research into  temporal logic, we adopt a resolution-based approach. The  method applies step and temporal resolution rules to the set  of formulae in a normal form. Whilst step resolution is similar to the classical resolution rule, the temporal resolution  rule resolves a formula, , that must eventually occur with  a set of formulae that together imply that can never occur. Thus the method is dependent on the efficient detection  of such sets of formulae. We present algorithms to search  for these sets of formulae, give a correctness argument, and  examples of their operation.  1 Introduction  Since it was first proposed in [13] temporal logics have  been used extensively in the specification and verification  of properties of concurrent and distributed systems [9]. If  in this application the ability to refer to a range of possible  execution paths is important then the power of the language  of branching-time logics is essential [9]. It has been observed that most correctness properties of concurrent programs (that do not deal with fairness) can be expressed  in the family of branching time logics called Computation  Tree Logics. The core logic we concentrate on is a Computation Tree Logic (CTL) [4] often regarded as the simplest  useful logic of this family. There are several extensions of  CTL of which CTL is the most powerful [8].  Much of the research on the verification of concurrent  and distributed systems has centered around the modelchecking technique utilising CTL [9]. Here the satisfiability  of a CTL formula is checked with respect to a model derived  from a finite-state program [9]. The underlying research on  decision procedures for branching time temporal logics has  mostly involved tableau or automata methods [8] with an  obvious lack of research into deductive proof methods.  For propositional linear-time temporal logics (PLTL) a  clausal resolution method [10] has been developed. This resolution approach has been extended to CTL in [2, 3]. Its  key elements consist of translation to a normal form and a  variety of resolution rules. The normal form is a set of formulae which utilize only √¢¬Ä¬únext√¢¬Ä¬ù, √¢¬Ä¬úalways√¢¬Ä¬ù and √¢¬Ä¬úsometime√¢¬Ä¬ù  temporal operators (all other operators are subsumed within  this representation). Two types of resolution rules are distinguished, namely, resolution within states known as step  resolution, and resolution over states known as temporal resolution. The latter applies when a proposition  occurs at  all future moments (known as a loop in ), and if  is also  constrained to be false at some point in the future. The efficient search for such loops is crucial to the temporal resolution method. In the linear-time case, several algorithms  for detecting loops have been developed [5, 6]. In this paper we select one of these loop detection algorithms and  extend it to apply to the branching time logic CTL.  The remaining of the paper is organized as follows. In  2 we overview the logic CTL. In 3 a clausal resolution  method is outlined. Algorithms to apply the temporal resolution rule and examples of their operation are given in 4.  A correctness argument is outlined in 5. Finally, in 6  we consider related work and in 7 provide concluding remarks.  2 The logic CTL  Here we summarize the syntax and semantics of the core  logic, CTL.  2.1. Syntax and semantics of CTL  In the language of CTL we utilize only future-time  (always),  (sometime),  (next time),   operators  (until) and  (unless). Additionally, we use path quantifiers A (on all future paths) and E (on some future path).  The syntax of CTL distinguishes state ( ) and path ( )  formulae. These are defined inductively as follows, where   is any well-formed formula of propositional logic, including classically defined constants  and  .                           A  E                 Well formed formulae of CTL are state formulae. Thus,  each CTL formula has a structure where any temporal operator can only be followed by a path operator or a classical operator, while any path operator can only be followed  by a temporal operator. An example of a CTL formula is  E  E  meaning √¢¬Ä¬òthere is a path on which  eventually holds and there is a path on which  always holds√¢¬Ä¬ô. It  follows that CTL is weaker than linear-time temporal logic  in its expressive capabilities within a path, but is more expressive in that it can quantify over paths themselves. As  an example of its restricted nature, note that no formula de are satisfied on  scribing the property √¢¬Ä¬úboth  and  the same specific path√¢¬Ä¬ù can be constructed using CTL syntax. For the detailed description of CTL√¢¬Ä¬ôs theoretical properties, subsystems and extensions see [8].  Before continuing with the semantics of CTL we introduce some notation. We interpret a well-formed formula      ,  of CTL in a tree-like model structure  where  is a set of states,    is a binary relation  over  and is an interpretation function mapping atomic  propositional symbols to truth values at each state.  A path,  , is a sequence of states   , over         such that for all          .  A path √Ç≈∫ is called a fullpath.  Given a path  and a state       we term  a finite subsequence       a prefix of a path   and an infinite sub-sequence of states         a  suffix of a path  abbreviating these respectively with          (or simply as     when it is clear  which path this prefix belongs to) and     .  We assume that a CTL model  satisfies the following  conditions:  1. there is a designated state,    , a root of a structure  (i.e. for all      ),  2. every state belongs to some fullpath, i.e. a path starting  at  ,  √ÇÀù It is known that if linear-time temporal logic is interpreted over discrete linear models with finite past and infinite future then adding past-time  operators does not give more expressiveness [11].  3. tree structures are of at most countable branching,  4. every state should have a successor state, and,  5. every path is isomorphic to  .  Below we define the satisfaction relation √¢¬Ä¬ò√¢¬Ä¬ô which evaluates well-formed CTL formulae at a state  in a model  . Postulates s1-s7 define satisfaction relation for the CTL  formulae at states while p1-p6 determine evaluation of their  subformulae along paths.    s1     s2      s3  s4  s5  s6  s7  p1  p2      .     .     and     or     or            .           .           .    A       .    E         .  .                            .                     .           .                                   .                      .                                   p3                            p4  p5                     p6            A well-formed formula,  , is satisfiable if, and only if,  there exists a model  such that     . A wellformed formula,  , is valid if, and only if,  is satisfied in  every possible model, i.e.for each ,     .  Recall that well-formed CTL formulae are state formulae and due to the syntactic requirement (see above) when  we evaluate a CTL formula, for example, A  , we reduce the problem    A  , following s6 above,  to the evaluation of  along each path  . This, acording to p4, means        . Since  must  be a state formula, applying p1, we obtain from the latter     . Now, if  contains another temporal operator, then this operator will again be preceded by a path  operator indicating a specific path context. For example, if    E  then the problem   E  will    be reduced, according to s7, to evaluating  along some  path  √ÇÀá√ÇÀù , etc.  2.2. Closure properties of CTL models  When trees are considered as models for distributed systems, paths through a tree are viewed as computations. The  natural requirements for such models would be suffix and  fusion closures. The former means that every suffix of a  path is itself a path. The latter requires that a system, following the prefix of a computation  , at any point    , is  able to follow any computation   originating from  . Finally, we might require that if a system follows a computation for an arbitrarily long time, then it can follow a computation forever. This corresponds to limit closure property,  meaning that for any fullpath √Ç≈∫ and any paths        (      ) such that √Ç≈∫ has the prefix    ,   has the prefix    ,  has the prefix     etc, the  following holds (see Figure 1):  The language for indices is based on the set of terms                  √Ç≈∫            iff    Definition 1 (Separated Normal Form for CTL)  Given a CTL formula  , the separated normal form for F,  SNF (F), is a set of clauses of the form          Thus, E  means that  holds on some path labelled as   . Indices of the type   aim to capture limit closure property. Once the translation to SNF  has been  carried out, all SNF clauses containing a √¢¬Ä¬òE√¢¬Ä¬ô quantifier  are labelled with some index (for more details see [2]).  Further, an additional operator,   , which effectively  identifies the initial state, is introduced:  A  √Ç≈∫         where each of the √¢¬Ä¬ú   √¢¬Ä¬ù is further restricted as in Figure 2, where each   ,  or  is a literal,  or  ,  and    is some index.         there exists an infinite path  that is a limit of the prefixes               .  In the following we assume that tree-like models of CTL  are suffix, fusion and limit closed  .      3. The temporal resolution method for CTL  Here we review the temporal resolution method for CTL  [3, 2] whose main components are translation into the  clausal normal form and application of resolution rules.  3.1. A normal form for CTL  The basic idea behind the normal form for CTL called  Separated Normal Form (SNF  ) is to identify the core  operators and generate formulae relevant to either the first  state in a model, or to all subsequent states in a model. The  transformation procedure uses fixpoint unwinding and subformula renaming in order to reduce an arbitrary formula  to SNF . To preserve a specific path context indices are  used.  √Ç≈æ A variety of difficult problems concerning branching-time logics are  due to the limit closure property, resulting, for example, in the case of  CTL , in the absence of a complete axiomatization.       A        E       Figure 1. Limit closure                            an initial clause          an A step clause    a E step clause          A      E     an A sometime clause       a E sometime clause  Figure 2. Form of SNF Clauses  The natural intuition here is that the initial clauses provide starting conditions while step and sometime clauses  constrain the future behaviour. For example, a step clause  A   A  means  √¢¬Ä¬úfor any fullpath and any state     , if  is  satisfied at a state  then  must be satisfied at the moment,  next to  , along each path which starts from  √¢¬Ä¬ù.  Similarly, interpreting A   E   , we use the  information that √¢¬Ä¬òE√¢¬Ä¬ô is associated with the index  :    , if  √¢¬Ä¬úfor any fullpath and any state     is satisfied at a state  then  must be satisfied at the  moment, next to  , along some path associated with   which departs from  √¢¬Ä¬ù.  Finally, A   E     means  √¢¬Ä¬úfor any fullpath and any state      if  is  satisfied at a state  then  must be satisfied at some state,  say    , along some path   associated with the limit  closure of  which departs from  √¢¬Ä¬ù.  All the other operators are subsumed within this representation. For example, the √¢¬Ä¬òA √¢¬Ä¬ô operator is represented  by a (possibly infinite) sequence of √¢¬Ä¬òA √¢¬Ä¬ô operations (see  [3]). For convenience we will omit the outer √¢¬Ä¬òA √¢¬Ä¬ô connective that surrounds the conjunction of clauses and drop  the conjunction considering the set of clauses.  a constant  to indicate this situation and, for example,  the conclusion of SRES 2 rule, when resolving   A  and   A  , will be   A  .  Once a contradiction within a state(s) is found, as for  example,   A  , then we simplify it applying the  following rule:  3.2. Resolution rules for CTL  The step resolution process terminates when either no new  resolvents are derived, or     is derived.  Once step resolution has been applied, the temporal resolution rule can be invoked. The basic idea here is to resolve  a set of formulae containing a loop in , i.e.a situation when   occurs at all future moments along some (E-loop in ) or  every path (an A-loop in ) from a particular point in a CTL  model, with the formula containing a , provided that  both refer to the same path. Thus, identification of loops  within given set of SNF  clauses, similar to PLTL, is  the crucial part of the temporal resolution method in CTL.  As in PLTL, some loops might be given directly as a set of  SNF clauses; in other cases loops might be more difficult to detect. One of the benefits of the normal form is  that it allows us to identify √¢¬Ä¬òhidden√¢¬Ä¬ô loops within some set  of clauses.  Once a set of SNF clauses, , has been obtained,  a resolution method is applied to . Here we repeatedly  apply √¢¬Ä¬òstep√¢¬Ä¬ô and √¢¬Ä¬òtemporal√¢¬Ä¬ô resolution rules, together with  various simplification steps.  3.2.1 Step resolution. Step (classical) resolution can be  used between formulae that refer to the initial moment of  time or same next moment on some or all paths. The corresponding step resolution rules are given below  SRES 1                           SRES 2                            A  A  A      SRES 3              A  E  E                        SRES 4              E  E  E                          where  is a literal and  is an index.  When an empty clause is generated on the right hand  side of the conclusion of the resolution rule, we introduce          P     where P is either of path quantifiers. The conculsion,     , in turn, requires that  must never be satisfied in  any moment in time. This is reflected in generating extra  constraints by applying the following rule:                   A   3.2.2. Loops in CTL. Loops in CTL are defined on sets  of merged clauses, which are, in turn, generated from step  clauses.  Merging              A  A  A                       A  E  E                          E  E  E                     Note that, similar to SRES 4, we allow merging of two  E step clauses if both existential path quantifiers refer to the  same path.  Definition 2 (Loop in CTL)  A loop in  is a set of  merged clauses (possibly labelled) of the form         P     P      then P  ,      A,                         !.           !, P is the √¢¬Ä¬òA√¢¬Ä¬ô path quantifier    is empty, and we have an A-loop in   we have indicated a E-loop in  on the path     ,  is a new index.  For this set of merged clauses, each right hand side implies one or more left hand sides from the side condition on  loops. Each right hand side implies . Hence, once one of  the left hand sides is satisfied, a literal  holds at all future  moments on some or all paths (dependent on the type of the  path quantifier).  As a simple example consider the following set of  clauses (where the first clause on its own gives us a loop  in ).    A      E    (1)  By merging both clauses, we obtain   E            In each of the states           along the path    the following formulae are satisfied       !, P only involves one √¢¬Ä¬òE√¢¬Ä¬ô  quantifier labelled by   or every P  which involves the √¢¬Ä¬òE√¢¬Ä¬ô quantifier has the same label   then        and we have a E-loop in  on the  path    , otherwise         if for all  where          We will abbreviate such loop by  P P   , where              , for all  where     and     if for all        E          √Ç≈∫  Figure 3. Effects of limit closure in CTL: Eloop        is a path, and each state along this path satisfies   , which gives us the desired E-loop in .  3.2.3. Temporal resolution rules. Now, using the expressions   A A  and   E E  as abbreviations  for sets of SNF clauses which together represent these  formulae, temporal resolution rules for CTL are defined as  follows.  TRES 1          A A   A  A    TRES 2      (2)  which gives us additionally a E-loop, in , which is linked  to the limit closure property of CTL. Consider a model  given in Figure 3, where we arbitrarily chose a fullpath  and let    be the first moment along which satisfies   . Therefore, there is a path   associated with   such that   , the successor of  on this path, satisfies    . Formula (2) means √¢¬Ä¬úfor any fullpath and any state       , if    is satisfied at  then E      is satisfied at  √¢¬Ä¬ù. Due to the fusion closure property, there  is a fullpath     ƒÇ¬Ü  (a concatenation of     and   ). Thus, setting      ƒÇ¬Ü  and    , we conclude that    E     . Therefore, there is  a path  associated with  such that there is a state,  next to  , say  , on this path which satisfies   , etc.  Hence, according to the limit closure property, the sequence        A A   E     E         TRES 3          E E     A  A      TRES 4          E E      E     E        In each case the resolvent ensures that once  has been  satisfied, the conditions,  , for triggering a -formula are  not allowed to occur, i.e.,  must be false, until the eventuality () has been satisfied. Although it might be surprising  that resolving an A with a E-loop in  results in an Aformula, if the premises of temporal resolution in this case  are satisfiable, the satisfiability of the conclusion of TRES 3  is guaranteed by the limit closure property (the corresponding proof is given in [2]).  This system of resolution rules is a complete deductive  method for the logic CTL ( [2, 3]).  4. Applying CTL Temporal Resolution  The clausal resolution approach to linear-time logic has  been shown to be particularly amenable to efficient implementation [5, 6]. Here we concentrate on one of these algorithms, the Breadth-First Search approach [6], and modify  it for use in our branching time setting.  4.1. Overview of the Loop Detection Method in CTL  While in PLTL we have only one temporal resolution  rule, in the branching-time framework, a variety of such  rules are defined. Depending on the type of a path quantifier in the √¢¬Ä¬òsometime√¢¬Ä¬ô SNF  clause, we look for different types of loops. In particular, given A, we search  for a set of clauses that together imply either A A   or E E  (labelled by any  ), which can be used  to apply TRES 1 and TRES 3. When we are resolving  with a √¢¬Ä¬òsometime√¢¬Ä¬ô formula containing E labelled by    , then we search for a set of clauses that together  imply either A A  or E E   to apply TRES 2  or TRES 4. In the latter case use of indices is crucial.  The Breadth-First Search Algorithm constructs a sequence of nodes that are labelled with formulae in Disjunctive Normal Form. This represents the left hand sides of  clauses used to expand the previous node which have been  disjointed and simplified. Clauses are selected for use in  the algorithm if they generate the required literal at the next  moment in time and their right hand side implies the previous node. The former ensures the required literal holds and  the latter gives the looping required so that the literal always  holds. If we build a new node that is equivalent to the previous one, using this approach, then we have detected a loop.  However, if we cannot create a new node then we terminate  without having found a loop.  4.2. Breadth-first A-loop search algorithm  Given a set, , of SNF clauses we develop an algorithm to detect an A-loop in  by constructing a set of nodes  " "    " labelled by formulae     , where  each      ! is in DNF and the label,  , of  the terminating node "  satisfies the following condition:    A A .  Thus, to detect an A-loop in  follow the steps below.  (1) Search for all SNF  clauses of the form #   A ,  for    to $, disjoin the left hand sides and make the label   , of the top node "  equivalent to this, i.e.  "   #       Simplify " . If  "   we have found a loop.  (2) Given a node "  , build node "  for        by  looking for clauses or combinations of clauses of the form    A   , for    to % where    " .  Disjoin the left hand sides so that  "             and simplify as previously.  (3) Repeat (2) until one of the conditions (a)-(c) holds:  (a)  "   . We have found a A-loop and return the  label of the terminating node,  .  (b)  "  " . We have found a A-loop and return the  label of the terminating node, DNF formula "  .  (c)  "  is empty. Terminate - no loop has been found.  4.3. Breadth-first E-loop search algorithm  To detect a E-loop in  do the following.  (1) Search for all the clauses of the form #   A , or  #  E    , for    to $, disjoin the left hand sides,  make the top node "  equivalent to this and label "  with  Ind, i.e.    "        #    where Ind is a set of all indices  occurring within  #  E    . Simplify " . If  "   we  terminate having found a loop.    Not surprisingly, the detection of a A-loop is almost  identical to that of Breadth-First Search in linear-time temporal logic. However, with the detection of an E-loop we  must take care when combining clauses (see below).  √Ç≈º To simplify the presentation below, since a label   of a node   uniquely identifies this node, instead of saying √¢¬Ä¬òa label    √ÇÀù     of a node  √¢¬Ä¬ô we will use the expression    √ÇÀù       .  (2) Given a node "   , build a node "   for         by looking for combinations of clauses of the  form   A    or   E      for     to % where    " . Disjoin the left hand sides  so that            "         step (2) of the E-loop search algorithm (i.e. all the pairs of  clauses can be merged and the right hand side contains  as  a conjunct and also implies "  ). So we disjoin the literals  on the left hand sides of the merged clauses 6+1, 7+2 and  8+3 to obtain node  "      where Ind√¢¬Ä¬ù is a set of all indices  occurring within    E      . Simplify " as previously.    (3) Repeat (2) until one of the conditions (a)-(c) holds:  (a)  "   . We terminate having found a E-loop  on path  and return the label of the terminating  node,  , provided that the following condition ()  is satisfied   if   is the only element of  then we have  found a E-loop in  on the path   , else    , where      &    E  (c)  "   4.4. Examples  Example 1. Consider the following set of SNF  clauses  in which we are looking for a loop:            &  $  '  (          E  A  A  A                       &    $  '          E  A  A  E    &  $  $        Noting that here A-loop searching algorithm detects a loop  $  A A , we will construct a E-loop.  1. The clauses 1√¢¬Ä¬ì4 have either A  or E  on their right  hand side. We disjoin their left hand sides and simplify to  give the top node  "  &  $  '  (       2. To build the next node, " , we see that the merged  clauses 6+1, 7+2 and 8+3 satisfy the expansion criteria in          &       we cannot now combine it with clause 1 as it has a different  path index. We can, however, merge it with either clause 2,  3 or 4 to give  &    $  &    '  &    (            &      &      &       E  E  E               The first two left hand sides will be removed via simplification to leave node "  as  "  &    (  $  '  is empty. Terminate - no loop has been found.  In a particular case of the E-loop detection algorithm, given a sometime clause labelled by   we search for  a loop on the path   . Thus, we only apply merging to those step clauses containing √¢¬Ä¬òE√¢¬Ä¬ô quantifier which are  labelled by  . This will guarantee that if the algorithm  terminates by finding a E-loop in , this loop will occur on  the desired path   .       on the path  is a new index.  (b)  "  " . We terminate having found a E-loop  and return the label of the terminating node, DNF formula " provided that condition  above is satisfied;  &    $  '  Note that merged clause 7+1 would be removed via simplification.  3. Clauses 7+2 and 8+3 still satisfy the expansion criteria  so we can add $  ' to our new node. However if we merge  clauses 5 and 6 to give   we have found a E-loop in                 4. Now only clauses 7+2 and 8+3 satisfy the expansion  criteria so the new node is  "    $  '       5. The same thing happens when we construct the next node  so we obtain  "  $  '    and terminate with the loop $  '  E      E       .  Example 2. Consider the following set of SNF  clauses             E  A                  A  E       It is not immediately obvious that this set of SNF   clauses contains a E-loop in , namely,    E E .  1. The clauses 1 and 2 have either A  or E  on their  right hand side, hence, we disjoin their left hand sides and  simplify to give the top node  "     2. To build the next node,  1+3 and 2+4, to obtain        E  E  "             , we derive merged clauses                 These satisfy the expansion criteria, so we add   to  the new node. Note that while we can not merge clauses  1 and 4 as they are labelled by different indices, we can,  additionally to the merging 1+3 and 2+4, obtain a merged  clause 2+3. However, its left hand side will be removed via  simplification to leave node " as  "              5. Correctness of the loop searching for CTL  Here we outline the soundness and completeness of the  loop detection algorithms. The following lemma is useful.  Lemma 1 Given a series of nodes "  , for   , output by  a Breadth-First A-Search for a loop in  then     A  3. Now, as "  " we terminate the searching with the  loop     E E     , where  is a new  index.    The model,  , (Figure 4), which satisfies the set of  clauses given in Example 2, in particular, represents this  loop. Pick a fullpath and a state   that is the first  state satisfying   .  "    A    "    PROOF :  For  *  in step (2) of the algorithm, given node "  , we  select clauses   A   , for    to %, where     " and the new node "  is the disjunction of  the  s. Therefore, for each   ,    A " and     A . Hence, we obtain   A  "    A  "      as required. (END)     E  Lemma 2 Given a series of nodes "  , for   , output by  a Breadth-First E-Search for a loop in  then     A  ƒÇ¬Ü      satisfies    and E       satisfies    and E        satisfies    and E      satisfies  and E                      PROOF :                  √Ç≈∫  Figure 4. E-loop in a combination of step  clauses with different labels  Suppose that    . Thus, according to merged  clause 1+3,    E      , i.e.there must be a  path  associated with  , such that    , the successor of  along  , satisfies  . Hence,     and therefore, according to merged clause 2+4,     E      . Therefore, we must have in the model  a path  (possibly different from     ), associated with  such that there is a state    ,  the successor of  , which satisfies   . Now, considering  , we apply the same reasoning as in the case of   , etc. Thus, there is a path )  , the limit closure of the  )   prefixes                such that  E . Hence,   as desired.    E E    E    "    Similar to the A-loop (END)  Theorem 1 [(Soundness)] Let  be a set of step clauses  and  be the literal we are searching for a loop in. For any  DNF formula # output by a Breadth-First A-Search (respectively a Breadth-First E-search), on ,      "     #  A  A    respectively #  E    E    PROOF : We prove this for the A-Search and the E-Search  is similar. From the termination conditions of the algorithm  given in 4.2 and 4.3 we know that either #   from  step (1) or step (3a), or "   " from step (3b). For  the former either the clause   A  is in the clauseset or there are clauses in the clause-set that together imply  this. Again, due to the implicit A -operators surrounding SNF clauses, the clause   A  holds in all  states on all paths. Therefore,    A A  holds  as required. Otherwise "   " and from Lemma 1  we have  A "  A "  . Thus, if we  terminate with # then  A #  A #   and   #  A A  as required. (END)    Theorem 2 [(Completeness)] Let be a set of step clauses  and  be the literal we are searching for a loop in. For  that together imply an Aany set of clauses    loop, i.e.  #  A A , (respectively a E-loop, i.e.   #  E E ) the Breadth-First A-Search (respectively E-Search) applied to outputs a DNF formula #   and #  #  .  PROOF :  As we only use A step clauses for the Aloop, completeness for the A-loop can be shown as in  the linear-time case [6]. Extract all A step clauses  from , delete the path quantifier and let the set of  (linear-time) clauses be  . Note also that the BreadthFirst A-Search algorithm is identical to that of BreadthFirst Search algorithm for linear-time temporal logic if  the path quantifiers are deleted. To show completeness in the linear-time case a graph is constructed from  the clauses in  , whose nodes are valuations of all  the propositions in  . Paths through the graph represent  all possible models of  . It is shown that if a loop exists in    , # , then this is represented in the graph of  by a terminal subgraph where the required literal  holds at each node.  More specifically # is satisfied by each node (a valuation)  in the subgraph. The completeness proof shows that each  step in the Breadth-First Search algorithm corresponds to  an operation on the graph. If the Breadth-First Search algorithm detects a loop returning the DNF formula #  then  this corresponds to the terminal subgraph representing the  largest most comprehensive loop in  . For more details see  [5].  The proof for E-loops is similar but we must construct  a graph as described above for each √¢¬Ä¬òpath√¢¬Ä¬ô through the  branching tree structure. (END)  6. Related work  Automata-theoretic methods for CTL extend those developed for PLTL [1, 8]. To test formulae of PLTL finite  automata on infinite strings are used, the appropriate type of  automata in the branching-time setting are finite automata  on infinite trees, i.e. when automaton visits a state it reads  an input tree rather then an input word. Given a CTL formula , a run of the automaton constructed for is considered successful if it meets certain requirements known  as √¢¬Ä¬úacceptance conditions√¢¬Ä¬ù. This is also known as checking  automaton for (non)emptiness. If the acceptance condition  is satisfied then a state structure of a successful run is not  empty and it gives a model for . Alternatively, a run is unsuccessful. If the automaton does not have a successful run  then is not satisfiable. Note that although the structure of  the normal form described in this work is close to alternating tree automata used in [1], there is no direct method of  testing these automata for (non)emptiness. On the contrary,  clausal resolution method is effectively applied to a set of  clauses of normal form.  Tableau-based method for CTL are outlined in [8]. Using tableau methods, to show that a formula is valid, we  negate and apply tableau algorithm. The algorithm systematically constructs a structure from which a model can  be generated. If the structure is empty then no model can  be constructed, the negated formula is unsatisfiable and the  original formula is valid. The incremental method of the  construction of the tableau [8] has been essentially used in  showing completeness of the resolution method for CTL  [2].  Proof methods for particular modal logics are given in  several papers, for example [12, 14]. Ohlbach takes a resolution based approach removing modal operators and replacing them with world path arguments to predicate and  function symbols, i.e. a modal diamond (possibility) is replaced by & meaning there is an accessible world & from  here. Similarly here we annotate E rules with an index  to denote which path we are referring to. Ohlbach requires sophisticated unification algorithms dependant upon  the properties of the paths concerned. In the CTL resolution  system matching indices is trivial.  Temporal logics are hard to reason about due to the interand  operators encoding, in case  action between the  of linear-time temporal logic, a simple form of induction i.e.                The formulation of induction extended to branching-time  temporal logic, which can be found in the axiomatization of  CTL [8], is given by a set of formulae of a complex structure, for example,  A        E      A   The complex resolution rule, and search method described  in this paper is required to deal with the above induction  principle. Note that induction in branching-time logic is additionally complicated by the limit closure property of the  underlying tree models and in case of the full branchingtime logic, CTL , represents a main difficulty in axiomatizing the latter.  One of the benefits of the clausal resolution technique  is the possibility of invoking a variety of well-developed  methods and refinements used in the framework of classical  logic. For example an initial investigation into the development of the set of support for classical logics [15] to that  for linear-time temporal logics has been made in [7]. The  refinement of this strategy is ongoing work and could potentially be adapted to the branching framework.  7 Conclusions  As we have already mentioned, most of the research on  the proof methods for branching-time logics has been concentrated around the tableau or automata methods [8]. In  this paper we have investigated the application of the clausal  resolution method for CTL [2, 3]. The authors know of no  other clausal resolution methods developed for branchingtime logics. Searching for a loop is the crucial part of the  resolution technique. We have described breadth-first algorithms of identifying A-loops and E-loops and sketched  the correctness argument. This, together with the algorithm  for the clausal resolution for CTL [2], makes the resolution  method developed practically suitable for implementation.  However, ways to improve the application of the temporal  resolution rule must be further investigated. Here, although  we have formulated one method of searching for a loop,  this is only the starting point. The work to be done in this  direction concerns, in particular, development of the strategies of the preferred loops to find first, reduction of the  search graphs and loop subsumption algorithms. Again, we  expect here to incorporate the related results obtained for  PLTL [5, 6]. Also, taking into account that in branchingtime logics we deal with path quantifiers, it might be useful  to investigate parallels between loop searching techniques  and (rather simple in this case) unification algorithms used  in the resolution technique for predicate logic.  Acknowledgements This work has been partially supported by funding from HEFCE, under a PhD studentship  and EPSRC, under research grant GR/L87491. Both authors would like to thank Michael Fisher for his advice and  comments on this work. We are also grateful to anonymous  referees for their useful suggestions on improving the presentation.  References  [1] O. Bernholtz, M. Vardi, and P. Wolper. An automatatheoretic approach to branching-time model checking. In  Computer Aided Verification. Proceedings of 6th International Workshop, volume 818 of Lecture Notes in Computer  Science. Springer-Verlag, 1994.  [2] A. Bolotov. Clausal Resolution for Branching-Time Temporal Logic. PhD thesis, The Manchester Metropolitan University, 1999, (submitted).  [3] A. Bolotov and M. Fisher. A clausal resolution method for  ctl branching time temporal logic. Journal of experimental  and theoretical artificial intelligence, (11):77√¢¬Ä¬ì93, 1999.  [4] E. M. Clarke and E. A. Emerson. Using Branching Time  Temporal Logic to Synthesise Synchronisation Skeletons.  Science of Computer Programming, pages 241√¢¬Ä¬ì266, 1982.  [5] C. Dixon. Search Strategies for Resolution in Temporal Logics. In M. A. McRobbie and J. K. Slaney, editors, Proceedings of the Thirteenth International Conference on Automated Deduction (CADE), volume 1104 of Lecture Notes  in Artificial Intelligence, pages 672√¢¬Ä¬ì687, New Brunswick,  New Jersey, July/August 1996. Springer-Verlag.  [6] C. Dixon. Temporal resolution using a breadth-first search  algorithm. Annals of Mathematics and Artificial Intelligence, 22, 1998.  [7] C. Dixon and M. Fisher. The Set of Support Strategy in Temporal Resolution. In Proceedings of TIME-98 the Fifth International Workshop on Temporal Representation and Reasoning, Sanibel Island, Florida, May 1998. IEEE Computer  Society Press.  [8] E. A. Emerson. Temporal and Modal Logic. In J. van  Leeuwen, editor, Handbook of Theoretical Computer Science: Volume B, Formal Models and Semantics., pages 996√¢¬Ä¬ì  1072. Elsevier, 1990.  [9] E. A. Emerson.  Automated reasoning about reactive  systems.. In Logics for Concurrency: Structures Versus Automata, Proc. of International Workshop, volume 1043 of  Lecture Notes in Computer Science. Springer-Verlag, 1996.  [10] M. Fisher. A Resolution Method for Temporal Logic. In  Proc. of the XII International Joint Conference on Artificial  Intelligence (IJCAI), 1991.  [11] D. Gabbay, A. Phueli, S. Shelah, and J. Stavi. On the temporal analysis of fairness. In Proceedings of 7th ACM Symposium on Principles of Programming Languages, 1980.  [12] H.-J. Ohlbach. A Resolution Calculus for Modal Logics.  Lecture Notes in Computer Science, 310:500√¢¬Ä¬ì516, May  1988.  [13] A. Pnueli. The Temporal Logic of Programs. In Proc. of  the Eighteenth Symposium on the Foundations of Computer  Science, 1977.  [14] L. A. Wallen. Matrix Proof Methods for Modal Logics. In  Proc. IJCAI-87, pages 917√¢¬Ä¬ì923, Milan, Aug. 1987.  [15] L. Wos, G. Robinson, and D. Carson. Efficiency and Completeness of the Set of Support Strategy in Theorem Proving.  J. ACM, 12:536√¢¬Ä¬ì541, Oct. 1965. 