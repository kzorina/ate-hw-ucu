L OLA: Runtime Monitoring of Synchronous  Systems  Ben DâAngelo â  Sriram Sankaranarayanan  Bernd Finkbeiner â  Henny B. Sipma â  â  CeĚsar SaĚnchez â  Sandeep Mehrotra âĄ  Will Robinson  Zohar Manna  â  â  â  Computer Science Department, Stanford University, Stanford, CA 94305  {bdangelo,srirams,cesar,sipma,manna}@theory.stanford.edu  â  Department of Computer Science, Saarland University  finkbeiner@cs.uni-sb.de  Abstractâ We present a speciďŹcation language and algorithms for the online and ofďŹine monitoring of synchronous  systems including circuits and embedded systems. Such  monitoring is useful not only for testing, but also under  actual deployment. The speciďŹcation language is simple  and expressive; it can describe both correctness/failure  assertions along with interesting statistical measures that  are useful for system proďŹling and coverage analysis.  The algorithm for online monitoring of queries in this  language follows a partial evaluation strategy: it incrementally constructs output streams from input streams,  while maintaining a store of partially evaluated expressions  for forward references. We identify a class of speciďŹcations, characterized syntactically, for which the algorithmâs  memory requirement is independent of the length of the  input streams. Being able to bound memory requirements  is especially important in online monitoring of large input  streams. We extend the concepts used in the online algorithm to construct an efďŹcient ofďŹine monitoring algorithm  for large traces.  We have implemented our algorithm and applied it to  two industrial systems, the PCI bus protocol and a memory  controller. The results demonstrate that our algorithms are  practical and that our speciďŹcation language is sufďŹciently  expressive to handle speciďŹcations of interest to industry.  I. I NTRODUCTION  Monitoring synchronous programs for safety and liveness properties is an important aspect of ensuring their  proper runtime behavior. An ofďŹine monitor analyzes  traces of a system post-simulation to spot violations of  This research was supported in part by NSF grants CCR-0121403, CCR-02-20134, CCR-02-09237, CNS-0411363, and CCF0430102, by ARO grant DAAD19-01-1-0723, by NAVY/ONR contract N00014-03-1-0939, by the Siebel Graduate Fellowship, and by  the BMBF grant 01 IS C38 B as part of the Verisoft project.  âĄ  Synopsys, Inc.  the speciďŹcation. OfďŹine monitoring is critical for testing  large systems before deployment. An online monitor  processes the system trace while it is being generated.  Online monitoring is used to detect violations of the  speciďŹcation when the system is in operation so that  they can be handled before they translate into observable  and cascading failures, and to adaptively optimize system  performance.  Runtime monitoring has received growing attention in  recent years [1], [2], [3]. While static veriďŹcation intends  to show that every (inďŹnite) run of a system satisďŹes  the speciďŹcation, runtime monitoring is concerned only  with a single (ďŹnite) trace. Runtime monitoring can be  viewed as an extension of testing with more powerful  speciďŹcation languages.  The ofďŹine monitoring problem is known to be easy  for purely past or purely future properties. It is well  known that for past properties, the online monitoring  problem can be solved efďŹciently using constant space  and linear time in the trace size. For future properties, on  the other hand, the space requirement generally depends  on the length of the trace, which suggests that online  monitoring may quickly become intractable in practical  applications with traces exceeding 106 simulation steps.  In this paper, we present a speciďŹcation language,  intended for industrial use. The language can express  properties involving both the past and the future. It is a  functional stream computation language like L USTRE [4]  and E STEREL [5], with features that are relevant to our  problem at hand. It is parsimonious in its number of  operators (expressions are constructed from three basic  operators), but the resulting expressiveness surpasses  temporal logics and many other existing formalisms  Proceedings of the 12th International Symposium on Temporal Representation and Reasoning (TIMEâ05)  1530-1311/05 $20.00 ÂŠ 2005 IEEE  including ďŹnite-state automata.  We provide a syntactic characterization of efďŹciently  monitorable speciďŹcations, for which the space requirement of the online monitoring algorithm is independent  of the size of the trace, and linear in the speciďŹcation  size. An analysis of some industrial speciďŹcations provided by Synopsys, Inc. showed that a large majority  of these speciďŹcations lie in this efďŹciently monitorable  class. For the ofďŹine monitoring problem, we demonstrate an efďŹcient monitoring strategy in the presence of  mixed past/future properties.  We have implemented our algorithm and speciďŹcation  language in a system called L OLA. L OLA accepts a  speciďŹcation in the form of a set of stream expressions,  and is then run on a set of input streams. Two types  of speciďŹcations are supported: properties that specify  correct behavior, and properties that specify statistical  measures that allow proďŹling the system that produces  the input streams. An execution of L OLA computes  arithmetic and logical expressions over the ďŹnite input  and intermediate streams to produce an output consisting  of error reports and the desired statistical information.  A. Related Work  Much of the initial work on runtime monitoring (cf.  [6], [7], [8]) was based on temporal logic [9]. In [10],  non-deterministic automata are built from LTL to check  violations of formulas over ďŹnite traces and the complexity of these problems is studied. LTL based speciďŹcations  have already been pursued in tools such as the Temporal  Rover [7] and Java PathExplorer [11]. One limitation of  this approach is that the logic must be adapted to handle  truncated traces. The approach taken in [12] considers  extensions of LTL for the case of truncated paths with  different interpretations (weak and strong) of the next  operator at the end of the trace. The choice of handling  success/failure on a ďŹnite trace frequently depends on  the situation being modeled.  Another important difference between runtime veriďŹcation and static veriďŹcation is that liveness properties  can never be violated on a ďŹnite trace. An appealing  solution is to extend the speciďŹcation language to compute quantitative measures based on the trace. Temporal  properties can be speciďŹed in L OLA, but one of the  main goals is to go beyond property checking to the  collection of numerical statistics. For example, instead  of checking the property âthere are only ďŹnitely many  retransmissions of each package,â which is vacuously  true over ďŹnite traces, we desire to evaluate queries like  âwhat is the average number of retransmissions.â Our  ďŹrst approach to combine the property proving with data  collection appeared in [13]. Following this trend, runtime veriďŹers can be used not only for bug-ďŹnding, but  also for proďŹling, coverage, vacuity and numerous other  analyses.  L OLA models runtime veriďŹcation as a stream computation. The deďŹnition of L OLA output streams in  terms of other streams resembles synchronous programming languages (notably L USTRE [4], E STEREL [5],  Signal [14]), but there is a signiďŹcant difference: these  languages are designed primarily for the construction of  synchronous systems. Therefore, output values for a time  instant are computed directly from values at the same and  previous instants. This assumption makes perfect sense  if we desire that the systems we specify be executable,  and therefore be causal. However, runtime speciďŹcations  are descriptive in nature. They include future formulas  whose evaluation may have to be delayed until future  values arrive. This requires stronger expressiveness in the  language and the corresponding evaluation strategies.  Other efforts in run-time veriďŹcation include [15],  which studies the efďŹcient generation of monitors from  speciďŹcations written as extended regular expressions,  and [16], which studies rewriting techniques for the  efďŹcient evaluation of LTL formulas on ďŹnite execution  traces, both online and ofďŹine. In [8], an efďŹcient method  for the online evaluation of past LTL properties is  presented. This method exploits that past LTL can be  recursively deďŹned using only values in the previous  state of the computation. Our efďŹciently monitorable  speciďŹcations generalize this idea, and apply it uniformly  to both veriďŹcation and data collection.  The system that most closely resembles L OLA is  Eagle [17]. Eagle allows the description of monitors  based on greatest and least ďŹxed points of recursive  deďŹnitions. Many logical formalisms used to describe  properties, including past and future LTL formulas, can  be translated to Eagle speciďŹcations. These are then  compiled into a set of rules that implements the monitor.  L OLA differs from Eagle in the descriptive nature of the  language, and in that L OLA is not restricted to checking  logical formulas, but can also express numerical queries.  II. L OLA OVERVIEW  In this section we describe the speciďŹcation language.  The monitoring algorithms will be presented in Section III.  A. SpeciďŹcation Language: Syntax  A L OLA speciďŹcation describes the computation of  output streams from a given set of input streams. A  Proceedings of the 12th International Symposium on Temporal Representation and Reasoning (TIMEâ05)  1530-1311/05 $20.00 ÂŠ 2005 IEEE  stream Ď of type T is a ďŹnite sequence of values from  T . We let Ď(i), i âĽ 0 denote the value of the stream at  time step i.  DeďŹnition 1 (L OLA speciďŹcation) A L OLA speciďŹcation is a set of equations over typed stream variables,  of the form  s1  ..  .  = e1 (t1 , . . . , tm , s1 , . . . , sn )  ..  .  sn = en (t1 , . . . , tm , s1 , . . . , sn ),  where s1 , . . . , sn are called the dependent variables  and t1 , . . . , tm are called the independent variables,  and e1 , . . . , en are stream expressions over s1 , . . . , sn  and t1 , . . . , tm . Independent variables refer to input  streams and dependent variables refer to output streamsâ .  A L OLA speciďŹcation can also declare certain output  boolean variables as triggers. Triggers generate notiďŹcations at instants when their corresponding values become  true . Triggers are speciďŹed in L OLA as  trigger Ď  where Ď is a boolan expression over streams.  A stream expression is constructed as follows:  â˘ If c is a constant of type T , then c is an atomic  stream expression of type T ;  â˘ If s is a stream variable of type T , then s is an  atomic stream expression of type T ;  â˘ Let f : T1 ĂT2 ĂÂˇ Âˇ ÂˇĂTk â T be a k -ary operator.  If for 1 â¤ i â¤ k , ei is an expression of type Ti , then  f (e1 , . . . , ek ) is a stream expression of type T ;  â˘ If b is a boolean stream expression and e1 , e2 are  stream expressions of type T , then ite(b, e1 , e2 )  is a stream expression of type T ; note that ite  abbreviates if-then-else.  â˘ If e is a stream expression of type T , c is a constant  of type T , and i is an integer, then e[i, c] is a stream  expression of type T . Informally, e[i, c] refers to the  value of the expression e offset i positions from the  current position. The constant c indicates the default  value to be provided, in case an offset of i takes us  past the end or before the beginning of the stream.  â  In our implementation we partition the dependent variables into  output variables and intermediate variables to distinguish streams that  are of interest to the user and those that are used only to facilitate  the computation of other streams. However, for the description of  the semantics and the algorithm this distinction is not important, and  hence we will ignore it in this paper.  Example 1 Let t1 , t2 be stream variables of type  boolean and t3 be a stream variable of type integer. The  following is an example of a L OLA speciďŹcation with  t1 , t2 and t3 as independent variables:  s1  s2  s3  s4  s5  s6  s7  s8  s9  s10  =  =  =  =  =  =  =  =  =  =  true  t3  t1 â¨ (t3 â¤ 1)  ((t3 )2 + 7) mod 15  ite(s3 , s4 , s4 + 1)  ite(t1 , t3 â¤ s4 , ÂŹs3 )  t1 [+1, false]  t1 [â1, true]  s9 [â1, 0] + (t3 mod 2)  t2 â¨ (t1 â§ s10 [1, true])  Stream variable s1 denotes a stream whose value is  true at all positions, while s2 denotes a stream whose  values are the same at all positions as those in t3 . The  values of the streams corresponding to s3 , . . . , s6 are  obtained by evaluating their deďŹning expressions placewise at each position. The stream corresponding to s7  is obtained by taking at each position i the value of  the stream corresponding to t1 at position i + 1, except  at the last position, which assumes the default value  false. Similarly for the stream for s8 , whose values are  equal to the values of the stream for t1 shifted by one  position, except that the value at the ďŹrst position is the  default value true. The stream speciďŹed by s9 counts  the number of odd entries in the stream assigned to t3 by  accumulating (t3 mod 2). Finally, s10 denotes the stream  that gives at each position the value of the temporal  formula t1 Until t2 with the stipulation that unresolved  eventualities be regarded as satisďŹed at the end of the  trace.  B. SpeciďŹcation Language: Semantics  The semantics of L OLA speciďŹcations is deďŹned in  terms of evaluation models, which describe the relation  between input streams and output streams.  DeďŹnition 2 (Evaluation Models) Let Ď be a L OLA  speciďŹcation over independent variables t1 , . . . , tm with  types T1 , . . . , Tm , and dependent variables s1 , . . . , sn  with types Tm+1 , . . . , Tm+n . Let Ď1 , . . . , Ďm be streams  of length N +1, with Ďi of type Ti . The tuple Ď1 , . . . , Ďn   of streams of length N + 1 with appropriate types is  called an evaluation model, if for each equation in Ď  si = ei (t1 , . . . , tm , s1 , . . . , sn ),  Ď1 , . . . , Ďn  satisďŹes the following associated equations:  Ďi (j) = val (ei )(j)  Proceedings of the 12th International Symposium on Temporal Representation and Reasoning (TIMEâ05)  1530-1311/05 $20.00 ÂŠ 2005 IEEE  for 0 â¤ j â¤ N  where val (e)(j) is deďŹned as follows. For the base cases:  val (c)(j) = c .  val (ti )(j) = Ďi (j) .  val (si )(j) = Ďi (j) .  For the inductive cases:  val (f (e1 , . . . , ek )(j) =  f (val (e1 )(j), . . . , val (ek )(j)) .  val (ite(b, e1 , e2 ))(j) =  if val (b)(j) then val (e1 )(j) else val (e2 )(j) .  val (e[k,   c])(j) =  val (e)(j + k) if 0 â¤ j + k â¤ N,  c  otherwise .  The set of all equations associated with Ď is denoted by  ĎĎ .  Example 2 Consider the L OLA speciďŹcation  Ď : s = t1 [1, 0] + ite(t2 [â1, true], t3 , t4 + t5 ).  The associated equations ĎĎ are  ďŁś  ďŁŤ  ďŁą  (j  â  1),  Ď  ďŁ´  2  ďŁ´  ďŁ´  ďŁˇ  ďŁŹ  ďŁ´  ďŁ´  Ď1 (j + 1) + ite ďŁ­ Ď3 (j),  ďŁ¸ j â [1, N ),  ďŁ´  ďŁ´  ďŁ´  ďŁ´  ďŁ´  Ď4 (j) + Ď5 (j)  ďŁ˛  ďŁś  ďŁŤ  Ď(j) =  Ď2 (N â 1),  ďŁ´  ďŁˇ  ďŁŹ  ďŁ´  ďŁ´  j = N,  ite ďŁ­ Ď3 (N ),  ďŁ¸  ďŁ´  ďŁ´  ďŁ´  ďŁ´  ďŁ´  Ď  (N  )  +  Ď  (N  )  ďŁ´  4  5  ďŁ´  ďŁł  j = 0.  Ď1 (1) + Ď3 (0)  A L OLA speciďŹcation is well-deďŹned if for any set of  appropriately typed input streams, all of the same length,  it has exactly one evaluation model.  Example 3 Consider the L OLA speciďŹcation  Ď1 : s1 = (t1 â¤ 10).  For the stream Ď1 : 0, . . . , 100, the associated equations  are Ď1 (j) = (Ď1 (j) â¤ 10). The only evaluation model  of Ď1 is the stream Ď1 (i) = true iff i â¤ 10. In fact,  this L OLA speciďŹcation is well-deďŹned, since it deďŹnes  a unique output for each possible input. However, the  speciďŹcation  Ď2 : s2 = s2 â§ (t1 â¤ 10)  is not well-deďŹned, because there are many streams Ď2  that satisfy Ď2,Ď for some input stream. Similarly, the  speciďŹcation  Ď3 : s3 = ÂŹs3  is not well-deďŹned, but for this speciďŹcation the reason  is that it has no evaluation models.  To avoid ill-deďŹned speciďŹcations we deďŹne a syntactic restriction on L OLA speciďŹcations guaranteeing that  any well-formed L OLA expression is also well-deďŹned.  DeďŹnition 3 (Dependency Graph) Let Ď be a L OLA  speciďŹcation. A dependency graph for Ď is a weighted  and directed multi-graph G = V, E, with vertex set  V = {s1 , . . . , sn , t1 , . . . , tm }. An edge e : si , sk , w  labeled with a weight w is in E iff the equation for  Ďi (j) in ĎĎ contains Ďk (j + w) as a subexpression of  the RHS, for some j (or e : si , tk , w for subexpression  Ďk (j +w)). Intuitively, the edge records the fact that si at  a particular position depends on the value of sk , offset  by w positions. Note that there can be multiple edges  between si and sk with different weights on each edge.  Vertices labeled by ti do not have outgoing edges.  Example 4 Consider the L OLA speciďŹcation over independent integer variables t1 , t2 :  ďŁś  ďŁŤ  s2 [â1, 7] â¤ t1 [1, 0],  ďŁ¸.  s1 = s2 [1, 0] + ite ďŁ­ s2 [â1, 0],  s2  s2 = (s1 + t2 [â2, 1]).  Its dependency graph, shown in Figure 1, has three edges  from s1 to s2 , with weights 1, 0, â1, and one zero  weighted edge from s2 back to s1 . There is one edge  from s1 to t1 , and one from s2 to t2 .  A walk of a graph is a sequence v1 , . . . , vk+1 of  vertices, for k âĽ 1, and edges e1 , . . . , ek , such that  ei : vi , vi+1 , wi . The walk is closed iff v1 = vk+1 .  The total weight of a walk is the sum of weights of its  edges.  DeďŹnition 4 (Well-Formed SpeciďŹcations) A L OLA  speciďŹcation is well-formed if there is no closed-walk  with total weight zero in its dependency graph.  Theorem 1 Every well-formed L OLA speciďŹcation is  well-deďŹned.  All proofs will be available in an extended version of this  document. The following alternative characterization of  well-formedness is useful for algorithmic purposes and  for the ofďŹine monitoring algorithm.  Proceedings of the 12th International Symposium on Temporal Representation and Reasoning (TIMEâ05)  1530-1311/05 $20.00 ÂŠ 2005 IEEE  @ABC  GFED  t1 o  1  @ABC  GFED  s1 l  1,0,â1  , GFED  @ABC  s  2  â2  0  @ABC  / GFED  t2  Fig. 1: Dependency graph for the speciďŹcation of Example 4.  Theorem 2 A L OLA speciďŹcation is well-formed iff no  strongly connected component in G has both a positive  and a negative weighted cycle.  The converse of Theorem 1 is not true: not every welldeďŹned L OLA speciďŹcation need be well-formed. For  instance, the speciďŹcation s = s â§ ÂŹs is well-deďŹned,  but not well-formed.  C. Statistics and Context-free Properties  We shall now demonstrate the use of our speciďŹcation  language for computing statistical properties over trace  data. Numerical properties over traces are essential as  (1) components of correctness properties that involve  counts, maxima or minima over trace data, and (2)  estimating performance and coverage metrics in the form  of averages.  L OLA can be used to compute incremental statistics,  i.e., measures that are deďŹned using an update function  fÎą (v, u) where u represents the measure thus far, and  v represents the new incoming data. Given a sequence  of values v1 , . . . , vn , with a special default value d, the  statistic over the data is deďŹned in the reverse sense as  v = fÎą (v1 , fÎą (v2 , . . . , fÎą (vn , d)))  or in the forward sense as  v = fÎą (vn , fÎą (vnâ1 , . . . , fÎą (v1 , d)))  Examples of such statistical measures include count with  fcount (v, u) = u+1, sum with fsum (v, u) = v +u, max  with fmax (u, v) = max (u, v), among many others; the  statistical average can be incrementally deďŹned as a pair  consisting of the sum and the count.  Given an update function fÎą and a data-stream v ,  the following L OLA queries compute the statistic in the  forward and reverse senses respectively:  stat f = fÎą (stat f [â1, d], v) ,  stat r = fÎą (stat r [1, d], v) .  For most common incremental statistical measures, either of these L OLA queries compute the same result.  The choice of a monitoring strategy can dictate the use  of one over another as will be evident in the subsequent  section.  The use of numeric data also increases the expressiveness of the language; it enables the expression of  context-free properties. Commonly encountered contextfree properties include properties such as âevery request  has a matching grant.â In programs, we may use such  properties to verify that every lock acquired has been released, or that every memory cell allocated is eventually  freed exactly once.  Example 5 Consider the property: âthe number of aâs  must always be no less than the number of bâs.â This  property can be expressed in L OLA as  s = s[â1, 0] + ite((a â§ ÂŹb), 1, 0)  + ite((b â§ ÂŹa), â1, 0)  trigger(s â¤ 0)  Integer streams in a L OLA speciďŹcation enable the  expression of context-free properties by being used as  counters to model stacks. For instance, a two alphabet  stack with alphabet symbols 0 and 1 can be modelled  by a counter. Each pop is implemented by dividing the  counter by 2, thereby eliminating the least signiďŹcant bit.  Each push is modelled by a multiplication by 2 followed  by addition, thereby setting the least signiďŹcant bit. Thus,  with one (unbounded) counter, a L OLA speciďŹcation can  express context-free properties.  It can be shown that L OLA speciďŹcations with only  boolean streams cannot express context-free properties.  III. M ONITORING A LGORITHM  In this section, we ďŹrst describe the setting for  the monitoring problem considered in the paper. We  then describe our monitoring algorithm using partial  evaluation of the equational semantics.  A. Monitoring Setup  We distinguish two situations for monitoring â online  and ofďŹine monitoring. With online monitoring, system  behaviors are observed as the system is run under a  test/real-life setting. In a simulation setting, we can  assume that the monitor is working in tandem with  the simulator, with the monitor processing a few trace  positions while the simulator waits, and then the monitor  waiting while the simulation proceeds to produce the  Proceedings of the 12th International Symposium on Temporal Representation and Reasoning (TIMEâ05)  1530-1311/05 $20.00 ÂŠ 2005 IEEE  next few positions. On the other hand, ofďŹine monitoring  assumes that the system has been run to completion,  and the trace data was dumped to a storage device. This  leads to the following restriction for online monitoring:  the traces are available a few points at a time starting  from time 0 onwards, and need to be processed online to  make way for more incoming data. In particular, random  access to the traces is not available.  B. Online Monitoring Algorithm  In online monitoring we assume that the trace is  available one position at a time, starting from time 0.  The length of the trace is assumed to be unknown and  large.  Let t1 , . . . , tm be independent (input) stream variables,  and s1 , . . . , sn be dependent (output) stream variables.  Let j âĽ 0 be the current position where the latest trace  data is available from all the input streams.  Evaluation Algorithm: The evaluation algorithm  maintains two stores of equations:  â˘ Resolved equations R of the form Ďi (j) = c, or  Ďi (j) = c, for constant c.  â˘ Unresolved equations U of the form Ďi (j) = ei for  all other stream expressions ei .  Initially both stores are empty. At the arrival of input  stream data for a particular position j , 0 â¤ j â¤ N ,  that is, when Ď1 (j), . . . , Ďm (j) become available, the  following steps are carried out:  1) The equations Ď1 (j) = c1 , . . . , Ďm (j) = cm are  added to R,  2) The associated equations for Ď1 (j), . . . , Ďn (j) are  added to U ,  3) The equations in U are simpliďŹed as much as  possible; if an equation becomes of the form  Ďi (j) = c, it is removed from U and added to R. If  c is true and the corresponding output variable si  is marked as a trigger, then a violation is reported.  4) For each stream ti ( also si ), there is a non-negative  constant ki such that Ďi (j âki ), if present in R can  be safely removed. The constant ki âĽ 0 is deďŹned  as    k is non-negative and  .  ki = max k  ti [âk, d] is a subexpression.  Intuitively, for any position j , j + ki is the latest  value in the future whose computation requires the  value of Ďi (j).  Example 6 To illustrate the last point, consider the  speciďŹcation,  s = s[â3, 0] + t.  Let Ď be the input stream. The value of ki for s is 3  and for t is zero. This indicates that for any input stream  Ď , the value Ď (j) can be removed from R at position j  itself. Similarly any Ď(j) â R may be removed from R  at (or after) position j + 3.  Equations in U are simpliďŹed using the following  rules:  1) Partial evaluation rules for function applications  such as,  true â§ e â e, 0 + x â x Âˇ Âˇ Âˇ  2) Rewrite rules for if-then,  ite(true, e1 , e2 ) â e1 Âˇ Âˇ Âˇ  3) Substitution of resolved positions from R. If  Ďi (j) = c â R, then every occurrence of Ďi (j)  in U is substituted by c and possibly simpliďŹed  further.  We illustrate the operation of the algorithm on a simple  example.  Example 7 Let t1 , t2 be two input boolean stream variables. Consider the speciďŹcation  Ď : s = t2 â¨ (t1 â§ s[1, false]),  which computes t1 Until t2 . The associated equations  for Ď are:    Ď2 (j) â¨ (Ď1 (j) â§ Ď(j + 1)) j + 1 â¤ N  Ď(j) =  otherwise.  Ď2 (j)  Let the input streams, Ď1 and Ď2 be given by  Ď1  Ď2  false  true  false  false  true  false  true  false  true  false  true  false  true  false  At position 0, we encounter false, true. The equation for Ď(0) is  Ď(0)  = Ď2 (0) â¨ (Ď1 (0) â§ Ď(1))  â true â¨ (false â§ Ď(1))  â true  and thus Ď(0) = true is added to the resolved store R.  At position 1, we encounter false, false and thus we  can set Ď(1) = false , which is also added to R. From  j = 2 until j = 5, we encounter true, false. At each of  these positions the equations Ď(j) = Ď(j + 1) are added  to U . The equation store U now has the equations  Ď(2) = Ď(3), Ď(3) = Ď(4), . . . , Ď(5) = Ď(6).  Proceedings of the 12th International Symposium on Temporal Representation and Reasoning (TIMEâ05)  1530-1311/05 $20.00 ÂŠ 2005 IEEE  At position 6, we encounter true, false with the added  information that the trace has ended. We set Ď(6) = false  and add it to R. This lets us resolve the equations in U  and set all the positions from 2 to 6 to false .  Note that the equation associated with Ďi (j) on the  LHS is added only after the current position reaches  j , even if the term Ďi (j) appears on the RHS of some  equation before position j is reached.  The algorithm above works in time and space that  is linear in the length of the trace and the size of the  speciďŹcation. Since the memory usage can be as large  as the length of the trace in the worst-case, the method  may not work for long simulations and large traces.  Example 8 Consider the following L OLA speciďŹcation:  ended = false[1, true]  s = ite(ended , t, s[1, true])  in which the output stream Ď takes the same value  everywhere that the input stream Ď takes at the end of  the trace. The partial evaluation algorithm maintains the  unresolved Ď(0), . . . , Ď(N ). Such speciďŹcations cannot  be monitored efďŹciently. Furthermore, if the variable  s appears in other expressions, the evaluation of the  corresponding streams need to be delayed until Ď can  be resolved.  In the next section we characterize an efďŹciently monitorable set of L OLA speciďŹcations based on the properties of their dependency graphs. The partial evaluation  algorithm will be shown to work efďŹciently for such  speciďŹcations.  C. EfďŹciently Monitorable SpeciďŹcations  We present a class of speciďŹcations that are efďŹciently  monitorable. These speciďŹcations are guaranteed to limit  the number of unresolved equations in the memory to a  pre-determined constant that depends only on the size of  the speciďŹcation and not on the size of the trace.  DeďŹnition 5 (EfďŹciently Monitorable SpeciďŹcations)  A L OLA speciďŹcation is efďŹciently monitorable (EM) if  its worst case memory requirement under our online  monitoring algorithm is constant in the size of the trace.  Example 9 Consider the speciďŹcation âEvery request  must be eventually followed by a grant before the trace  endsâ, which can be expressed as follows:  reqgrant = ite(request, evgrant, true)  evgrant = grant â¨ evgrant[1, false]  trigger (ÂŹ reqgrant)  The speciďŹcation encodes the temporal assertion  (request â âŚ(grant)). Another way that produces  the same result is    waitgrant =    ÂŹgrant â§  request â¨  waitgrant[â1, false]     trigger ended â§ waitgrant  The stream waitgrant records if the monitor is currently  waiting for a grant. The monitor waits for a grant  whenever it encounters a request and stops waiting if  there is a grant . If the trace ends while the monitor is  still waiting, it triggers an error. The latter formulation  is efďŹciently monitorable, while the former is not. For  instance, at every time instance, waitgrant(i) is instantly  resolved given its previous value, and those of the input  streams. Thus, the simple partial evaluation algorithm  monitors the latter with very little, constant, buffering.  The following theorem characterizes efďŹciently monitorable L OLA speciďŹcations.  Theorem 3 If the dependency graph of a L OLA query  has no positive cycles then it is efďŹciently monitorable.  The converse of the theorem above does not hold  in general. However, in the absence of an alternative  syntactic characterization of EM speciďŹcation, we shall  henceforth use the term EM speciďŹcation to denote  queries whose dependency graphs do not contain positive  cycles.  Given graph G, that does not have any positive weight  cycles, we construct a graph G+ , obtained by removing  all negative weight edges from G. Furthermore, among  all the edges in G between two nodes si and sj , we  choose to add only that edge to G+ which has the  maximum positive weight. The graph G+ has no self  loops or multiple edges, and hence is a weighted directed  acyclic graph (DAG). For each node si â G+ , we deďŹne  âi as follows:  ďŁą  ,  ďŁ´  ďŁ˛0, if there is no outgoing edge from si  w(ej )  âi =  ej : si ââââ sj  ďŁ´  , ow .  ďŁłmax âj + w(ej )  is an edge in G+  Example  tion:  s1  s2  s3  10 Consider the following L OLA speciďŹca= t1 [1, false] â§ s3 [â7, false]  = ite(s1 [2, true], t2 [2, 0], t2 [â1, 2])  = (s2 [4, true] â¤ 5)  The dependency graph G is shown in Figure 2. The  values of the â function are as follows:  â(t1 ) = â(t2 ) = 0, â(s1 ) = 1, â(s2 ) = 3, â(s3 ) = 7.  Proceedings of the 12th International Symposium on Temporal Representation and Reasoning (TIMEâ05)  1530-1311/05 $20.00 ÂŠ 2005 IEEE  â7  @ABC  GFED  s3  v  4  @ABC  / GFED  s2  2  2,â1    @ABC  GFED  t2  @ABC  / GFED  s1  1    @ABC  GFED  t1  (a) Dependency graph G.  @ABC  GFED  s3  4  @ABC  / GFED  s2  2  2    @ABC  GFED  t2  @ABC  / GFED  s1  1    @ABC  GFED  t1  (b) Derived graph G+ .  Fig. 2: The dependency graph G for Example 10 and its derived graph G+ .  The signiďŹcance of the â function is clear through the  following theorem.  Theorem 4 The partial evaluation algorithm resolves  any trace position Ďi (j) before time j + âi .  The memory requirement is therefore constant in N  for an efďŹcient speciďŹcation. This number of unresolved  positions in U is upper-bounded by O(â1 + Âˇ Âˇ Âˇ + ân ).  For instance, computing the â values for the queries  in Example 9, we ďŹnd that â(waitgrant) = 0. This  shows that the value of waitgrant resolves immediately,  given its previous value and the inputs. Our experimental  results in the subsequent section show that requiring  speciďŹcations to be efďŹciently monitorable is not unreasonable in practice. Furthermore, streams involved  in positive cycles can be discarded or even rewritten  (as shown in Example 9) for the purposes of online  monitoring.  The framework developed generalizes naturally to an  ofďŹine monitoring algorithm. Please refer to the full  version of this paper available online.  IV. A PPLICATIONS  There are numerous applications of this formalism. In  this section, we describe two such applications obtained  directly from the industry. Synopsys, Inc. provided some  circuit simulation dumps, along with speciďŹcations written in the industry standard System Verilog Assertions  (SVA)[18]. We were able to hand-translate the SVA  queries directly into L OLA speciďŹcations, a process that  is potentially mechanizable.  Our OC AML-based implementation of L OLA reads a  trace ďŹle and the speciďŹcation ďŹle. It implements the  online monitoring algorithm described in Section III with  some direct optimizations. We have incorporated facilities for displaying dependency graphs of speciďŹcations.  The following two case studies were considered:  a) Memory Controller: A Verilog model for a  memory controller was simulated yielding 13 input  streams. The corresponding SVA assertions were handtranslated into a L OLA speciďŹcation. The speciďŹcation  had 21 intermediate streams and 15 output streams, all  of which were declared triggers. Properties enforced  included mutual exclusion of signals, correct transfers of  address and data, and timing speciďŹcations (e.g. signal  stability for 3 or 4 cycles). The speciďŹcations were not  EM : the dependency graph had three positive-sum cycles,  each encoding a temporal until operator. Figure 3 shows  the performance of L OLA on these traces.  b) PCI: We hand translated SVA assertions describing the PCI 2.2 speciďŹcations for the master. A circuit  implementing the master was simulated for varying times  to produce a set of traces to plot the performance. The  speciďŹcation had 15 input streams, 161 output streams  and 87 trigger streams. Our initial implementation contained three positive weight cycles. We were able to  remove these by rewriting the queries carefully. Running  times can also be found in Figure 3. Bugs were deliberately introduced into the circuit in order to evaluate  the effectiveness of runtime veriďŹcation. L OLA reports  numerous useful trigger violations for the longest trace.  V. C ONCLUSIONS  We have presented L OLA, a formalism for runtime  veriďŹcation based on a functional language over ďŹnite streams equipped with a partial evaluation-based  strategy for online evaluation. Our formalism combines  runtime veriďŹcation of boolean temporal speciďŹcations  with statistical measures to estimate coverage and specify  complex temporal patterns. By evaluating our system on  industrial strength speciďŹcations, we have demonstrated  that L OLA can express relevant properties. Using dependency graphs, we have characterized efďŹciently monitorable queries that can be monitored online efďŹciently  in terms of space. Based on our case-studies so far, the  restriction to efďŹciently monitorable speciďŹcations seems  Proceedings of the 12th International Symposium on Temporal Representation and Reasoning (TIMEâ05)  1530-1311/05 $20.00 ÂŠ 2005 IEEE  # simulation steps  5000  10000  20000  50000  100000  200000  500000  1000000  Controller example  # clock pos. edges time (sec)  250  0.18  500  0.35  1000  0.71  2500  1.78  5000  3.47  10000  6.83  25000  17.02  50000  33.70  PCI example  # clock pos. edges  834  1667  3334  8334  16667  33334  83334  166667  time  4.62  8.87  19.04  29.47  52.53  99.17  236.96  467.98  Fig. 3: Running times for both examples. All timings were measured on an Intel Xeon Processor running Linux  2.4 with 2Gb RAM.  practical.  In the future, we intend to study automatic techniques  for rewriting non-EM speciďŹcations into efďŹciently monitorable ones where possible, and in further collaboration  with industry study the applicability of these techniques  for larger case studies. We expect that for such use  some syntactic sugar needs to be added to L OLA to  facilitate speciďŹcation of common constructs. Also the  error reporting needs to be improved by synthesizing  explanations for each violation. Extensions to handle  synchronous systems with many clocks, asynchronous  systems, and distributed systems are also under consideration.  R EFERENCES  [1] K. Havelund and G. RosĚ§u, Eds., Runtime VeriďŹcation 2001  (RVâ01), ser. ENTCS, vol. 55. Elsevier, 2001.  [2] ââ, Runtime VeriďŹcation 2002 (RVâ02), ser. ENTCS, vol. 70,  no. 4. Elsevier, 2002.  [3] O. Sokolsky and M. Viswanathan, Eds., Runtime VeriďŹcation  2002 (RVâ03), ser. ENTCS, vol. 89, no. 2. Elsevier, 2003.  [4] N. Halbwachs, P. Caspi, P. Raymond, and D. Pilaud, âThe  synchronous data-ďŹow programming language LUSTRE,â Proc.  of IEEE, vol. 79, no. 9, pp. 1305â1320, 1991.  [5] G. Berry, Proof, language, and interaction: essays in honour  of Robin Milner. MIT Press, 2000, ch. The foundations of  Esterel, pp. 425â454.  [6] I. Lee, S. Kannan, M. Kim, O. Sokolsky, and M. Viswanathan,  âRuntime Assurance Based on Formal SpeciďŹcations,â in Proc.  of the International Conference on Parallel and Distributed  Processing Techniques and Applications, 1999.  [7] D. Drusinsky, âThe temporal rover and the ATG rover,â in SPIN  Model Cheking and Software VeriďŹcation, 2000, pp. 323â330.  [8] K. Havelund and G. RosĚ§u, âSynthesizing monitors for safety  properties,â in Proc. of TACASâ02. Springer, 2002, pp. 342â  356.  [9] Z. Manna and A. Pnueli, Temporal VeriďŹcation of Reactive  Systems: Safety. New York: Springer, 1995.  [10] O. Kupferman and M. Y. Vardi, âModel checking of safety  properties,â Formal Methods in System Design, vol. 19, no. 3,  pp. 291â314, 2001.  [11] K. Havelund and G. RosĚ§u, âAn overview of the runtime  veriďŹcation tool java pathexplorer,â Formal Methods for Systems  Design, vol. 24, no. 2, pp. 189â215, 2004.  [12] C. Eisner, D. Fisman, J. Havlicek, Y. Lustig, A. McIsaac,  and D. V. Campenhout, âReasoning with temporal logic on  truncated paths,â in Proc. of CAVâ03, ser. LNCS, vol. 2725.  Springer, 2003, pp. 27â39.  [13] B. Finkbeiner, S. Sankaranarayanan, and H. B. Sipma, âCollecting statistics over runtime executions,â in [2].  [14] T. Gautier, P. Le Guernic, and L. Besnard, âSIGNAL: A  declarative language for synchronous programming of realtime systems,â in Proc. Conference on Functional Programming  Languages and Computer Architecture. Springer, 1987, pp.  257â277.  [15] K. Sen and G. RosĚ§u, âGenerating optimal monitors for extended  regular expressions,â in [3].  [16] G. RosĚ§u and K. Havelund, âRewriting-based techniques for runtime veriďŹcation,â Journal of Automated Software Engineering  (to appear).  [17] H. Barringer, A. Goldberg, K. Havelund, and K. Sen, âRulebased runtime veriďŹcation,â in Proc. of 5th International Conference VMCAIâ04, ser. LNCS, vol. 2937. Springer, 2004, pp.  44â57.  [18] âSystem verilog assertion homepage,â 2003, [Online] Available:  http://www.eda.org/sv-ac.  Proceedings of the 12th International Symposium on Temporal Representation and Reasoning (TIMEâ05)  1530-1311/05 $20.00 ÂŠ 2005 IEEE 