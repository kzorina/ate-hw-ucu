L OLA: Runtime Monitoring of Synchronous  Systems  Ben DÃ¢Â€Â™Angelo Ã¢ÂˆÂ—  Sriram Sankaranarayanan  Bernd Finkbeiner Ã¢Â€  Henny B. Sipma Ã¢ÂˆÂ—  Ã¢ÂˆÂ—  CeÄšÂsar SaÄšÂnchez Ã¢ÂˆÂ—  Sandeep Mehrotra Ã¢Â€Ä„  Will Robinson  Zohar Manna  Ã¢ÂˆÂ—  Ã¢ÂˆÂ—  Ã¢ÂˆÂ—  Computer Science Department, Stanford University, Stanford, CA 94305  {bdangelo,srirams,cesar,sipma,manna}@theory.stanford.edu  Ã¢Â€  Department of Computer Science, Saarland University  finkbeiner@cs.uni-sb.de  AbstractÃ¢Â€Â” We present a speciÄÅ¹Âcation language and algorithms for the online and ofÄÅ¹Â‚ine monitoring of synchronous  systems including circuits and embedded systems. Such  monitoring is useful not only for testing, but also under  actual deployment. The speciÄÅ¹Âcation language is simple  and expressive; it can describe both correctness/failure  assertions along with interesting statistical measures that  are useful for system proÄÅ¹Âling and coverage analysis.  The algorithm for online monitoring of queries in this  language follows a partial evaluation strategy: it incrementally constructs output streams from input streams,  while maintaining a store of partially evaluated expressions  for forward references. We identify a class of speciÄÅ¹Âcations, characterized syntactically, for which the algorithmÃ¢Â€Â™s  memory requirement is independent of the length of the  input streams. Being able to bound memory requirements  is especially important in online monitoring of large input  streams. We extend the concepts used in the online algorithm to construct an efÄÅ¹Âcient ofÄÅ¹Â‚ine monitoring algorithm  for large traces.  We have implemented our algorithm and applied it to  two industrial systems, the PCI bus protocol and a memory  controller. The results demonstrate that our algorithms are  practical and that our speciÄÅ¹Âcation language is sufÄÅ¹Âciently  expressive to handle speciÄÅ¹Âcations of interest to industry.  I. I NTRODUCTION  Monitoring synchronous programs for safety and liveness properties is an important aspect of ensuring their  proper runtime behavior. An ofÄÅ¹Â‚ine monitor analyzes  traces of a system post-simulation to spot violations of  This research was supported in part by NSF grants CCR-0121403, CCR-02-20134, CCR-02-09237, CNS-0411363, and CCF0430102, by ARO grant DAAD19-01-1-0723, by NAVY/ONR contract N00014-03-1-0939, by the Siebel Graduate Fellowship, and by  the BMBF grant 01 IS C38 B as part of the Verisoft project.  Ã¢Â€Ä„  Synopsys, Inc.  the speciÄÅ¹Âcation. OfÄÅ¹Â‚ine monitoring is critical for testing  large systems before deployment. An online monitor  processes the system trace while it is being generated.  Online monitoring is used to detect violations of the  speciÄÅ¹Âcation when the system is in operation so that  they can be handled before they translate into observable  and cascading failures, and to adaptively optimize system  performance.  Runtime monitoring has received growing attention in  recent years [1], [2], [3]. While static veriÄÅ¹Âcation intends  to show that every (inÄÅ¹Ânite) run of a system satisÄÅ¹Âes  the speciÄÅ¹Âcation, runtime monitoring is concerned only  with a single (ÄÅ¹Ânite) trace. Runtime monitoring can be  viewed as an extension of testing with more powerful  speciÄÅ¹Âcation languages.  The ofÄÅ¹Â‚ine monitoring problem is known to be easy  for purely past or purely future properties. It is well  known that for past properties, the online monitoring  problem can be solved efÄÅ¹Âciently using constant space  and linear time in the trace size. For future properties, on  the other hand, the space requirement generally depends  on the length of the trace, which suggests that online  monitoring may quickly become intractable in practical  applications with traces exceeding 106 simulation steps.  In this paper, we present a speciÄÅ¹Âcation language,  intended for industrial use. The language can express  properties involving both the past and the future. It is a  functional stream computation language like L USTRE [4]  and E STEREL [5], with features that are relevant to our  problem at hand. It is parsimonious in its number of  operators (expressions are constructed from three basic  operators), but the resulting expressiveness surpasses  temporal logics and many other existing formalisms  Proceedings of the 12th International Symposium on Temporal Representation and Reasoning (TIMEÃ¢Â€Â™05)  1530-1311/05 $20.00 Ã‚Å  2005 IEEE  including ÄÅ¹Ânite-state automata.  We provide a syntactic characterization of efÄÅ¹Âciently  monitorable speciÄÅ¹Âcations, for which the space requirement of the online monitoring algorithm is independent  of the size of the trace, and linear in the speciÄÅ¹Âcation  size. An analysis of some industrial speciÄÅ¹Âcations provided by Synopsys, Inc. showed that a large majority  of these speciÄÅ¹Âcations lie in this efÄÅ¹Âciently monitorable  class. For the ofÄÅ¹Â‚ine monitoring problem, we demonstrate an efÄÅ¹Âcient monitoring strategy in the presence of  mixed past/future properties.  We have implemented our algorithm and speciÄÅ¹Âcation  language in a system called L OLA. L OLA accepts a  speciÄÅ¹Âcation in the form of a set of stream expressions,  and is then run on a set of input streams. Two types  of speciÄÅ¹Âcations are supported: properties that specify  correct behavior, and properties that specify statistical  measures that allow proÄÅ¹Âling the system that produces  the input streams. An execution of L OLA computes  arithmetic and logical expressions over the ÄÅ¹Ânite input  and intermediate streams to produce an output consisting  of error reports and the desired statistical information.  A. Related Work  Much of the initial work on runtime monitoring (cf.  [6], [7], [8]) was based on temporal logic [9]. In [10],  non-deterministic automata are built from LTL to check  violations of formulas over ÄÅ¹Ânite traces and the complexity of these problems is studied. LTL based speciÄÅ¹Âcations  have already been pursued in tools such as the Temporal  Rover [7] and Java PathExplorer [11]. One limitation of  this approach is that the logic must be adapted to handle  truncated traces. The approach taken in [12] considers  extensions of LTL for the case of truncated paths with  different interpretations (weak and strong) of the next  operator at the end of the trace. The choice of handling  success/failure on a ÄÅ¹Ânite trace frequently depends on  the situation being modeled.  Another important difference between runtime veriÄÅ¹Âcation and static veriÄÅ¹Âcation is that liveness properties  can never be violated on a ÄÅ¹Ânite trace. An appealing  solution is to extend the speciÄÅ¹Âcation language to compute quantitative measures based on the trace. Temporal  properties can be speciÄÅ¹Âed in L OLA, but one of the  main goals is to go beyond property checking to the  collection of numerical statistics. For example, instead  of checking the property Ã¢Â€Âœthere are only ÄÅ¹Ânitely many  retransmissions of each package,Ã¢Â€Â which is vacuously  true over ÄÅ¹Ânite traces, we desire to evaluate queries like  Ã¢Â€Âœwhat is the average number of retransmissions.Ã¢Â€Â Our  ÄÅ¹Ârst approach to combine the property proving with data  collection appeared in [13]. Following this trend, runtime veriÄÅ¹Âers can be used not only for bug-ÄÅ¹Ânding, but  also for proÄÅ¹Âling, coverage, vacuity and numerous other  analyses.  L OLA models runtime veriÄÅ¹Âcation as a stream computation. The deÄÅ¹Ânition of L OLA output streams in  terms of other streams resembles synchronous programming languages (notably L USTRE [4], E STEREL [5],  Signal [14]), but there is a signiÄÅ¹Âcant difference: these  languages are designed primarily for the construction of  synchronous systems. Therefore, output values for a time  instant are computed directly from values at the same and  previous instants. This assumption makes perfect sense  if we desire that the systems we specify be executable,  and therefore be causal. However, runtime speciÄÅ¹Âcations  are descriptive in nature. They include future formulas  whose evaluation may have to be delayed until future  values arrive. This requires stronger expressiveness in the  language and the corresponding evaluation strategies.  Other efforts in run-time veriÄÅ¹Âcation include [15],  which studies the efÄÅ¹Âcient generation of monitors from  speciÄÅ¹Âcations written as extended regular expressions,  and [16], which studies rewriting techniques for the  efÄÅ¹Âcient evaluation of LTL formulas on ÄÅ¹Ânite execution  traces, both online and ofÄÅ¹Â‚ine. In [8], an efÄÅ¹Âcient method  for the online evaluation of past LTL properties is  presented. This method exploits that past LTL can be  recursively deÄÅ¹Âned using only values in the previous  state of the computation. Our efÄÅ¹Âciently monitorable  speciÄÅ¹Âcations generalize this idea, and apply it uniformly  to both veriÄÅ¹Âcation and data collection.  The system that most closely resembles L OLA is  Eagle [17]. Eagle allows the description of monitors  based on greatest and least ÄÅ¹Âxed points of recursive  deÄÅ¹Ânitions. Many logical formalisms used to describe  properties, including past and future LTL formulas, can  be translated to Eagle speciÄÅ¹Âcations. These are then  compiled into a set of rules that implements the monitor.  L OLA differs from Eagle in the descriptive nature of the  language, and in that L OLA is not restricted to checking  logical formulas, but can also express numerical queries.  II. L OLA OVERVIEW  In this section we describe the speciÄÅ¹Âcation language.  The monitoring algorithms will be presented in Section III.  A. SpeciÄÅ¹Âcation Language: Syntax  A L OLA speciÄÅ¹Âcation describes the computation of  output streams from a given set of input streams. A  Proceedings of the 12th International Symposium on Temporal Representation and Reasoning (TIMEÃ¢Â€Â™05)  1530-1311/05 $20.00 Ã‚Å  2005 IEEE  stream ÄÂƒ of type T is a ÄÅ¹Ânite sequence of values from  T . We let ÄÂƒ(i), i Ã¢Â‰Ä½ 0 denote the value of the stream at  time step i.  DeÄÅ¹Ânition 1 (L OLA speciÄÅ¹Âcation) A L OLA speciÄÅ¹Âcation is a set of equations over typed stream variables,  of the form  s1  ..  .  = e1 (t1 , . . . , tm , s1 , . . . , sn )  ..  .  sn = en (t1 , . . . , tm , s1 , . . . , sn ),  where s1 , . . . , sn are called the dependent variables  and t1 , . . . , tm are called the independent variables,  and e1 , . . . , en are stream expressions over s1 , . . . , sn  and t1 , . . . , tm . Independent variables refer to input  streams and dependent variables refer to output streamsÃ¢ÂˆÂ— .  A L OLA speciÄÅ¹Âcation can also declare certain output  boolean variables as triggers. Triggers generate notiÄÅ¹Âcations at instants when their corresponding values become  true . Triggers are speciÄÅ¹Âed in L OLA as  trigger ÄÂ•  where ÄÂ• is a boolan expression over streams.  A stream expression is constructed as follows:  Ã¢Â€Ë˜ If c is a constant of type T , then c is an atomic  stream expression of type T ;  Ã¢Â€Ë˜ If s is a stream variable of type T , then s is an  atomic stream expression of type T ;  Ã¢Â€Ë˜ Let f : T1 Ä‚Â—T2 Ä‚Â—Ã‚Ë‡ Ã‚Ë‡ Ã‚Ë‡Ä‚Â—Tk Ã¢Â†Â’ T be a k -ary operator.  If for 1 Ã¢Â‰Â¤ i Ã¢Â‰Â¤ k , ei is an expression of type Ti , then  f (e1 , . . . , ek ) is a stream expression of type T ;  Ã¢Â€Ë˜ If b is a boolean stream expression and e1 , e2 are  stream expressions of type T , then ite(b, e1 , e2 )  is a stream expression of type T ; note that ite  abbreviates if-then-else.  Ã¢Â€Ë˜ If e is a stream expression of type T , c is a constant  of type T , and i is an integer, then e[i, c] is a stream  expression of type T . Informally, e[i, c] refers to the  value of the expression e offset i positions from the  current position. The constant c indicates the default  value to be provided, in case an offset of i takes us  past the end or before the beginning of the stream.  Ã¢ÂˆÂ—  In our implementation we partition the dependent variables into  output variables and intermediate variables to distinguish streams that  are of interest to the user and those that are used only to facilitate  the computation of other streams. However, for the description of  the semantics and the algorithm this distinction is not important, and  hence we will ignore it in this paper.  Example 1 Let t1 , t2 be stream variables of type  boolean and t3 be a stream variable of type integer. The  following is an example of a L OLA speciÄÅ¹Âcation with  t1 , t2 and t3 as independent variables:  s1  s2  s3  s4  s5  s6  s7  s8  s9  s10  =  =  =  =  =  =  =  =  =  =  true  t3  t1 Ã¢ÂˆÂ¨ (t3 Ã¢Â‰Â¤ 1)  ((t3 )2 + 7) mod 15  ite(s3 , s4 , s4 + 1)  ite(t1 , t3 Ã¢Â‰Â¤ s4 , Ã‚Å¹s3 )  t1 [+1, false]  t1 [Ã¢ÂˆÂ’1, true]  s9 [Ã¢ÂˆÂ’1, 0] + (t3 mod 2)  t2 Ã¢ÂˆÂ¨ (t1 Ã¢ÂˆÂ§ s10 [1, true])  Stream variable s1 denotes a stream whose value is  true at all positions, while s2 denotes a stream whose  values are the same at all positions as those in t3 . The  values of the streams corresponding to s3 , . . . , s6 are  obtained by evaluating their deÄÅ¹Âning expressions placewise at each position. The stream corresponding to s7  is obtained by taking at each position i the value of  the stream corresponding to t1 at position i + 1, except  at the last position, which assumes the default value  false. Similarly for the stream for s8 , whose values are  equal to the values of the stream for t1 shifted by one  position, except that the value at the ÄÅ¹Ârst position is the  default value true. The stream speciÄÅ¹Âed by s9 counts  the number of odd entries in the stream assigned to t3 by  accumulating (t3 mod 2). Finally, s10 denotes the stream  that gives at each position the value of the temporal  formula t1 Until t2 with the stipulation that unresolved  eventualities be regarded as satisÄÅ¹Âed at the end of the  trace.  B. SpeciÄÅ¹Âcation Language: Semantics  The semantics of L OLA speciÄÅ¹Âcations is deÄÅ¹Âned in  terms of evaluation models, which describe the relation  between input streams and output streams.  DeÄÅ¹Ânition 2 (Evaluation Models) Let ÄÂ• be a L OLA  speciÄÅ¹Âcation over independent variables t1 , . . . , tm with  types T1 , . . . , Tm , and dependent variables s1 , . . . , sn  with types Tm+1 , . . . , Tm+n . Let ÄÂ„1 , . . . , ÄÂ„m be streams  of length N +1, with ÄÂ„i of type Ti . The tuple ÄÂƒ1 , . . . , ÄÂƒn   of streams of length N + 1 with appropriate types is  called an evaluation model, if for each equation in ÄÂ•  si = ei (t1 , . . . , tm , s1 , . . . , sn ),  ÄÂƒ1 , . . . , ÄÂƒn  satisÄÅ¹Âes the following associated equations:  ÄÂƒi (j) = val (ei )(j)  Proceedings of the 12th International Symposium on Temporal Representation and Reasoning (TIMEÃ¢Â€Â™05)  1530-1311/05 $20.00 Ã‚Å  2005 IEEE  for 0 Ã¢Â‰Â¤ j Ã¢Â‰Â¤ N  where val (e)(j) is deÄÅ¹Âned as follows. For the base cases:  val (c)(j) = c .  val (ti )(j) = ÄÂ„i (j) .  val (si )(j) = ÄÂƒi (j) .  For the inductive cases:  val (f (e1 , . . . , ek )(j) =  f (val (e1 )(j), . . . , val (ek )(j)) .  val (ite(b, e1 , e2 ))(j) =  if val (b)(j) then val (e1 )(j) else val (e2 )(j) .  val (e[k,   c])(j) =  val (e)(j + k) if 0 Ã¢Â‰Â¤ j + k Ã¢Â‰Â¤ N,  c  otherwise .  The set of all equations associated with ÄÂ• is denoted by  ÄÂ•ÄÂƒ .  Example 2 Consider the L OLA speciÄÅ¹Âcation  ÄÂ• : s = t1 [1, 0] + ite(t2 [Ã¢ÂˆÂ’1, true], t3 , t4 + t5 ).  The associated equations ÄÂ•ÄÂƒ are  ÄÅÅ›  ÄÅÅ¤  ÄÅÄ…  (j  Ã¢ÂˆÂ’  1),  ÄÂ„  ÄÅÂ´  2  ÄÅÂ´  ÄÅÂ´  ÄÅË‡  ÄÅÅ¹  ÄÅÂ´  ÄÅÂ´  ÄÂ„1 (j + 1) + ite ÄÅÂ­ ÄÂ„3 (j),  ÄÅÂ¸ j Ã¢ÂˆÂˆ [1, N ),  ÄÅÂ´  ÄÅÂ´  ÄÅÂ´  ÄÅÂ´  ÄÅÂ´  ÄÂ„4 (j) + ÄÂ„5 (j)  ÄÅË›  ÄÅÅ›  ÄÅÅ¤  ÄÂƒ(j) =  ÄÂ„2 (N Ã¢ÂˆÂ’ 1),  ÄÅÂ´  ÄÅË‡  ÄÅÅ¹  ÄÅÂ´  ÄÅÂ´  j = N,  ite ÄÅÂ­ ÄÂ„3 (N ),  ÄÅÂ¸  ÄÅÂ´  ÄÅÂ´  ÄÅÂ´  ÄÅÂ´  ÄÅÂ´  ÄÂ„  (N  )  +  ÄÂ„  (N  )  ÄÅÂ´  4  5  ÄÅÂ´  ÄÅÅ‚  j = 0.  ÄÂ„1 (1) + ÄÂ„3 (0)  A L OLA speciÄÅ¹Âcation is well-deÄÅ¹Âned if for any set of  appropriately typed input streams, all of the same length,  it has exactly one evaluation model.  Example 3 Consider the L OLA speciÄÅ¹Âcation  ÄÂ•1 : s1 = (t1 Ã¢Â‰Â¤ 10).  For the stream ÄÂ„1 : 0, . . . , 100, the associated equations  are ÄÂƒ1 (j) = (ÄÂ„1 (j) Ã¢Â‰Â¤ 10). The only evaluation model  of ÄÂ•1 is the stream ÄÂƒ1 (i) = true iff i Ã¢Â‰Â¤ 10. In fact,  this L OLA speciÄÅ¹Âcation is well-deÄÅ¹Âned, since it deÄÅ¹Ânes  a unique output for each possible input. However, the  speciÄÅ¹Âcation  ÄÂ•2 : s2 = s2 Ã¢ÂˆÂ§ (t1 Ã¢Â‰Â¤ 10)  is not well-deÄÅ¹Âned, because there are many streams ÄÂƒ2  that satisfy ÄÂ•2,ÄÂƒ for some input stream. Similarly, the  speciÄÅ¹Âcation  ÄÂ•3 : s3 = Ã‚Å¹s3  is not well-deÄÅ¹Âned, but for this speciÄÅ¹Âcation the reason  is that it has no evaluation models.  To avoid ill-deÄÅ¹Âned speciÄÅ¹Âcations we deÄÅ¹Âne a syntactic restriction on L OLA speciÄÅ¹Âcations guaranteeing that  any well-formed L OLA expression is also well-deÄÅ¹Âned.  DeÄÅ¹Ânition 3 (Dependency Graph) Let ÄÂ• be a L OLA  speciÄÅ¹Âcation. A dependency graph for ÄÂ• is a weighted  and directed multi-graph G = V, E, with vertex set  V = {s1 , . . . , sn , t1 , . . . , tm }. An edge e : si , sk , w  labeled with a weight w is in E iff the equation for  ÄÂƒi (j) in ÄÂ•ÄÂƒ contains ÄÂƒk (j + w) as a subexpression of  the RHS, for some j (or e : si , tk , w for subexpression  ÄÂ„k (j +w)). Intuitively, the edge records the fact that si at  a particular position depends on the value of sk , offset  by w positions. Note that there can be multiple edges  between si and sk with different weights on each edge.  Vertices labeled by ti do not have outgoing edges.  Example 4 Consider the L OLA speciÄÅ¹Âcation over independent integer variables t1 , t2 :  ÄÅÅ›  ÄÅÅ¤  s2 [Ã¢ÂˆÂ’1, 7] Ã¢Â‰Â¤ t1 [1, 0],  ÄÅÂ¸.  s1 = s2 [1, 0] + ite ÄÅÂ­ s2 [Ã¢ÂˆÂ’1, 0],  s2  s2 = (s1 + t2 [Ã¢ÂˆÂ’2, 1]).  Its dependency graph, shown in Figure 1, has three edges  from s1 to s2 , with weights 1, 0, Ã¢ÂˆÂ’1, and one zero  weighted edge from s2 back to s1 . There is one edge  from s1 to t1 , and one from s2 to t2 .  A walk of a graph is a sequence v1 , . . . , vk+1 of  vertices, for k Ã¢Â‰Ä½ 1, and edges e1 , . . . , ek , such that  ei : vi , vi+1 , wi . The walk is closed iff v1 = vk+1 .  The total weight of a walk is the sum of weights of its  edges.  DeÄÅ¹Ânition 4 (Well-Formed SpeciÄÅ¹Âcations) A L OLA  speciÄÅ¹Âcation is well-formed if there is no closed-walk  with total weight zero in its dependency graph.  Theorem 1 Every well-formed L OLA speciÄÅ¹Âcation is  well-deÄÅ¹Âned.  All proofs will be available in an extended version of this  document. The following alternative characterization of  well-formedness is useful for algorithmic purposes and  for the ofÄÅ¹Â‚ine monitoring algorithm.  Proceedings of the 12th International Symposium on Temporal Representation and Reasoning (TIMEÃ¢Â€Â™05)  1530-1311/05 $20.00 Ã‚Å  2005 IEEE  @ABC  GFED  t1 o  1  @ABC  GFED  s1 l  1,0,Ã¢ÂˆÂ’1  , GFED  @ABC  s  2  Ã¢ÂˆÂ’2  0  @ABC  / GFED  t2  Fig. 1: Dependency graph for the speciÄÅ¹Âcation of Example 4.  Theorem 2 A L OLA speciÄÅ¹Âcation is well-formed iff no  strongly connected component in G has both a positive  and a negative weighted cycle.  The converse of Theorem 1 is not true: not every welldeÄÅ¹Âned L OLA speciÄÅ¹Âcation need be well-formed. For  instance, the speciÄÅ¹Âcation s = s Ã¢ÂˆÂ§ Ã‚Å¹s is well-deÄÅ¹Âned,  but not well-formed.  C. Statistics and Context-free Properties  We shall now demonstrate the use of our speciÄÅ¹Âcation  language for computing statistical properties over trace  data. Numerical properties over traces are essential as  (1) components of correctness properties that involve  counts, maxima or minima over trace data, and (2)  estimating performance and coverage metrics in the form  of averages.  L OLA can be used to compute incremental statistics,  i.e., measures that are deÄÅ¹Âned using an update function  fÃÄ… (v, u) where u represents the measure thus far, and  v represents the new incoming data. Given a sequence  of values v1 , . . . , vn , with a special default value d, the  statistic over the data is deÄÅ¹Âned in the reverse sense as  v = fÃÄ… (v1 , fÃÄ… (v2 , . . . , fÃÄ… (vn , d)))  or in the forward sense as  v = fÃÄ… (vn , fÃÄ… (vnÃ¢ÂˆÂ’1 , . . . , fÃÄ… (v1 , d)))  Examples of such statistical measures include count with  fcount (v, u) = u+1, sum with fsum (v, u) = v +u, max  with fmax (u, v) = max (u, v), among many others; the  statistical average can be incrementally deÄÅ¹Âned as a pair  consisting of the sum and the count.  Given an update function fÃÄ… and a data-stream v ,  the following L OLA queries compute the statistic in the  forward and reverse senses respectively:  stat f = fÃÄ… (stat f [Ã¢ÂˆÂ’1, d], v) ,  stat r = fÃÄ… (stat r [1, d], v) .  For most common incremental statistical measures, either of these L OLA queries compute the same result.  The choice of a monitoring strategy can dictate the use  of one over another as will be evident in the subsequent  section.  The use of numeric data also increases the expressiveness of the language; it enables the expression of  context-free properties. Commonly encountered contextfree properties include properties such as Ã¢Â€Âœevery request  has a matching grant.Ã¢Â€Â In programs, we may use such  properties to verify that every lock acquired has been released, or that every memory cell allocated is eventually  freed exactly once.  Example 5 Consider the property: Ã¢Â€Âœthe number of aÃ¢Â€Â™s  must always be no less than the number of bÃ¢Â€Â™s.Ã¢Â€Â This  property can be expressed in L OLA as  s = s[Ã¢ÂˆÂ’1, 0] + ite((a Ã¢ÂˆÂ§ Ã‚Å¹b), 1, 0)  + ite((b Ã¢ÂˆÂ§ Ã‚Å¹a), Ã¢ÂˆÂ’1, 0)  trigger(s Ã¢Â‰Â¤ 0)  Integer streams in a L OLA speciÄÅ¹Âcation enable the  expression of context-free properties by being used as  counters to model stacks. For instance, a two alphabet  stack with alphabet symbols 0 and 1 can be modelled  by a counter. Each pop is implemented by dividing the  counter by 2, thereby eliminating the least signiÄÅ¹Âcant bit.  Each push is modelled by a multiplication by 2 followed  by addition, thereby setting the least signiÄÅ¹Âcant bit. Thus,  with one (unbounded) counter, a L OLA speciÄÅ¹Âcation can  express context-free properties.  It can be shown that L OLA speciÄÅ¹Âcations with only  boolean streams cannot express context-free properties.  III. M ONITORING A LGORITHM  In this section, we ÄÅ¹Ârst describe the setting for  the monitoring problem considered in the paper. We  then describe our monitoring algorithm using partial  evaluation of the equational semantics.  A. Monitoring Setup  We distinguish two situations for monitoring Ã¢Â€Â” online  and ofÄÅ¹Â‚ine monitoring. With online monitoring, system  behaviors are observed as the system is run under a  test/real-life setting. In a simulation setting, we can  assume that the monitor is working in tandem with  the simulator, with the monitor processing a few trace  positions while the simulator waits, and then the monitor  waiting while the simulation proceeds to produce the  Proceedings of the 12th International Symposium on Temporal Representation and Reasoning (TIMEÃ¢Â€Â™05)  1530-1311/05 $20.00 Ã‚Å  2005 IEEE  next few positions. On the other hand, ofÄÅ¹Â‚ine monitoring  assumes that the system has been run to completion,  and the trace data was dumped to a storage device. This  leads to the following restriction for online monitoring:  the traces are available a few points at a time starting  from time 0 onwards, and need to be processed online to  make way for more incoming data. In particular, random  access to the traces is not available.  B. Online Monitoring Algorithm  In online monitoring we assume that the trace is  available one position at a time, starting from time 0.  The length of the trace is assumed to be unknown and  large.  Let t1 , . . . , tm be independent (input) stream variables,  and s1 , . . . , sn be dependent (output) stream variables.  Let j Ã¢Â‰Ä½ 0 be the current position where the latest trace  data is available from all the input streams.  Evaluation Algorithm: The evaluation algorithm  maintains two stores of equations:  Ã¢Â€Ë˜ Resolved equations R of the form ÄÂƒi (j) = c, or  ÄÂ„i (j) = c, for constant c.  Ã¢Â€Ë˜ Unresolved equations U of the form ÄÂƒi (j) = ei for  all other stream expressions ei .  Initially both stores are empty. At the arrival of input  stream data for a particular position j , 0 Ã¢Â‰Â¤ j Ã¢Â‰Â¤ N ,  that is, when ÄÂ„1 (j), . . . , ÄÂ„m (j) become available, the  following steps are carried out:  1) The equations ÄÂ„1 (j) = c1 , . . . , ÄÂ„m (j) = cm are  added to R,  2) The associated equations for ÄÂƒ1 (j), . . . , ÄÂƒn (j) are  added to U ,  3) The equations in U are simpliÄÅ¹Âed as much as  possible; if an equation becomes of the form  ÄÂƒi (j) = c, it is removed from U and added to R. If  c is true and the corresponding output variable si  is marked as a trigger, then a violation is reported.  4) For each stream ti ( also si ), there is a non-negative  constant ki such that ÄÂ„i (j Ã¢ÂˆÂ’ki ), if present in R can  be safely removed. The constant ki Ã¢Â‰Ä½ 0 is deÄÅ¹Âned  as    k is non-negative and  .  ki = max k  ti [Ã¢ÂˆÂ’k, d] is a subexpression.  Intuitively, for any position j , j + ki is the latest  value in the future whose computation requires the  value of ÄÂ„i (j).  Example 6 To illustrate the last point, consider the  speciÄÅ¹Âcation,  s = s[Ã¢ÂˆÂ’3, 0] + t.  Let ÄÂ„ be the input stream. The value of ki for s is 3  and for t is zero. This indicates that for any input stream  ÄÂ„ , the value ÄÂ„ (j) can be removed from R at position j  itself. Similarly any ÄÂƒ(j) Ã¢ÂˆÂˆ R may be removed from R  at (or after) position j + 3.  Equations in U are simpliÄÅ¹Âed using the following  rules:  1) Partial evaluation rules for function applications  such as,  true Ã¢ÂˆÂ§ e Ã¢Â†Â’ e, 0 + x Ã¢Â†Â’ x Ã‚Ë‡ Ã‚Ë‡ Ã‚Ë‡  2) Rewrite rules for if-then,  ite(true, e1 , e2 ) Ã¢Â†Â’ e1 Ã‚Ë‡ Ã‚Ë‡ Ã‚Ë‡  3) Substitution of resolved positions from R. If  ÄÂƒi (j) = c Ã¢ÂˆÂˆ R, then every occurrence of ÄÂƒi (j)  in U is substituted by c and possibly simpliÄÅ¹Âed  further.  We illustrate the operation of the algorithm on a simple  example.  Example 7 Let t1 , t2 be two input boolean stream variables. Consider the speciÄÅ¹Âcation  ÄÂ• : s = t2 Ã¢ÂˆÂ¨ (t1 Ã¢ÂˆÂ§ s[1, false]),  which computes t1 Until t2 . The associated equations  for ÄÂ• are:    ÄÂ„2 (j) Ã¢ÂˆÂ¨ (ÄÂ„1 (j) Ã¢ÂˆÂ§ ÄÂƒ(j + 1)) j + 1 Ã¢Â‰Â¤ N  ÄÂƒ(j) =  otherwise.  ÄÂ„2 (j)  Let the input streams, ÄÂ„1 and ÄÂ„2 be given by  ÄÂ„1  ÄÂ„2  false  true  false  false  true  false  true  false  true  false  true  false  true  false  At position 0, we encounter false, true. The equation for ÄÂƒ(0) is  ÄÂƒ(0)  = ÄÂ„2 (0) Ã¢ÂˆÂ¨ (ÄÂ„1 (0) Ã¢ÂˆÂ§ ÄÂƒ(1))  Ã¢Â†Â’ true Ã¢ÂˆÂ¨ (false Ã¢ÂˆÂ§ ÄÂƒ(1))  Ã¢Â†Â’ true  and thus ÄÂƒ(0) = true is added to the resolved store R.  At position 1, we encounter false, false and thus we  can set ÄÂƒ(1) = false , which is also added to R. From  j = 2 until j = 5, we encounter true, false. At each of  these positions the equations ÄÂƒ(j) = ÄÂƒ(j + 1) are added  to U . The equation store U now has the equations  ÄÂƒ(2) = ÄÂƒ(3), ÄÂƒ(3) = ÄÂƒ(4), . . . , ÄÂƒ(5) = ÄÂƒ(6).  Proceedings of the 12th International Symposium on Temporal Representation and Reasoning (TIMEÃ¢Â€Â™05)  1530-1311/05 $20.00 Ã‚Å  2005 IEEE  At position 6, we encounter true, false with the added  information that the trace has ended. We set ÄÂƒ(6) = false  and add it to R. This lets us resolve the equations in U  and set all the positions from 2 to 6 to false .  Note that the equation associated with ÄÂƒi (j) on the  LHS is added only after the current position reaches  j , even if the term ÄÂƒi (j) appears on the RHS of some  equation before position j is reached.  The algorithm above works in time and space that  is linear in the length of the trace and the size of the  speciÄÅ¹Âcation. Since the memory usage can be as large  as the length of the trace in the worst-case, the method  may not work for long simulations and large traces.  Example 8 Consider the following L OLA speciÄÅ¹Âcation:  ended = false[1, true]  s = ite(ended , t, s[1, true])  in which the output stream ÄÂƒ takes the same value  everywhere that the input stream ÄÂ„ takes at the end of  the trace. The partial evaluation algorithm maintains the  unresolved ÄÂƒ(0), . . . , ÄÂƒ(N ). Such speciÄÅ¹Âcations cannot  be monitored efÄÅ¹Âciently. Furthermore, if the variable  s appears in other expressions, the evaluation of the  corresponding streams need to be delayed until ÄÂƒ can  be resolved.  In the next section we characterize an efÄÅ¹Âciently monitorable set of L OLA speciÄÅ¹Âcations based on the properties of their dependency graphs. The partial evaluation  algorithm will be shown to work efÄÅ¹Âciently for such  speciÄÅ¹Âcations.  C. EfÄÅ¹Âciently Monitorable SpeciÄÅ¹Âcations  We present a class of speciÄÅ¹Âcations that are efÄÅ¹Âciently  monitorable. These speciÄÅ¹Âcations are guaranteed to limit  the number of unresolved equations in the memory to a  pre-determined constant that depends only on the size of  the speciÄÅ¹Âcation and not on the size of the trace.  DeÄÅ¹Ânition 5 (EfÄÅ¹Âciently Monitorable SpeciÄÅ¹Âcations)  A L OLA speciÄÅ¹Âcation is efÄÅ¹Âciently monitorable (EM) if  its worst case memory requirement under our online  monitoring algorithm is constant in the size of the trace.  Example 9 Consider the speciÄÅ¹Âcation Ã¢Â€ÂœEvery request  must be eventually followed by a grant before the trace  endsÃ¢Â€Â, which can be expressed as follows:  reqgrant = ite(request, evgrant, true)  evgrant = grant Ã¢ÂˆÂ¨ evgrant[1, false]  trigger (Ã‚Å¹ reqgrant)  The speciÄÅ¹Âcation encodes the temporal assertion  (request Ã¢Â†Â’ Ã¢Â™Åš(grant)). Another way that produces  the same result is    waitgrant =    Ã‚Å¹grant Ã¢ÂˆÂ§  request Ã¢ÂˆÂ¨  waitgrant[Ã¢ÂˆÂ’1, false]     trigger ended Ã¢ÂˆÂ§ waitgrant  The stream waitgrant records if the monitor is currently  waiting for a grant. The monitor waits for a grant  whenever it encounters a request and stops waiting if  there is a grant . If the trace ends while the monitor is  still waiting, it triggers an error. The latter formulation  is efÄÅ¹Âciently monitorable, while the former is not. For  instance, at every time instance, waitgrant(i) is instantly  resolved given its previous value, and those of the input  streams. Thus, the simple partial evaluation algorithm  monitors the latter with very little, constant, buffering.  The following theorem characterizes efÄÅ¹Âciently monitorable L OLA speciÄÅ¹Âcations.  Theorem 3 If the dependency graph of a L OLA query  has no positive cycles then it is efÄÅ¹Âciently monitorable.  The converse of the theorem above does not hold  in general. However, in the absence of an alternative  syntactic characterization of EM speciÄÅ¹Âcation, we shall  henceforth use the term EM speciÄÅ¹Âcation to denote  queries whose dependency graphs do not contain positive  cycles.  Given graph G, that does not have any positive weight  cycles, we construct a graph G+ , obtained by removing  all negative weight edges from G. Furthermore, among  all the edges in G between two nodes si and sj , we  choose to add only that edge to G+ which has the  maximum positive weight. The graph G+ has no self  loops or multiple edges, and hence is a weighted directed  acyclic graph (DAG). For each node si Ã¢ÂˆÂˆ G+ , we deÄÅ¹Âne  Ã¢ÂˆÂ†i as follows:  ÄÅÄ…  ,  ÄÅÂ´  ÄÅË›0, if there is no outgoing edge from si  w(ej )  Ã¢ÂˆÂ†i =  ej : si Ã¢ÂˆÂ’Ã¢ÂˆÂ’Ã¢ÂˆÂ’Ã¢Â†Â’ sj  ÄÅÂ´  , ow .  ÄÅÅ‚max Ã¢ÂˆÂ†j + w(ej )  is an edge in G+  Example  tion:  s1  s2  s3  10 Consider the following L OLA speciÄÅ¹Âca= t1 [1, false] Ã¢ÂˆÂ§ s3 [Ã¢ÂˆÂ’7, false]  = ite(s1 [2, true], t2 [2, 0], t2 [Ã¢ÂˆÂ’1, 2])  = (s2 [4, true] Ã¢Â‰Â¤ 5)  The dependency graph G is shown in Figure 2. The  values of the Ã¢ÂˆÂ† function are as follows:  Ã¢ÂˆÂ†(t1 ) = Ã¢ÂˆÂ†(t2 ) = 0, Ã¢ÂˆÂ†(s1 ) = 1, Ã¢ÂˆÂ†(s2 ) = 3, Ã¢ÂˆÂ†(s3 ) = 7.  Proceedings of the 12th International Symposium on Temporal Representation and Reasoning (TIMEÃ¢Â€Â™05)  1530-1311/05 $20.00 Ã‚Å  2005 IEEE  Ã¢ÂˆÂ’7  @ABC  GFED  s3  v  4  @ABC  / GFED  s2  2  2,Ã¢ÂˆÂ’1    @ABC  GFED  t2  @ABC  / GFED  s1  1    @ABC  GFED  t1  (a) Dependency graph G.  @ABC  GFED  s3  4  @ABC  / GFED  s2  2  2    @ABC  GFED  t2  @ABC  / GFED  s1  1    @ABC  GFED  t1  (b) Derived graph G+ .  Fig. 2: The dependency graph G for Example 10 and its derived graph G+ .  The signiÄÅ¹Âcance of the Ã¢ÂˆÂ† function is clear through the  following theorem.  Theorem 4 The partial evaluation algorithm resolves  any trace position ÄÂƒi (j) before time j + Ã¢ÂˆÂ†i .  The memory requirement is therefore constant in N  for an efÄÅ¹Âcient speciÄÅ¹Âcation. This number of unresolved  positions in U is upper-bounded by O(Ã¢ÂˆÂ†1 + Ã‚Ë‡ Ã‚Ë‡ Ã‚Ë‡ + Ã¢ÂˆÂ†n ).  For instance, computing the Ã¢ÂˆÂ† values for the queries  in Example 9, we ÄÅ¹Ând that Ã¢ÂˆÂ†(waitgrant) = 0. This  shows that the value of waitgrant resolves immediately,  given its previous value and the inputs. Our experimental  results in the subsequent section show that requiring  speciÄÅ¹Âcations to be efÄÅ¹Âciently monitorable is not unreasonable in practice. Furthermore, streams involved  in positive cycles can be discarded or even rewritten  (as shown in Example 9) for the purposes of online  monitoring.  The framework developed generalizes naturally to an  ofÄÅ¹Â‚ine monitoring algorithm. Please refer to the full  version of this paper available online.  IV. A PPLICATIONS  There are numerous applications of this formalism. In  this section, we describe two such applications obtained  directly from the industry. Synopsys, Inc. provided some  circuit simulation dumps, along with speciÄÅ¹Âcations written in the industry standard System Verilog Assertions  (SVA)[18]. We were able to hand-translate the SVA  queries directly into L OLA speciÄÅ¹Âcations, a process that  is potentially mechanizable.  Our OC AML-based implementation of L OLA reads a  trace ÄÅ¹Âle and the speciÄÅ¹Âcation ÄÅ¹Âle. It implements the  online monitoring algorithm described in Section III with  some direct optimizations. We have incorporated facilities for displaying dependency graphs of speciÄÅ¹Âcations.  The following two case studies were considered:  a) Memory Controller: A Verilog model for a  memory controller was simulated yielding 13 input  streams. The corresponding SVA assertions were handtranslated into a L OLA speciÄÅ¹Âcation. The speciÄÅ¹Âcation  had 21 intermediate streams and 15 output streams, all  of which were declared triggers. Properties enforced  included mutual exclusion of signals, correct transfers of  address and data, and timing speciÄÅ¹Âcations (e.g. signal  stability for 3 or 4 cycles). The speciÄÅ¹Âcations were not  EM : the dependency graph had three positive-sum cycles,  each encoding a temporal until operator. Figure 3 shows  the performance of L OLA on these traces.  b) PCI: We hand translated SVA assertions describing the PCI 2.2 speciÄÅ¹Âcations for the master. A circuit  implementing the master was simulated for varying times  to produce a set of traces to plot the performance. The  speciÄÅ¹Âcation had 15 input streams, 161 output streams  and 87 trigger streams. Our initial implementation contained three positive weight cycles. We were able to  remove these by rewriting the queries carefully. Running  times can also be found in Figure 3. Bugs were deliberately introduced into the circuit in order to evaluate  the effectiveness of runtime veriÄÅ¹Âcation. L OLA reports  numerous useful trigger violations for the longest trace.  V. C ONCLUSIONS  We have presented L OLA, a formalism for runtime  veriÄÅ¹Âcation based on a functional language over ÄÅ¹Ânite streams equipped with a partial evaluation-based  strategy for online evaluation. Our formalism combines  runtime veriÄÅ¹Âcation of boolean temporal speciÄÅ¹Âcations  with statistical measures to estimate coverage and specify  complex temporal patterns. By evaluating our system on  industrial strength speciÄÅ¹Âcations, we have demonstrated  that L OLA can express relevant properties. Using dependency graphs, we have characterized efÄÅ¹Âciently monitorable queries that can be monitored online efÄÅ¹Âciently  in terms of space. Based on our case-studies so far, the  restriction to efÄÅ¹Âciently monitorable speciÄÅ¹Âcations seems  Proceedings of the 12th International Symposium on Temporal Representation and Reasoning (TIMEÃ¢Â€Â™05)  1530-1311/05 $20.00 Ã‚Å  2005 IEEE  # simulation steps  5000  10000  20000  50000  100000  200000  500000  1000000  Controller example  # clock pos. edges time (sec)  250  0.18  500  0.35  1000  0.71  2500  1.78  5000  3.47  10000  6.83  25000  17.02  50000  33.70  PCI example  # clock pos. edges  834  1667  3334  8334  16667  33334  83334  166667  time  4.62  8.87  19.04  29.47  52.53  99.17  236.96  467.98  Fig. 3: Running times for both examples. All timings were measured on an Intel Xeon Processor running Linux  2.4 with 2Gb RAM.  practical.  In the future, we intend to study automatic techniques  for rewriting non-EM speciÄÅ¹Âcations into efÄÅ¹Âciently monitorable ones where possible, and in further collaboration  with industry study the applicability of these techniques  for larger case studies. We expect that for such use  some syntactic sugar needs to be added to L OLA to  facilitate speciÄÅ¹Âcation of common constructs. Also the  error reporting needs to be improved by synthesizing  explanations for each violation. Extensions to handle  synchronous systems with many clocks, asynchronous  systems, and distributed systems are also under consideration.  R EFERENCES  [1] K. Havelund and G. RosÄšÂ§u, Eds., Runtime VeriÄÅ¹Âcation 2001  (RVÃ¢Â€Â™01), ser. ENTCS, vol. 55. Elsevier, 2001.  [2] Ã¢Â€Â”Ã¢Â€Â”, Runtime VeriÄÅ¹Âcation 2002 (RVÃ¢Â€Â™02), ser. ENTCS, vol. 70,  no. 4. Elsevier, 2002.  [3] O. Sokolsky and M. Viswanathan, Eds., Runtime VeriÄÅ¹Âcation  2002 (RVÃ¢Â€Â™03), ser. ENTCS, vol. 89, no. 2. Elsevier, 2003.  [4] N. Halbwachs, P. Caspi, P. Raymond, and D. Pilaud, Ã¢Â€ÂœThe  synchronous data-ÄÅ¹Â‚ow programming language LUSTRE,Ã¢Â€Â Proc.  of IEEE, vol. 79, no. 9, pp. 1305Ã¢Â€Â“1320, 1991.  [5] G. Berry, Proof, language, and interaction: essays in honour  of Robin Milner. MIT Press, 2000, ch. The foundations of  Esterel, pp. 425Ã¢Â€Â“454.  [6] I. Lee, S. Kannan, M. Kim, O. Sokolsky, and M. Viswanathan,  Ã¢Â€ÂœRuntime Assurance Based on Formal SpeciÄÅ¹Âcations,Ã¢Â€Â in Proc.  of the International Conference on Parallel and Distributed  Processing Techniques and Applications, 1999.  [7] D. Drusinsky, Ã¢Â€ÂœThe temporal rover and the ATG rover,Ã¢Â€Â in SPIN  Model Cheking and Software VeriÄÅ¹Âcation, 2000, pp. 323Ã¢Â€Â“330.  [8] K. Havelund and G. RosÄšÂ§u, Ã¢Â€ÂœSynthesizing monitors for safety  properties,Ã¢Â€Â in Proc. of TACASÃ¢Â€Â™02. Springer, 2002, pp. 342Ã¢Â€Â“  356.  [9] Z. Manna and A. Pnueli, Temporal VeriÄÅ¹Âcation of Reactive  Systems: Safety. New York: Springer, 1995.  [10] O. Kupferman and M. Y. Vardi, Ã¢Â€ÂœModel checking of safety  properties,Ã¢Â€Â Formal Methods in System Design, vol. 19, no. 3,  pp. 291Ã¢Â€Â“314, 2001.  [11] K. Havelund and G. RosÄšÂ§u, Ã¢Â€ÂœAn overview of the runtime  veriÄÅ¹Âcation tool java pathexplorer,Ã¢Â€Â Formal Methods for Systems  Design, vol. 24, no. 2, pp. 189Ã¢Â€Â“215, 2004.  [12] C. Eisner, D. Fisman, J. Havlicek, Y. Lustig, A. McIsaac,  and D. V. Campenhout, Ã¢Â€ÂœReasoning with temporal logic on  truncated paths,Ã¢Â€Â in Proc. of CAVÃ¢Â€Â™03, ser. LNCS, vol. 2725.  Springer, 2003, pp. 27Ã¢Â€Â“39.  [13] B. Finkbeiner, S. Sankaranarayanan, and H. B. Sipma, Ã¢Â€ÂœCollecting statistics over runtime executions,Ã¢Â€Â in [2].  [14] T. Gautier, P. Le Guernic, and L. Besnard, Ã¢Â€ÂœSIGNAL: A  declarative language for synchronous programming of realtime systems,Ã¢Â€Â in Proc. Conference on Functional Programming  Languages and Computer Architecture. Springer, 1987, pp.  257Ã¢Â€Â“277.  [15] K. Sen and G. RosÄšÂ§u, Ã¢Â€ÂœGenerating optimal monitors for extended  regular expressions,Ã¢Â€Â in [3].  [16] G. RosÄšÂ§u and K. Havelund, Ã¢Â€ÂœRewriting-based techniques for runtime veriÄÅ¹Âcation,Ã¢Â€Â Journal of Automated Software Engineering  (to appear).  [17] H. Barringer, A. Goldberg, K. Havelund, and K. Sen, Ã¢Â€ÂœRulebased runtime veriÄÅ¹Âcation,Ã¢Â€Â in Proc. of 5th International Conference VMCAIÃ¢Â€Â™04, ser. LNCS, vol. 2937. Springer, 2004, pp.  44Ã¢Â€Â“57.  [18] Ã¢Â€ÂœSystem verilog assertion homepage,Ã¢Â€Â 2003, [Online] Available:  http://www.eda.org/sv-ac.  Proceedings of the 12th International Symposium on Temporal Representation and Reasoning (TIMEÃ¢Â€Â™05)  1530-1311/05 $20.00 Ã‚Å  2005 IEEE 