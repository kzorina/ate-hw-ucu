A Finite-State Approach to Event Semantics  Tim Fernando  Computer Science Department  Trinity College, Dublin 2, Ireland  Tim.Fernando@cs.tcd.ie  Abstract  Events employed in natural language semantics are  characterized in terms of regular languages, each string in  which can be regarded as a motion picture. The relevant  finite automata then amount to movie cameras/projectors,  or more formally, to finite Kripke structures with partial valuations. The usual regular constructs (concatenation, choice, etc) are supplemented with superposition of  strings/automata/languages, realized model-theoretically  as conjunction.  (i) a (finite, 2-pointed) frame N, A, 0, 1 to be a finite set  N of nodes, a set A Ã¢ÂŠÂ† N Ä‚Â— N of arcs, and distinguished nodes 0 and 1 (which often but not always are  the numbers 0 and 1 ordinarily denote), and  (ii) a (ÃÅš-)event-automaton E to be a frame NE , AE ,  0E , 1E and labeling function lE : NE Ã¢Â†Â’ Pow(ÃÅš) that  maps a node n Ã¢ÂˆÂˆ NE to a set lE (n) Ã¢ÂŠÂ† ÃÅš of formulas.  To illustrate, the very rudimentary picture (2) of  die(Romeo) is provided by the event-automaton  {0, 1}, {(0, 1)}, 0, 1, l where dom(l) = {0, 1},  l(0) = {alive(Romeo)} and l(1) = {dead(Romeo)}.  alive(Romeo) Ã¢ÂˆÂ’Ã¢Â†Â’ dead(Romeo)  1. Introduction  (2)  Due in no small measure to [2], events of some form or  another have become a common tool for semantically analyzing expressions of change in English (e.g. [15, 6, 9]).  Under this approach, a sentence such as (1) is taken to describe an event of Mary swimming a mile, culminating in  the past.  Alternative analyses of die(Romeo) are, of course, possible,  the idea being to  (1) Mary swam a mile.  The language L(E) of E is  Such events are formulated below as runs of machines that  collectively constitute a causal order around which to explain temporality in natural language ([11, 18]). Similar  ideas have been developed in [19, 13, 12, 17, 5], the distinctive feature of the present proposal being the use of a finite  automaton for a declarative representation (as opposed to  a procedural implementation) of a fragment of a first-order  model. That fragment is given by strings accepted by the  automaton Ã¢Â€Â” that is to say, by motion pictures taken by  a movie camera (or, passing from accepting to generating  devices, by films played by a movie projector).  2. Event-types as automata/languages  Formally, it is convenient to present the relevant automata as Kripke models over some finite set ÃÅš of formulas  (roughly the propositional fluents in [10]), defining  (i) generalize (0, 1) to a path 0 Ã‚Ë‡ Ã‚Ë‡ Ã‚Ë‡ 1 from 0 to 1, and  (ii) label a node n on that path by a set of formulas (true at  n).  L(E) = {lE (0E ) Ã‚Ë‡ Ã‚Ë‡ Ã‚Ë‡ lE (1E ) | 0E Ã‚Ë‡ Ã‚Ë‡ Ã‚Ë‡ 1E Ã¢ÂˆÂˆ Path(E)}  where Path(E) consists of strings n1 Ã‚Ë‡ Ã‚Ë‡ Ã‚Ë‡ nk Ã¢ÂˆÂˆ NE + such  that n1 = 0E , nk = 1E and (ni , ni+1 ) Ã¢ÂˆÂˆ AE for 1 Ã¢Â‰Â¤ i <  k. Clearly, L(E) is just the language accepted by the finite  automaton with initial node START Ã¢ÂˆÂˆ NE , accepting node  1E , and labeled transitions  lE (m)  n Ã¢ÂˆÂ’Ã¢Â†Â’ m for (n, m) Ã¢ÂˆÂˆ AE  lE (0E )  plus START Ã¢ÂˆÂ’Ã¢Â†Â’ 0E . (That is, the finite automaton for E  is obtained by moving node labels over to arcs that point to  the node, throwing in an extra node START to point to 0E .)  Conversely, an obvious limitation on an event-automaton E  is that it accepts only non-empty strings, any two of which  begin with the same symbol and end with the same symbol.  This limitation can be overcome by permitting the empty  Proceedings of the Ninth International Symposium on Temporal Representation and Reasoning (TIMEÃ¢Â€Â™02)  1530-1311/02 $17.00 Ã‚Å  2002 IEEE  string to label 0E and/or 1E , so as to implement nondeterministic choice + as follows.  E  E + E  =  [ ]        E    [ ]  As it turns out, it suffices to allow lE (0E ) = lE (1E ) = in  order to capture all regular languages.  Proposition 1. For every regular language L Ã¢ÂŠÂ† Pow(ÃÅš)Ã¢ÂˆÂ— ,  there is a finite set E[L] of ÃÅš-event-automata, the sum of  which accepts the non-empty strings in L    LÃ¢ÂˆÂ’{ } =  L(E) .  EÃ¢ÂˆÂˆE[L]  Proof. Working with regular expressions L, we define E[L]  by induction. Let E[L + L ] be E[L] Ã¢ÂˆÅ E[L ], and E[LL ] be  {EE  | E Ã¢ÂˆÂˆ E[L], E  Ã¢ÂˆÂˆ E[L ]} unioned with E[L] if Ã¢ÂˆÂˆ L  and/or E[L ] if Ã¢ÂˆÂˆ L (defining EE  in the obvious way).  As for LÃ¢ÂˆÂ— , form  N = {(n, E) | E Ã¢ÂˆÂˆ E[L], n Ã¢ÂˆÂˆ NE }  A = {((n, E), (m, E)) | E Ã¢ÂˆÂˆ E[L], (n, m) Ã¢ÂˆÂˆ AE }  Ã¢ÂˆÅ {((1E , E), (0E  , E  )) | E, E  Ã¢ÂˆÂˆ E[L]}  l(n, E) = lE (n)  and set E[LÃ¢ÂˆÂ— ] = {N, A, (0E , E), (1E , E), l | E Ã¢ÂˆÂˆ E[L]}.    2.1. Moens-Steedman and the Vendler classes  Applying [11], let 0 and 1 be preparatory and consequent  states respectively, and let a durative event(-type) E come  with an inceptive event E i and a culminative event E c , the  consequent state of E i being the preparatory state of E c ,  termed the progressive state pE of E  pE  = 1E i = 0 E c .  Extracting a loop pE Ã¢Â†Â’ pE from the equality 1E i = 0E c  and taking 0E = 0E i and 1E = 1E c , we get the transitions  AE  = 0 E Ã¢Â†Â’ p E Ã¢Â†Â’ p E Ã¢Â†Â’ 1E .  From this, VendlerÃ¢Â€Â™s well-known aspectual classifications  drop out once pE is related to 1E and 0E . For activities E  like Ã¢Â€Âœswim,Ã¢Â€Â pE = 1E inasmuch as every subtransition of a  swim counts as a swim. By contrast, for accomplishments  E such as Ã¢Â€Âœswim a mile,Ã¢Â€Â no proper subtransition from 0E  can end at 1E . (This is the Ã¢Â€ÂœdirectedÃ¢Â€Â analog of quantization  [9]). The contrasting factive entailments of activities  Mary was swimming  |= Mary swam  and accomplishments  Mary was swimming a mile  |= Mary swam a mile  can then be linked to the test: is pE = 1E ? Identifying statives E with the equations 0E = pE = 1E , the oddness (or  markedness) of the progressive form of stative verbs might  be blamed on the equality of progressive and simple forms  (making the progressive operator, as it were, semantically  redundant) or, focusing on 0E , the lack of progress from 0E  (insofar as 0E = 1E ). Pushing this line further, let pE = 0E  for achievements E such as Ã¢Â€ÂœwinÃ¢Â€Â and Ã¢Â€Âœbegin,Ã¢Â€Â reducing  the difference between achievements and accomplishments  mentioned, for example, in [6], pp 560-561, to whether or  not pE = 0E (pE = 1E holding in neither case).  Path(E)  01+  0p+ 1  1+  0+ 1  Vendler-class(E)  activity  accomplishment  stative [0 = 1]  achievement  pE = 1E  +  Ã¢ÂˆÂ’  +  Ã¢ÂˆÂ’  pE = 0 E  Ã¢ÂˆÂ’  Ã¢ÂˆÂ’  +  +  Table 1. A first stab.  Is Table 1 faithful to a reading of 0E and 1E as the  preparatory and consequent states of E? Do we want to  confuse the progressive state of Ã¢Â€ÂœswimmingÃ¢Â€Â with the consequent state for Ã¢Â€Âœhave swumÃ¢Â€Â? The answer to both questions must surely be: no. Which is not to say that Table  1 is all wrong. But rather that it ought to be re-interpreted  with the identifications Ã¢Â€Â˜0=preparatoryÃ¢Â€Â™ and Ã¢Â€Â˜1=consequentÃ¢Â€Â™  relaxed. Table 1 gives only a partial picture Ã¢Â€Â” namely,  that concerning some formula ÄÂ• expressing culmination  of (an event-occurrence of type) E. Indeed, the entries  01+ and 0+ 1 in Table 1 are reminiscent of the constructs  Con-BEC(ÄÂ•) and Min-BEC(ÄÂ•) in [13], where the Vendler  classes are characterized by binary features [Ã‚Ä… for] and [Ã‚Ä…  Prog] that Table 1 interprets according to (3).  (3) E is [+ for] iff pE = 1E .  E is [+ Prog] iff pE = 0E .  (3) leaves out the labeling lE that turns a frame into a Kripke  model, suggesting that aspectual properties we ascribe to E  might be reducible to the frame of E.  2.2. Framing and/or simulating aspect?  Testing the hypothesis that aspect can be confined to  frames calls for a fuller account of aspect than that offered  by Table 1. [19] provides an elegant analysis of aspect,  with arcs in a frame beefed up to arrows ([20]). Most (if  not all) the ideas in [19] can, I suspect, be reformulated in  terms of event-automata, with a single arrow blown up to a  (sub)frame (of a monster frame). To my knowledge, such  Proceedings of the Ninth International Symposium on Temporal Representation and Reasoning (TIMEÃ¢Â€Â™02)  1530-1311/02 $17.00 Ã‚Å  2002 IEEE  a reformulation has yet to be carried out, or shown conclusively to be impossible (or a step backwards). Whether or  not [19] provides, on balance, evidence for the reducibility  of aspect to frames (be they irreducibly populated by arrows  or not), I think it is fair to describe the focus of [19] as being  a frame (drawn there as figure 12, page 98) wherein to locate certain formulas (written there ÄÂ•, Cl(ÄÂ•), P f (ÄÂ•), etc).  The attention paid to the frame is well-deserved inasmuch  as it fleshes out a temporal ontology for aspect, with arrows  for the progressive, the perfect, etc.  Further afield, Ã¢Â€Âœan active computational representation  for verb semantics called x-schemasÃ¢Â€Â is presented in [1]  that analyzes aspect Ã¢Â€Âœin terms of the context-sensitive interaction between verb-specific x-schemas and a controller  x-schema that captures important regularities in the evolution of events.Ã¢Â€Â The controller x-schema goes beyond the  temporal ontology of [19] in recognizing points at which  events are suspended, resumed, etc. Indeed, x-schemas go  beyond much of formal natural language semantics in offering a cognitive processing picture with Ã¢Â€Âœsimulative inference,Ã¢Â€Â as opposed to a model-theoretic account oriented  around (not so much a mind that processes language as) an  external reality that language describes. That said, there is  a growing appreciation within model-theoretic semantics of  the importance of cognitive considerations (e.g. [18, 5]). A  model-theoretic account that says nothing about cognitive  mechanisms can hardly be a complete theory of language.  But this does not render the admittedly incomplete pictures  offered by traditional model-theoretic analyses irrelevant.  If programming languages have denotational semantics distinct from their operational semantics, why not natural languages? It is precisely to understand what computational  accounts such as [12] come to Ã¢Â€Â” and the proliferation of  concurrency models suggests there are bound to be many  such accounts Ã¢Â€Â” that one abstracts away as much of their  computational details as one can usefully get away with.  (Exactly what is useful is, alas, a matter of taste.)  Getting back to the specifics at hand, we have from page  9 of [18] the following claim:  aspectual categories like activity and accomplishment are ways of viewing a happenning, rather  than intrinsic properties of verbs and associated  propositions, or of objective reality and the external world.  Keeping in mind the motion picture-camera/projector  metaphor previously mentioned, it is natural to associate  (i) Ã¢Â€Âœways of viewingÃ¢Â€Â with an event-automaton E (or,  more narrowly, the frame of E)  and, on the other hand,  (ii) the Ã¢Â€Âœassociated propositions,Ã¢Â€Â Ã¢Â€Âœobjective reality and  the external worldÃ¢Â€Â with what E is about.  But what is E about? Notice that Table 1 falls short of a  model-theoretic analysis of say, [Ã‚Ä… for] and [Ã‚Ä… Prog] under  (3). In particular, it is natural to ask: how can we make  precise what information the nodes 1, 0 and p encode in  Table 1? A brief answer is: apply the labeling lE of E to  1, 0 and p. Passing from Path(E) to L(E), our emphasis  shifts from the mechanism E to the description L(E) of  Ã¢Â€Âœthe external worldÃ¢Â€Â that E contributes (as Ã‚Â§3 below spells  out).  2.3. Superposition: from N and Pow(ÃÅš) to Cn  Apart from the usual regular constructs composing finite  automata with each other, the particular alphabet Pow(ÃÅš)  suggests aligning two strings ÃÄ…1 Ã‚Ë‡ Ã‚Ë‡ Ã‚Ë‡ ÃÄ…k and ÃÄ…1 Ã‚Ë‡ Ã‚Ë‡ Ã‚Ë‡ ÃÄ…k of  equal length against each other to form a string  (ÃÄ…1 Ã¢ÂˆÅ ÃÄ…1 ) Ã‚Ë‡ Ã‚Ë‡ Ã‚Ë‡ (ÃÄ…k Ã¢ÂˆÅ ÃÄ…k )  of length k, where the ith-symbol ÃÄ…i Ã¢ÂˆÅ ÃÄ…i is ÃÄ…i and ÃÄ…i superimposed on each other. For instance, taking  ÃÄ…  ÃÄ…1  ÃÄ…2  ÃÄ…3  =  =  =  {swim(Mary)}  {in(Mary,Ireland)}  {in(Mary,IrishSea)}  =  {in(Mary,Wales)} ,  the string ÃÄ…ÃÄ…ÃÄ… portraying Mary swimming can be componentwise superimposed on ÃÄ…1 ÃÄ…2 ÃÄ…3 to give the string  (ÃÄ… Ã¢ÂˆÅ ÃÄ…1 ) (ÃÄ… Ã¢ÂˆÅ ÃÄ…2 ) (ÃÄ… Ã¢ÂˆÅ ÃÄ…3 )  depicting Mary swimming from Ireland to Wales. Now,  stepping from strings up to languages L and L , let  L &Ã¢ÂˆÅ L  = {(ÃÄ…1 Ã¢ÂˆÅ ÃÄ…1 ) Ã‚Ë‡ Ã‚Ë‡ Ã‚Ë‡ (ÃÄ…k Ã¢ÂˆÅ ÃÄ…k ) | k Ã¢Â‰Ä½ 1,  ÃÄ…1 Ã‚Ë‡ Ã‚Ë‡ Ã‚Ë‡ ÃÄ…k Ã¢ÂˆÂˆ L, ÃÄ…1 Ã‚Ë‡ Ã‚Ë‡ Ã‚Ë‡ ÃÄ…k Ã¢ÂˆÂˆ L } ,  while over event automata E and E  , define an eventautomaton E Ä‚Â—Ã¢ÂˆÅ E  by NEÄ‚Â—Ã¢ÂˆÅ E  = NE Ä‚Â— NE  , 0EÄ‚Â—Ã¢ÂˆÅ E  =  (0E , 0E  ), 1EÄ‚Â—Ã¢ÂˆÅ E  = (1E , 1E  ), and  AEÄ‚Â—Ã¢ÂˆÅ E   = {((n, n ), (m, m )) | (n, m) Ã¢ÂˆÂˆ AE  and (n , m ) Ã¢ÂˆÂˆ AE  }  lEÄ‚Â—Ã¢ÂˆÅ E  (n, n ) = lE (n) Ã¢ÂˆÅ lE  (n ) .  E Ä‚Â—Ã¢ÂˆÅ E  is the (unconstrained) concurrent composition of  E and E  , with language  L(E Ä‚Â—Ã¢ÂˆÅ E  ) =  L(E) &Ã¢ÂˆÅ L(E  ) .  But should we be allowed to superimpose any two pictures ÃÄ… and ÃÄ… on each other? If pictures are assumed to be  complete descriptions (as the sets labeling a Kripke model  Proceedings of the Ninth International Symposium on Temporal Representation and Reasoning (TIMEÃ¢Â€Â™02)  1530-1311/02 $17.00 Ã‚Å  2002 IEEE  ordinarily are), then they can be superimposed only on  themselves, suggesting that we restrict the nodes of EÄ‚Â—Ã¢ÂˆÅ E   to the pullback      {(n, n ) Ã¢ÂˆÂˆ NE Ä‚Â— NE  | lE (n) = lE  (n )}.  This restriction, call it P (E, E  ), yields the usual construction intersecting languages L(E) and L(E  )  L(P (E, E  )) =  L(E) Ã¢ÂˆÅ  L(E  ) .  On the other hand, if pictures are understood as incomplete  (as we shall), then some middle ground between E Ä‚Â—Ã¢ÂˆÅ E   and P (E, E  ) might be sought, allowing the superposition of some but not all pairs of pictures. (Take Ã¢Â€Â˜MaryswimmingÃ¢Â€Â™ and Ã¢Â€Â˜two-ticks-of-an-hour clockÃ¢Â€Â™ versus Ã¢Â€Â˜MarysleepingÃ¢Â€Â™ and Ã¢Â€Â˜Mary-wide-awake.Ã¢Â€Â™) Accordingly, let us  weaken the requirement on acceptable node pairs n, n from  lE (n) = lE  (n ) to lE (n)Ã¢ÂˆÅlE  (n ) being, in a precise sense,  legitimate.  To pick out what pictures an event-automaton can frame,  let us henceforth assume ÃÅš comes equipped with a nonempty family Cn Ã¢ÂŠÂ† Pow(ÃÅš) that is Ã¢ÂŠÂ†-closed (ie for all  ÃÄ… Ã¢ÂˆÂˆ Cn, Pow(ÃÄ…) Ã¢ÂŠÂ† Cn), with the intended reading  ÃÄ… Ã¢ÂˆÂˆ Cn  Returning to Ã‚Â§2.1, with an event-automaton E replaced  by a language L, let us define analogs of 0E , pE and 1E as  pictures ÃÄ…(L), ÃÂ´(L) and ÄÂ‰(L) Ã¢ÂŠÂ† Pow(ÃÅš) of the inceptive,  progressive and culminative stages of L given by    ÃÄ…(L) =  {ÄÂƒ1 | ÄÂƒ Ã¢ÂˆÂˆ L}    ÃÂ´(L) =  {ÄÂƒi | i > 1 and ÄÂƒ Ã¢ÂˆÂˆ L with length > i}    ÄÂ‰(L) =  {ÄÂƒi | i Ã¢Â‰Ä½ 1 and ÄÂƒ Ã¢ÂˆÂˆ L with length i}  where ÄÂƒi is the ith-symbol of the infinite string ÄÂƒÃ¢ÂˆÂ…Ã¢ÂˆÂ obtained by concatenating ÄÂƒ to the left of the infinite string Ã¢ÂˆÂ…Ã¢ÂˆÂ  of Ã¢ÂˆÂ…Ã¢Â€Â™s. Next, instead of forming 0E Ã¢Â†Â’ pE Ã¢Â†Â’ pE Ã¢Â†Â’ 1E ,  define the Ã¢Â€ÂœMoens-SteedmanÃ¢Â€Â language  MS(L) =  = (L &Ã¢ÂˆÅ L ) Ã¢ÂˆÅ  Cn+  = {(ÃÄ…1 Ã¢ÂˆÅ ÃÄ…1 ) Ã‚Ë‡ Ã‚Ë‡ Ã‚Ë‡ (ÃÄ…k Ã¢ÂˆÅ ÃÄ…k ) | k Ã¢Â‰Ä½ 1,  ÃÄ…1 Ã‚Ë‡ Ã‚Ë‡ Ã‚Ë‡ ÃÄ…k Ã¢ÂˆÂˆ L, ÃÄ…1 Ã‚Ë‡ Ã‚Ë‡ Ã‚Ë‡ ÃÄ…k Ã¢ÂˆÂˆ L  and ÃÄ…i Ã¢ÂˆÅ ÃÄ…i Ã¢ÂˆÂˆ Cn for 1 Ã¢Â‰Â¤ i Ã¢Â‰Â¤ k}      of &Ã¢ÂˆÅ . As for E Ä‚Â—Ã¢ÂˆÅ E , let E Ä‚Â—Cn E be the restriction of  E Ä‚Â—Ã¢ÂˆÅ E  to the set of nodes  {(n, n ) Ã¢ÂˆÂˆ NE Ä‚Â— NE  | lE (n) Ã¢ÂˆÅ lE  (n ) Ã¢ÂˆÂˆ Cn}  provided this set includes both (0E , 0E  ) and (1E , 1E  );  otherwise, let E Ä‚Â—Cn E  be the event-automaton  {0, 1}, Ã¢ÂˆÂ…, 0, 1, l where l(0) = l(1) = Ã¢Âˆ  with empty language.  Proposition 2. For all event-automata E and E  ,  L(E Ä‚Â—Cn E  ) = L(E) &Cn L(E  ) .  Henceforth, we focus on regular languages over Cn, as opposed to event-automata (linked to these languages according to Propositions 1 and 2). This has a technical advantage  illustrated by the ease in formulating  Proposition 3. For all languages L, L and L Ã¢ÂŠÂ† Pow(ÃÅš)Ã¢ÂˆÂ— ,  ÃÄ…(L) ÃÂ´(L)+ ÄÂ‰(L)  (which differs from Table 1 in yielding strings only with  length Ã¢Â‰Ä½ 3) and in place of (3), let  iff ÃÄ… is consistent/conceivable/a cartoon  for every ÃÄ… Ã¢ÂŠÂ† ÃÅš. Cn induces the refinement  L &Cn L  2.4. Table 1 and (3) revisited with superposition  for(L) =  Ã¢ÂˆÂ… ÄÂ‰(L)+ Ã¢Âˆ  prog(L) =  Ã¢ÂˆÂ… ÃÄ…(L) Ã¢Âˆ  +  where Ã‚Ë‡ is a negation operation on subsets ÃË› of ÃÅš such that  ÃË› Ã¢ÂˆÅ ÃË› Ã¢ÂˆÂˆ Cn and for all ÃÅ‚ Ã¢ÂˆÂˆ Cn,  ÃÅ‚ Ã¢ÂˆÅ ÃË› Ã¢ÂˆÂˆ Cn  or  ÃÅ‚ Ã¢ÂˆÅ ÃË› Ã¢ÂˆÂˆ Cn .  Finally, we turn Table 1 into the definitions  Activ(L) = MS(L) &Cn for(L) &Cn prog(L)  Accmp(L) = MS(L) &Cn forÃ¢ÂˆÂ’ (L) &Cn prog(L)  Stat(L) = MS(L) &Cn for(L) &Cn progÃ¢ÂˆÂ’ (L)  Achie(L) = MS(L) &Cn forÃ¢ÂˆÂ’ (L) &Cn progÃ¢ÂˆÂ’ (L)  where  +  forÃ¢ÂˆÂ’ (L) = Ã¢ÂˆÂ… ÄÂ‰(L) Ã¢Âˆ  progÃ¢ÂˆÂ’ (L) = Ã¢ÂˆÂ… ÃÄ…(L)+ Ã¢ÂˆÂ… .  Having used the function MS to motivate the definitions of  for(L), prog(L), forÃ¢ÂˆÂ’ (L) and progÃ¢ÂˆÂ’ (L), notice that MS  contributes nothing to differentiating v(L) for v Ã¢ÂˆÂˆ {Activ,  Accmp, Stat, Achie}. And instead of defining forÃ¢ÂˆÂ’ (L) and  prog(L) in terms of negation Ã‚Ë‡ on subsets of ÃÅš, we might  specify how a function on languages classifies languages.  Given an arbitrary function f on languages, let us say  (a) L &Cn L = L &Cn L  (i) L is [Ã¢ÂˆÂ’f ] if L&Cn f (L) = Ã¢Âˆ  (b) (L &Cn L ) &Cn L = L &Cn (L &Cn L )  (ii) L is f -acceptable if L&Cn f (L) = Ã¢ÂˆÂ…, and  (c) L &Cn Ã¢ÂˆÂ…+ = L iff L Ã¢ÂŠÂ† Cn+ .  (iii) L is [+f ] if L is f -acceptable and L = L&Cn f (L).  Proceedings of the Ninth International Symposium on Temporal Representation and Reasoning (TIMEÃ¢Â€Â™02)  1530-1311/02 $17.00 Ã‚Å  2002 IEEE  Notice that if L is Activ-acceptable, then L is for- and progacceptable, and Activ(L) is [+ for] and [+ prog]. Similar  remarks can be made about the other v(L)Ã¢Â€Â™s.  Under the definitions above, [+ for] amounts to a sortal/aspectual restriction that Ã¢Â€Â˜forÃ¢Â€Â™ imposes on the verb  phrase with which it combines. (Furthermore, that restriction is treated along the lines of the approach to presupposition in [7], with L satisfying the presuppositions of Ã¢Â€Â˜forÃ¢Â€Â™  precisely if L is [+ for].) Passing again to arbitrary functions f on languages, let us call f Cn-conjunctive if  f (L) =  f (f (L))  f (L) =  f (L) =  f (L) &Cn f (L)  f (L &Cn f (L))  example Ã¢Â€Â” Ã¢Â€Â˜read for an hour,Ã¢Â€Â™ analyzed as  (Ã¢ÂˆÂ… {read}+ ) &Cn for(Ã¢ÂˆÂ… {read}+ ) &Cn  ({time(x)} Ã¢ÂˆÂ…+ {time(y), hour(x, y)})  = {time(x)} {read}+ {read, time(y), hour(x, y)}  with parameters x and y, and restrictions time(x), time(y),  hour(x, y) that we will return to in the next section.  3. Event-tokens and models  for all languages L that are f -acceptable.  Our attention in this section shifts from event-types to  event-tokens, embedded in a model of reality that the formulas in ÃÅš describe. An important part of that model is a  temporal frame (Ot, SÄÂ„ ) consisting of a Ã¢Â€ÂœsuccessorÃ¢Â€Â relation  SÄÂ„ Ã¢ÂŠÂ† Ot Ä‚Â— Ot on a set Ot of Ã¢Â€Âœobservation times.Ã¢Â€Â  Proposition 4.  Examples.  (a) If f is Cn-conjunctive, then for every f -acceptable language L, both f (L) and L&Cn f (L) are [+f ].  (b) Each of Activ, Accmp, Stat, Achie is Cn-conjunctive,  as are the functions sending L to Ã¢ÂˆÂ… ÄÂ‰(L)+ ÄÂ‰(L) and  ÃÄ…(L) ÃÄ…(L)+ Ã¢ÂˆÂ… (which are slight variants of for(L) and  progÃ¢ÂˆÂ’ (L), respectively).  Pausing for an example, consider the following pair from  [1].  (4)  a. She read the book for an hour.  b. She read the book in an hour.  On the surface, (4) poses a challenge to the prohibition  against Ã¢Â€Â˜forÃ¢Â€Â™ and Ã¢Â€Â˜inÃ¢Â€Â™ being able to fill the same holes (ie [+  for]=[Ã¢ÂˆÂ’ in]). But, as pointed out in [1], (4b) entails that Ã¢Â€Â˜she  finished reading the bookÃ¢Â€Â™ whereas (4a) does not. That is,  Ã¢Â€Â˜read the bookÃ¢Â€Â™ amounts in (4a) to Ã¢Â€Â˜read parts of the bookÃ¢Â€Â™  and in (4b) to Ã¢Â€Â˜read the entire book.Ã¢Â€Â™ It is well-known (e.g.  [9, 13]) that the argument of a verb can shape the aspectual property of the verb phrase, so that, in particular, Ã¢Â€Â˜read  parts of the bookÃ¢Â€Â™ is naturally conceptualized as an activity, whereas Ã¢Â€Â˜read the bookÃ¢Â€Â™ (or especially, Ã¢Â€Â˜read the entire  bookÃ¢Â€Â™) is an accomplishment (that culminates with all unread parts of the book consumed). Thus, Ã¢Â€Â˜for an hourÃ¢Â€Â™ combines easily with Ã¢Â€Â˜read parts of the book,Ã¢Â€Â™ while Ã¢Â€Â˜in an hourÃ¢Â€Â™  modifies Ã¢Â€Â˜read the entire book.Ã¢Â€Â™ But what does &Cn have  to do with any of this? Following the widespread use of  conjunction in event semantics, we can apply &Cn to combine not only Ã¢Â€Â˜for an hourÃ¢Â€Â™ with Ã¢Â€Â˜read parts of the bookÃ¢Â€Â™ but  also the argument Ã¢Â€Â˜parts of the bookÃ¢Â€Â™ (or Ã¢Â€Â˜the entire bookÃ¢Â€Â™)  with Ã¢Â€Â˜read.Ã¢Â€Â™ That is, &Cn is offered here as a tool for the  logical investigation that lexical semantics richly deserves  (e.g. [3, 15]). Focusing on time, let us work out a simple  (i) Ot is the set of integers, and SÄÂ„ is the usual successor  (+1) function.  (ii) Ot Ã¢ÂŠÂ† Pow(Pt) Ã¢ÂˆÂ’ {Ã¢ÂˆÂ…} for some set Pt of points linearly  ordered by <ÄÂ„ , and SÄÂ„ is the set of all pairs (t, t ) Ã¢ÂˆÂˆ  Ot Ä‚Â— Ot such that  (Ã¢ÂˆÂ€x Ã¢ÂˆÂˆ t)(Ã¢ÂˆÂ€y Ã¢ÂˆÂˆ t ) x <ÄÂ„ y and  not (Ã¢ÂˆÂƒt Ã¢ÂˆÂˆ Ot) t Ã¢ÂŠÂ† gap(t, t )  where gap(t, t ) is {z Ã¢ÂˆÂˆ Pt Ã¢ÂˆÂ’ (t Ã¢ÂˆÅ t ) | (Ã¢ÂˆÂƒx Ã¢ÂˆÂˆ t)(Ã¢ÂˆÂƒy Ã¢ÂˆÂˆ  t ) x <ÄÂ„ z <ÄÂ„ y}. (The second conjunct excludes  gaps containing observation times, guarding against  insertion anomalies.) More concretely, if Pt is the set   of real numbers, ÃÂ´ is some positive number (fixing  a level of granularity/degree of error-tolerance) and Ot  is the set of non-empty open intervals  o(p, q) =  {r Ã¢ÂˆÂˆ  | p < r < q}  with rational end-points p, q such that q Ã¢ÂˆÂ’ p > ÃÂ´, then  for all o(p, q), o(p , q  ) Ã¢ÂˆÂˆ Ot,  o(p, q) SÄÂ„ o(p , q  ) iff 0 Ã¢Â‰Â¤ p Ã¢ÂˆÂ’ q Ã¢Â‰Â¤ ÃÂ´ .  Note that Ot is countable and SÄÂ„ is not functional.  It will suffice throughout this section to equate an eventtype with a language L Ã¢ÂŠÂ† Cn+ , the strings from which we  anchor in a temporal frame as follows. An event(-token)  of event-type L is a function e from some finite subset  {t1 , t2 , . . . , tk } of Ot to Cn such that  t1 SÄÂ„ t2 SÄÂ„ Ã‚Ë‡ Ã‚Ë‡ Ã‚Ë‡ SÄÂ„ tk  and  e(t1 )e(t2 ) Ã‚Ë‡ Ã‚Ë‡ Ã‚Ë‡ e(tk ) Ã¢ÂˆÂˆ L .  To state that e is an event of event-type L, we write  Proceedings of the Ninth International Symposium on Temporal Representation and Reasoning (TIMEÃ¢Â€Â™02)  1530-1311/02 $17.00 Ã‚Å  2002 IEEE  e:L.  For typical choices of SÄÂ„ , at most one SÄÂ„ -chain can be arranged from a finite subset dom(e) of Ot, whence e picks  out at a unique string in L. Also, the definition of Ã¢Â€Â˜e : LÃ¢Â€Â™  can be relativized to a binary relation SÄÂ„ that depends on L,  but for simplicity, we will leave SÄÂ„ fixed in the background.  Assuming an observation time can occur at most once in an  SÄÂ„ -chain (ie t1 SÄÂ„ t2 SÄÂ„ Ã‚Ë‡ Ã‚Ë‡ Ã‚Ë‡ tk and i = j imply ti = tj ), the  totality of events of event-type L is essentially L&Cn L(SÄÂ„ )  where L(SÄÂ„ ) is the set of finite SÄÂ„ -chains. In general, however, L(SÄÂ„ ) is not a regular language, and the special role  it plays in time-stamping L makes it natural to present an  event as a function whose domain is a finite subset of Ot.  To form a model from events, we must spell out what  contribution an event e makes. A simple answer is that e  contributes the set  Ã¢ÂˆÂ†(e) =  {@(ÄÂ•, t) | t Ã¢ÂˆÂˆ dom(e) and ÄÂ• Ã¢ÂˆÂˆ e(t)}  of formulas, where Ã¢Â€Â˜@(ÄÂ•, t)Ã¢Â€Â™ is some formula saying: ÄÂ•  holds at t. Recalling the formulas time(x), time(y) and  hour(x, y) from the end of section 2, we might equate  @(time(x), t) with Ã¢Â€Â˜x = tÃ¢Â€Â™, @(time(y), t) with Ã¢Â€Â˜y = tÃ¢Â€Â™ and  @(hour(x, y), t) with Ã¢Â€Â˜hour(x, y)Ã¢Â€Â™ (the dependence on t of  hour(x, y) being spurious). By contrast, for read (and many  other ÃÅš-formulas), it is useful to construe @(read,t) as literally the string Ã¢Â€Â˜@(read, t)Ã¢Â€Â™. In view of these differences,  let us partition ÃÅš into three sets  ÃÅš = ÃÅš= Ã¢ÂˆÅ ÃÅšg Ã¢ÂˆÅ ÃÅšl  where ÃÅš= consists of ÃÅš-formulas such as time(x) that translate to equations, ÃÅšg consists of Ã¢Â€ÂœglobalÃ¢Â€Â ÃÅš-formulas such  as hour(x, y) that are independent of t, and ÃÅšl consists of  Ã¢Â€ÂœlocalÃ¢Â€Â ÃÅš-formulas such as read. From ÃÅš= -formulas in e,  we form the substitution  ÃÂ¸e  =  3.1. Lumping events into forcing-conditions  Next, generalizing from event(-token)s to the set Ot (  Cn of partial functions (p, q, . . .) from Ot to Cn, let  be the  partial order on Ot ( Cn comparing information content as  follows  pq  iff dom(p) Ã¢ÂŠÂ† dom(q) and  (Ã¢ÂˆÂ€t Ã¢ÂˆÂˆ dom(p)) p(t) Ã¢ÂŠÂ† q(t) .  (The intuition is that p  q says q is at least as informative  as p.) Given a collection ET of event-types and a partial  function p : Ot ( Cn, let ET(p) be the set of ET-events  -contained in p  ET(p) =  {e | e  p and (Ã¢ÂˆÂƒL Ã¢ÂˆÂˆ ET) e : L} ,  this being the bit of reality ET carves up from p. Fix an  expansion Time = (Ot, SÄÂ„ , . . .) of (Ot, SÄÂ„ ) to the vocabulary (aka signature, language, set of non-logical symbols)  of ÃÅšg so that every ÄÂˆ Ã¢ÂˆÂˆ ÃÅšg can be judged to be true  or false in Time. Also, to extract a model from a partial  function p : Ot ( Cn, we have to be careful about overlapping observation times, which we henceforth assume is  given by a family OÄÂ„ Ã¢ÂŠÂ† Pow(Ot) Ã¢ÂˆÂ’ {Ã¢ÂˆÂ…}. (For example, if  Ot Ã¢ÂŠÂ† Pow(Pt) Ã¢ÂˆÂ’ {Ã¢ÂˆÂ…}, then   OÄÂ„ consists of all non-empty  families T Ã¢ÂŠÂ† Ot such that T = Ã¢ÂˆÂ….) Let  (i) P (ET, Time, OÄÂ„ ) be the set of partial functions p :  Ot ( Cn such that for all e Ã¢ÂˆÂˆ ET(p) and ÄÂˆ Ã¢ÂˆÂˆ Ã¢ÂˆÂ†g (e),  Time |= ÄÂˆ ,  and for all T Ã¢ÂˆÂˆ OÄÂ„ where T Ã¢ÂŠÂ† dom(p),    p(t) Ã¢ÂˆÂˆ Cn  {(x, t) | t Ã¢ÂˆÂˆ dom(e) and time(x) Ã¢ÂˆÂˆ e(t)}  which we then apply to the rest of the ÃÅš-formulas in e to get  Ã¢ÂˆÂ†g (e)  = {ÄÂ•[ÃÂ¸e ] | (Ã¢ÂˆÂƒt Ã¢ÂˆÂˆ dom(e)) ÄÂ• Ã¢ÂˆÂˆ e(t) Ã¢ÂˆÅ  ÃÅšg }  Ã¢ÂˆÂ†l (e)  = {@(ÄÂ•[ÃÂ¸e ], t) | t Ã¢ÂˆÂˆ dom(e) and ÄÂ• Ã¢ÂˆÂˆ e(t) Ã¢ÂˆÅ  ÃÅšl }  with the understanding that ÄÂ•[ÃÂ¸e ] is falsum Ã¢ÂŠÄ½ if ÃÂ¸e is not  functional, else ÄÂ•[ÃÂ¸e ] is ÄÂ• with every variable x Ã¢ÂˆÂˆ dom(ÃÂ¸e )  replaced by ÃÂ¸e (x).1  tÃ¢ÂˆÂˆT  (ii) v(ÃÅš) be the vocabulary consisting of unary relation  symbols @(ÄÂˆ, Ã‚Ë‡) for every ÄÂˆ Ã¢ÂˆÂˆ ÃÅšl (with Ã¢Â€Â˜@(ÄÂ•, t)Ã¢Â€Â™ to  be read: Ã¢Â€Â˜ÄÂ• holds at tÃ¢Â€Â™), and  (iii) fET be the function that maps a partial function p :  Ot ( Cn to    Ã¢ÂˆÂ†l (e) .  fET (p) =  eÃ¢ÂˆÂˆET(p)  1A  substitution pairs variables (or parameters) with terms Ã¢Â€Â” the terms  in this case being observation times. ÃÂ¸e provides a means of binding variables x Ã¢ÂˆÂˆ dom(ÃÂ¸e ) locally to e, allowing multiple instantiations of x to  co-exist (in a model). That is, instead of proliferating alphabetic variants  of an event-type, the event-type is construed as parametric, with x as a  temporal parameter that an event e instantiates as ÃÂ¸e (x). The thematic  arguments of an event-type (e.g. agent, patient) can also be presented as  parameters, provided an event specifies instantiations of these parameters.  For the sake of simplicity, parameters and substitutions are confined here  to observation times.  Let us define a ÃÅš(Time)-model to be an expansion of Time  to the vocabulary v(ÃÅš, Ot) (= v(ÃÅš) Ã¢ÂˆÅ Ot) where the constants t (in Ot) are interpreted as t. (To simplify notation, we do not distinguish between t qua constant, and t  qua semantic interpretation.) Now, given an element pÄšÂ‚ of  P (ET, Time, OÄÂ„ ), how might we build a ÃÅš(Time)-model  that contains ET(pÄšÂ‚)? Allowing for ÃÅš(Time)-models that  Proceedings of the Ninth International Symposium on Temporal Representation and Reasoning (TIMEÃ¢Â€Â™02)  1530-1311/02 $17.00 Ã‚Å  2002 IEEE  may or may not contain events beyond those in ET(pÄšÂ‚), let  us pass from pÄšÂ‚ to a set P Ã¢ÂŠÂ† P (ET, Time, OÄÂ„ ) with least element pÄšÂ‚. (To restrict events to those in ET(pÄšÂ‚), take  P = {pÄšÂ‚}.) Applying the Ã¢Â€ÂœforcingÃ¢Â€Â machinery in, for example, [8],2 let us define a forcing predicate ||Ã¢ÂˆÂ’P (which  we simplify to ||Ã¢ÂˆÂ’) that relates forcing-conditions p Ã¢ÂˆÂˆ P to  v(ÃÅš, Ot)-formulas (closed under Ã‚Å¹, Ã¢ÂˆÂ¨ and Ã¢ÂˆÂƒ) as follows:  (a) A generic set G induces a ÃÅš(Time)-model Time(G)  such that for every v(ÃÅš, Ot)-formula ÄÂ•,  Time(G) |= ÄÂ•  (b) Assuming ÃÅšl and Ot are countable,  p ||Ã¢ÂˆÂ’w ÄÂ•  iff for every generic G s.t. p Ã¢ÂˆÂˆ G,  Time(G) |= ÄÂ• .  (i) basing ||Ã¢ÂˆÂ’ on fET ,  p ||Ã¢ÂˆÂ’ @(ÄÂˆ, t)  iff @(ÄÂˆ, t) Ã¢ÂˆÂˆ fET (p)  for all ÄÂˆ Ã¢ÂˆÂˆ ÃÅšl and t Ã¢ÂˆÂˆ Ot  (ii) confining our search for Ã‚Å¹ÄÂ•-counterexamples to qÃ¢Â€Â™s in  P such that p  q,  p ||Ã¢ÂˆÂ’ Ã‚Å¹ÄÂ• iff not (Ã¢ÂˆÂƒq Ã¢ÂˆÂˆ P ) (p  q and q ||Ã¢ÂˆÂ’ ÄÂ•)  (iii) externalizing Ã¢ÂˆÂ¨ to non-deterministic choice +,  p ||Ã¢ÂˆÂ’ ÄÂ• Ã¢ÂˆÂ¨ ÄÂ•  iff p ||Ã¢ÂˆÂ’ ÄÂ• or p ||Ã¢ÂˆÂ’ ÄÂ•  Forcing-conditions p span the divide between events e Ã¢ÂˆÂˆ  ET(p) and ÃÅš(Time)-models Time(G), for generic G p.  Given P Ã¢ÂŠÂ† P (ET, Time, OÄÂ„ ), let MOD(P ) be the set of  ÃÅš(Time)-models generated by P -generic sets  MOD(P ) = {Time(G) | G is P -generic} ,  and (going down , rather than [as is the case for generic  sets] up), let PET be P with all its ET-events    ET(p) .  PET = P Ã¢ÂˆÅ  pÃ¢ÂˆÂˆP  The following proposition is easily proved.  (iv) restricting Ã¢ÂˆÂƒ to Ot,  p ||Ã¢ÂˆÂ’ Ã¢ÂˆÂƒxÄÂ• iff p ||Ã¢ÂˆÂ’ ÄÂ•[x/t] for some t Ã¢ÂˆÂˆ Ot .  3.2. Between events and worlds  Applied twice, Ã‚Å¹ yields a notion of weak forcing ||Ã¢ÂˆÂ’w  p ||Ã¢ÂˆÂ’w ÄÂ•  iff (Ã¢ÂˆÂƒp Ã¢ÂˆÂˆ G) p ||Ã¢ÂˆÂ’ ÄÂ• .  iff p ||Ã¢ÂˆÂ’ Ã‚Å¹Ã‚Å¹ÄÂ•  that extends ||Ã¢ÂˆÂ’ in a manner that can be characterized by  ÃÅš(Time)-models generated by certain subsets of P . More  specifically, a subset G of P is (P -)generic if for all p, q Ã¢ÂˆÂˆ  P,  (i) whenever p Ã¢ÂˆÂˆ G and q  p, q Ã¢ÂˆÂˆ G  (ii) whenever p, q Ã¢ÂˆÂˆ G, there exists r Ã¢ÂˆÂˆ G such that p  r  and q  r  (iii) for every v(ÃÅš, Ot)-formula ÄÂ•, there exists r Ã¢ÂˆÂˆ G such  that r ||Ã¢ÂˆÂ’ ÄÂ• or r ||Ã¢ÂˆÂ’ Ã‚Å¹ÄÂ•.  Let us record fundamental results explained in [8] as  Fact 5.  2 In the terminology of [8], we get a forcing property P, Ã¢Â‰Â¤, f  (over the  base vocabulary v(ÃÅš) and set Ot of constants) where Ã¢Â‰Â¤ is the restriction  of  to P , and f is a function with domain P mapping p Ã¢ÂˆÂˆ P to f (p) =  fET (p) Ã¢ÂˆÅ {Ã¢Â€Â˜t = tÃ¢Â€Â™ | t Ã¢ÂˆÂˆ Ot}. As our only constants are those from Ot  (no two of which are to be semantically identified), equality is trivial and  is accordingly left out above.    It is perhaps also worth noting that [8] allows infinitary disjunctions ,  which should come in handy for infinitary +. As it is, we can (in line  with a finite-state perspective) limit the forcing-conditions in the present  section to finite functions, provided we do not require that a generic set be  represented by a single forcing-condition.  Proposition 6. If P Ã¢ÂŠÂ† P (ET, Time, OÄÂ„ ), then  PET Ã¢ÂŠÂ†  MOD(PET ) =  P (ET, Time, OÄÂ„ )  MOD(P )  and ||Ã¢ÂˆÂ’P is the restriction of ||Ã¢ÂˆÂ’PET to P .  Why   bother forming PET ? Because in PET , events  e Ã¢ÂˆÂˆ pÃ¢ÂˆÂˆP ET(p) count as forcing-conditions, allowing us  to ask of a v(ÃÅš, Ot)-formula ÄÂ• whether or not e forces ÄÂ•.  But beyond ÄÂ• of the form @(ÄÂˆ, t), what else is there to  Ã¢Â€Â˜e ||Ã¢ÂˆÂ’ ÄÂ•Ã¢Â€Â™? Simplifying notation, let us henceforth assume  P = PET . Observe that for every ET-event e Ã¢ÂˆÂˆ P , ÄÂˆ Ã¢ÂˆÂˆ ÃÅšl  and t Ã¢ÂˆÂˆ Ot,  e ||Ã¢ÂˆÂ’ @(ÄÂˆ, t) iff t Ã¢ÂˆÂˆ dom(e) and ÄÂˆ Ã¢ÂˆÂˆ e(t)  and if ÃÅš is closed under negations Ã¢ÂˆÅº ÄÂˆ (with {ÄÂˆ, Ã¢ÂˆÅº ÄÂˆ} Ã¢ÂˆÂˆ  Cn),  e ||Ã¢ÂˆÂ’ @(Ã¢ÂˆÅº ÄÂˆ, t)  implies  e ||Ã¢ÂˆÂ’ Ã‚Å¹@(ÄÂˆ, t) ,  the converse of which does not, in general, hold. Readers  familiar with [14] might liken the discrepancy here to that  between constructible falsity (Ã¢ÂˆÅº) and intuitionistic negation  (Ã‚Å¹). More specifically, Ã‚Å¹ brings the full space P of forcingconditions into the picture, denying the existence of a extension p of e in P such that p ||Ã¢ÂˆÂ’ @(ÄÂˆ, t), whereas Ã¢ÂˆÅº  requires local, positive evidence e. Indeed, the double negation translation Ã‚Å¹Ã‚Å¹ underlying ||Ã¢ÂˆÂ’w weakens the requirement of local, positive evidence to  e ||Ã¢ÂˆÂ’ Ã‚Å¹Ã‚Å¹ÄÂ•  iff (Ã¢ÂˆÂ€p Ã¢ÂˆÂˆ P s.t. e  p)  (Ã¢ÂˆÂƒq Ã¢ÂˆÂˆ P s.t. p  q) q ||Ã¢ÂˆÂ’ ÄÂ• ,  Proceedings of the Ninth International Symposium on Temporal Representation and Reasoning (TIMEÃ¢Â€Â™02)  1530-1311/02 $17.00 Ã‚Å  2002 IEEE  allowing for the possibility that e ||Ã¢ÂˆÂ’w @(ÄÂˆ, t) but not  e ||Ã¢ÂˆÂ’ @(ÄÂˆ, t). That is, e may not be enough to settle  Ã¢Â€Â˜e ||Ã¢ÂˆÂ’ Ã‚Å¹Ã‚Å¹@(ÄÂˆ, t)Ã¢Â€Â™, although arguably, if e ||Ã¢ÂˆÂ’ Ã‚Å¹Ã‚Å¹ÄÂ•, then,  as e  e Ã¢ÂˆÂˆ P , there is positive evidence q " e in P for ÄÂ•  (except that it alone may not suffice). At stake between Ã¢ÂˆÅº  and Ã‚Å¹ is the distinction between explicit and implicit information. Ã¢Â€Â˜e ||Ã¢ÂˆÂ’ @(Ã¢ÂˆÅº ÄÂˆ, t)Ã¢Â€Â™ says that explicit in e is information for Ã¢ÂˆÅº ÄÂˆ at t, whereas Ã¢Â€Â˜e ||Ã¢ÂˆÂ’ Ã‚Å¹@(ÄÂˆ, t)Ã¢Â€Â™ claims only that  information against ÄÂˆ at t can be inferred from e, possibly  with the aid of P . The question arises: how do we pick P  and/or MOD(P )? I hope to report on this matter elsewhere.  4. Conclusion  The finite-state approach to event semantics above is  presented in two parts: one centered around event-types,  formulated as finite automata, or more abstractly, regular  languages; and the other around event-tokens, grounding  strings from an event-type in a model. The strings are built  from a set ÃÅš of formulas, which correspond to the propositional fluents of [10]. It is natural to ask: where in the  present approach are the situations? Given a generic set G  and a time t Ã¢ÂˆÂˆ Ot, one might expect to reconstruct a situation, understood as Ã¢Â€Âœthe complete state of the universe at an  instant of timeÃ¢Â€Â [10], from the snapshot  {ÄÂ• | (Ã¢ÂˆÂƒp Ã¢ÂˆÂˆ G) p ||Ã¢ÂˆÂ’ @(ÄÂ•, t)}.  Evidently, the presentation above is not oriented around situations. Much more prominent is partiality, embodied in  the first part by Ä‚Â—Cn /&Cn (playing the role of conjunction  in a Davidsonian approach to event modification), and in  the second part by  (linking events to worlds, to give the  pictures in ÃÅš model-theoretic bite).  Speaking of partiality, it bears stressing that the present  approach puts finite automata in the service of declarative,  as opposed to operational, semantics, shying away from details of how language is processed. Despite this limitation,  I do think that  (i) a useful temporal ontology reflecting Ã¢Â€Âœways of viewingÃ¢Â€Â ([18]) can be fashioned from finite automata (perhaps with help from [19, 13]), and that  (ii) the restriction to regular languages ought to have positive consequences for both the representational and inferential aspects of the frame problem ([10]) for natural  language ([18]).  Obviously, there is much work to be done. As to what  has been carried out, I close with the note that it was  conceived as part of a model-theoretic re-interpretation of  propositions-as-types (applied to natural language in [16]),  pushing typed ÃÅ¥-calculi analyses of logical connectives  down to the sub-atomic (lexical) level through finite-state  methods. (The interested reader is referred to the constructive eventuality assumption in [4], Ã‚Â§3.1.)  References  [1] N. Chang, D. Gildea, and S. Narayanan. A dynamic model  of aspectual composition. In Proc. CogSci 98, 1998.  [2] D. Davidson. The logical form of action sentences. In  N. Rescher, editor, The Logic of Decision and Action. University of Pittsburgh Press, 1967.  [3] D. R. Dowty. Word Meaning and Montague Grammar. Reidel, Dordrecht, 1979.  [4] T. Fernando. Conservative generalized quantifiers and presupposition. In Proc. Semantics and Linguistic Theory XI.  Cornell University, 2001.  [5] F. Hamm and M. van Lambalgen.  Event calculus,  nominalization, and the progressive.  Available from  www.semanticsarchive.net, 2000.  [6] H. Kamp and U. Reyle. From Discourse to Logic. Kluwer  Academic Publishers, Dordrecht, 1993.  [7] L. Karttunen. Presupposition and linguistic context. Theoretical Linguistics, pages 181Ã¢Â€Â“194, 1974.  [8] H. J. Keisler. Forcing and the omitting types theorem. In  M. Morley, editor, Studies in Model Theory. The Mathematical Association of America, 1973.  [9] M. Krifka. Nominal reference, temporal constitution and  quantification in event semantics. In R. Bartsch, J. van Benthem, and P. van Emde Boas, editors, Semantics and Contextual Expressions. Foris, Dordrecht, 1989.  [10] J. McCarthy and P. Hayes. Some philosophical problems  from the standpoint of artificial intelligence. In M. Meltzer  and D. Michie, editors, Machine Intelligence 4. Edinburgh  University Press, 1969.  [11] M. Moens and M. Steedman. Temporal ontology and temporal reference. Computational Linguistics, 14:15Ã¢Â€Â“28, 1988.  [12] S. Narayanan. Reasoning about actions in narrative undertanding. In Proceedings of IJCAI Ã¢Â€Â™99. Morgan Kaufmann,  San Francisco, 1999.  [13] R. Naumann. Aspects of changes: a dynamic event semantics. J. Semantics, 18:27Ã¢Â€Â“81, 2001.  [14] D. Nelson. Constructible falsity. J. Symbolic Logic,  14(1):16Ã¢Â€Â“26, 1949.  [15] T. Parsons. Events in the Semantics of English: A Study in  Subatomic Semantics. MIT Press, Cambridge, MA, 1990.  [16] A. Ranta. Type-Theoretical Grammar. Oxford University  Press, Oxford, 1994.  [17] R. Reiter. Narratives as programs. In Principles of Knowlege Representation: Procedings of KR 2000. Morgan Kaufmann, San Francisco, 2000.  [18] M. Steedman. The Productions of Time. Draft, ftp://  ftp.cogsci.ed.ac.uk/pub/steedman/temporality/temporality.ps.gz, July 2000.  [19] S. Tojo. Event, state and process in arrow logic. Minds and  Machines, 9:81Ã¢Â€Â“103, 1999.  [20] J. van Benthem. A note on dunamic arrow logic. In J. van  Eijck and A. Visser, editors, Logic and Information Flow.  MIT Press, Cambridge, MA, 1994.  Proceedings of the Ninth International Symposium on Temporal Representation and Reasoning (TIMEÃ¢Â€Â™02)  1530-1311/02 $17.00 Ã‚Å  2002 IEEE 