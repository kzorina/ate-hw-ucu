A Finite-State Approach to Event Semantics  Tim Fernando  Computer Science Department  Trinity College, Dublin 2, Ireland  Tim.Fernando@cs.tcd.ie  Abstract  Events employed in natural language semantics are  characterized in terms of regular languages, each string in  which can be regarded as a motion picture. The relevant  finite automata then amount to movie cameras/projectors,  or more formally, to finite Kripke structures with partial valuations. The usual regular constructs (concatenation, choice, etc) are supplemented with superposition of  strings/automata/languages, realized model-theoretically  as conjunction.  (i) a (finite, 2-pointed) frame N, A, 0, 1 to be a finite set  N of nodes, a set A â N Ă N of arcs, and distinguished nodes 0 and 1 (which often but not always are  the numbers 0 and 1 ordinarily denote), and  (ii) a (ÎŚ-)event-automaton E to be a frame NE , AE ,  0E , 1E and labeling function lE : NE â Pow(ÎŚ) that  maps a node n â NE to a set lE (n) â ÎŚ of formulas.  To illustrate, the very rudimentary picture (2) of  die(Romeo) is provided by the event-automaton  {0, 1}, {(0, 1)}, 0, 1, l where dom(l) = {0, 1},  l(0) = {alive(Romeo)} and l(1) = {dead(Romeo)}.  alive(Romeo) ââ dead(Romeo)  1. Introduction  (2)  Due in no small measure to [2], events of some form or  another have become a common tool for semantically analyzing expressions of change in English (e.g. [15, 6, 9]).  Under this approach, a sentence such as (1) is taken to describe an event of Mary swimming a mile, culminating in  the past.  Alternative analyses of die(Romeo) are, of course, possible,  the idea being to  (1) Mary swam a mile.  The language L(E) of E is  Such events are formulated below as runs of machines that  collectively constitute a causal order around which to explain temporality in natural language ([11, 18]). Similar  ideas have been developed in [19, 13, 12, 17, 5], the distinctive feature of the present proposal being the use of a finite  automaton for a declarative representation (as opposed to  a procedural implementation) of a fragment of a first-order  model. That fragment is given by strings accepted by the  automaton â that is to say, by motion pictures taken by  a movie camera (or, passing from accepting to generating  devices, by films played by a movie projector).  2. Event-types as automata/languages  Formally, it is convenient to present the relevant automata as Kripke models over some finite set ÎŚ of formulas  (roughly the propositional fluents in [10]), defining  (i) generalize (0, 1) to a path 0 Âˇ Âˇ Âˇ 1 from 0 to 1, and  (ii) label a node n on that path by a set of formulas (true at  n).  L(E) = {lE (0E ) Âˇ Âˇ Âˇ lE (1E ) | 0E Âˇ Âˇ Âˇ 1E â Path(E)}  where Path(E) consists of strings n1 Âˇ Âˇ Âˇ nk â NE + such  that n1 = 0E , nk = 1E and (ni , ni+1 ) â AE for 1 â¤ i <  k. Clearly, L(E) is just the language accepted by the finite  automaton with initial node START â NE , accepting node  1E , and labeled transitions  lE (m)  n ââ m for (n, m) â AE  lE (0E )  plus START ââ 0E . (That is, the finite automaton for E  is obtained by moving node labels over to arcs that point to  the node, throwing in an extra node START to point to 0E .)  Conversely, an obvious limitation on an event-automaton E  is that it accepts only non-empty strings, any two of which  begin with the same symbol and end with the same symbol.  This limitation can be overcome by permitting the empty  Proceedings of the Ninth International Symposium on Temporal Representation and Reasoning (TIMEâ02)  1530-1311/02 $17.00 ÂŠ 2002 IEEE  string to label 0E and/or 1E , so as to implement nondeterministic choice + as follows.  E  E + E  =  [ ]        E    [ ]  As it turns out, it suffices to allow lE (0E ) = lE (1E ) = in  order to capture all regular languages.  Proposition 1. For every regular language L â Pow(ÎŚ)â ,  there is a finite set E[L] of ÎŚ-event-automata, the sum of  which accepts the non-empty strings in L    Lâ{ } =  L(E) .  EâE[L]  Proof. Working with regular expressions L, we define E[L]  by induction. Let E[L + L ] be E[L] âŞ E[L ], and E[LL ] be  {EE  | E â E[L], E  â E[L ]} unioned with E[L] if â L  and/or E[L ] if â L (defining EE  in the obvious way).  As for Lâ , form  N = {(n, E) | E â E[L], n â NE }  A = {((n, E), (m, E)) | E â E[L], (n, m) â AE }  âŞ {((1E , E), (0E  , E  )) | E, E  â E[L]}  l(n, E) = lE (n)  and set E[Lâ ] = {N, A, (0E , E), (1E , E), l | E â E[L]}.    2.1. Moens-Steedman and the Vendler classes  Applying [11], let 0 and 1 be preparatory and consequent  states respectively, and let a durative event(-type) E come  with an inceptive event E i and a culminative event E c , the  consequent state of E i being the preparatory state of E c ,  termed the progressive state pE of E  pE  = 1E i = 0 E c .  Extracting a loop pE â pE from the equality 1E i = 0E c  and taking 0E = 0E i and 1E = 1E c , we get the transitions  AE  = 0 E â p E â p E â 1E .  From this, Vendlerâs well-known aspectual classifications  drop out once pE is related to 1E and 0E . For activities E  like âswim,â pE = 1E inasmuch as every subtransition of a  swim counts as a swim. By contrast, for accomplishments  E such as âswim a mile,â no proper subtransition from 0E  can end at 1E . (This is the âdirectedâ analog of quantization  [9]). The contrasting factive entailments of activities  Mary was swimming  |= Mary swam  and accomplishments  Mary was swimming a mile  |= Mary swam a mile  can then be linked to the test: is pE = 1E ? Identifying statives E with the equations 0E = pE = 1E , the oddness (or  markedness) of the progressive form of stative verbs might  be blamed on the equality of progressive and simple forms  (making the progressive operator, as it were, semantically  redundant) or, focusing on 0E , the lack of progress from 0E  (insofar as 0E = 1E ). Pushing this line further, let pE = 0E  for achievements E such as âwinâ and âbegin,â reducing  the difference between achievements and accomplishments  mentioned, for example, in [6], pp 560-561, to whether or  not pE = 0E (pE = 1E holding in neither case).  Path(E)  01+  0p+ 1  1+  0+ 1  Vendler-class(E)  activity  accomplishment  stative [0 = 1]  achievement  pE = 1E  +  â  +  â  pE = 0 E  â  â  +  +  Table 1. A first stab.  Is Table 1 faithful to a reading of 0E and 1E as the  preparatory and consequent states of E? Do we want to  confuse the progressive state of âswimmingâ with the consequent state for âhave swumâ? The answer to both questions must surely be: no. Which is not to say that Table  1 is all wrong. But rather that it ought to be re-interpreted  with the identifications â0=preparatoryâ and â1=consequentâ  relaxed. Table 1 gives only a partial picture â namely,  that concerning some formula Ď expressing culmination  of (an event-occurrence of type) E. Indeed, the entries  01+ and 0+ 1 in Table 1 are reminiscent of the constructs  Con-BEC(Ď) and Min-BEC(Ď) in [13], where the Vendler  classes are characterized by binary features [Âą for] and [Âą  Prog] that Table 1 interprets according to (3).  (3) E is [+ for] iff pE = 1E .  E is [+ Prog] iff pE = 0E .  (3) leaves out the labeling lE that turns a frame into a Kripke  model, suggesting that aspectual properties we ascribe to E  might be reducible to the frame of E.  2.2. Framing and/or simulating aspect?  Testing the hypothesis that aspect can be confined to  frames calls for a fuller account of aspect than that offered  by Table 1. [19] provides an elegant analysis of aspect,  with arcs in a frame beefed up to arrows ([20]). Most (if  not all) the ideas in [19] can, I suspect, be reformulated in  terms of event-automata, with a single arrow blown up to a  (sub)frame (of a monster frame). To my knowledge, such  Proceedings of the Ninth International Symposium on Temporal Representation and Reasoning (TIMEâ02)  1530-1311/02 $17.00 ÂŠ 2002 IEEE  a reformulation has yet to be carried out, or shown conclusively to be impossible (or a step backwards). Whether or  not [19] provides, on balance, evidence for the reducibility  of aspect to frames (be they irreducibly populated by arrows  or not), I think it is fair to describe the focus of [19] as being  a frame (drawn there as figure 12, page 98) wherein to locate certain formulas (written there Ď, Cl(Ď), P f (Ď), etc).  The attention paid to the frame is well-deserved inasmuch  as it fleshes out a temporal ontology for aspect, with arrows  for the progressive, the perfect, etc.  Further afield, âan active computational representation  for verb semantics called x-schemasâ is presented in [1]  that analyzes aspect âin terms of the context-sensitive interaction between verb-specific x-schemas and a controller  x-schema that captures important regularities in the evolution of events.â The controller x-schema goes beyond the  temporal ontology of [19] in recognizing points at which  events are suspended, resumed, etc. Indeed, x-schemas go  beyond much of formal natural language semantics in offering a cognitive processing picture with âsimulative inference,â as opposed to a model-theoretic account oriented  around (not so much a mind that processes language as) an  external reality that language describes. That said, there is  a growing appreciation within model-theoretic semantics of  the importance of cognitive considerations (e.g. [18, 5]). A  model-theoretic account that says nothing about cognitive  mechanisms can hardly be a complete theory of language.  But this does not render the admittedly incomplete pictures  offered by traditional model-theoretic analyses irrelevant.  If programming languages have denotational semantics distinct from their operational semantics, why not natural languages? It is precisely to understand what computational  accounts such as [12] come to â and the proliferation of  concurrency models suggests there are bound to be many  such accounts â that one abstracts away as much of their  computational details as one can usefully get away with.  (Exactly what is useful is, alas, a matter of taste.)  Getting back to the specifics at hand, we have from page  9 of [18] the following claim:  aspectual categories like activity and accomplishment are ways of viewing a happenning, rather  than intrinsic properties of verbs and associated  propositions, or of objective reality and the external world.  Keeping in mind the motion picture-camera/projector  metaphor previously mentioned, it is natural to associate  (i) âways of viewingâ with an event-automaton E (or,  more narrowly, the frame of E)  and, on the other hand,  (ii) the âassociated propositions,â âobjective reality and  the external worldâ with what E is about.  But what is E about? Notice that Table 1 falls short of a  model-theoretic analysis of say, [Âą for] and [Âą Prog] under  (3). In particular, it is natural to ask: how can we make  precise what information the nodes 1, 0 and p encode in  Table 1? A brief answer is: apply the labeling lE of E to  1, 0 and p. Passing from Path(E) to L(E), our emphasis  shifts from the mechanism E to the description L(E) of  âthe external worldâ that E contributes (as Â§3 below spells  out).  2.3. Superposition: from N and Pow(ÎŚ) to Cn  Apart from the usual regular constructs composing finite  automata with each other, the particular alphabet Pow(ÎŚ)  suggests aligning two strings Îą1 Âˇ Âˇ Âˇ Îąk and Îą1 Âˇ Âˇ Âˇ Îąk of  equal length against each other to form a string  (Îą1 âŞ Îą1 ) Âˇ Âˇ Âˇ (Îąk âŞ Îąk )  of length k, where the ith-symbol Îąi âŞ Îąi is Îąi and Îąi superimposed on each other. For instance, taking  Îą  Îą1  Îą2  Îą3  =  =  =  {swim(Mary)}  {in(Mary,Ireland)}  {in(Mary,IrishSea)}  =  {in(Mary,Wales)} ,  the string ÎąÎąÎą portraying Mary swimming can be componentwise superimposed on Îą1 Îą2 Îą3 to give the string  (Îą âŞ Îą1 ) (Îą âŞ Îą2 ) (Îą âŞ Îą3 )  depicting Mary swimming from Ireland to Wales. Now,  stepping from strings up to languages L and L , let  L &âŞ L  = {(Îą1 âŞ Îą1 ) Âˇ Âˇ Âˇ (Îąk âŞ Îąk ) | k âĽ 1,  Îą1 Âˇ Âˇ Âˇ Îąk â L, Îą1 Âˇ Âˇ Âˇ Îąk â L } ,  while over event automata E and E  , define an eventautomaton E ĂâŞ E  by NEĂâŞ E  = NE Ă NE  , 0EĂâŞ E  =  (0E , 0E  ), 1EĂâŞ E  = (1E , 1E  ), and  AEĂâŞ E   = {((n, n ), (m, m )) | (n, m) â AE  and (n , m ) â AE  }  lEĂâŞ E  (n, n ) = lE (n) âŞ lE  (n ) .  E ĂâŞ E  is the (unconstrained) concurrent composition of  E and E  , with language  L(E ĂâŞ E  ) =  L(E) &âŞ L(E  ) .  But should we be allowed to superimpose any two pictures Îą and Îą on each other? If pictures are assumed to be  complete descriptions (as the sets labeling a Kripke model  Proceedings of the Ninth International Symposium on Temporal Representation and Reasoning (TIMEâ02)  1530-1311/02 $17.00 ÂŠ 2002 IEEE  ordinarily are), then they can be superimposed only on  themselves, suggesting that we restrict the nodes of EĂâŞ E   to the pullback      {(n, n ) â NE Ă NE  | lE (n) = lE  (n )}.  This restriction, call it P (E, E  ), yields the usual construction intersecting languages L(E) and L(E  )  L(P (E, E  )) =  L(E) âŠ L(E  ) .  On the other hand, if pictures are understood as incomplete  (as we shall), then some middle ground between E ĂâŞ E   and P (E, E  ) might be sought, allowing the superposition of some but not all pairs of pictures. (Take âMaryswimmingâ and âtwo-ticks-of-an-hour clockâ versus âMarysleepingâ and âMary-wide-awake.â) Accordingly, let us  weaken the requirement on acceptable node pairs n, n from  lE (n) = lE  (n ) to lE (n)âŞlE  (n ) being, in a precise sense,  legitimate.  To pick out what pictures an event-automaton can frame,  let us henceforth assume ÎŚ comes equipped with a nonempty family Cn â Pow(ÎŚ) that is â-closed (ie for all  Îą â Cn, Pow(Îą) â Cn), with the intended reading  Îą â Cn  Returning to Â§2.1, with an event-automaton E replaced  by a language L, let us define analogs of 0E , pE and 1E as  pictures Îą(L), Î´(L) and Ď(L) â Pow(ÎŚ) of the inceptive,  progressive and culminative stages of L given by    Îą(L) =  {Ď1 | Ď â L}    Î´(L) =  {Ďi | i > 1 and Ď â L with length > i}    Ď(L) =  {Ďi | i âĽ 1 and Ď â L with length i}  where Ďi is the ith-symbol of the infinite string Ďââ obtained by concatenating Ď to the left of the infinite string ââ  of ââs. Next, instead of forming 0E â pE â pE â 1E ,  define the âMoens-Steedmanâ language  MS(L) =  = (L &âŞ L ) âŠ Cn+  = {(Îą1 âŞ Îą1 ) Âˇ Âˇ Âˇ (Îąk âŞ Îąk ) | k âĽ 1,  Îą1 Âˇ Âˇ Âˇ Îąk â L, Îą1 Âˇ Âˇ Âˇ Îąk â L  and Îąi âŞ Îąi â Cn for 1 â¤ i â¤ k}      of &âŞ . As for E ĂâŞ E , let E ĂCn E be the restriction of  E ĂâŞ E  to the set of nodes  {(n, n ) â NE Ă NE  | lE (n) âŞ lE  (n ) â Cn}  provided this set includes both (0E , 0E  ) and (1E , 1E  );  otherwise, let E ĂCn E  be the event-automaton  {0, 1}, â, 0, 1, l where l(0) = l(1) = â  with empty language.  Proposition 2. For all event-automata E and E  ,  L(E ĂCn E  ) = L(E) &Cn L(E  ) .  Henceforth, we focus on regular languages over Cn, as opposed to event-automata (linked to these languages according to Propositions 1 and 2). This has a technical advantage  illustrated by the ease in formulating  Proposition 3. For all languages L, L and L â Pow(ÎŚ)â ,  Îą(L) Î´(L)+ Ď(L)  (which differs from Table 1 in yielding strings only with  length âĽ 3) and in place of (3), let  iff Îą is consistent/conceivable/a cartoon  for every Îą â ÎŚ. Cn induces the refinement  L &Cn L  2.4. Table 1 and (3) revisited with superposition  for(L) =  â Ď(L)+ â  prog(L) =  â Îą(L) â  +  where Âˇ is a negation operation on subsets Î˛ of ÎŚ such that  Î˛ âŞ Î˛ â Cn and for all Îł â Cn,  Îł âŞ Î˛ â Cn  or  Îł âŞ Î˛ â Cn .  Finally, we turn Table 1 into the definitions  Activ(L) = MS(L) &Cn for(L) &Cn prog(L)  Accmp(L) = MS(L) &Cn forâ (L) &Cn prog(L)  Stat(L) = MS(L) &Cn for(L) &Cn progâ (L)  Achie(L) = MS(L) &Cn forâ (L) &Cn progâ (L)  where  +  forâ (L) = â Ď(L) â  progâ (L) = â Îą(L)+ â .  Having used the function MS to motivate the definitions of  for(L), prog(L), forâ (L) and progâ (L), notice that MS  contributes nothing to differentiating v(L) for v â {Activ,  Accmp, Stat, Achie}. And instead of defining forâ (L) and  prog(L) in terms of negation Âˇ on subsets of ÎŚ, we might  specify how a function on languages classifies languages.  Given an arbitrary function f on languages, let us say  (a) L &Cn L = L &Cn L  (i) L is [âf ] if L&Cn f (L) = â  (b) (L &Cn L ) &Cn L = L &Cn (L &Cn L )  (ii) L is f -acceptable if L&Cn f (L) = â, and  (c) L &Cn â+ = L iff L â Cn+ .  (iii) L is [+f ] if L is f -acceptable and L = L&Cn f (L).  Proceedings of the Ninth International Symposium on Temporal Representation and Reasoning (TIMEâ02)  1530-1311/02 $17.00 ÂŠ 2002 IEEE  Notice that if L is Activ-acceptable, then L is for- and progacceptable, and Activ(L) is [+ for] and [+ prog]. Similar  remarks can be made about the other v(L)âs.  Under the definitions above, [+ for] amounts to a sortal/aspectual restriction that âforâ imposes on the verb  phrase with which it combines. (Furthermore, that restriction is treated along the lines of the approach to presupposition in [7], with L satisfying the presuppositions of âforâ  precisely if L is [+ for].) Passing again to arbitrary functions f on languages, let us call f Cn-conjunctive if  f (L) =  f (f (L))  f (L) =  f (L) =  f (L) &Cn f (L)  f (L &Cn f (L))  example â âread for an hour,â analyzed as  (â {read}+ ) &Cn for(â {read}+ ) &Cn  ({time(x)} â+ {time(y), hour(x, y)})  = {time(x)} {read}+ {read, time(y), hour(x, y)}  with parameters x and y, and restrictions time(x), time(y),  hour(x, y) that we will return to in the next section.  3. Event-tokens and models  for all languages L that are f -acceptable.  Our attention in this section shifts from event-types to  event-tokens, embedded in a model of reality that the formulas in ÎŚ describe. An important part of that model is a  temporal frame (Ot, SĎ ) consisting of a âsuccessorâ relation  SĎ â Ot Ă Ot on a set Ot of âobservation times.â  Proposition 4.  Examples.  (a) If f is Cn-conjunctive, then for every f -acceptable language L, both f (L) and L&Cn f (L) are [+f ].  (b) Each of Activ, Accmp, Stat, Achie is Cn-conjunctive,  as are the functions sending L to â Ď(L)+ Ď(L) and  Îą(L) Îą(L)+ â (which are slight variants of for(L) and  progâ (L), respectively).  Pausing for an example, consider the following pair from  [1].  (4)  a. She read the book for an hour.  b. She read the book in an hour.  On the surface, (4) poses a challenge to the prohibition  against âforâ and âinâ being able to fill the same holes (ie [+  for]=[â in]). But, as pointed out in [1], (4b) entails that âshe  finished reading the bookâ whereas (4a) does not. That is,  âread the bookâ amounts in (4a) to âread parts of the bookâ  and in (4b) to âread the entire book.â It is well-known (e.g.  [9, 13]) that the argument of a verb can shape the aspectual property of the verb phrase, so that, in particular, âread  parts of the bookâ is naturally conceptualized as an activity, whereas âread the bookâ (or especially, âread the entire  bookâ) is an accomplishment (that culminates with all unread parts of the book consumed). Thus, âfor an hourâ combines easily with âread parts of the book,â while âin an hourâ  modifies âread the entire book.â But what does &Cn have  to do with any of this? Following the widespread use of  conjunction in event semantics, we can apply &Cn to combine not only âfor an hourâ with âread parts of the bookâ but  also the argument âparts of the bookâ (or âthe entire bookâ)  with âread.â That is, &Cn is offered here as a tool for the  logical investigation that lexical semantics richly deserves  (e.g. [3, 15]). Focusing on time, let us work out a simple  (i) Ot is the set of integers, and SĎ is the usual successor  (+1) function.  (ii) Ot â Pow(Pt) â {â} for some set Pt of points linearly  ordered by <Ď , and SĎ is the set of all pairs (t, t ) â  Ot Ă Ot such that  (âx â t)(ây â t ) x <Ď y and  not (ât â Ot) t â gap(t, t )  where gap(t, t ) is {z â Pt â (t âŞ t ) | (âx â t)(ây â  t ) x <Ď z <Ď y}. (The second conjunct excludes  gaps containing observation times, guarding against  insertion anomalies.) More concretely, if Pt is the set   of real numbers, Î´ is some positive number (fixing  a level of granularity/degree of error-tolerance) and Ot  is the set of non-empty open intervals  o(p, q) =  {r â  | p < r < q}  with rational end-points p, q such that q â p > Î´, then  for all o(p, q), o(p , q  ) â Ot,  o(p, q) SĎ o(p , q  ) iff 0 â¤ p â q â¤ Î´ .  Note that Ot is countable and SĎ is not functional.  It will suffice throughout this section to equate an eventtype with a language L â Cn+ , the strings from which we  anchor in a temporal frame as follows. An event(-token)  of event-type L is a function e from some finite subset  {t1 , t2 , . . . , tk } of Ot to Cn such that  t1 SĎ t2 SĎ Âˇ Âˇ Âˇ SĎ tk  and  e(t1 )e(t2 ) Âˇ Âˇ Âˇ e(tk ) â L .  To state that e is an event of event-type L, we write  Proceedings of the Ninth International Symposium on Temporal Representation and Reasoning (TIMEâ02)  1530-1311/02 $17.00 ÂŠ 2002 IEEE  e:L.  For typical choices of SĎ , at most one SĎ -chain can be arranged from a finite subset dom(e) of Ot, whence e picks  out at a unique string in L. Also, the definition of âe : Lâ  can be relativized to a binary relation SĎ that depends on L,  but for simplicity, we will leave SĎ fixed in the background.  Assuming an observation time can occur at most once in an  SĎ -chain (ie t1 SĎ t2 SĎ Âˇ Âˇ Âˇ tk and i = j imply ti = tj ), the  totality of events of event-type L is essentially L&Cn L(SĎ )  where L(SĎ ) is the set of finite SĎ -chains. In general, however, L(SĎ ) is not a regular language, and the special role  it plays in time-stamping L makes it natural to present an  event as a function whose domain is a finite subset of Ot.  To form a model from events, we must spell out what  contribution an event e makes. A simple answer is that e  contributes the set  â(e) =  {@(Ď, t) | t â dom(e) and Ď â e(t)}  of formulas, where â@(Ď, t)â is some formula saying: Ď  holds at t. Recalling the formulas time(x), time(y) and  hour(x, y) from the end of section 2, we might equate  @(time(x), t) with âx = tâ, @(time(y), t) with ây = tâ and  @(hour(x, y), t) with âhour(x, y)â (the dependence on t of  hour(x, y) being spurious). By contrast, for read (and many  other ÎŚ-formulas), it is useful to construe @(read,t) as literally the string â@(read, t)â. In view of these differences,  let us partition ÎŚ into three sets  ÎŚ = ÎŚ= âŞ ÎŚg âŞ ÎŚl  where ÎŚ= consists of ÎŚ-formulas such as time(x) that translate to equations, ÎŚg consists of âglobalâ ÎŚ-formulas such  as hour(x, y) that are independent of t, and ÎŚl consists of  âlocalâ ÎŚ-formulas such as read. From ÎŚ= -formulas in e,  we form the substitution  Î¸e  =  3.1. Lumping events into forcing-conditions  Next, generalizing from event(-token)s to the set Ot (  Cn of partial functions (p, q, . . .) from Ot to Cn, let  be the  partial order on Ot ( Cn comparing information content as  follows  pq  iff dom(p) â dom(q) and  (ât â dom(p)) p(t) â q(t) .  (The intuition is that p  q says q is at least as informative  as p.) Given a collection ET of event-types and a partial  function p : Ot ( Cn, let ET(p) be the set of ET-events  -contained in p  ET(p) =  {e | e  p and (âL â ET) e : L} ,  this being the bit of reality ET carves up from p. Fix an  expansion Time = (Ot, SĎ , . . .) of (Ot, SĎ ) to the vocabulary (aka signature, language, set of non-logical symbols)  of ÎŚg so that every Ď â ÎŚg can be judged to be true  or false in Time. Also, to extract a model from a partial  function p : Ot ( Cn, we have to be careful about overlapping observation times, which we henceforth assume is  given by a family OĎ â Pow(Ot) â {â}. (For example, if  Ot â Pow(Pt) â {â}, then   OĎ consists of all non-empty  families T â Ot such that T = â.) Let  (i) P (ET, Time, OĎ ) be the set of partial functions p :  Ot ( Cn such that for all e â ET(p) and Ď â âg (e),  Time |= Ď ,  and for all T â OĎ where T â dom(p),    p(t) â Cn  {(x, t) | t â dom(e) and time(x) â e(t)}  which we then apply to the rest of the ÎŚ-formulas in e to get  âg (e)  = {Ď[Î¸e ] | (ât â dom(e)) Ď â e(t) âŠ ÎŚg }  âl (e)  = {@(Ď[Î¸e ], t) | t â dom(e) and Ď â e(t) âŠ ÎŚl }  with the understanding that Ď[Î¸e ] is falsum âĽ if Î¸e is not  functional, else Ď[Î¸e ] is Ď with every variable x â dom(Î¸e )  replaced by Î¸e (x).1  tâT  (ii) v(ÎŚ) be the vocabulary consisting of unary relation  symbols @(Ď, Âˇ) for every Ď â ÎŚl (with â@(Ď, t)â to  be read: âĎ holds at tâ), and  (iii) fET be the function that maps a partial function p :  Ot ( Cn to    âl (e) .  fET (p) =  eâET(p)  1A  substitution pairs variables (or parameters) with terms â the terms  in this case being observation times. Î¸e provides a means of binding variables x â dom(Î¸e ) locally to e, allowing multiple instantiations of x to  co-exist (in a model). That is, instead of proliferating alphabetic variants  of an event-type, the event-type is construed as parametric, with x as a  temporal parameter that an event e instantiates as Î¸e (x). The thematic  arguments of an event-type (e.g. agent, patient) can also be presented as  parameters, provided an event specifies instantiations of these parameters.  For the sake of simplicity, parameters and substitutions are confined here  to observation times.  Let us define a ÎŚ(Time)-model to be an expansion of Time  to the vocabulary v(ÎŚ, Ot) (= v(ÎŚ) âŞ Ot) where the constants t (in Ot) are interpreted as t. (To simplify notation, we do not distinguish between t qua constant, and t  qua semantic interpretation.) Now, given an element pĚ of  P (ET, Time, OĎ ), how might we build a ÎŚ(Time)-model  that contains ET(pĚ)? Allowing for ÎŚ(Time)-models that  Proceedings of the Ninth International Symposium on Temporal Representation and Reasoning (TIMEâ02)  1530-1311/02 $17.00 ÂŠ 2002 IEEE  may or may not contain events beyond those in ET(pĚ), let  us pass from pĚ to a set P â P (ET, Time, OĎ ) with least element pĚ. (To restrict events to those in ET(pĚ), take  P = {pĚ}.) Applying the âforcingâ machinery in, for example, [8],2 let us define a forcing predicate ||âP (which  we simplify to ||â) that relates forcing-conditions p â P to  v(ÎŚ, Ot)-formulas (closed under ÂŹ, â¨ and â) as follows:  (a) A generic set G induces a ÎŚ(Time)-model Time(G)  such that for every v(ÎŚ, Ot)-formula Ď,  Time(G) |= Ď  (b) Assuming ÎŚl and Ot are countable,  p ||âw Ď  iff for every generic G s.t. p â G,  Time(G) |= Ď .  (i) basing ||â on fET ,  p ||â @(Ď, t)  iff @(Ď, t) â fET (p)  for all Ď â ÎŚl and t â Ot  (ii) confining our search for ÂŹĎ-counterexamples to qâs in  P such that p  q,  p ||â ÂŹĎ iff not (âq â P ) (p  q and q ||â Ď)  (iii) externalizing â¨ to non-deterministic choice +,  p ||â Ď â¨ Ď  iff p ||â Ď or p ||â Ď  Forcing-conditions p span the divide between events e â  ET(p) and ÎŚ(Time)-models Time(G), for generic G p.  Given P â P (ET, Time, OĎ ), let MOD(P ) be the set of  ÎŚ(Time)-models generated by P -generic sets  MOD(P ) = {Time(G) | G is P -generic} ,  and (going down , rather than [as is the case for generic  sets] up), let PET be P with all its ET-events    ET(p) .  PET = P âŞ  pâP  The following proposition is easily proved.  (iv) restricting â to Ot,  p ||â âxĎ iff p ||â Ď[x/t] for some t â Ot .  3.2. Between events and worlds  Applied twice, ÂŹ yields a notion of weak forcing ||âw  p ||âw Ď  iff (âp â G) p ||â Ď .  iff p ||â ÂŹÂŹĎ  that extends ||â in a manner that can be characterized by  ÎŚ(Time)-models generated by certain subsets of P . More  specifically, a subset G of P is (P -)generic if for all p, q â  P,  (i) whenever p â G and q  p, q â G  (ii) whenever p, q â G, there exists r â G such that p  r  and q  r  (iii) for every v(ÎŚ, Ot)-formula Ď, there exists r â G such  that r ||â Ď or r ||â ÂŹĎ.  Let us record fundamental results explained in [8] as  Fact 5.  2 In the terminology of [8], we get a forcing property P, â¤, f  (over the  base vocabulary v(ÎŚ) and set Ot of constants) where â¤ is the restriction  of  to P , and f is a function with domain P mapping p â P to f (p) =  fET (p) âŞ {ât = tâ | t â Ot}. As our only constants are those from Ot  (no two of which are to be semantically identified), equality is trivial and  is accordingly left out above.    It is perhaps also worth noting that [8] allows infinitary disjunctions ,  which should come in handy for infinitary +. As it is, we can (in line  with a finite-state perspective) limit the forcing-conditions in the present  section to finite functions, provided we do not require that a generic set be  represented by a single forcing-condition.  Proposition 6. If P â P (ET, Time, OĎ ), then  PET â  MOD(PET ) =  P (ET, Time, OĎ )  MOD(P )  and ||âP is the restriction of ||âPET to P .  Why   bother forming PET ? Because in PET , events  e â pâP ET(p) count as forcing-conditions, allowing us  to ask of a v(ÎŚ, Ot)-formula Ď whether or not e forces Ď.  But beyond Ď of the form @(Ď, t), what else is there to  âe ||â Ďâ? Simplifying notation, let us henceforth assume  P = PET . Observe that for every ET-event e â P , Ď â ÎŚl  and t â Ot,  e ||â @(Ď, t) iff t â dom(e) and Ď â e(t)  and if ÎŚ is closed under negations âź Ď (with {Ď, âź Ď} â  Cn),  e ||â @(âź Ď, t)  implies  e ||â ÂŹ@(Ď, t) ,  the converse of which does not, in general, hold. Readers  familiar with [14] might liken the discrepancy here to that  between constructible falsity (âź) and intuitionistic negation  (ÂŹ). More specifically, ÂŹ brings the full space P of forcingconditions into the picture, denying the existence of a extension p of e in P such that p ||â @(Ď, t), whereas âź  requires local, positive evidence e. Indeed, the double negation translation ÂŹÂŹ underlying ||âw weakens the requirement of local, positive evidence to  e ||â ÂŹÂŹĎ  iff (âp â P s.t. e  p)  (âq â P s.t. p  q) q ||â Ď ,  Proceedings of the Ninth International Symposium on Temporal Representation and Reasoning (TIMEâ02)  1530-1311/02 $17.00 ÂŠ 2002 IEEE  allowing for the possibility that e ||âw @(Ď, t) but not  e ||â @(Ď, t). That is, e may not be enough to settle  âe ||â ÂŹÂŹ@(Ď, t)â, although arguably, if e ||â ÂŹÂŹĎ, then,  as e  e â P , there is positive evidence q " e in P for Ď  (except that it alone may not suffice). At stake between âź  and ÂŹ is the distinction between explicit and implicit information. âe ||â @(âź Ď, t)â says that explicit in e is information for âź Ď at t, whereas âe ||â ÂŹ@(Ď, t)â claims only that  information against Ď at t can be inferred from e, possibly  with the aid of P . The question arises: how do we pick P  and/or MOD(P )? I hope to report on this matter elsewhere.  4. Conclusion  The finite-state approach to event semantics above is  presented in two parts: one centered around event-types,  formulated as finite automata, or more abstractly, regular  languages; and the other around event-tokens, grounding  strings from an event-type in a model. The strings are built  from a set ÎŚ of formulas, which correspond to the propositional fluents of [10]. It is natural to ask: where in the  present approach are the situations? Given a generic set G  and a time t â Ot, one might expect to reconstruct a situation, understood as âthe complete state of the universe at an  instant of timeâ [10], from the snapshot  {Ď | (âp â G) p ||â @(Ď, t)}.  Evidently, the presentation above is not oriented around situations. Much more prominent is partiality, embodied in  the first part by ĂCn /&Cn (playing the role of conjunction  in a Davidsonian approach to event modification), and in  the second part by  (linking events to worlds, to give the  pictures in ÎŚ model-theoretic bite).  Speaking of partiality, it bears stressing that the present  approach puts finite automata in the service of declarative,  as opposed to operational, semantics, shying away from details of how language is processed. Despite this limitation,  I do think that  (i) a useful temporal ontology reflecting âways of viewingâ ([18]) can be fashioned from finite automata (perhaps with help from [19, 13]), and that  (ii) the restriction to regular languages ought to have positive consequences for both the representational and inferential aspects of the frame problem ([10]) for natural  language ([18]).  Obviously, there is much work to be done. As to what  has been carried out, I close with the note that it was  conceived as part of a model-theoretic re-interpretation of  propositions-as-types (applied to natural language in [16]),  pushing typed Îť-calculi analyses of logical connectives  down to the sub-atomic (lexical) level through finite-state  methods. (The interested reader is referred to the constructive eventuality assumption in [4], Â§3.1.)  References  [1] N. Chang, D. Gildea, and S. Narayanan. A dynamic model  of aspectual composition. In Proc. CogSci 98, 1998.  [2] D. Davidson. The logical form of action sentences. In  N. Rescher, editor, The Logic of Decision and Action. University of Pittsburgh Press, 1967.  [3] D. R. Dowty. Word Meaning and Montague Grammar. Reidel, Dordrecht, 1979.  [4] T. Fernando. Conservative generalized quantifiers and presupposition. In Proc. Semantics and Linguistic Theory XI.  Cornell University, 2001.  [5] F. Hamm and M. van Lambalgen.  Event calculus,  nominalization, and the progressive.  Available from  www.semanticsarchive.net, 2000.  [6] H. Kamp and U. Reyle. From Discourse to Logic. Kluwer  Academic Publishers, Dordrecht, 1993.  [7] L. Karttunen. Presupposition and linguistic context. Theoretical Linguistics, pages 181â194, 1974.  [8] H. J. Keisler. Forcing and the omitting types theorem. In  M. Morley, editor, Studies in Model Theory. The Mathematical Association of America, 1973.  [9] M. Krifka. Nominal reference, temporal constitution and  quantification in event semantics. In R. Bartsch, J. van Benthem, and P. van Emde Boas, editors, Semantics and Contextual Expressions. Foris, Dordrecht, 1989.  [10] J. McCarthy and P. Hayes. Some philosophical problems  from the standpoint of artificial intelligence. In M. Meltzer  and D. Michie, editors, Machine Intelligence 4. Edinburgh  University Press, 1969.  [11] M. Moens and M. Steedman. Temporal ontology and temporal reference. Computational Linguistics, 14:15â28, 1988.  [12] S. Narayanan. Reasoning about actions in narrative undertanding. In Proceedings of IJCAI â99. Morgan Kaufmann,  San Francisco, 1999.  [13] R. Naumann. Aspects of changes: a dynamic event semantics. J. Semantics, 18:27â81, 2001.  [14] D. Nelson. Constructible falsity. J. Symbolic Logic,  14(1):16â26, 1949.  [15] T. Parsons. Events in the Semantics of English: A Study in  Subatomic Semantics. MIT Press, Cambridge, MA, 1990.  [16] A. Ranta. Type-Theoretical Grammar. Oxford University  Press, Oxford, 1994.  [17] R. Reiter. Narratives as programs. In Principles of Knowlege Representation: Procedings of KR 2000. Morgan Kaufmann, San Francisco, 2000.  [18] M. Steedman. The Productions of Time. Draft, ftp://  ftp.cogsci.ed.ac.uk/pub/steedman/temporality/temporality.ps.gz, July 2000.  [19] S. Tojo. Event, state and process in arrow logic. Minds and  Machines, 9:81â103, 1999.  [20] J. van Benthem. A note on dunamic arrow logic. In J. van  Eijck and A. Visser, editors, Logic and Information Flow.  MIT Press, Cambridge, MA, 1994.  Proceedings of the Ninth International Symposium on Temporal Representation and Reasoning (TIMEâ02)  1530-1311/02 $17.00 ÂŠ 2002 IEEE 