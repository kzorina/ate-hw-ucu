2013 20th International Symposium on Temporal Representation and Reasoning  Complexity of Model Checking over General Linear  Time  Tim French, John Mc Cabe-Dansted and Mark Reynolds  School of Computer Science and Software Engineering  The University of Western Australia  35 Stirling Highway, Crawley WA 6009  Perth, Australia.  Email: {tim.french,john.mccabe-dansted,mark.reynolds}@uwa.edu.au  with discrete points. If a sentence of natural language or some  strange formalism can determine the behaviour of a signal over  a linear order, we can check it.  Our second generalisation is more important. Timed automata are tremendously useful mathematical objects for veriďŹcation and design tasks [4], [5] but there are many properties  exhibited in the real continuous world that do not seem  amenable to easy modelling by their fundamental discrete step  by step action. To name just a few consider the following: the  approach of Achilles to Zenoâs Tortoise [6]; a fractal signal  [7] (see Figure 1); the inďŹnitesimal chattering of a sliding  controller [8] (like a perfect ABS braking system); or mathematically deďŹned hypothetical signals like one true at precisely  the irrational real numbers. An automaton allowing a cycle of  shorter and shorter durations may give an indication of the  possibility of some Zeno type behaviour but it does not allow  speciďŹcation of what happens after the accumulation point.  Furthermore, even developers of more conventional automatalike machines have to sometimes consider the behaviour of  their system with an environment that is less well-behaved  and they would beneďŹt from being able to describe a wide  range of environmental possibilities. In this paper, we allow  structures exhibiting any deďŹnable boolean signals.  A simple and long-established propositional temporal language adequate for our situation is L(U, S), the propositional  temporal language using Kampâs Until and Since connectives [9]. We interpret L(U, S) over general linear ďŹows and  call the logic US/L. If we restrict semantics to just the real  numbers then the logic is sometimes called RTLâroughly  Metric Temporal Logic [10], [11] without the metrics.  Recent work [12] addressed the problem of synthesis of  linear models of US/L formulasâďŹnding an algorithm to  describe a linear model of any given satisďŹable formula. This  required a formal language for outputting details of models.  To do this, the paper presented a compositional language  for model expressions, building upon pioneering work by  [13], [14], [15], [16]. An abstract syntax with a few basic  composition operators allows an expression to specify how to  iteratively build an arbitrarily complex linear structure from  simple singleton point structures. This language is expressively  adequate, as any satisďŹable formula of US/L has a model  representable in this language [12].  AbstractâTemporal logics over general linear time allow  us to capture continuous properties in applications such as  distributed systems, natural language, message passing and A.I.  modelling of human reasoning. Linear time structures, however,  can exhibit a wide range of behaviours that are hard to reason  with, or even describe ďŹnitely. Recently, a formal language of  Model Expressions has been proposed to allow the convenient  ďŹnite description of an adequately representative range of these  generally inďŹnite structures. Given a model described in this  Model Expression language and a temporal logic formula, a  model checking algorithm decides whether the formula is satisďŹed  at some time in the model. Tools based on such algorithms would  support a wide variety of tasks such as veriďŹcation and counterexample investigation.  A previous paper gave an exponential space algorithm for the  problem of model checking Until/Since temporal formulas over  linear time Model Expressions. Here we prove that the problem is  actually PSPACE-complete. We present a new PSPACE algorithm  and we show PSPACE-hardness by a reduction from quantiďŹed  boolean formulas.  Keywords-Model Checking; Complexity; General Linear  Flows; Dense Time; Logic  I. I NTRODUCTION  Since [1] ďŹrst made the radical suggestion that a model  with a continuous ďŹow of time might be better for handling  concurrent systems than traditional discrete temporal logics,  there has been steadily increasing development of appropriate  non-discrete formalisms, techniques, tools and their foundations. The important quality assurance task of veriďŹcation of  a system, formalised as model-checking, has developed from  simple checking of a Kripke structure against an LTL formula  in discrete time [2] to checking all traces of a timed automata  in continuous time against temporal metric constraints [3].  Here we also consider model checking of temporal properties in not necessarily discrete time models but we generalise  the problem in several important but related ways. We consider  any underlying linear models of time and we do not assume  that the structure to âcheckâ has been generated by the action  of some ďŹnite mechanism moving from discrete state to discrete state. So time may be the non-negative reals or the natural  numbers but it may instead be the rationals or the integers  or some ďŹnite sequence of continuous intervals interspersed  The work was partially supported by the Australian Research Council.  1530-1311/13 $26.00 ÂŠ 2013 IEEE  1550-1311/13  DOI 10.1109/TIME.2013.21  107  95                          ďŹnite duplications of submodels. By contrast [12] focussed on  expressively complete ďŹnite representations of inďŹnite/dense  structures, for which ďŹnite duplication is not required, so the  formalism has only operators for inďŹnite repeats of submodels.  Thus the actual model-checking algorithms end up being quite  different.  In section 2 we deďŹne the logic US/L and in section 3, we  deďŹne model expressions. Section 4 contains our PSPACEhardness result and section 5 presents the new PSPACE model  checking algorithm.                      Fig. 1.  An example of a fractal signal  II. T HE LOGIC  In this section, we introduce the logic US/L. We ďŹrst deďŹne  the temporal language L(U, S) of Until and Since. Then US/L  is just the logic of L(U, S) over the class of all structures with  a linear ďŹow of time.  L(U, S) is a propositional language and we work with a  ďŹxed countable set L of atomic propositions (or atoms). A  frame (T, <), or ďŹow of time, is any irreďŹexive linear order.  Structures T = (T, <, h) will have a frame (T, <) and a  valuation h for the atoms, i.e. for each atom p â L, h(p) â T .  The well-formed formulas of L(U, S) are generated from  the atomic propositions by the 2-place connectives U and  S (both used in a preďŹx manner) along with the boolean  connectives ÂŹ and â§. That is, we deďŹne the set of formulas  recursively to contain the atoms and for formulas Îą and Î˛, we  include ÂŹÎą, Îą â§ Î˛, U (Îą, Î˛) and S(Îą, Î˛).  Formulas are evaluated at points in structures T =  (T, <, h). We write T, x |= Îą when Îą is true at point x â T .  This is deďŹned inductively as follows. Suppose that we have  deďŹned the truth of formulas Îą and Î˛, at all points of T. Then  for all points x:  T, x |= p  iff x â h(p), for p atomic;  T, x |= ÂŹÎą  iff T, x |= Îą;  T, x |= Îą â§ Î˛  iff both T, x |= Îą and T, x |= Î˛;  T, x |= U (Îą, Î˛) iff there is y > x in T such that  T, y |= Îą and for all z â T  such that x < z < y we have  T, z |= Î˛; and  T, x |= S(Îą, Î˛) iff there is y < x in T such that  T, y |= Îą and for all z â T  such that y < z < x we have  T, z |= Î˛.  Along with standard logical abbreviations Îąâ¨Î˛ = ÂŹ(Îąâ§Î˛),  Îą â Î˛ = ÂŹÎą â¨ Î˛, and Îą â Î˛ = (Îą â Î˛) â§ (Î˛ â Îą), we use  the following temporal abbreviations in illustrating the logic:  F Îą = U (Îą, ), âalpha will be true (sometime in the future)â  GÎą = ÂŹF (ÂŹÎą), âalpha will always hold (in the future)â; and  their past time versions P and H.  Having ďŹnite representations for structures also opens the  possibility for an algorithm for model checking formulas  against those representations. Such a general linear time model  checking algorithm was presented for this problem in [17]. The  algorithm had complexity exponential in time and space.  Let us consider a example such as the fractal signals of, e.g.,  [7]. Figure 1 shows a simpliďŹed hypothetical fractal signal  where all spikes are upwards. Let p hold during periods of  increasing signal, q describe a decreasing one, and r represent  a constant signal. Assume that these propositions also hold  at the start and ends of the appropriate intervals. Using the  new notation of [12] can then represent the pattern of increments and decrements in this signal with the Model Expression r + {r, p} + p + {p, q} + q + {q, r} + r. Useful properties of this signal can be speciďŹed in L(U, S). For  example, we can reach a region of increment directly from  a constant region so r â§ U (p, r â¨ p) is satisďŹed within the  model. However, we cannot reach a region of decrement from  a region of increment, so r â§U (q, r â¨ q) is not satisďŹed within  the model. Checking such claims is the work of a modelchecking algorithm.  In this paper, we will show that model checking US/L  formulas against (general linear time) Model Expressions is  actually PSPACE-Complete. We show PSPACE-hardness by a  reduction from the satisďŹability problem for quantiďŹed boolean  formula. This hardness result is quite robust in the sense that it  only needs a fraction of the operators available, and removing  more operators results in a problem in P.  We then show that the problem is in PSPACE by giving  a polynomial space model checking algorithm. This is essentially an improved variant of the [17] algorithm. However, we  do not want to claim that the new algorithm would be better  for practical use. For this reason we have not implemented  the algorithm although an implementation of the original  algorithm is available [18].  There are some similarities between the model checking  task here and the task of model checking LTL formulas against  âcompressed pathsâ as described in [19]. In fact, we have been  able to follow a similar approach to theirs for our proof of  PSPACE-hardness. Like model expressions, the compressed  path formalism allows concise expressions of structures (but  there only ďŹnite discrete ones) via duplication of submodels.  However, the compressed paths of [19] were intended to  represent ďŹnite discrete paths efďŹciently and thus only allowed  III. B UILDING S TRUCTURES  As in [12], we deďŹne a notation which allows the description  of temporal structures. Each expression tells us how to build  a structure out of simple basic structures via four ways of  putting structures together to form larger ones.  The general idea is simple. Using singleton structuresâ  the ďŹow of time is one pointâwe build up to more complex  108  96  structures by the iterative application of any of the operations.  There are four operations available:  1) concatenation of two structures, consisting of one followed by the other;  2) Ď repeats of some structure laid end to end towards the  past;  3) Ď repeats laid end to end towards the future;  4) and making a densely thorough shufďŹe of copies from a  ďŹnite set of structures.  These operations are well-known from the study of linear  orders (see e.g. [14]).  Model Expressions are an abstract syntax to deďŹne models  using the following set of primitive operators based on the  four operations:  â  â â  â  I ::= a | Îť | I + J | I | I | I0 , Âˇ Âˇ Âˇ , In   are important for modelling US/L formulas. Every satisďŹable  US/L formula Ď has an ME I such that a structure T that  corresponds to I will satisfy Ď, yet MEs are minimal in that  excluding any operator (except Îť) will render them unable to  represent models for some US/L formulas.  We will give an illustration of the non-trivial operations  â  â  below. The lead operation, I = J has Ď submodels, each  corresponding to J , and each preceding the last, as illustrated  in Figure 2.  The trail operator is the mirror image of lead, whereby  â  â  I = J has Ď structures, each corresponding to J and each  proceeding the earlier structures.  The shufďŹe operator is harder to represent with a diagram.  The model expression I = I1 , . . . In  corresponds to a dense,  thorough mixture of intervals corresponding to I1 , . . . , In ,  without endpoints. We deďŹne the shufďŹe operation using the  rationals, Q as they are a convenient order with the required  properties.  The deďŹnition of model expressions is not deterministic, as  the construct for the shufďŹe I1 , Âˇ Âˇ Âˇ , In  does not specify how  the structures corresponding to I1 , Âˇ Âˇ Âˇ , In are mapped to Q.  This is inconsequential, and as long as the mapping is dense  for each i from 1 to n, the resulting structures will be models  of the same formulas [12].  where a â ÎŁ = 2L so the letter indicates the atoms true at a  point. We refer to these operators, respectively, as a letter, the  empty order, concatenation, lead, trail, and shufďŹe.  DeďŹnition 1. [Correspondence] A model expression I corresponds to a structure as follows:  â˘ Îť is the empty sequence and corresponds to the (pseudo)  frame1 (â, <, h) where < and h are empty relations.  â˘ a corresponds to any single point structure ({x}, <, h)  where < is the empty relation and h(p) = {x} if and  only if p â a.  â˘ I +J corresponds to a structure (T, <, h) if and only if T  is the disjoint union of two sets U and V where âu â U ,  âv â V , u < v and I corresponds to (U, <U , hU ) and J  corresponds to (V, <V , hV ). The symbols <U , hU refer  to the restriction of the relations < and h to apply only  to elements of U .  â  â  â˘ I corresponds to the structure (T, <, h) if and only if T  is the disjoint union of sets {Ui |i â Ď} where for all i, for  all u â Ui , for all v â Ui+1 , v < u, and I corresponds  to (Ui , <Ui , hUi ).  â  â  â˘ I corresponds to the structure (T, <, h) if and only if T  is the disjoint union of sets {Ui |i â Ď} where for all i, for  all u â Ui , for all v â Ui+1 , u < v, and I corresponds  to (Ui , <Ui , hUi ).  â˘ I0 , Âˇ Âˇ Âˇ , In  corresponds to the structure (T, <, h) if and  only if T is the disjoint union of sets {Ui |i â Q} where  1) for all i â Q, (Ui , <Ui , hUi ) corresponds to some  Ij for j â¤ n,  2) for every j â¤ n, for every a = b â Q, there is some  k in the open interval (a, b) where Ij corresponds  to (Uk , <Uk , hUk ),  3) for every a < b â Q, for all u â Ua , for all v â Ub ,  u < v.  IV. H ARDNESS R ESULT  DeďŹnition 2. We deďŹne the USME-checking problem as  follows: given an ME I and formula Ď, determine whether  there exists a structure T = (T, <, h) corresponding to I and  point x â T such that T, x  Ď.  The reduction we will use to prove PSPACE-hardness will  be from satisďŹability of prenex QBF formulas. We now provide  a deďŹnition of these formulas.  DeďŹnition 3. A prenex QBF is a formula of the form  ârn ârnâ1 Âˇ Âˇ Âˇ âr2 âr1 Ď where n is even and Ď is a Boolean formula using only atoms in the set {r1 , . . . , rn }. A subformula  of a prenex QBF formula is a QBF formula. For QBF formulas  Îą, Î˛ and atom r we let Îą [r/Î˛] be the formula obtained from  Îą by replacing each occurrence of the atom r with Î˛. For  any Boolean formula Ď and atom r, ârĎ is equivalent to  Ď [r/ ] â§ Ď [r/âĽ] and ârĎ is equivalent to ÂŹârÂŹĎ and hence  Ď [r/ ] â¨ Ď [r/âĽ].  We see that a prenex QBF is equivalent to a boolean formula  with all atoms replaced with or âĽ. As such, a prenex QBF  is equivalent to a theorem of Propositional Calculus iff it is  satisďŹable. We say that a prenex QBF evaluates to true iff it  is equivalent to a theorem (or equivalently, if it is satisďŹable).  The reduction from QBF satisďŹability solving to model  checking compressed paths [19] makes use of efďŹcient replication of identical submodels. In our reduction to MEs we  will use the â  â operator to replicate submodels; however, this  gives us less ďŹexibility. Whereas [19] distinguished between  duplicated submodels by following one with an fn atom and  the other with a tn atom we instead use the Until operator to  To allow more elegant phrasing we take âI corresponds  to Tâ to be equivalent to âT corresponds to Iâ. The MEs  1 Of course, the empty pseudo-frame is not counted as a frame and we do  not allow empty structures.  109  97  J  ...  Fig. 2.  IâĄ e  e  I  I  e  e  I1  I1  J  J  â  â  The lead operation, where I = J  e  e  I  I  e  e  I2  I2  e ... e  e ... e  I  I  e  e  In  In  ..  .  e  e  I  I  e  e  ..  .  Fig. 3.  The shufďŹe operation, where I = I1 , Âˇ Âˇ Âˇ , In   deďŹne a formula Îąi to distinguish the last instance from the  ďŹrst. Using this trick we now deďŹne a reduction from testing  the satisďŹability of QBF formula to ME-checking as follows:  will now show that this reduction is correct and thus the MEchecking problem is PSPACE-hard. It can be convenient to  treat formulas as atoms, so we provide the deďŹnitions:  DeďŹnition 4. For the rest of this section we let J0 = â and  âââââââââ  let Ji = {pi } + Jiâ1 + {qi } for each positive i, let Îąi =  ÂŹ (qi â¨ U (pi , ÂŹqi )), ďŹx a positive even integer n, let Ďq =  ârn ârnâ1 Âˇ Âˇ Âˇ âr2 âr1 Ď be some prenex QBF formula on the  set of atoms r1 , . . . , rn , and let Ď be the formula that results  when each ri is replaced by Îąi in the Boolean formula Ď.  We let Ď0 = Ď and in general let Ďi = U (qi , pi â Ďiâ1 )  for positive odd i and let Ďi = ÂŹ (U (qi , ÂŹ (pi â§ Ďiâ1 ))) for  positive even i. We reduce the problem âIs the QBF formula  Ďq satisďŹableâ to checking the L(U, S) formula pstart â Ďn  against the ME {pstart } + Jn .  DeďŹnition 5. Say T = (T, <, h) is a structure, then T with  an L(U, S) formula Îą added as an atom is TÎą = (T, <, h )  interpreted over the set of atoms LâŞ{Îą} where h (p) = h (p)  for all p â L and for each point x â T we have x â h (Îą)  iff T, x  Îą. Where I is an ME we let I Îą be the ME that  results when Îą is added to every letter of I (not just letters at  which Îą would be satisďŹed). Given a set Î¨ = {Îą1 , . . . , Îąm }  of L(U, S) formulas and an ME I we deďŹne I Î¨ to be the  result I Îą1 ÂˇÂˇÂˇÎą1 of replacing each letter a in I with a âŞ Î¨.  â  â  Note that if any structure corresponds to I then it must also  â  â  correspond to I + I [20]. Using this we can easily prove the  next lemma inductively.  The truth of Îąi at qi points is unimportant to the correctness  of the reduction and so we could have deďŹned Îąi as being  just ÂŹU (pi , ÂŹqi ); however, ensuring Îąi is not true at the  same time as qi makes the formal statement and proof of  Lemma 6 below simpler. The intuition behind our choice of  Ďi is that Îąj will be true throughout the last (prior to {qi })  submodel corresponding to {pi } + Ji+1 , but false throughout  the previous such submodels. Thus U (qi , pi â Ďiâ1 ) means  âfor points satisfying pi , including points where Îąi is false  and points where Îąi is true, it is the case that Ďiâ1 â, and so  is used as our translation of âri . Likewise the intuition behind  ÂŹ (U (qi , ÂŹ (pi â§ Ďiâ1 ))) is that it requires Ďiâ1 at one of the  points satisfying pi , and we can choose from one of these  points that satisfy Îąi or the point which satisďŹes ÂŹÎąi . We  Lemma 6. For each i we let Ti = (T, <, h) be a structure  corresponding to Ji . The structure TÎą1 ÂˇÂˇÂˇÎąi with each Îąi  added as an atom corresponds to Ji where J  is deďŹned  recursively: J0 = â and for each positive i we let Ji =  ââââââââ  ââ  Îąi  + {qi }.  {pi } + J  iâ1 + {pi , Îąi } + J  iâ1  Proof: The lemma is trivially true for i = 0. Say that    the lemma is correct up to i â 1, that is Jiâ1  corresponds  âââââââââ  Îą1 ÂˇÂˇÂˇÎąiâ1  to Tiâ1  . By deďŹnition {pi } + Jiâ1 + {qi } and the  âââââââââ  equivalent ME {pi } + Jiâ1 + {pi } + Jiâ1 + {qi } correspond  ââââââââââ  Îą ÂˇÂˇÂˇÎą  to Ti . We see that Ti 1 iâ1 corresponds to {pi } + J  iâ1 +  110  98  {pi } + J  iâ1 + {qi }. Recall that Îąi = ÂŹ (qi â¨ U (pi , ÂŹqi )).  At the ďŹnal point qi is true so Îąi is false. The atom pi  does not occur within J  iâ1 so U (pi , ÂŹqi ) must be false  throughout the J  iâ1 immediately preceding {qi }; hence Îąi is  true there. As we have deďŹned Until to be strict, U (pi , ÂŹqi )  is also false at the last occurrence of pi . The atom qi does  ââââââââââ  not occur within {pi } + J  iâ1 so we see that U (pi , ÂŹqi ) is  Îą ÂˇÂˇÂˇÎą  Îą  true when followed by pi . Hence Ti 1 iâ1 i corresponds to  â  â  â  â  â  â  â  â  â  â  Îąi  Ji = {pi } + J  iâ1 + {pi , Îąi } + J  iâ1  + {qi }. By induction  the lemma holds for all non-negative integers i.  From Lemma 6 we see that for any subset S â [1, n] there  exists a point x â T such that for all i â [1, n] we have T, x   Îąi iff i â S. This is enough to give us NP-hardness. We see  that a USME-checker returns âtrueâ, when given Ď and In as  input, precisely when Ď is satisďŹable. As we have a polynomial  time reduction from Boolean satisďŹability solving, an NP-hard  problem [21], we know the USME-checking problem is NPhard; however, the goal is to prove PSPACE-hardness and so  we need a reduction from a PSPACE-hard problem. Boolean  satisďŹability with alternating quantiďŹers is PSPACE-complete  (see for example [22]). SatisďŹability of QuantiďŹed Boolean  Formulas (QBF) is trivially reducible to satisďŹability of QBF  in prenex normal form, so we will only consider prenex QBF  and QBF that are subformulas of a prenex QBF.  Î¨âŞÎą  Î¨ + J  iâ1 i + {qi }.  We see that for each x â hU (pi ) either {pi , Îąi } âŞ Î¨ or  {pi } âŞ Î¨ corresponds to T{x} . We see that where {pi } âŞ Î¨  corresponds to T{x} , x is immediately prior to an interval of  Î¨  points V such that TV corresponds to J  iâ1 . As i is a minimal  counter example i â 1 does not provide a counter example.  Thus T, x  Ďiâ1 iff ĎSiâ1 evaluates to true. Likewise if  {pi , Îąi } âŞ Î¨ corresponds to T{x} we see that T, x  Ďiâ1  iff ĎSâŞi  iâ1 evaluates to true. We now further divide the case of  i > 0 into odd and even cases.  Suppose i is odd. Then Ďi = U (qi , pi â Ďiâ1 ) and Ďi =  âri Ďiâ1 . We see that T, z  Ďi is true precisely if for all x â  hU (pi ) we have T, x  Ďiâ1 . From the previous paragraph  we see that for the ďŹnal x â hU (pi ) we have T, x  Ďiâ1  iff ĎSâŞi  iâ1 evaluates to true, and for the other x â hU (pi ) we  have T, x  Ďiâ1 iff ĎSiâ1 evaluates to true. Thus T, z  Ďiâ1  S  precisely if ĎSâŞi  iâ1 and Ďiâ1 both evaluate to true; or in other  S  S  words Ďi = (ârĎiâ1 ) is true. By contradiction, i is even.  As i is even, Ďi = ÂŹ (U (qi , ÂŹ (pi â§ Ďiâ1 ))) and Ďi =  âri Ďiâ1 . We see that T, z  Ďi is true precisely if for some  x â hU (pi ) we have T, x  Ďiâ1 . There is such an x  S  iff either ĎSâŞi  iâ1 or Ďiâ1 evaluate to true; or in other words  S  ĎSi = (âri Ďiâ1 ) is true.  We have now shown that the minimal counter example i  cannot be zero, a positive odd number or a positive even  number. By contradiction, no counterexample exists.  This lemma demonstrates that our reduction from QBF is  correct, and gives us the following theorem:  DeďŹnition 7. Given a QBF formula Î˛ and set S â {1, . . . , n},  we let Î˛ S be the formula that results when each free variable  if j â S and âĽ if j â  / S. Let  rj in Î˛ is replaced with  Ď0 = Ď, for each positive odd i let Ďi = âri Ďiâ1 and for each  positive even i let Ďi = âri Ďiâ1 .  Theorem 9. The USME-Checking problem is PSPACE-hard.  Note that the Ďn deďŹned above is the same as the prenex  QBF Ďq = ârn ârnâ1 Âˇ Âˇ Âˇ âr2 âr1 Ď. The following lemma then  demonstrates the existence of a reduction from satisďŹability  solving of QBF.  Note that a more traditional deďŹnition of the model checking  problem would only require us to determine whether the  formula is a satisďŹed at a particular point. Note that this  deďŹnition would still be PSPACE-hard as we are only interested in the truth of Ďn at the ďŹrst point of the reduction.  Also note that Ďn does not use the Since operator so limiting  formulas to those of L (U ) (or L (S), as the Since operator  is essentially just a mirror image of the until operator) would  still leave a PSPACE-hard model-checking problem. In the  next section we outline a polynomial space implementation for  USME-checking, showing that the USME-checking problem  is PSPACE-complete.  Note also that we used the qi atoms to assist in reasoning  about the correctness of the reduction. We do not claim  that this reduction is in any sense minimal. Consider, for  example, a smaller reduction similar to above but where  âââââââââââ  J0 = {p1 }, for each positive i we have Ji = {pi+1 } + Jiâ1 ,  Îąi = U (pi , ÂŹpi+1 ) and we model check the formula Ďn  against the model Jn .  Note that this PSPACE-hardness result only requires MEs  with â  â and + (not shufďŹes or â  â) and does not require the  Since operator in the formula. Equivalently we could use  â and + in the ME and exclude Until from the formula.  â  Thus this result is quite robust to restrictions of the ME  Lemma 8. Let T = (T, <, h) be a structure corresponding  to Jn . Let T = (T, <, h ) = TÎą1 ÂˇÂˇÂˇÎąn . Let i â {0, . . . , n},  let S = {s1 , . . . , sm } be a subset of {i + 1, . . . , n}, let  Î¨ = {Îąs1 , . . . , Îąsm }. Finally, let U be an interval of points  Î¨  in T such that J  i corresponds to TU and z be a point  immediately prior to U . Then ĎSi evaluates to true precisely  if T, z  Ďi .  Proof: Assume that i is the smallest i that provides a  counterexample to this lemma.  We see that if i = 0 then there is one point x â U and that  TU corresponds to â. We see that for each j we have x â  h (Îąj ) iff j â S, and further for a point z immediately prior  to x, we have x â h (Îąj ) ââ T, x  Îąj ââ T, z  Îąj .  Each atom rj in ĎSi = ĎS0 = ĎS has been substituted for  / S (and  or âĽ, for  if j â S (and T, z  Îąj ) or âĽ if j â  T, z  ÂŹÎąj ). Thus T, z  Ď0 iff ĎS evaluates to true.  Now consider i > 0. Recall that TU corresponds to  âââââââââââÎ¨ââ  Î¨  J  i = {pi } âŞ Î¨ + J  iâ1 + {pi , Îąi }âŞ  111  99  next section terminating in polynomial time.  and/or formula. An obvious question is whether we can get  a result that is even stronger. We now consider some obvious  stronger restrictions, and show that all of these restrictions  lead to a problem in P. Given that we consider a number  of restrictions, and that a full discussion of their precise  complexity would require reference to the implementation in  [17], we do not consider each restriction in detail, for example  we will not discuss whether the restriction is P-hard. Note that,  in practice, the unrestricted ME-checking problem is fairly  easy. For example, the implementation in [17] performs well  on randomly generated problems and uses an amount of time  linear in the size of the model.  We have seen that we only need either lead or trail to  give PSPACE-hardness. The original decision procedure [17]  worked by expanding the ME to add formulas as atomic propositions. Adding each formula was polynomial but interactions  between Until and â  â (likewise S and â  â) could roughly  triple the size of the ME after adding a formula leading to  exponential growth of the ME. No other interactions led to  growth in the size of the ME. Thus the size of the ďŹnal ME  is the same as the input ME if we exclude both lead and trail,  and so we see the following proposition is true.  V. A P OLYNOMIAL S PACE I MPLEMENTATION  In this section we outline how to model check a formula Ď  against an ME I using only a polynomial amount of space.  We now deďŹne presatisfaction. Intuitively T = (T, <, h)  presatisďŹes U (Îą, Î˛) means U (Îą, Î˛) would be true at a point  immediately prior to all points in T .  DeďŹnition 13. We say that a structure T = (T, <, h) presatisďŹes U (Îą, Î˛) iff there exists a y â T such that T, y  Îą and  for each x â T we have x < y â T, x  Î˛.  Postsatisfaction is similar but is the mirror image, so informally T = (T, <, h) postsatisďŹes S (Îą, Î˛) means S (Îą, Î˛)  would be true at a point immediately after all points in T .  As with [17], we iterate over the formulas from smallest  to largest; however, we do not actually modify the ME to  add atoms. The algorithm in [17] pushed down formulas as  atoms into an ME I so the result only depended on I and  the formulas of the form U (Îą, Î˛) that were presatisďŹed after  the interval that corresponding to I and the formulas of the  form S (Îą, Î˛) that were postsatisďŹed before the interval; in  this formulation we store the set Î¨ of such formulas instead  of extending I with new atoms.  Proposition 10. If we exclude both lead and trail from MEs  (or both until and since from formulas) the ME-checking  problem becomes polynomial  DeďŹnition 14. Let S be the set of formulas of the form  S (Îą, Î˛) and U be the set of formulas of the form U (Îą, Î˛).  Let Ď1 , . . . , Ďn be an enumeration of subformulas of the ďŹxed  formula Ď and negations of strict subformulas of Ď such that  for any i, j â [1, n] if Ďi is a subformula of Ďj then i â¤ j.  We let Ďâ¤j be the set {Ď1 , . . . , Ďj }, and let deďŹne equivalence  up to j on sets of formulas S and T as follows S ââ¤j T iff  S âŠ Ďâ¤j = T âŠ Ďâ¤j .  If we exclude â+â from MEs we can see by induction  that Until and Since formulas are true either everywhere or  nowhere, and so adding formulas as atoms would not grow  the size of the ME. It is easy to see the following proposition  must be true.  Proposition 11. If we exclude â+â from MEs, the USMEchecking problem becomes polynomial.  Theorem 12. Model-checking a formula Ď in the fragment  L (F, P ) of L (U, S) against an ME I is in P.  Below we deďŹne a recursive function A. Informally,  A (I, ÎŚ, Ď) = (Î, Î¨) is intended to represent the statement:  if we have an interval TV that corresponds to I, ÎŚ is the set  of formulas in U presatisďŹed immediately after V in T and  formulas in S postsatisďŹed immediately before V in T then  it must be the case that the set of formulas satisďŹed within  TV is Î and the set formulas in U presatisďŹed immediately  before V in T and formulas in S postsatisďŹed immediately  after V in T is Î¨. The formula Ď indicates that we are only  interested in whether Ď â Î and so we can limit ourselves to  subformulas of Ď and their negations. The algorithm works by  generating increasing accurate approximations to (Î, Î¨) that  are accurate up to some subformula Ďj .  Proof: We see that as time advances an F formula can become false, but can never become true. Thus we can choose an  ordering F Î˛1 , . . . , F Î˛n of the n F -subformulas of Ď such that  for all i, j with i â¤ j we have F Î˛j â F Î˛i true throughout I.  This means that the set of formulas presatisďŹed at some point  is one of the n + 1 values â,{F Î˛1 }, . . . , {F Î˛1 , . . . , F Î˛n }. We  can likewise order the m H-formulas. This means that the set  of pre and post-satisďŹed formulas takes one of (n + 1) (m + 1)  values, and will result in the implementation described in the  DeďŹnition 15. Let K be an ME, and ÎŚ be a set of formulae.  We deďŹne A (K, ÎŚ, Ď) to be the pair of sets of formulas (Î, Î¨)  as follows.  We consider various possible forms of K. The ďŹrst case  we consider is a letter. In the following construction we build  increasingly accurate approximations of (Î, Î¨): for each j we  have Îj ââ¤j Î and Î¨j ââ¤j Î¨.  Case 0. K = Îť. Since K corresponds to the empty pseudo  frame it cannot satisfy any formula so we let Î = â, likewise  Our original PSPACE hardness result relied only on â+â  and one of lead or trail. We have now considered excluding  both those operators. In each case the model checking problem  became polynomial. Note that our PSPACE-hardness result  only required one of Until and Since, and if we exclude  both, the USME-checking problem becomes polynomial. An  obvious question is whether we can get a hardness result using  only temporal connectives such as F , (and its dual G) or its  past time equivalent H. We will now outline why we cannot  do so.  112  100  will not be presatisďŹed. Clearly U (Îą, Î˛) is presatisďŹed if Î˛  is found everywhere in K and Îą occurs in K or we append a  structure to T that presatisďŹes U (Îą, Î˛).  â˘ Î¨0 = â, Î0 = â  â˘ for each i :  â If Ďi is of the form U (Îą, Î˛) or S (Îą, Î˛) then  â If ÂŹÎ˛ â  / Îiâ1 â§ (Îą â Îiâ1 â¨ Ďi â ÎŚ) then Î¨i =  Î¨iâ1 âŞ {Ďi }  â else Î¨i = Î¨iâ1 \ {Ďi }.  â for every integer j â [0, m] we let:      Îji , Î¨ji = A (Ij , (Î¨i âŠ S) âŞ (Î¨i âŠ U) , Ďi )  it cannot affect pre or postsatisfaction so Î¨ = ÎŚ.  Case 1. K is a letter:  â˘ Î0 = â, Î¨0 = â  â˘ for each i:  â We let Îi be a set such that Îi \{Ďi } = Îiâ1 \{Ďi }  /  and: if Ďi is of the form ÂŹÎą then Ďi â Îi iff Îą â  Îiâ1 ; if Ďi is of the form Îą â§ Î˛ then Ďi â Îi iff  Îą â Îiâ1 â§ Î˛ â Îiâ1 ; if Ďi is an atom then Ďi â Îi  iff Ďi â K; if Ďi â U âŞ S then Ďi â Îi iff Ď â ÎŚ.  â Ďi â Î¨ iff Ďi is of the form U (Îą, Î˛) or S (Îą, Î˛) and  either Îą â Îi or (Î˛ â Îi ) â§ (Ďi â ÎŚ).  â We let Î be the minimal expansion of În such that  for each Ďi , we have Ďi â Î iff Ďi â În and ÂŹĎi â  Î iff Ďi â  / În . We add the negations into Î so that  when we have an ME with multiple letters we can  express âÎą occurs everywhereâ as ÂŹÎą â  / Î.  Case 2. K = I + J : The construction for + is similar.  However, we ďŹrst build approximations for the subMEs I  and J . To understand the following construction note that the  formulas postsatisďŹed following J are the same as those following I +J , that is ÎŚâŠU. Likewise the formulas presatisďŹed  prior to I are the same as those presatisďŹed prior to I + J ,  that is (ÎŚ âŠ S). We iteratively call A using approximations to  I  ÎŚ. This works because each time we calculate Î¨J  i (or Î¨i ) the  approximation we pass is correct up to Ďi and A is structured  such that some later formula Ďj for j > i cannot affect whether  Ďi is included in the input. To see that the approximation is  correct up to Ďi take forexample the case where Ďi â S and  / U.  note that Î¨Iiâ1 âŠ S = Î¨Ii âŠ S as Ďi â  J  I  â˘ let Î¨0 = Î¨0 = â,  â˘ for each i :  â If Ďi â  / U âŞ S then let:           J J  Îi , Î¨i = A J , (ÎŚ âŠ U) âŞ Î¨Iiâ1 âŠ S , Ďi   I I          Îi , Î¨i = A I, (ÎŚ âŠ S) âŞ Î¨J  iâ1 âŠ U , Ďi  â˘    â Îi = 0â¤jâ¤m Îji  Î = În , Î¨ = Î¨ n .  â  â  The original model checking procedure from [17] unwinds I  â  â  into something of the form I0 + I1 + Âˇ Âˇ Âˇ + Im . The intuition  behind integer j below is that it indexes Ij in this expansion.  We handle â  â as an expansion of + so its deďŹnition below  mostly follows the approach for I + J . However, note that â  â  has a limit point on the left, and so at the left hand the since  operator behaves similarly to the shufďŹe.  â  â  Case 4. K = I :  â˘ let m be the number of instances of U in Ď.  0  m  â˘ let Î¨0 = Î¨0 = â,  â˘ for each i :  â let Î¨m+1  = ÎŚ âŠ U.  i  / S then let Î¨â1  = Î¨0iâ1 and for each j â  â If Ďi â  i  [0, m] from m down to 0 let:  â If Ďi â S is of the form S (Îą, Î˛) then      â If ÂŹÎ˛ â  / Î0iâ1 â§ Îą â Î0iâ1 â¨ Ďi â ÎŚ then Î¨â1  =  i  0  =  Î¨  \  {Ď  }.  Î¨0iâ1 âŞ {Ďi } else Î¨â1  i  iâ1  i      â for each j from 0 up to m let Îji , Î¨ji =            j+1  âŠ  S  âŞ  Î¨  âŠ  U  ,  Ď  A I, Î¨jâ1  i  i  iâ1   0      j  â˘ Î=  Î  ,  Î¨  =  Î¨  âŠ  U  âŞ (Î¨m  n  n âŠ S)  0â¤jâ¤m n  â  â  Case 5. K = I : Broadly similar to above, but the mirror  image. For example, the intuition behind integer j is now that  â  â  it indexes Ij of an expansion Im + Âˇ Âˇ Âˇ + I1 + I0 .  â˘ let m be the number of instances of S in Ď.  0  m  â˘ let Î¨0 = Î¨0 = â,  â˘ for each i :  â let Î¨m+1  = ÎŚ âŠ S.  i  / U then let Î¨â1  = Î¨0iâ1 and  â If Ďi â  i   for each  j â [0, m] from m down to 0 let Îji , Î¨ji =            j+1  âŠ  U  âŞ  Î¨  âŠ  S  ,  Ď  A I, Î¨jâ1  i  iâ1  i  â If Ďi â U then      â If ÂŹÎ˛ â  / Î0iâ1 â§ Îą â Î0iâ1 â¨ Ďi â ÎŚ then Î¨â1  =  i  =  Î¨  \  {Ď  }.  Î¨iâ1 âŞ {Ďi } else Î¨â1  iâ1  i  i      â for each j from 0 up to m let Îji , Î¨ji =            j+1  âŠ  U  âŞ  Î¨  âŠ  S  ,  Ď  A J , Î¨jâ1  i  i  iâ1  â If Ďi â U then let:           J J  Î , Î¨ = A J , (ÎŚ âŠ U) âŞ Î¨Iiâ1 âŠ S , Ďi   i I iI        J    Îi , Î¨i = A I, (ÎŚ âŠ S) âŞ Î¨i âŠ U , Ďi  â If Ďi â S then let:           I I  Îi , Î¨i = A I, (ÎŚ âŠ S) âŞ Î¨J  iâ1 âŠ U , Ďi           J J  Îi , Î¨i = A J , (ÎŚ âŠ U) âŞ Î¨Ii âŠ S , Ďi  I  I  J  J  Î = ÎIn âŞ ÎJ  n; Î¨ = Î¨n ;Î¨ = Î¨n ;  âŠ  S  Î¨ = Î¨In âŠ U âŞ Î¨J  n  Case 3. K = I0 , . . . , Im : Note that a shufďŹe is a dense mixture and so the fragment of a structure T corresponding K that  whatever occurs before (or after) a substructure corresponding  to Ii corresponds to K itself. When determining whether  U (Îą, Î˛) is presatisďŹed before a structure corresponding to K,  we see that if Î˛ is not true throughout K then we see that,  since K represents a dense mixture, even the smallest preďŹx of  the structure corresponding to K will have ÂŹÎ˛ and so U (Îą, Î˛)  â˘  113  101        Î = 0â¤jâ¤m Îjn , Î¨ = Î¨0n âŠ S âŞ (Î¨m  n âŠ U)  Note that we could eliminate the case where K = Îť, as  the algebraic equivalences in [20] could be used to reduce the  input ME I to an equivalent ME without Îť occurring (or the  trivial ME that contains only Îť, for which the model checking  problem is trivial as it has no points and thus cannot satisfy  any formula).  Kripke structures primarily results from these disjunctions  while in the model checking MEs the difďŹculty comes from  the operators â  â and â  â used to represent Zeno properties, and  is related to the difďŹculty with compressed paths.  It is interesting that the complexity of model-checking  in this context matches that of synthesis and satisďŹability.  Synthesis [12] and satisďŹability [16] checking L(U, S) are also  PSPACE-complete over the reals, and over general linear time  as well [23].  â˘  DeďŹnition 16. The âPolynomial Space Model Checking Procedureâ is as follows: given an ME I and formula Ď we return  âtrueâ iff Ď â Î where (Î, Î¨) = A (I, ÎŚ, Ď).  R EFERENCES  [1] H. Barringer, R. Kuiper, and A. Pnueli, âA really abstract concurrent  model and its temporal logic,â in Proceedings of 13th ACM Symposium  on Principles of Programming Languages, 1986, pp. 173 â 183.  [2] A. Sistla and E. Clarke, âComplexity of propositional linear temporal  logics,â J. ACM, vol. 32, pp. 733â749, 1985.  [3] P. Bouyer, N. Markey, J. Ouaknine, and J. Worrell, âOn expressiveness  and complexity in real-time model checking,â in Proc. of the 35th  Intl. Colloq. on Automata, Languages and Programming, Part II, ser.  ICALP â08. Berlin, Heidelberg: Springer-Verlag, 2008, pp. 124â135.  [4] R. Alur, C. Courcoubetis, and D. L. Dill, âModel-checking for real-time  systems,â in LICS. IEEE Computer Society, 1990, pp. 414â425.  [5] R. Alur and D. Dill, âAutomata for modeling real-time systems,â in  Automata, Languages and Programming, ser. LNCS, M. Paterson, Ed.  Springer Berlin / Heidelberg, 1990, vol. 443, pp. 322â335.  [6] N. Huggett, âZenosĚ paradoxes,â in The Stanford Encyclopedia of Philosophy, winter 2010 ed., E. N. Zalta, Ed., 2010.  [7] G. W. Wornell and A. V. Oppenheim, âEstimation of fractal signals  from noisy measurements using wavelets,â Signal Processing, IEEE  Transactions on, vol. 40, no. 3, pp. 611â623, 1992.  [8] P. J. Mosterman, âHybrid dynamic systems: mode transition behavior in  hybrid dynamic systems,â in Winter Simulation Conference, S. E. Chick  et al Eds. ACM, 2003, pp. 623â631.  [9] H. Kamp, âTense logic and the theory of linear order,â Ph.D. dissertation,  University of California, Los Angeles, 1968.  [10] R. Koymans, âSpecifying real-time properties with metric temporal  logic,â Real-time systems, vol. 2, no. 4, pp. 255â299, 1990.  [11] J. Ouaknine and J. Worrell, âSome recent results in metric temporal  logic,â in Formal Modeling and Analysis of Timed Systems. Springer,  2008, pp. 1â13.  [12] T. French, J. C. Mc Cabe-Dansted, and M. Reynolds, âSynthesis for  temporal logic over the reals,â in Advances in Modal Logic, T. Bolander,  T. BrauĚner, S. Ghilardi, and L. S. Moss, Eds. College Publications,  2012, pp. 217â238.  [13] H. LaĚuchli and J. Leonard, âOn the elementary theory of linear order,â  Fundamenta Mathematicae, vol. 59, pp. 109â116, 1966.  [14] J. P. Burgess and Y. Gurevich, âThe decision problem for linear temporal  logic,â Notre Dame J. Formal Logic, vol. 26, no. 2, pp. 115â128, 1985.  [15] M. Reynolds, âContinuous temporal models,â in Australian Joint Conference on ArtiďŹcial Intelligence, ser. Lecture Notes in Computer Science,  M. Stumptner et al, Eds., vol. 2256. Springer, 2001, pp. 414â425.  [16] ââ, âThe complexity of the temporal logic over the reals,â Annals of  Pure and Applied Logic, vol. 161, no. 8, pp. 1063â1096, 2010.  [17] T. French, J. Mc Cabe-Dansted, and M. Reynolds, âModel checking  general linear temporal logic,â 2013, accepted to appear in TABLEAU.  [18] J. C. Mc Cabe-Dansted, âModel checker for general linear time (online  applet and data),â 2012, http://www.csse.uwa.edu.au/âźmark/research/  Online/mechecker.html.  [19] N. Markey and P. Schnoebelen, âModel checking a path,â in CONCUR  2003-concurrency theory. Springer, 2003, pp. 251â265.  [20] T. French, J. Mc Cabe-Dansted, and M. Reynolds, âAn algebraic system  for linear orders,â 2013, accepted to appear in TIME 2013.  [21] S. A. Cook, âThe complexity of theorem-proving procedures,â in Proceedings of the third annual ACM symposium on Theory of computing,  ser. STOC â71. New York, NY, USA: ACM, 1971, pp. 151â158.  [22] L. J. Stockmeyer and A. R. Meyer, âWord problems requiring exponential time(preliminary report),â in Proceedings of the ďŹfth annual ACM  symposium on Theory of computing, ser. STOC â73. New York, NY,  USA: ACM, 1973, pp. 1â9.  [23] M. Reynolds, âThe complexity of temporal logics over linear time,â  Journal of Studies in Logic, vol. 3, pp. 19â50, 2010.  As this model checker is a reformulation of the modelchecker in [17], the proof of correctness is similar. We now  show that the USME-checking problem is in PSPACE.  Theorem  17.   We can solve the model checking problem in    2  O |I| |Ď| space.  Proof: Consider an obvious implementation of A as a  recursive function. We can discard ÎŚi and Î¨i after ÎŚi+1 and  Î¨i+1 have been computed. Each set of formulas can be stored  as an array of bits of length n, with the ith bit representing  whether Ďi is in the set and so the amount of space required  to store an array of formulas is |Ď|. We see that we only need  to store a number of such arrays of order |I| per recursion,  and the recursion depth is at most |I|. Hence we can solve  2  the model checking problem in space of order |I| |Ď|.  VI. C ONCLUSION  In this paper we have shown that the model checking problem for US/L formulas over Model Expressions is PSPACEComplete. We presented a simple recursive procedure which,  unlike [17], does not construct an ME or store interim MEs  and thus only requires polynomial space with regard to the  total length of input |I| + |Ď|. We have also proven a hardness  result by a reduction from QBF satisďŹability solving, giving  us PSPACE-completeness. Interestingly, it is known that the  USME-checking problem is polynomial if either the length of  the input formula or input model is ďŹxed [17] (but clearly not  if neither are ďŹxed, unless P=PSPACE). Our PSPACE-hardness  result is quite robust in the sense that it depends only upon +,  â  â, U and the classical operators; removing further operators  will result in a polynomial problem. Despite their semantic  complexity, shufďŹes do not contribute to the computational  complexity of the problem.  The complexity is quite similar to that of LTL which is also  PSPACE-complete for model checking against both Kripke  structures [2] and compressed paths [19]. Note that while  LTL is simpler than US/L, the Kripke models allow the LTL  model checker to non-deterministically pick loops through the  Kripke structure, an issue that the USME (and compressed  path) checker does not need to handle. Also, MEs do not have  disjunctions, and so MEs represent just one possible trace of  a system, whereas the traditional model checking problem of  LTL has the models represent systems which can have many  possible traces. The difďŹculty in model checking LTL against  114  102 