2013 20th International Symposium on Temporal Representation and Reasoning  Complexity of Model Checking over General Linear  Time  Tim French, John Mc Cabe-Dansted and Mark Reynolds  School of Computer Science and Software Engineering  The University of Western Australia  35 Stirling Highway, Crawley WA 6009  Perth, Australia.  Email: {tim.french,john.mccabe-dansted,mark.reynolds}@uwa.edu.au  with discrete points. If a sentence of natural language or some  strange formalism can determine the behaviour of a signal over  a linear order, we can check it.  Our second generalisation is more important. Timed automata are tremendously useful mathematical objects for veriÄÅ¹Âcation and design tasks [4], [5] but there are many properties  exhibited in the real continuous world that do not seem  amenable to easy modelling by their fundamental discrete step  by step action. To name just a few consider the following: the  approach of Achilles to ZenoÃ¢Â€Â™s Tortoise [6]; a fractal signal  [7] (see Figure 1); the inÄÅ¹Ânitesimal chattering of a sliding  controller [8] (like a perfect ABS braking system); or mathematically deÄÅ¹Âned hypothetical signals like one true at precisely  the irrational real numbers. An automaton allowing a cycle of  shorter and shorter durations may give an indication of the  possibility of some Zeno type behaviour but it does not allow  speciÄÅ¹Âcation of what happens after the accumulation point.  Furthermore, even developers of more conventional automatalike machines have to sometimes consider the behaviour of  their system with an environment that is less well-behaved  and they would beneÄÅ¹Ât from being able to describe a wide  range of environmental possibilities. In this paper, we allow  structures exhibiting any deÄÅ¹Ânable boolean signals.  A simple and long-established propositional temporal language adequate for our situation is L(U, S), the propositional  temporal language using KampÃ¢Â€Â™s Until and Since connectives [9]. We interpret L(U, S) over general linear ÄÅ¹Â‚ows and  call the logic US/L. If we restrict semantics to just the real  numbers then the logic is sometimes called RTLÃ¢Â€Â”roughly  Metric Temporal Logic [10], [11] without the metrics.  Recent work [12] addressed the problem of synthesis of  linear models of US/L formulasÃ¢Â€Â”ÄÅ¹Ânding an algorithm to  describe a linear model of any given satisÄÅ¹Âable formula. This  required a formal language for outputting details of models.  To do this, the paper presented a compositional language  for model expressions, building upon pioneering work by  [13], [14], [15], [16]. An abstract syntax with a few basic  composition operators allows an expression to specify how to  iteratively build an arbitrarily complex linear structure from  simple singleton point structures. This language is expressively  adequate, as any satisÄÅ¹Âable formula of US/L has a model  representable in this language [12].  AbstractÃ¢Â€Â”Temporal logics over general linear time allow  us to capture continuous properties in applications such as  distributed systems, natural language, message passing and A.I.  modelling of human reasoning. Linear time structures, however,  can exhibit a wide range of behaviours that are hard to reason  with, or even describe ÄÅ¹Ânitely. Recently, a formal language of  Model Expressions has been proposed to allow the convenient  ÄÅ¹Ânite description of an adequately representative range of these  generally inÄÅ¹Ânite structures. Given a model described in this  Model Expression language and a temporal logic formula, a  model checking algorithm decides whether the formula is satisÄÅ¹Âed  at some time in the model. Tools based on such algorithms would  support a wide variety of tasks such as veriÄÅ¹Âcation and counterexample investigation.  A previous paper gave an exponential space algorithm for the  problem of model checking Until/Since temporal formulas over  linear time Model Expressions. Here we prove that the problem is  actually PSPACE-complete. We present a new PSPACE algorithm  and we show PSPACE-hardness by a reduction from quantiÄÅ¹Âed  boolean formulas.  Keywords-Model Checking; Complexity; General Linear  Flows; Dense Time; Logic  I. I NTRODUCTION  Since [1] ÄÅ¹Ârst made the radical suggestion that a model  with a continuous ÄÅ¹Â‚ow of time might be better for handling  concurrent systems than traditional discrete temporal logics,  there has been steadily increasing development of appropriate  non-discrete formalisms, techniques, tools and their foundations. The important quality assurance task of veriÄÅ¹Âcation of  a system, formalised as model-checking, has developed from  simple checking of a Kripke structure against an LTL formula  in discrete time [2] to checking all traces of a timed automata  in continuous time against temporal metric constraints [3].  Here we also consider model checking of temporal properties in not necessarily discrete time models but we generalise  the problem in several important but related ways. We consider  any underlying linear models of time and we do not assume  that the structure to Ã¢Â€ÂœcheckÃ¢Â€Â has been generated by the action  of some ÄÅ¹Ânite mechanism moving from discrete state to discrete state. So time may be the non-negative reals or the natural  numbers but it may instead be the rationals or the integers  or some ÄÅ¹Ânite sequence of continuous intervals interspersed  The work was partially supported by the Australian Research Council.  1530-1311/13 $26.00 Ã‚Å  2013 IEEE  1550-1311/13  DOI 10.1109/TIME.2013.21  107  95                          ÄÅ¹Ânite duplications of submodels. By contrast [12] focussed on  expressively complete ÄÅ¹Ânite representations of inÄÅ¹Ânite/dense  structures, for which ÄÅ¹Ânite duplication is not required, so the  formalism has only operators for inÄÅ¹Ânite repeats of submodels.  Thus the actual model-checking algorithms end up being quite  different.  In section 2 we deÄÅ¹Âne the logic US/L and in section 3, we  deÄÅ¹Âne model expressions. Section 4 contains our PSPACEhardness result and section 5 presents the new PSPACE model  checking algorithm.                      Fig. 1.  An example of a fractal signal  II. T HE LOGIC  In this section, we introduce the logic US/L. We ÄÅ¹Ârst deÄÅ¹Âne  the temporal language L(U, S) of Until and Since. Then US/L  is just the logic of L(U, S) over the class of all structures with  a linear ÄÅ¹Â‚ow of time.  L(U, S) is a propositional language and we work with a  ÄÅ¹Âxed countable set L of atomic propositions (or atoms). A  frame (T, <), or ÄÅ¹Â‚ow of time, is any irreÄÅ¹Â‚exive linear order.  Structures T = (T, <, h) will have a frame (T, <) and a  valuation h for the atoms, i.e. for each atom p Ã¢ÂˆÂˆ L, h(p) Ã¢ÂŠÂ† T .  The well-formed formulas of L(U, S) are generated from  the atomic propositions by the 2-place connectives U and  S (both used in a preÄÅ¹Âx manner) along with the boolean  connectives Ã‚Å¹ and Ã¢ÂˆÂ§. That is, we deÄÅ¹Âne the set of formulas  recursively to contain the atoms and for formulas ÃÄ… and ÃË›, we  include Ã‚Å¹ÃÄ…, ÃÄ… Ã¢ÂˆÂ§ ÃË›, U (ÃÄ…, ÃË›) and S(ÃÄ…, ÃË›).  Formulas are evaluated at points in structures T =  (T, <, h). We write T, x |= ÃÄ… when ÃÄ… is true at point x Ã¢ÂˆÂˆ T .  This is deÄÅ¹Âned inductively as follows. Suppose that we have  deÄÅ¹Âned the truth of formulas ÃÄ… and ÃË›, at all points of T. Then  for all points x:  T, x |= p  iff x Ã¢ÂˆÂˆ h(p), for p atomic;  T, x |= Ã‚Å¹ÃÄ…  iff T, x |= ÃÄ…;  T, x |= ÃÄ… Ã¢ÂˆÂ§ ÃË›  iff both T, x |= ÃÄ… and T, x |= ÃË›;  T, x |= U (ÃÄ…, ÃË›) iff there is y > x in T such that  T, y |= ÃÄ… and for all z Ã¢ÂˆÂˆ T  such that x < z < y we have  T, z |= ÃË›; and  T, x |= S(ÃÄ…, ÃË›) iff there is y < x in T such that  T, y |= ÃÄ… and for all z Ã¢ÂˆÂˆ T  such that y < z < x we have  T, z |= ÃË›.  Along with standard logical abbreviations ÃÄ…Ã¢ÂˆÂ¨ÃË› = Ã‚Å¹(ÃÄ…Ã¢ÂˆÂ§ÃË›),  ÃÄ… Ã¢Â†Â’ ÃË› = Ã‚Å¹ÃÄ… Ã¢ÂˆÂ¨ ÃË›, and ÃÄ… Ã¢Â†Â” ÃË› = (ÃÄ… Ã¢Â†Â’ ÃË›) Ã¢ÂˆÂ§ (ÃË› Ã¢Â†Â’ ÃÄ…), we use  the following temporal abbreviations in illustrating the logic:  F ÃÄ… = U (ÃÄ…, ), Ã¢Â€Âœalpha will be true (sometime in the future)Ã¢Â€Â  GÃÄ… = Ã‚Å¹F (Ã‚Å¹ÃÄ…), Ã¢Â€Âœalpha will always hold (in the future)Ã¢Â€Â; and  their past time versions P and H.  Having ÄÅ¹Ânite representations for structures also opens the  possibility for an algorithm for model checking formulas  against those representations. Such a general linear time model  checking algorithm was presented for this problem in [17]. The  algorithm had complexity exponential in time and space.  Let us consider a example such as the fractal signals of, e.g.,  [7]. Figure 1 shows a simpliÄÅ¹Âed hypothetical fractal signal  where all spikes are upwards. Let p hold during periods of  increasing signal, q describe a decreasing one, and r represent  a constant signal. Assume that these propositions also hold  at the start and ends of the appropriate intervals. Using the  new notation of [12] can then represent the pattern of increments and decrements in this signal with the Model Expression r + {r, p} + p + {p, q} + q + {q, r} + r. Useful properties of this signal can be speciÄÅ¹Âed in L(U, S). For  example, we can reach a region of increment directly from  a constant region so r Ã¢ÂˆÂ§ U (p, r Ã¢ÂˆÂ¨ p) is satisÄÅ¹Âed within the  model. However, we cannot reach a region of decrement from  a region of increment, so r Ã¢ÂˆÂ§U (q, r Ã¢ÂˆÂ¨ q) is not satisÄÅ¹Âed within  the model. Checking such claims is the work of a modelchecking algorithm.  In this paper, we will show that model checking US/L  formulas against (general linear time) Model Expressions is  actually PSPACE-Complete. We show PSPACE-hardness by a  reduction from the satisÄÅ¹Âability problem for quantiÄÅ¹Âed boolean  formula. This hardness result is quite robust in the sense that it  only needs a fraction of the operators available, and removing  more operators results in a problem in P.  We then show that the problem is in PSPACE by giving  a polynomial space model checking algorithm. This is essentially an improved variant of the [17] algorithm. However, we  do not want to claim that the new algorithm would be better  for practical use. For this reason we have not implemented  the algorithm although an implementation of the original  algorithm is available [18].  There are some similarities between the model checking  task here and the task of model checking LTL formulas against  Ã¢Â€Âœcompressed pathsÃ¢Â€Â as described in [19]. In fact, we have been  able to follow a similar approach to theirs for our proof of  PSPACE-hardness. Like model expressions, the compressed  path formalism allows concise expressions of structures (but  there only ÄÅ¹Ânite discrete ones) via duplication of submodels.  However, the compressed paths of [19] were intended to  represent ÄÅ¹Ânite discrete paths efÄÅ¹Âciently and thus only allowed  III. B UILDING S TRUCTURES  As in [12], we deÄÅ¹Âne a notation which allows the description  of temporal structures. Each expression tells us how to build  a structure out of simple basic structures via four ways of  putting structures together to form larger ones.  The general idea is simple. Using singleton structuresÃ¢Â€Â”  the ÄÅ¹Â‚ow of time is one pointÃ¢Â€Â”we build up to more complex  108  96  structures by the iterative application of any of the operations.  There are four operations available:  1) concatenation of two structures, consisting of one followed by the other;  2) ÄÂ‰ repeats of some structure laid end to end towards the  past;  3) ÄÂ‰ repeats laid end to end towards the future;  4) and making a densely thorough shufÄÅ¹Â‚e of copies from a  ÄÅ¹Ânite set of structures.  These operations are well-known from the study of linear  orders (see e.g. [14]).  Model Expressions are an abstract syntax to deÄÅ¹Âne models  using the following set of primitive operators based on the  four operations:  Ã¢Â†Â  Ã¢ÂˆÂ’ Ã¢ÂˆÂ’  Ã¢Â†Â’  I ::= a | ÃÅ¥ | I + J | I | I | I0 , Ã‚Ë‡ Ã‚Ë‡ Ã‚Ë‡ , In   are important for modelling US/L formulas. Every satisÄÅ¹Âable  US/L formula ÄÂ† has an ME I such that a structure T that  corresponds to I will satisfy ÄÂ†, yet MEs are minimal in that  excluding any operator (except ÃÅ¥) will render them unable to  represent models for some US/L formulas.  We will give an illustration of the non-trivial operations  Ã¢Â†Â  Ã¢ÂˆÂ’  below. The lead operation, I = J has ÄÂ‰ submodels, each  corresponding to J , and each preceding the last, as illustrated  in Figure 2.  The trail operator is the mirror image of lead, whereby  Ã¢Â†Â’  Ã¢ÂˆÂ’  I = J has ÄÂ‰ structures, each corresponding to J and each  proceeding the earlier structures.  The shufÄÅ¹Â‚e operator is harder to represent with a diagram.  The model expression I = I1 , . . . In  corresponds to a dense,  thorough mixture of intervals corresponding to I1 , . . . , In ,  without endpoints. We deÄÅ¹Âne the shufÄÅ¹Â‚e operation using the  rationals, Q as they are a convenient order with the required  properties.  The deÄÅ¹Ânition of model expressions is not deterministic, as  the construct for the shufÄÅ¹Â‚e I1 , Ã‚Ë‡ Ã‚Ë‡ Ã‚Ë‡ , In  does not specify how  the structures corresponding to I1 , Ã‚Ë‡ Ã‚Ë‡ Ã‚Ë‡ , In are mapped to Q.  This is inconsequential, and as long as the mapping is dense  for each i from 1 to n, the resulting structures will be models  of the same formulas [12].  where a Ã¢ÂˆÂˆ ÃÅ = 2L so the letter indicates the atoms true at a  point. We refer to these operators, respectively, as a letter, the  empty order, concatenation, lead, trail, and shufÄÅ¹Â‚e.  DeÄÅ¹Ânition 1. [Correspondence] A model expression I corresponds to a structure as follows:  Ã¢Â€Ë˜ ÃÅ¥ is the empty sequence and corresponds to the (pseudo)  frame1 (Ã¢ÂˆÂ…, <, h) where < and h are empty relations.  Ã¢Â€Ë˜ a corresponds to any single point structure ({x}, <, h)  where < is the empty relation and h(p) = {x} if and  only if p Ã¢ÂˆÂˆ a.  Ã¢Â€Ë˜ I +J corresponds to a structure (T, <, h) if and only if T  is the disjoint union of two sets U and V where Ã¢ÂˆÂ€u Ã¢ÂˆÂˆ U ,  Ã¢ÂˆÂ€v Ã¢ÂˆÂˆ V , u < v and I corresponds to (U, <U , hU ) and J  corresponds to (V, <V , hV ). The symbols <U , hU refer  to the restriction of the relations < and h to apply only  to elements of U .  Ã¢Â†Â  Ã¢ÂˆÂ’  Ã¢Â€Ë˜ I corresponds to the structure (T, <, h) if and only if T  is the disjoint union of sets {Ui |i Ã¢ÂˆÂˆ ÄÂ‰} where for all i, for  all u Ã¢ÂˆÂˆ Ui , for all v Ã¢ÂˆÂˆ Ui+1 , v < u, and I corresponds  to (Ui , <Ui , hUi ).  Ã¢Â†Â’  Ã¢ÂˆÂ’  Ã¢Â€Ë˜ I corresponds to the structure (T, <, h) if and only if T  is the disjoint union of sets {Ui |i Ã¢ÂˆÂˆ ÄÂ‰} where for all i, for  all u Ã¢ÂˆÂˆ Ui , for all v Ã¢ÂˆÂˆ Ui+1 , u < v, and I corresponds  to (Ui , <Ui , hUi ).  Ã¢Â€Ë˜ I0 , Ã‚Ë‡ Ã‚Ë‡ Ã‚Ë‡ , In  corresponds to the structure (T, <, h) if and  only if T is the disjoint union of sets {Ui |i Ã¢ÂˆÂˆ Q} where  1) for all i Ã¢ÂˆÂˆ Q, (Ui , <Ui , hUi ) corresponds to some  Ij for j Ã¢Â‰Â¤ n,  2) for every j Ã¢Â‰Â¤ n, for every a = b Ã¢ÂˆÂˆ Q, there is some  k in the open interval (a, b) where Ij corresponds  to (Uk , <Uk , hUk ),  3) for every a < b Ã¢ÂˆÂˆ Q, for all u Ã¢ÂˆÂˆ Ua , for all v Ã¢ÂˆÂˆ Ub ,  u < v.  IV. H ARDNESS R ESULT  DeÄÅ¹Ânition 2. We deÄÅ¹Âne the USME-checking problem as  follows: given an ME I and formula ÄÂ†, determine whether  there exists a structure T = (T, <, h) corresponding to I and  point x Ã¢ÂˆÂˆ T such that T, x  ÄÂ†.  The reduction we will use to prove PSPACE-hardness will  be from satisÄÅ¹Âability of prenex QBF formulas. We now provide  a deÄÅ¹Ânition of these formulas.  DeÄÅ¹Ânition 3. A prenex QBF is a formula of the form  Ã¢ÂˆÂƒrn Ã¢ÂˆÂ€rnÃ¢ÂˆÂ’1 Ã‚Ë‡ Ã‚Ë‡ Ã‚Ë‡ Ã¢ÂˆÂƒr2 Ã¢ÂˆÂ€r1 ÄÂˆ where n is even and ÄÂˆ is a Boolean formula using only atoms in the set {r1 , . . . , rn }. A subformula  of a prenex QBF formula is a QBF formula. For QBF formulas  ÃÄ…, ÃË› and atom r we let ÃÄ… [r/ÃË›] be the formula obtained from  ÃÄ… by replacing each occurrence of the atom r with ÃË›. For  any Boolean formula ÄÂˆ and atom r, Ã¢ÂˆÂ€rÄÂˆ is equivalent to  ÄÂˆ [r/ ] Ã¢ÂˆÂ§ ÄÂˆ [r/Ã¢ÂŠÄ½] and Ã¢ÂˆÂƒrÄÂˆ is equivalent to Ã‚Å¹Ã¢ÂˆÂ€rÃ‚Å¹ÄÂˆ and hence  ÄÂˆ [r/ ] Ã¢ÂˆÂ¨ ÄÂˆ [r/Ã¢ÂŠÄ½].  We see that a prenex QBF is equivalent to a boolean formula  with all atoms replaced with or Ã¢ÂŠÄ½. As such, a prenex QBF  is equivalent to a theorem of Propositional Calculus iff it is  satisÄÅ¹Âable. We say that a prenex QBF evaluates to true iff it  is equivalent to a theorem (or equivalently, if it is satisÄÅ¹Âable).  The reduction from QBF satisÄÅ¹Âability solving to model  checking compressed paths [19] makes use of efÄÅ¹Âcient replication of identical submodels. In our reduction to MEs we  will use the Ã¢Â†Â  Ã¢ÂˆÂ’ operator to replicate submodels; however, this  gives us less ÄÅ¹Â‚exibility. Whereas [19] distinguished between  duplicated submodels by following one with an fn atom and  the other with a tn atom we instead use the Until operator to  To allow more elegant phrasing we take Ã¢Â€ÂœI corresponds  to TÃ¢Â€Â to be equivalent to Ã¢Â€ÂœT corresponds to IÃ¢Â€Â. The MEs  1 Of course, the empty pseudo-frame is not counted as a frame and we do  not allow empty structures.  109  97  J  ...  Fig. 2.  IÃ¢Â‰Ä„ e  e  I  I  e  e  I1  I1  J  J  Ã¢Â†Â  Ã¢ÂˆÂ’  The lead operation, where I = J  e  e  I  I  e  e  I2  I2  e ... e  e ... e  I  I  e  e  In  In  ..  .  e  e  I  I  e  e  ..  .  Fig. 3.  The shufÄÅ¹Â‚e operation, where I = I1 , Ã‚Ë‡ Ã‚Ë‡ Ã‚Ë‡ , In   deÄÅ¹Âne a formula ÃÄ…i to distinguish the last instance from the  ÄÅ¹Ârst. Using this trick we now deÄÅ¹Âne a reduction from testing  the satisÄÅ¹Âability of QBF formula to ME-checking as follows:  will now show that this reduction is correct and thus the MEchecking problem is PSPACE-hard. It can be convenient to  treat formulas as atoms, so we provide the deÄÅ¹Ânitions:  DeÄÅ¹Ânition 4. For the rest of this section we let J0 = Ã¢ÂˆÂ… and  Ã¢Â†ÂÃ¢ÂˆÂ’Ã¢ÂˆÂ’Ã¢ÂˆÂ’Ã¢ÂˆÂ’Ã¢ÂˆÂ’Ã¢ÂˆÂ’Ã¢ÂˆÂ’Ã¢ÂˆÂ’  let Ji = {pi } + JiÃ¢ÂˆÂ’1 + {qi } for each positive i, let ÃÄ…i =  Ã‚Å¹ (qi Ã¢ÂˆÂ¨ U (pi , Ã‚Å¹qi )), ÄÅ¹Âx a positive even integer n, let ÄÂ†q =  Ã¢ÂˆÂƒrn Ã¢ÂˆÂ€rnÃ¢ÂˆÂ’1 Ã‚Ë‡ Ã‚Ë‡ Ã‚Ë‡ Ã¢ÂˆÂƒr2 Ã¢ÂˆÂ€r1 ÄÂ† be some prenex QBF formula on the  set of atoms r1 , . . . , rn , and let ÄÂ† be the formula that results  when each ri is replaced by ÃÄ…i in the Boolean formula ÄÂ†.  We let ÄÂˆ0 = ÄÂ† and in general let ÄÂˆi = U (qi , pi Ã¢Â†Â’ ÄÂˆiÃ¢ÂˆÂ’1 )  for positive odd i and let ÄÂˆi = Ã‚Å¹ (U (qi , Ã‚Å¹ (pi Ã¢ÂˆÂ§ ÄÂˆiÃ¢ÂˆÂ’1 ))) for  positive even i. We reduce the problem Ã¢Â€ÂœIs the QBF formula  ÄÂ†q satisÄÅ¹ÂableÃ¢Â€Â to checking the L(U, S) formula pstart Ã¢Â†Â’ ÄÂˆn  against the ME {pstart } + Jn .  DeÄÅ¹Ânition 5. Say T = (T, <, h) is a structure, then T with  an L(U, S) formula ÃÄ… added as an atom is TÃÄ… = (T, <, h )  interpreted over the set of atoms LÃ¢ÂˆÅ{ÃÄ…} where h (p) = h (p)  for all p Ã¢ÂˆÂˆ L and for each point x Ã¢ÂˆÂˆ T we have x Ã¢ÂˆÂˆ h (ÃÄ…)  iff T, x  ÃÄ…. Where I is an ME we let I ÃÄ… be the ME that  results when ÃÄ… is added to every letter of I (not just letters at  which ÃÄ… would be satisÄÅ¹Âed). Given a set ÃÂ¨ = {ÃÄ…1 , . . . , ÃÄ…m }  of L(U, S) formulas and an ME I we deÄÅ¹Âne I ÃÂ¨ to be the  result I ÃÄ…1 Ã‚Ë‡Ã‚Ë‡Ã‚Ë‡ÃÄ…1 of replacing each letter a in I with a Ã¢ÂˆÅ ÃÂ¨.  Ã¢Â†Â  Ã¢ÂˆÂ’  Note that if any structure corresponds to I then it must also  Ã¢Â†Â  Ã¢ÂˆÂ’  correspond to I + I [20]. Using this we can easily prove the  next lemma inductively.  The truth of ÃÄ…i at qi points is unimportant to the correctness  of the reduction and so we could have deÄÅ¹Âned ÃÄ…i as being  just Ã‚Å¹U (pi , Ã‚Å¹qi ); however, ensuring ÃÄ…i is not true at the  same time as qi makes the formal statement and proof of  Lemma 6 below simpler. The intuition behind our choice of  ÄÂˆi is that ÃÄ…j will be true throughout the last (prior to {qi })  submodel corresponding to {pi } + Ji+1 , but false throughout  the previous such submodels. Thus U (qi , pi Ã¢Â†Â’ ÄÂˆiÃ¢ÂˆÂ’1 ) means  Ã¢Â€Âœfor points satisfying pi , including points where ÃÄ…i is false  and points where ÃÄ…i is true, it is the case that ÄÂˆiÃ¢ÂˆÂ’1 Ã¢Â€Â, and so  is used as our translation of Ã¢ÂˆÂ€ri . Likewise the intuition behind  Ã‚Å¹ (U (qi , Ã‚Å¹ (pi Ã¢ÂˆÂ§ ÄÂˆiÃ¢ÂˆÂ’1 ))) is that it requires ÄÂˆiÃ¢ÂˆÂ’1 at one of the  points satisfying pi , and we can choose from one of these  points that satisfy ÃÄ…i or the point which satisÄÅ¹Âes Ã‚Å¹ÃÄ…i . We  Lemma 6. For each i we let Ti = (T, <, h) be a structure  corresponding to Ji . The structure TÃÄ…1 Ã‚Ë‡Ã‚Ë‡Ã‚Ë‡ÃÄ…i with each ÃÄ…i  added as an atom corresponds to Ji where J  is deÄÅ¹Âned  recursively: J0 = Ã¢ÂˆÂ… and for each positive i we let Ji =  Ã¢Â†ÂÃ¢ÂˆÂ’Ã¢ÂˆÂ’Ã¢ÂˆÂ’Ã¢ÂˆÂ’Ã¢ÂˆÂ’Ã¢ÂˆÂ’Ã¢ÂˆÂ’  Ã¢ÂˆÂ’Ã¢ÂˆÂ’  ÃÄ…i  + {qi }.  {pi } + J  iÃ¢ÂˆÂ’1 + {pi , ÃÄ…i } + J  iÃ¢ÂˆÂ’1  Proof: The lemma is trivially true for i = 0. Say that    the lemma is correct up to i Ã¢ÂˆÂ’ 1, that is JiÃ¢ÂˆÂ’1  corresponds  Ã¢Â†ÂÃ¢ÂˆÂ’Ã¢ÂˆÂ’Ã¢ÂˆÂ’Ã¢ÂˆÂ’Ã¢ÂˆÂ’Ã¢ÂˆÂ’Ã¢ÂˆÂ’Ã¢ÂˆÂ’  ÃÄ…1 Ã‚Ë‡Ã‚Ë‡Ã‚Ë‡ÃÄ…iÃ¢ÂˆÂ’1  to TiÃ¢ÂˆÂ’1  . By deÄÅ¹Ânition {pi } + JiÃ¢ÂˆÂ’1 + {qi } and the  Ã¢Â†ÂÃ¢ÂˆÂ’Ã¢ÂˆÂ’Ã¢ÂˆÂ’Ã¢ÂˆÂ’Ã¢ÂˆÂ’Ã¢ÂˆÂ’Ã¢ÂˆÂ’Ã¢ÂˆÂ’  equivalent ME {pi } + JiÃ¢ÂˆÂ’1 + {pi } + JiÃ¢ÂˆÂ’1 + {qi } correspond  Ã¢Â†ÂÃ¢ÂˆÂ’Ã¢ÂˆÂ’Ã¢ÂˆÂ’Ã¢ÂˆÂ’Ã¢ÂˆÂ’Ã¢ÂˆÂ’Ã¢ÂˆÂ’Ã¢ÂˆÂ’Ã¢ÂˆÂ’  ÃÄ… Ã‚Ë‡Ã‚Ë‡Ã‚Ë‡ÃÄ…  to Ti . We see that Ti 1 iÃ¢ÂˆÂ’1 corresponds to {pi } + J  iÃ¢ÂˆÂ’1 +  110  98  {pi } + J  iÃ¢ÂˆÂ’1 + {qi }. Recall that ÃÄ…i = Ã‚Å¹ (qi Ã¢ÂˆÂ¨ U (pi , Ã‚Å¹qi )).  At the ÄÅ¹Ânal point qi is true so ÃÄ…i is false. The atom pi  does not occur within J  iÃ¢ÂˆÂ’1 so U (pi , Ã‚Å¹qi ) must be false  throughout the J  iÃ¢ÂˆÂ’1 immediately preceding {qi }; hence ÃÄ…i is  true there. As we have deÄÅ¹Âned Until to be strict, U (pi , Ã‚Å¹qi )  is also false at the last occurrence of pi . The atom qi does  Ã¢Â†ÂÃ¢ÂˆÂ’Ã¢ÂˆÂ’Ã¢ÂˆÂ’Ã¢ÂˆÂ’Ã¢ÂˆÂ’Ã¢ÂˆÂ’Ã¢ÂˆÂ’Ã¢ÂˆÂ’Ã¢ÂˆÂ’  not occur within {pi } + J  iÃ¢ÂˆÂ’1 so we see that U (pi , Ã‚Å¹qi ) is  ÃÄ… Ã‚Ë‡Ã‚Ë‡Ã‚Ë‡ÃÄ…  ÃÄ…  true when followed by pi . Hence Ti 1 iÃ¢ÂˆÂ’1 i corresponds to  Ã¢Â†Â  Ã¢ÂˆÂ’  Ã¢ÂˆÂ’  Ã¢ÂˆÂ’  Ã¢ÂˆÂ’  Ã¢ÂˆÂ’  Ã¢ÂˆÂ’  Ã¢ÂˆÂ’  Ã¢ÂˆÂ’  Ã¢ÂˆÂ’  ÃÄ…i  Ji = {pi } + J  iÃ¢ÂˆÂ’1 + {pi , ÃÄ…i } + J  iÃ¢ÂˆÂ’1  + {qi }. By induction  the lemma holds for all non-negative integers i.  From Lemma 6 we see that for any subset S Ã¢ÂŠÂ† [1, n] there  exists a point x Ã¢ÂˆÂˆ T such that for all i Ã¢ÂˆÂˆ [1, n] we have T, x   ÃÄ…i iff i Ã¢ÂˆÂˆ S. This is enough to give us NP-hardness. We see  that a USME-checker returns Ã¢Â€ÂœtrueÃ¢Â€Â, when given ÄÂ† and In as  input, precisely when ÄÂ† is satisÄÅ¹Âable. As we have a polynomial  time reduction from Boolean satisÄÅ¹Âability solving, an NP-hard  problem [21], we know the USME-checking problem is NPhard; however, the goal is to prove PSPACE-hardness and so  we need a reduction from a PSPACE-hard problem. Boolean  satisÄÅ¹Âability with alternating quantiÄÅ¹Âers is PSPACE-complete  (see for example [22]). SatisÄÅ¹Âability of QuantiÄÅ¹Âed Boolean  Formulas (QBF) is trivially reducible to satisÄÅ¹Âability of QBF  in prenex normal form, so we will only consider prenex QBF  and QBF that are subformulas of a prenex QBF.  ÃÂ¨Ã¢ÂˆÅÃÄ…  ÃÂ¨ + J  iÃ¢ÂˆÂ’1 i + {qi }.  We see that for each x Ã¢ÂˆÂˆ hU (pi ) either {pi , ÃÄ…i } Ã¢ÂˆÅ ÃÂ¨ or  {pi } Ã¢ÂˆÅ ÃÂ¨ corresponds to T{x} . We see that where {pi } Ã¢ÂˆÅ ÃÂ¨  corresponds to T{x} , x is immediately prior to an interval of  ÃÂ¨  points V such that TV corresponds to J  iÃ¢ÂˆÂ’1 . As i is a minimal  counter example i Ã¢ÂˆÂ’ 1 does not provide a counter example.  Thus T, x  ÄÂˆiÃ¢ÂˆÂ’1 iff ÄÂ†SiÃ¢ÂˆÂ’1 evaluates to true. Likewise if  {pi , ÃÄ…i } Ã¢ÂˆÅ ÃÂ¨ corresponds to T{x} we see that T, x  ÄÂˆiÃ¢ÂˆÂ’1  iff ÄÂ†SÃ¢ÂˆÅi  iÃ¢ÂˆÂ’1 evaluates to true. We now further divide the case of  i > 0 into odd and even cases.  Suppose i is odd. Then ÄÂˆi = U (qi , pi Ã¢Â†Â’ ÄÂˆiÃ¢ÂˆÂ’1 ) and ÄÂ†i =  Ã¢ÂˆÂ€ri ÄÂ†iÃ¢ÂˆÂ’1 . We see that T, z  ÄÂˆi is true precisely if for all x Ã¢ÂˆÂˆ  hU (pi ) we have T, x  ÄÂˆiÃ¢ÂˆÂ’1 . From the previous paragraph  we see that for the ÄÅ¹Ânal x Ã¢ÂˆÂˆ hU (pi ) we have T, x  ÄÂˆiÃ¢ÂˆÂ’1  iff ÄÂ†SÃ¢ÂˆÅi  iÃ¢ÂˆÂ’1 evaluates to true, and for the other x Ã¢ÂˆÂˆ hU (pi ) we  have T, x  ÄÂˆiÃ¢ÂˆÂ’1 iff ÄÂ†SiÃ¢ÂˆÂ’1 evaluates to true. Thus T, z  ÄÂˆiÃ¢ÂˆÂ’1  S  precisely if ÄÂ†SÃ¢ÂˆÅi  iÃ¢ÂˆÂ’1 and ÄÂ†iÃ¢ÂˆÂ’1 both evaluate to true; or in other  S  S  words ÄÂ†i = (Ã¢ÂˆÂ€rÄÂ†iÃ¢ÂˆÂ’1 ) is true. By contradiction, i is even.  As i is even, ÄÂˆi = Ã‚Å¹ (U (qi , Ã‚Å¹ (pi Ã¢ÂˆÂ§ ÄÂˆiÃ¢ÂˆÂ’1 ))) and ÄÂ†i =  Ã¢ÂˆÂƒri ÄÂ†iÃ¢ÂˆÂ’1 . We see that T, z  ÄÂˆi is true precisely if for some  x Ã¢ÂˆÂˆ hU (pi ) we have T, x  ÄÂˆiÃ¢ÂˆÂ’1 . There is such an x  S  iff either ÄÂ†SÃ¢ÂˆÅi  iÃ¢ÂˆÂ’1 or ÄÂ†iÃ¢ÂˆÂ’1 evaluate to true; or in other words  S  ÄÂ†Si = (Ã¢ÂˆÂƒri ÄÂ†iÃ¢ÂˆÂ’1 ) is true.  We have now shown that the minimal counter example i  cannot be zero, a positive odd number or a positive even  number. By contradiction, no counterexample exists.  This lemma demonstrates that our reduction from QBF is  correct, and gives us the following theorem:  DeÄÅ¹Ânition 7. Given a QBF formula ÃË› and set S Ã¢ÂŠÂ† {1, . . . , n},  we let ÃË› S be the formula that results when each free variable  if j Ã¢ÂˆÂˆ S and Ã¢ÂŠÄ½ if j Ã¢ÂˆÂˆ  / S. Let  rj in ÃË› is replaced with  ÄÂ†0 = ÄÂ†, for each positive odd i let ÄÂ†i = Ã¢ÂˆÂ€ri ÄÂ†iÃ¢ÂˆÂ’1 and for each  positive even i let ÄÂ†i = Ã¢ÂˆÂƒri ÄÂ†iÃ¢ÂˆÂ’1 .  Theorem 9. The USME-Checking problem is PSPACE-hard.  Note that the ÄÂ†n deÄÅ¹Âned above is the same as the prenex  QBF ÄÂ†q = Ã¢ÂˆÂƒrn Ã¢ÂˆÂ€rnÃ¢ÂˆÂ’1 Ã‚Ë‡ Ã‚Ë‡ Ã‚Ë‡ Ã¢ÂˆÂƒr2 Ã¢ÂˆÂ€r1 ÄÂ†. The following lemma then  demonstrates the existence of a reduction from satisÄÅ¹Âability  solving of QBF.  Note that a more traditional deÄÅ¹Ânition of the model checking  problem would only require us to determine whether the  formula is a satisÄÅ¹Âed at a particular point. Note that this  deÄÅ¹Ânition would still be PSPACE-hard as we are only interested in the truth of ÄÂˆn at the ÄÅ¹Ârst point of the reduction.  Also note that ÄÂˆn does not use the Since operator so limiting  formulas to those of L (U ) (or L (S), as the Since operator  is essentially just a mirror image of the until operator) would  still leave a PSPACE-hard model-checking problem. In the  next section we outline a polynomial space implementation for  USME-checking, showing that the USME-checking problem  is PSPACE-complete.  Note also that we used the qi atoms to assist in reasoning  about the correctness of the reduction. We do not claim  that this reduction is in any sense minimal. Consider, for  example, a smaller reduction similar to above but where  Ã¢Â†ÂÃ¢ÂˆÂ’Ã¢ÂˆÂ’Ã¢ÂˆÂ’Ã¢ÂˆÂ’Ã¢ÂˆÂ’Ã¢ÂˆÂ’Ã¢ÂˆÂ’Ã¢ÂˆÂ’Ã¢ÂˆÂ’Ã¢ÂˆÂ’  J0 = {p1 }, for each positive i we have Ji = {pi+1 } + JiÃ¢ÂˆÂ’1 ,  ÃÄ…i = U (pi , Ã‚Å¹pi+1 ) and we model check the formula ÄÂ†n  against the model Jn .  Note that this PSPACE-hardness result only requires MEs  with Ã¢Â†Â  Ã¢ÂˆÂ’ and + (not shufÄÅ¹Â‚es or Ã¢ÂˆÂ’  Ã¢Â†Â’) and does not require the  Since operator in the formula. Equivalently we could use  Ã¢Â†Â’ and + in the ME and exclude Until from the formula.  Ã¢ÂˆÂ’  Thus this result is quite robust to restrictions of the ME  Lemma 8. Let T = (T, <, h) be a structure corresponding  to Jn . Let T = (T, <, h ) = TÃÄ…1 Ã‚Ë‡Ã‚Ë‡Ã‚Ë‡ÃÄ…n . Let i Ã¢ÂˆÂˆ {0, . . . , n},  let S = {s1 , . . . , sm } be a subset of {i + 1, . . . , n}, let  ÃÂ¨ = {ÃÄ…s1 , . . . , ÃÄ…sm }. Finally, let U be an interval of points  ÃÂ¨  in T such that J  i corresponds to TU and z be a point  immediately prior to U . Then ÄÂ†Si evaluates to true precisely  if T, z  ÄÂˆi .  Proof: Assume that i is the smallest i that provides a  counterexample to this lemma.  We see that if i = 0 then there is one point x Ã¢ÂˆÂˆ U and that  TU corresponds to Ã¢ÂˆÂ…. We see that for each j we have x Ã¢ÂˆÂˆ  h (ÃÄ…j ) iff j Ã¢ÂˆÂˆ S, and further for a point z immediately prior  to x, we have x Ã¢ÂˆÂˆ h (ÃÄ…j ) Ã¢Â‡ÂÃ¢Â‡Â’ T, x  ÃÄ…j Ã¢Â‡ÂÃ¢Â‡Â’ T, z  ÃÄ…j .  Each atom rj in ÄÂ†Si = ÄÂ†S0 = ÄÂ†S has been substituted for  / S (and  or Ã¢ÂŠÄ½, for  if j Ã¢ÂˆÂˆ S (and T, z  ÃÄ…j ) or Ã¢ÂŠÄ½ if j Ã¢ÂˆÂˆ  T, z  Ã‚Å¹ÃÄ…j ). Thus T, z  ÄÂˆ0 iff ÄÂ†S evaluates to true.  Now consider i > 0. Recall that TU corresponds to  Ã¢Â†ÂÃ¢ÂˆÂ’Ã¢ÂˆÂ’Ã¢ÂˆÂ’Ã¢ÂˆÂ’Ã¢ÂˆÂ’Ã¢ÂˆÂ’Ã¢ÂˆÂ’Ã¢ÂˆÂ’Ã¢ÂˆÂ’Ã¢ÂˆÂ’ÃÂ¨Ã¢ÂˆÂ’Ã¢ÂˆÂ’  ÃÂ¨  J  i = {pi } Ã¢ÂˆÅ ÃÂ¨ + J  iÃ¢ÂˆÂ’1 + {pi , ÃÄ…i }Ã¢ÂˆÅ  111  99  next section terminating in polynomial time.  and/or formula. An obvious question is whether we can get  a result that is even stronger. We now consider some obvious  stronger restrictions, and show that all of these restrictions  lead to a problem in P. Given that we consider a number  of restrictions, and that a full discussion of their precise  complexity would require reference to the implementation in  [17], we do not consider each restriction in detail, for example  we will not discuss whether the restriction is P-hard. Note that,  in practice, the unrestricted ME-checking problem is fairly  easy. For example, the implementation in [17] performs well  on randomly generated problems and uses an amount of time  linear in the size of the model.  We have seen that we only need either lead or trail to  give PSPACE-hardness. The original decision procedure [17]  worked by expanding the ME to add formulas as atomic propositions. Adding each formula was polynomial but interactions  between Until and Ã¢Â†Â  Ã¢ÂˆÂ’ (likewise S and Ã¢ÂˆÂ’  Ã¢Â†Â’) could roughly  triple the size of the ME after adding a formula leading to  exponential growth of the ME. No other interactions led to  growth in the size of the ME. Thus the size of the ÄÅ¹Ânal ME  is the same as the input ME if we exclude both lead and trail,  and so we see the following proposition is true.  V. A P OLYNOMIAL S PACE I MPLEMENTATION  In this section we outline how to model check a formula ÄÂ†  against an ME I using only a polynomial amount of space.  We now deÄÅ¹Âne presatisfaction. Intuitively T = (T, <, h)  presatisÄÅ¹Âes U (ÃÄ…, ÃË›) means U (ÃÄ…, ÃË›) would be true at a point  immediately prior to all points in T .  DeÄÅ¹Ânition 13. We say that a structure T = (T, <, h) presatisÄÅ¹Âes U (ÃÄ…, ÃË›) iff there exists a y Ã¢ÂˆÂˆ T such that T, y  ÃÄ… and  for each x Ã¢ÂˆÂˆ T we have x < y Ã¢Â†Â’ T, x  ÃË›.  Postsatisfaction is similar but is the mirror image, so informally T = (T, <, h) postsatisÄÅ¹Âes S (ÃÄ…, ÃË›) means S (ÃÄ…, ÃË›)  would be true at a point immediately after all points in T .  As with [17], we iterate over the formulas from smallest  to largest; however, we do not actually modify the ME to  add atoms. The algorithm in [17] pushed down formulas as  atoms into an ME I so the result only depended on I and  the formulas of the form U (ÃÄ…, ÃË›) that were presatisÄÅ¹Âed after  the interval that corresponding to I and the formulas of the  form S (ÃÄ…, ÃË›) that were postsatisÄÅ¹Âed before the interval; in  this formulation we store the set ÃÂ¨ of such formulas instead  of extending I with new atoms.  Proposition 10. If we exclude both lead and trail from MEs  (or both until and since from formulas) the ME-checking  problem becomes polynomial  DeÄÅ¹Ânition 14. Let S be the set of formulas of the form  S (ÃÄ…, ÃË›) and U be the set of formulas of the form U (ÃÄ…, ÃË›).  Let ÄÂ†1 , . . . , ÄÂ†n be an enumeration of subformulas of the ÄÅ¹Âxed  formula ÄÂ† and negations of strict subformulas of ÄÂ† such that  for any i, j Ã¢ÂˆÂˆ [1, n] if ÄÂ†i is a subformula of ÄÂ†j then i Ã¢Â‰Â¤ j.  We let ÄÂ†Ã¢Â‰Â¤j be the set {ÄÂ†1 , . . . , ÄÂ†j }, and let deÄÅ¹Âne equivalence  up to j on sets of formulas S and T as follows S Ã¢Â‰ÂˆÃ¢Â‰Â¤j T iff  S Ã¢ÂˆÅ  ÄÂ†Ã¢Â‰Â¤j = T Ã¢ÂˆÅ  ÄÂ†Ã¢Â‰Â¤j .  If we exclude Ã¢Â€Âœ+Ã¢Â€Â from MEs we can see by induction  that Until and Since formulas are true either everywhere or  nowhere, and so adding formulas as atoms would not grow  the size of the ME. It is easy to see the following proposition  must be true.  Proposition 11. If we exclude Ã¢Â€Âœ+Ã¢Â€Â from MEs, the USMEchecking problem becomes polynomial.  Theorem 12. Model-checking a formula ÄÂ† in the fragment  L (F, P ) of L (U, S) against an ME I is in P.  Below we deÄÅ¹Âne a recursive function A. Informally,  A (I, ÃÅš, ÄÂ†) = (ÃÂ˜, ÃÂ¨) is intended to represent the statement:  if we have an interval TV that corresponds to I, ÃÅš is the set  of formulas in U presatisÄÅ¹Âed immediately after V in T and  formulas in S postsatisÄÅ¹Âed immediately before V in T then  it must be the case that the set of formulas satisÄÅ¹Âed within  TV is ÃÂ˜ and the set formulas in U presatisÄÅ¹Âed immediately  before V in T and formulas in S postsatisÄÅ¹Âed immediately  after V in T is ÃÂ¨. The formula ÄÂ† indicates that we are only  interested in whether ÄÂ† Ã¢ÂˆÂˆ ÃÂ˜ and so we can limit ourselves to  subformulas of ÄÂ† and their negations. The algorithm works by  generating increasing accurate approximations to (ÃÂ˜, ÃÂ¨) that  are accurate up to some subformula ÄÂ†j .  Proof: We see that as time advances an F formula can become false, but can never become true. Thus we can choose an  ordering F ÃË›1 , . . . , F ÃË›n of the n F -subformulas of ÄÂ† such that  for all i, j with i Ã¢Â‰Â¤ j we have F ÃË›j Ã¢Â†Â’ F ÃË›i true throughout I.  This means that the set of formulas presatisÄÅ¹Âed at some point  is one of the n + 1 values Ã¢ÂˆÂ…,{F ÃË›1 }, . . . , {F ÃË›1 , . . . , F ÃË›n }. We  can likewise order the m H-formulas. This means that the set  of pre and post-satisÄÅ¹Âed formulas takes one of (n + 1) (m + 1)  values, and will result in the implementation described in the  DeÄÅ¹Ânition 15. Let K be an ME, and ÃÅš be a set of formulae.  We deÄÅ¹Âne A (K, ÃÅš, ÄÂ†) to be the pair of sets of formulas (ÃÂ˜, ÃÂ¨)  as follows.  We consider various possible forms of K. The ÄÅ¹Ârst case  we consider is a letter. In the following construction we build  increasingly accurate approximations of (ÃÂ˜, ÃÂ¨): for each j we  have ÃÂ˜j Ã¢Â‰ÂˆÃ¢Â‰Â¤j ÃÂ˜ and ÃÂ¨j Ã¢Â‰ÂˆÃ¢Â‰Â¤j ÃÂ¨.  Case 0. K = ÃÅ¥. Since K corresponds to the empty pseudo  frame it cannot satisfy any formula so we let ÃÂ˜ = Ã¢ÂˆÂ…, likewise  Our original PSPACE hardness result relied only on Ã¢Â€Âœ+Ã¢Â€Â  and one of lead or trail. We have now considered excluding  both those operators. In each case the model checking problem  became polynomial. Note that our PSPACE-hardness result  only required one of Until and Since, and if we exclude  both, the USME-checking problem becomes polynomial. An  obvious question is whether we can get a hardness result using  only temporal connectives such as F , (and its dual G) or its  past time equivalent H. We will now outline why we cannot  do so.  112  100  will not be presatisÄÅ¹Âed. Clearly U (ÃÄ…, ÃË›) is presatisÄÅ¹Âed if ÃË›  is found everywhere in K and ÃÄ… occurs in K or we append a  structure to T that presatisÄÅ¹Âes U (ÃÄ…, ÃË›).  Ã¢Â€Ë˜ ÃÂ¨0 = Ã¢ÂˆÂ…, ÃÂ˜0 = Ã¢Âˆ  Ã¢Â€Ë˜ for each i :  Ã¢Â€Â“ If ÄÂ†i is of the form U (ÃÄ…, ÃË›) or S (ÃÄ…, ÃË›) then  Ã¢ÂˆÂ— If Ã‚Å¹ÃË› Ã¢ÂˆÂˆ  / ÃÂ˜iÃ¢ÂˆÂ’1 Ã¢ÂˆÂ§ (ÃÄ… Ã¢ÂˆÂˆ ÃÂ˜iÃ¢ÂˆÂ’1 Ã¢ÂˆÂ¨ ÄÂ†i Ã¢ÂˆÂˆ ÃÅš) then ÃÂ¨i =  ÃÂ¨iÃ¢ÂˆÂ’1 Ã¢ÂˆÅ {ÄÂ†i }  Ã¢ÂˆÂ— else ÃÂ¨i = ÃÂ¨iÃ¢ÂˆÂ’1 \ {ÄÂ†i }.  Ã¢Â€Â“ for every integer j Ã¢ÂˆÂˆ [0, m] we let:      ÃÂ˜ji , ÃÂ¨ji = A (Ij , (ÃÂ¨i Ã¢ÂˆÅ  S) Ã¢ÂˆÅ (ÃÂ¨i Ã¢ÂˆÅ  U) , ÄÂ†i )  it cannot affect pre or postsatisfaction so ÃÂ¨ = ÃÅš.  Case 1. K is a letter:  Ã¢Â€Ë˜ ÃÂ˜0 = Ã¢ÂˆÂ…, ÃÂ¨0 = Ã¢Âˆ  Ã¢Â€Ë˜ for each i:  Ã¢Â€Â“ We let ÃÂ˜i be a set such that ÃÂ˜i \{ÄÂ†i } = ÃÂ˜iÃ¢ÂˆÂ’1 \{ÄÂ†i }  /  and: if ÄÂ†i is of the form Ã‚Å¹ÃÄ… then ÄÂ†i Ã¢ÂˆÂˆ ÃÂ˜i iff ÃÄ… Ã¢ÂˆÂˆ  ÃÂ˜iÃ¢ÂˆÂ’1 ; if ÄÂ†i is of the form ÃÄ… Ã¢ÂˆÂ§ ÃË› then ÄÂ†i Ã¢ÂˆÂˆ ÃÂ˜i iff  ÃÄ… Ã¢ÂˆÂˆ ÃÂ˜iÃ¢ÂˆÂ’1 Ã¢ÂˆÂ§ ÃË› Ã¢ÂˆÂˆ ÃÂ˜iÃ¢ÂˆÂ’1 ; if ÄÂ†i is an atom then ÄÂ†i Ã¢ÂˆÂˆ ÃÂ˜i  iff ÄÂ†i Ã¢ÂˆÂˆ K; if ÄÂ†i Ã¢ÂˆÂˆ U Ã¢ÂˆÅ S then ÄÂ†i Ã¢ÂˆÂˆ ÃÂ˜i iff ÄÂ† Ã¢ÂˆÂˆ ÃÅš.  Ã¢Â€Â“ ÄÂ†i Ã¢ÂˆÂˆ ÃÂ¨ iff ÄÂ†i is of the form U (ÃÄ…, ÃË›) or S (ÃÄ…, ÃË›) and  either ÃÄ… Ã¢ÂˆÂˆ ÃÂ˜i or (ÃË› Ã¢ÂˆÂˆ ÃÂ˜i ) Ã¢ÂˆÂ§ (ÄÂ†i Ã¢ÂˆÂˆ ÃÅš).  Ã¢Â€Â“ We let ÃÂ˜ be the minimal expansion of ÃÂ˜n such that  for each ÄÂ†i , we have ÄÂ†i Ã¢ÂˆÂˆ ÃÂ˜ iff ÄÂ†i Ã¢ÂˆÂˆ ÃÂ˜n and Ã‚Å¹ÄÂ†i Ã¢ÂˆÂˆ  ÃÂ˜ iff ÄÂ†i Ã¢ÂˆÂˆ  / ÃÂ˜n . We add the negations into ÃÂ˜ so that  when we have an ME with multiple letters we can  express Ã¢Â€ÂœÃÄ… occurs everywhereÃ¢Â€Â as Ã‚Å¹ÃÄ… Ã¢ÂˆÂˆ  / ÃÂ˜.  Case 2. K = I + J : The construction for + is similar.  However, we ÄÅ¹Ârst build approximations for the subMEs I  and J . To understand the following construction note that the  formulas postsatisÄÅ¹Âed following J are the same as those following I +J , that is ÃÅšÃ¢ÂˆÅ U. Likewise the formulas presatisÄÅ¹Âed  prior to I are the same as those presatisÄÅ¹Âed prior to I + J ,  that is (ÃÅš Ã¢ÂˆÅ  S). We iteratively call A using approximations to  I  ÃÅš. This works because each time we calculate ÃÂ¨J  i (or ÃÂ¨i ) the  approximation we pass is correct up to ÄÂ†i and A is structured  such that some later formula ÄÂ†j for j > i cannot affect whether  ÄÂ†i is included in the input. To see that the approximation is  correct up to ÄÂ†i take forexample the case where ÄÂ†i Ã¢ÂˆÂˆ S and  / U.  note that ÃÂ¨IiÃ¢ÂˆÂ’1 Ã¢ÂˆÅ  S = ÃÂ¨Ii Ã¢ÂˆÅ  S as ÄÂ†i Ã¢ÂˆÂˆ  J  I  Ã¢Â€Ë˜ let ÃÂ¨0 = ÃÂ¨0 = Ã¢ÂˆÂ…,  Ã¢Â€Ë˜ for each i :  Ã¢Â€Â“ If ÄÂ†i Ã¢ÂˆÂˆ  / U Ã¢ÂˆÅ S then let:           J J  ÃÂ˜i , ÃÂ¨i = A J , (ÃÅš Ã¢ÂˆÅ  U) Ã¢ÂˆÅ ÃÂ¨IiÃ¢ÂˆÂ’1 Ã¢ÂˆÅ  S , ÄÂ†i   I I          ÃÂ˜i , ÃÂ¨i = A I, (ÃÅš Ã¢ÂˆÅ  S) Ã¢ÂˆÅ ÃÂ¨J  iÃ¢ÂˆÂ’1 Ã¢ÂˆÅ  U , ÄÂ†i  Ã¢Â€Ë˜    Ã¢Â€Â“ ÃÂ˜i = 0Ã¢Â‰Â¤jÃ¢Â‰Â¤m ÃÂ˜ji  ÃÂ˜ = ÃÂ˜n , ÃÂ¨ = ÃÂ¨ n .  Ã¢Â†Â  Ã¢ÂˆÂ’  The original model checking procedure from [17] unwinds I  Ã¢Â†Â  Ã¢ÂˆÂ’  into something of the form I0 + I1 + Ã‚Ë‡ Ã‚Ë‡ Ã‚Ë‡ + Im . The intuition  behind integer j below is that it indexes Ij in this expansion.  We handle Ã¢Â†Â  Ã¢ÂˆÂ’ as an expansion of + so its deÄÅ¹Ânition below  mostly follows the approach for I + J . However, note that Ã¢Â†Â  Ã¢ÂˆÂ’  has a limit point on the left, and so at the left hand the since  operator behaves similarly to the shufÄÅ¹Â‚e.  Ã¢Â†Â  Ã¢ÂˆÂ’  Case 4. K = I :  Ã¢Â€Ë˜ let m be the number of instances of U in ÄÂ†.  0  m  Ã¢Â€Ë˜ let ÃÂ¨0 = ÃÂ¨0 = Ã¢ÂˆÂ…,  Ã¢Â€Ë˜ for each i :  Ã¢Â€Â“ let ÃÂ¨m+1  = ÃÅš Ã¢ÂˆÅ  U.  i  / S then let ÃÂ¨Ã¢ÂˆÂ’1  = ÃÂ¨0iÃ¢ÂˆÂ’1 and for each j Ã¢ÂˆÂˆ  Ã¢Â€Â“ If ÄÂ†i Ã¢ÂˆÂˆ  i  [0, m] from m down to 0 let:  Ã¢Â€Â“ If ÄÂ†i Ã¢ÂˆÂˆ S is of the form S (ÃÄ…, ÃË›) then      Ã¢ÂˆÂ— If Ã‚Å¹ÃË› Ã¢ÂˆÂˆ  / ÃÂ˜0iÃ¢ÂˆÂ’1 Ã¢ÂˆÂ§ ÃÄ… Ã¢ÂˆÂˆ ÃÂ˜0iÃ¢ÂˆÂ’1 Ã¢ÂˆÂ¨ ÄÂ†i Ã¢ÂˆÂˆ ÃÅš then ÃÂ¨Ã¢ÂˆÂ’1  =  i  0  =  ÃÂ¨  \  {ÄÂ†  }.  ÃÂ¨0iÃ¢ÂˆÂ’1 Ã¢ÂˆÅ {ÄÂ†i } else ÃÂ¨Ã¢ÂˆÂ’1  i  iÃ¢ÂˆÂ’1  i      Ã¢ÂˆÂ— for each j from 0 up to m let ÃÂ˜ji , ÃÂ¨ji =            j+1  Ã¢ÂˆÅ   S  Ã¢ÂˆÅ  ÃÂ¨  Ã¢ÂˆÅ   U  ,  ÄÂ†  A I, ÃÂ¨jÃ¢ÂˆÂ’1  i  i  iÃ¢ÂˆÂ’1   0      j  Ã¢Â€Ë˜ ÃÂ˜=  ÃÂ˜  ,  ÃÂ¨  =  ÃÂ¨  Ã¢ÂˆÅ   U  Ã¢ÂˆÅ (ÃÂ¨m  n  n Ã¢ÂˆÅ  S)  0Ã¢Â‰Â¤jÃ¢Â‰Â¤m n  Ã¢Â†Â’  Ã¢ÂˆÂ’  Case 5. K = I : Broadly similar to above, but the mirror  image. For example, the intuition behind integer j is now that  Ã¢Â†Â’  Ã¢ÂˆÂ’  it indexes Ij of an expansion Im + Ã‚Ë‡ Ã‚Ë‡ Ã‚Ë‡ + I1 + I0 .  Ã¢Â€Ë˜ let m be the number of instances of S in ÄÂ†.  0  m  Ã¢Â€Ë˜ let ÃÂ¨0 = ÃÂ¨0 = Ã¢ÂˆÂ…,  Ã¢Â€Ë˜ for each i :  Ã¢Â€Â“ let ÃÂ¨m+1  = ÃÅš Ã¢ÂˆÅ  S.  i  / U then let ÃÂ¨Ã¢ÂˆÂ’1  = ÃÂ¨0iÃ¢ÂˆÂ’1 and  Ã¢Â€Â“ If ÄÂ†i Ã¢ÂˆÂˆ  i   for each  j Ã¢ÂˆÂˆ [0, m] from m down to 0 let ÃÂ˜ji , ÃÂ¨ji =            j+1  Ã¢ÂˆÅ   U  Ã¢ÂˆÅ  ÃÂ¨  Ã¢ÂˆÅ   S  ,  ÄÂ†  A I, ÃÂ¨jÃ¢ÂˆÂ’1  i  iÃ¢ÂˆÂ’1  i  Ã¢Â€Â“ If ÄÂ†i Ã¢ÂˆÂˆ U then      Ã¢ÂˆÂ— If Ã‚Å¹ÃË› Ã¢ÂˆÂˆ  / ÃÂ˜0iÃ¢ÂˆÂ’1 Ã¢ÂˆÂ§ ÃÄ… Ã¢ÂˆÂˆ ÃÂ˜0iÃ¢ÂˆÂ’1 Ã¢ÂˆÂ¨ ÄÂ†i Ã¢ÂˆÂˆ ÃÅš then ÃÂ¨Ã¢ÂˆÂ’1  =  i  =  ÃÂ¨  \  {ÄÂ†  }.  ÃÂ¨iÃ¢ÂˆÂ’1 Ã¢ÂˆÅ {ÄÂ†i } else ÃÂ¨Ã¢ÂˆÂ’1  iÃ¢ÂˆÂ’1  i  i      Ã¢ÂˆÂ— for each j from 0 up to m let ÃÂ˜ji , ÃÂ¨ji =            j+1  Ã¢ÂˆÅ   U  Ã¢ÂˆÅ  ÃÂ¨  Ã¢ÂˆÅ   S  ,  ÄÂ†  A J , ÃÂ¨jÃ¢ÂˆÂ’1  i  i  iÃ¢ÂˆÂ’1  Ã¢Â€Â“ If ÄÂ†i Ã¢ÂˆÂˆ U then let:           J J  ÃÂ˜ , ÃÂ¨ = A J , (ÃÅš Ã¢ÂˆÅ  U) Ã¢ÂˆÅ ÃÂ¨IiÃ¢ÂˆÂ’1 Ã¢ÂˆÅ  S , ÄÂ†i   i I iI        J    ÃÂ˜i , ÃÂ¨i = A I, (ÃÅš Ã¢ÂˆÅ  S) Ã¢ÂˆÅ ÃÂ¨i Ã¢ÂˆÅ  U , ÄÂ†i  Ã¢Â€Â“ If ÄÂ†i Ã¢ÂˆÂˆ S then let:           I I  ÃÂ˜i , ÃÂ¨i = A I, (ÃÅš Ã¢ÂˆÅ  S) Ã¢ÂˆÅ ÃÂ¨J  iÃ¢ÂˆÂ’1 Ã¢ÂˆÅ  U , ÄÂ†i           J J  ÃÂ˜i , ÃÂ¨i = A J , (ÃÅš Ã¢ÂˆÅ  U) Ã¢ÂˆÅ ÃÂ¨Ii Ã¢ÂˆÅ  S , ÄÂ†i  I  I  J  J  ÃÂ˜ = ÃÂ˜In Ã¢ÂˆÅ ÃÂ˜J  n; ÃÂ¨ = ÃÂ¨n ;ÃÂ¨ = ÃÂ¨n ;  Ã¢ÂˆÅ   S  ÃÂ¨ = ÃÂ¨In Ã¢ÂˆÅ  U Ã¢ÂˆÅ ÃÂ¨J  n  Case 3. K = I0 , . . . , Im : Note that a shufÄÅ¹Â‚e is a dense mixture and so the fragment of a structure T corresponding K that  whatever occurs before (or after) a substructure corresponding  to Ii corresponds to K itself. When determining whether  U (ÃÄ…, ÃË›) is presatisÄÅ¹Âed before a structure corresponding to K,  we see that if ÃË› is not true throughout K then we see that,  since K represents a dense mixture, even the smallest preÄÅ¹Âx of  the structure corresponding to K will have Ã‚Å¹ÃË› and so U (ÃÄ…, ÃË›)  Ã¢Â€Ë˜  113  101        ÃÂ˜ = 0Ã¢Â‰Â¤jÃ¢Â‰Â¤m ÃÂ˜jn , ÃÂ¨ = ÃÂ¨0n Ã¢ÂˆÅ  S Ã¢ÂˆÅ (ÃÂ¨m  n Ã¢ÂˆÅ  U)  Note that we could eliminate the case where K = ÃÅ¥, as  the algebraic equivalences in [20] could be used to reduce the  input ME I to an equivalent ME without ÃÅ¥ occurring (or the  trivial ME that contains only ÃÅ¥, for which the model checking  problem is trivial as it has no points and thus cannot satisfy  any formula).  Kripke structures primarily results from these disjunctions  while in the model checking MEs the difÄÅ¹Âculty comes from  the operators Ã¢Â†Â  Ã¢ÂˆÂ’ and Ã¢ÂˆÂ’  Ã¢Â†Â’ used to represent Zeno properties, and  is related to the difÄÅ¹Âculty with compressed paths.  It is interesting that the complexity of model-checking  in this context matches that of synthesis and satisÄÅ¹Âability.  Synthesis [12] and satisÄÅ¹Âability [16] checking L(U, S) are also  PSPACE-complete over the reals, and over general linear time  as well [23].  Ã¢Â€Ë˜  DeÄÅ¹Ânition 16. The Ã¢Â€ÂœPolynomial Space Model Checking ProcedureÃ¢Â€Â is as follows: given an ME I and formula ÄÂ† we return  Ã¢Â€ÂœtrueÃ¢Â€Â iff ÄÂ† Ã¢ÂˆÂˆ ÃÂ˜ where (ÃÂ˜, ÃÂ¨) = A (I, ÃÅš, ÄÂ†).  R EFERENCES  [1] H. Barringer, R. Kuiper, and A. Pnueli, Ã¢Â€ÂœA really abstract concurrent  model and its temporal logic,Ã¢Â€Â in Proceedings of 13th ACM Symposium  on Principles of Programming Languages, 1986, pp. 173 Ã¢Â€Â“ 183.  [2] A. Sistla and E. Clarke, Ã¢Â€ÂœComplexity of propositional linear temporal  logics,Ã¢Â€Â J. ACM, vol. 32, pp. 733Ã¢Â€Â“749, 1985.  [3] P. Bouyer, N. Markey, J. Ouaknine, and J. Worrell, Ã¢Â€ÂœOn expressiveness  and complexity in real-time model checking,Ã¢Â€Â in Proc. of the 35th  Intl. Colloq. on Automata, Languages and Programming, Part II, ser.  ICALP Ã¢Â€Â™08. Berlin, Heidelberg: Springer-Verlag, 2008, pp. 124Ã¢Â€Â“135.  [4] R. Alur, C. Courcoubetis, and D. L. Dill, Ã¢Â€ÂœModel-checking for real-time  systems,Ã¢Â€Â in LICS. IEEE Computer Society, 1990, pp. 414Ã¢Â€Â“425.  [5] R. Alur and D. Dill, Ã¢Â€ÂœAutomata for modeling real-time systems,Ã¢Â€Â in  Automata, Languages and Programming, ser. LNCS, M. Paterson, Ed.  Springer Berlin / Heidelberg, 1990, vol. 443, pp. 322Ã¢Â€Â“335.  [6] N. Huggett, Ã¢Â€ÂœZenosÄšÂ paradoxes,Ã¢Â€Â in The Stanford Encyclopedia of Philosophy, winter 2010 ed., E. N. Zalta, Ed., 2010.  [7] G. W. Wornell and A. V. Oppenheim, Ã¢Â€ÂœEstimation of fractal signals  from noisy measurements using wavelets,Ã¢Â€Â Signal Processing, IEEE  Transactions on, vol. 40, no. 3, pp. 611Ã¢Â€Â“623, 1992.  [8] P. J. Mosterman, Ã¢Â€ÂœHybrid dynamic systems: mode transition behavior in  hybrid dynamic systems,Ã¢Â€Â in Winter Simulation Conference, S. E. Chick  et al Eds. ACM, 2003, pp. 623Ã¢Â€Â“631.  [9] H. Kamp, Ã¢Â€ÂœTense logic and the theory of linear order,Ã¢Â€Â Ph.D. dissertation,  University of California, Los Angeles, 1968.  [10] R. Koymans, Ã¢Â€ÂœSpecifying real-time properties with metric temporal  logic,Ã¢Â€Â Real-time systems, vol. 2, no. 4, pp. 255Ã¢Â€Â“299, 1990.  [11] J. Ouaknine and J. Worrell, Ã¢Â€ÂœSome recent results in metric temporal  logic,Ã¢Â€Â in Formal Modeling and Analysis of Timed Systems. Springer,  2008, pp. 1Ã¢Â€Â“13.  [12] T. French, J. C. Mc Cabe-Dansted, and M. Reynolds, Ã¢Â€ÂœSynthesis for  temporal logic over the reals,Ã¢Â€Â in Advances in Modal Logic, T. Bolander,  T. BrauÄšÂˆner, S. Ghilardi, and L. S. Moss, Eds. College Publications,  2012, pp. 217Ã¢Â€Â“238.  [13] H. LaÄšÂˆuchli and J. Leonard, Ã¢Â€ÂœOn the elementary theory of linear order,Ã¢Â€Â  Fundamenta Mathematicae, vol. 59, pp. 109Ã¢Â€Â“116, 1966.  [14] J. P. Burgess and Y. Gurevich, Ã¢Â€ÂœThe decision problem for linear temporal  logic,Ã¢Â€Â Notre Dame J. Formal Logic, vol. 26, no. 2, pp. 115Ã¢Â€Â“128, 1985.  [15] M. Reynolds, Ã¢Â€ÂœContinuous temporal models,Ã¢Â€Â in Australian Joint Conference on ArtiÄÅ¹Âcial Intelligence, ser. Lecture Notes in Computer Science,  M. Stumptner et al, Eds., vol. 2256. Springer, 2001, pp. 414Ã¢Â€Â“425.  [16] Ã¢Â€Â”Ã¢Â€Â”, Ã¢Â€ÂœThe complexity of the temporal logic over the reals,Ã¢Â€Â Annals of  Pure and Applied Logic, vol. 161, no. 8, pp. 1063Ã¢Â€Â“1096, 2010.  [17] T. French, J. Mc Cabe-Dansted, and M. Reynolds, Ã¢Â€ÂœModel checking  general linear temporal logic,Ã¢Â€Â 2013, accepted to appear in TABLEAU.  [18] J. C. Mc Cabe-Dansted, Ã¢Â€ÂœModel checker for general linear time (online  applet and data),Ã¢Â€Â 2012, http://www.csse.uwa.edu.au/Ã¢ÂˆÅºmark/research/  Online/mechecker.html.  [19] N. Markey and P. Schnoebelen, Ã¢Â€ÂœModel checking a path,Ã¢Â€Â in CONCUR  2003-concurrency theory. Springer, 2003, pp. 251Ã¢Â€Â“265.  [20] T. French, J. Mc Cabe-Dansted, and M. Reynolds, Ã¢Â€ÂœAn algebraic system  for linear orders,Ã¢Â€Â 2013, accepted to appear in TIME 2013.  [21] S. A. Cook, Ã¢Â€ÂœThe complexity of theorem-proving procedures,Ã¢Â€Â in Proceedings of the third annual ACM symposium on Theory of computing,  ser. STOC Ã¢Â€Â™71. New York, NY, USA: ACM, 1971, pp. 151Ã¢Â€Â“158.  [22] L. J. Stockmeyer and A. R. Meyer, Ã¢Â€ÂœWord problems requiring exponential time(preliminary report),Ã¢Â€Â in Proceedings of the ÄÅ¹Âfth annual ACM  symposium on Theory of computing, ser. STOC Ã¢Â€Â™73. New York, NY,  USA: ACM, 1973, pp. 1Ã¢Â€Â“9.  [23] M. Reynolds, Ã¢Â€ÂœThe complexity of temporal logics over linear time,Ã¢Â€Â  Journal of Studies in Logic, vol. 3, pp. 19Ã¢Â€Â“50, 2010.  As this model checker is a reformulation of the modelchecker in [17], the proof of correctness is similar. We now  show that the USME-checking problem is in PSPACE.  Theorem  17.   We can solve the model checking problem in    2  O |I| |ÄÂ†| space.  Proof: Consider an obvious implementation of A as a  recursive function. We can discard ÃÅši and ÃÂ¨i after ÃÅši+1 and  ÃÂ¨i+1 have been computed. Each set of formulas can be stored  as an array of bits of length n, with the ith bit representing  whether ÄÂ†i is in the set and so the amount of space required  to store an array of formulas is |ÄÂ†|. We see that we only need  to store a number of such arrays of order |I| per recursion,  and the recursion depth is at most |I|. Hence we can solve  2  the model checking problem in space of order |I| |ÄÂ†|.  VI. C ONCLUSION  In this paper we have shown that the model checking problem for US/L formulas over Model Expressions is PSPACEComplete. We presented a simple recursive procedure which,  unlike [17], does not construct an ME or store interim MEs  and thus only requires polynomial space with regard to the  total length of input |I| + |ÄÂ†|. We have also proven a hardness  result by a reduction from QBF satisÄÅ¹Âability solving, giving  us PSPACE-completeness. Interestingly, it is known that the  USME-checking problem is polynomial if either the length of  the input formula or input model is ÄÅ¹Âxed [17] (but clearly not  if neither are ÄÅ¹Âxed, unless P=PSPACE). Our PSPACE-hardness  result is quite robust in the sense that it depends only upon +,  Ã¢Â†Â  Ã¢ÂˆÂ’, U and the classical operators; removing further operators  will result in a polynomial problem. Despite their semantic  complexity, shufÄÅ¹Â‚es do not contribute to the computational  complexity of the problem.  The complexity is quite similar to that of LTL which is also  PSPACE-complete for model checking against both Kripke  structures [2] and compressed paths [19]. Note that while  LTL is simpler than US/L, the Kripke models allow the LTL  model checker to non-deterministically pick loops through the  Kripke structure, an issue that the USME (and compressed  path) checker does not need to handle. Also, MEs do not have  disjunctions, and so MEs represent just one possible trace of  a system, whereas the traditional model checking problem of  LTL has the models represent systems which can have many  possible traces. The difÄÅ¹Âculty in model checking LTL against  114  102 