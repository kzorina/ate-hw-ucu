On-the-fly Automata Construction  for Dynamic Linear Time Temporal Logic  Laura Giordano  Università del Piemonte Orientale  Alessandria, Italy  laura@mfn.unipmn.it  Abstract  We present a tableau-based algorithm for obtaining a  Büchi automaton from a formula in Dynamic Linear Time  Temporal Logic (DLT L), a logic which extends LTL by indexing the until operator with regular programs. The construction of the states of the automaton is similar to the standard construction for LT L, but a different technique must  be used to verify the fulfillment of until formulas. The resulting automaton is a Büchi automaton rather than a generalized one. The construction can be done on-the-fly, while  checking for the emptiness of the automaton.  1. Introduction  The problem of constructing automata from Linear-Time  Temporal (LTL) formulas has been deeply studied [11]. The  interest on this problem comes from the wide use temporal logic for the verification of properties of concurrent systems. The standard approach to LTL model checking consists of translating the negation of a given LTL formula  (property) into a Büchi automaton, and checking the product of the property automaton and the model for language  emptiness. Therefore it is essential to keep the size of the  automaton as small as possible. A tableau-based algorithm  for efficiently constructing a Büchi automaton is presented  in [2]. This algorithm allows to build the graph “on the fly”  and in most cases builds quite small automata, although the  problem is intrinsically exponential. Further improvements  have been presented in [1, 8].  Dynamic Linear Time Temporal Logic (DLT L) [6] extends LTL by indexing the until operator with programs in  Propositional Dynamic Logic, and has been shown to be  strictly more expressive than LTL [6]. In [3, 4] we have developed an action theory based on DLTL and of its product version [5], and we have shown how to use it to model  multi-agent systems and to verify their properties, in particular by using model checking techniques. In [6] it is shown  Alberto Martelli  Università di Torino  Torino, Italy  mrt@di.unito.it  that the satisfiability problem for DLTL can be solved in exponential time, by reducing it to the emptiness problem for  Büchi automata. This motivates the interest in developing  efficient techniques for translating formulas into automata.  In this paper we present an efficient tableau-based algorithm for constructing a Büchi automaton from a DLTL formula. The construction of the states of the automaton is similar to the standard construction for LT L [2], but the possibility of indexing until formulas with regular programs  puts stronger constraints on the fulfillment of until formulas than in LTL, requiring more complex acceptance conditions. Thus we extend the structure of graph nodes and the  acceptance conditions by adapting a technique proposed in  [6]. The resulting automaton will be a Büchi automaton instead of a generalized Büchi automaton as in [2].  2. Dynamic Linear Time Temporal Logic  In this section we shortly define the syntax and semantics of DLTL as introduced in [6]. In such a linear time temporal logic the next state modality is indexed by actions.  Moreover, (and this is the extension to LTL) the until operator is indexed by programs in Propositional Dynamic Logic  (PDL).  Let Σ be a finite non-empty alphabet. The members of Σ  are actions. Let Σ∗ and Σω be the set of finite and infinite  words on Σ, where ω = {0, 1, 2, . . .}. Let Σ∞ =Σ∗ ∪ Σω .  We denote by σ, σ 0 the words over Σω and by τ, τ 0 the words  over Σ∗ . Moreover, we denote by ≤ the usual prefix ordering over Σ∗ and, for u ∈ Σ∞ , we denote by prf(u) the set  of finite prefixes of u.  We define the set of programs (regular expressions)  P rg(Σ) generated by Σ as follows:  P rg(Σ) ::= a | π1 + π2 | π1 ; π2 | π ∗  where a ∈ Σ and π1 , π2 , π range over P rg(Σ). A set of finite words is associated with each program by the mapping  ∗  [[]] : P rg(Σ) → 2Σ , which is defined as follows:  • [[a]] = {a};  • [[π1 + π2 ]] = [[π1 ]] ∪ [[π2 ]];  • [[π1 ; π2 ]] = {τ1 τ2 | τ1 ∈ [[π1 ]] and τ2 ∈ [[π2 ]]};  S  • [[π ∗ ]] = [[π i ]], where  A Büchi automaton over an alphabet Σ is a tuple B =  (Q, →, Qin , F ) where:  • Q is a finite nonempty set of states;  • →⊆ Q × Σ × Q is a transition relation;  • Qin ⊆ Q is the set of initial states;  • F ⊆ Q is a set of accepting states.  – [[π 0 ]] = {ε}  – [[π i+1 ]] = {τ1 τ2 | τ1 ∈ [[π]] and τ2 ∈ [[π i ]]},  for every i ∈ ω.  Let P = {p1 , p2 , . . .} be a countable set of atomic  propositions. The set of formulas of DLTL(Σ) is defined as  follows:  DLTL(Σ) ::= p | ¬α | α ∨ β | αU π β  where p ∈ P and α, β range over DLTL(Σ).  A model of DLTL(Σ) is a pair M = (σ, V ) where  σ ∈ Σω and V : prf (σ) → 2P is a valuation function.  Given a model M = (σ, V ), a finite word τ ∈ prf (σ) and  a formula α, the satisfiability of a formula α at τ in M , written M, τ |= α, is defined as follows:  • M, τ |= p iff p ∈ V (τ );  • M, τ |= ¬α iff M, τ 6|= α;  • M, τ |= α ∨ β iff M, τ |= α or M, τ |= β;  • M, τ |= αU π β iff there exists τ 0 ∈ [[π]] such that  τ τ 0 ∈ prf (σ) and M, τ τ 0 |= β. Moreover, for every  τ 00 such that ε ≤ τ 00 < τ 01 , M, τ τ 00 |= α.  A formula α is satisfiable iff there is a model M = (σ, V )  and a finite word τ ∈ prf (σ) such that M, τ |= α.  The formula αU π β is true at τ if “α until β” is true on a  finite stretch of behavior which is in the linear time behavior of the program π.  The derived modalities hπi and [π] can be defined as follows: hπiα ≡ >U π α and [π]α ≡ ¬hπi¬α.  Furthermore, if we let Σ = {a1 , . . . , an }, the U, O  (next),  3 and 2 of LTL can be defined as follows: Oα ≡  W  ∗  haiα,  αUβ ≡ αU Σ β, 3α ≡ >Uα, 2α ≡ ¬3¬α,  a∈Σ  ∗  where, in U Σ , Σ is taken to be a shorthand for the program a1 + . . . + an . Hence both LTL(Σ) and PDL are fragments of DLTL(Σ). As shown in [6], DLTL(Σ) is strictly  more expressive than LTL(Σ). In fact, as the logic ETL [10]  to which DLTL is inspired, DLTL has the full expressive  power of the monadic second order theory of ω-sequences.  3. Automaton Construction  In this section we show how to build a Büchi automaton for a given DLTL formula φ using a tableau-like procedure. The automaton generates all the infinite sequences  (models) satisfying the formula φ. First we recall the definition of Büchi automata.  1  We define τ ≤ τ 0 iff ∃τ 00 such that τ τ 00 = τ 0 . Moreover, τ < τ 0 iff  τ ≤ τ 0 and τ 6= τ 0 .  Let σ ∈ Σω . Then a run of B over σ is a map ρ : prf (σ) →  Q such that:  • ρ(ε) ∈ Qin  a  • ρ(τ ) → ρ(τ a) for each τ a ∈ prf (σ)  The run ρ is accepting iff inf(ρ) ∩ F 6= ∅, where inf(ρ) ⊆ Q  is given by: q ∈ inf (ρ) iff ρ(τ ) = q for infinitely many  τ ∈ prf (σ). Finally L(B), the language of ω-words accepted by B, is: L(B) = {σ|∃ an accepting run of B over  σ}.  Our aim is now to construct a Büchi automaton for a  given DLTL formula φ. We build a graph defining the states  and transitions of the automaton. A tableau-like procedure  allows a node to be expanded by applying propositional  rules as well as by expanding the temporal operators. It  will make use of a reformulation of the following axioms  of DLTL  in [6]2 :  W  a∈Σ hai>  W  W  0  αU π β ≡ (β ∨ (α ∧ a∈Σ hai π0 ∈δa (π) αU π β)),  for ε ∈ [[π]],  W  W  0  αU π β ≡ α ∧ a∈Σ hai π0 ∈δa (π) αU π β,  for ε 6∈ [[π]],  where  a  a  δa (π) = {π 0 |π −→ π 0 } and −→ is a transition relation  (defined in [6]) such that the program π 0 is obtained from  the program π by executing action a.  In our construction, we exploit the equivalence results  between regular expressions and finite automata and we  make use of an equivalent formulation of DLTL formulas  in which “until” formulas are indexed with finite automata  rather than regular expressions. Thus we have αU A β instead of αU π β, where L(A) = [[π]]. In fact, for each regular expression π there is an (²-free) nondeterministic finite  automaton A, accepting the language [[π]] generated by π.  Moreover the size of the automaton is linear in the size of  π [7]. Satisfiability of until formulas αU A β must be modified accordingly by replacing [[π]] with L(A) in the definition above3 .  More precisely, in the construction we will make use of  the following notation for automata. Let A = (Q, δ, QF )  be an ²-free nondeterministic finite automaton over the alphabet Σ without an initial state, where Q is a finite set of  2  3  Remember that haiα ≡ >U a α.  The idea of using finite state automata to label ”until” formulas is inspired both to the automata construction for DLTL in [6] and to the  automata construction for ETL in [9].  states, δ : Q × Σ → 2Q is the transition function, and QF is  the set of final states. Given a state q ∈ Q, we denote with  A(q) an automaton A with initial state q.  The two axioms above will thus be restated as follows:  W  W  0  αU A(q) β ≡ (β∨(α∧ a∈Σ hai q0 ∈δ(q,a) αU A(q ) β))  (q is a final state) W  W  0  αU A(q) β ≡ α ∧ a∈Σ hai q0 ∈δ(q,a) αU A(q ) β  (q is not a final state)  These formulas can  to be valid. Observe  W be easily proved  0  that the disjunction q0 ∈δ(q,a) αU A(q ) β is a finite disjunction, as the set of states q 0 in δ(q, a) is finite.  The main procedure to construct the Büchi automaton  for a formula φ builds a graph G(φ) whose nodes are labelled by sets of formulas, and which defines the states  and the transitions of the Büchi automaton. The procedure  makes use of an auxiliary tableau-based function which is  described in the next section.  3.1. Tableau computation  The tableau procedure we introduce makes use of signed  formulas, i.e. formulas prefixed with the symbol T or F.  This procedure takes as input a set of formulas4 and returns  a set of sets of formulas, obtained by expanding the input  set according to a set of tableau rules, formulated as follows:  φ ⇒ ψ1 , ψ2 , if φ belongs to the set of formulas, then add ψ1 and ψ2 to the set  φ ⇒ ψ1 |ψ2 , if φ belongs to the set of formulas, then make two copies of the set and add  ψ1 to one of them and ψ2 to the other one.  The rules are the following:  T(α ∧ β) ⇒ Tα, Tβ  F(α ∨ β) ⇒ Fα, Fβ  F(α ∧ β) ⇒ Fα|Fβ  T(α ∨ β) ⇒ Tα|Tβ  T¬α ⇒ Fα  F¬α ⇒ Tα  W  W  0  R1 TαU A(q) β ⇒ T(β∨(α∧ a∈Σ hai q0 ∈δ(q,a) αU A(q ) β))  (q is a final state)  W  W  0  R2 TαU A(q) β ⇒ T(α ∧ a∈Σ hai q0 ∈δ(q,a) αU A(q ) β)  (q is not a final state)  W  W  0  FαU A(q) β ⇒ F(β∨(α∧ a∈Σ hai q0 ∈δ(q,a) αU A(q ) β))  (q is a final state)  W  W  0  FαU A(q) β ⇒ F(α ∧ a∈Σ hai q0 ∈δ(q,a) αU A(q ) β)  (q is not a final state)  Given a set of formulas s, function tableau(s) works as  follows:  4  In this section we will always refer to signed formulas  • add T  W  a∈Σ hai>  to s,  • expand the set of formulas of s according to the above  rules (by possibly creating new sets) until all formulas  in all sets have been expanded,  • return the resulting set of sets.  W  Formula T a∈Σ hai> makes explicit that in DLTL each  state must be followed by a next state (O> is an axiom in  DLTL).  If the expansion of a set of formulas produces an inconsistent set, then this set is deleted (consistency constraint).  A set is inconsistent if it contains either “T⊥” or “F>” or  “Tα and Fα” or “Thaiα and Thbiβ with a 6= b”.  Observe that the expansion of an until formula αU A(q) β  only requires a finite number of steps, namely a number of  steps linear in the size of the automaton.  It is easy to see that for each set of formulas returned by  tableau there is exactly one symbol a ∈ Σ such that the  set contains  formulas of the form Thaiα. In fact, because  W  of T a∈Σ hai>, there must be at least one formula of that  kind, whereas the consistency constraint prevents from having more than one formula of the form Thaiα for different  symbols a ∈ Σ.  3.2. Building the graph  To build the graph we will consider each set of formulas obtained through the tableau construction as a node of  the graph. The above tableau rules do not expand formulas  of the kind haiα. Since the operator hai is a next state operator, expanding this kind of formulas from a node n means  to create a new node containing α connected to n through  an edge labelled with a. Given a node n containing a formula Thaiα, then the set of nodes connected to n through  an edge labelled a is given by tableau({Tα|Thaiα ∈ n} ∪  {Fα|Fhaiα ∈ n}).  States and transitions of the Büchi automaton are obtained directly from the nodes and edges of the graph. While  we will give later the details of the construction of the automaton, we want now to address the problem of defining  accepting conditions. Intuitively this has to do with until  formulas, i.e. formulas of the form TαU A(q) β. If a node n  of the graph contains the formula TαU A(q) β, then we will  accept an infinite path containing this node if it is followed  in the path by a node n0 containing Tβ and TαU A(qF ) β,  where qF is a final state of A. Furthermore if τ is the sequence of labels in the path from n to n0 , then τ must belong to L(A(q)), and all nodes between n and n0 must contain Tα.  This problem has been solved in LTL by imposing generalized Büchi acceptance conditions. In our formulation they  could be stated as follows: For each subformula αU β of the  Figure 1. (a) automaton A and (b) graph for  2hA(s1 )ip  initial formula there is a set F of accepting states including all the nodes q ∈ Q such that either TαUβ is not contained in the node or Tβ holds. Unfortunately a similar solution does not apply in the case of DLTL, because acceptance of until formulas is more constrained than in LTL.  Let us consider for instance the formula 2hA(s1 )ip,  with Σ = {a}. The automaton A is given in Figure 1(a).  By eliminating the derived modalities, this formula can be  rewritten as the signed formula F(>U A1 (s0 ) ¬(>U A(s1 ) p)),  where the automaton A1 has only one (final) state s0 connected to itself through a transition labelled a. By applying  the above construction starting from this formula, we obtain  the graph in Figure 1(b), where for simplicity we have kept  only the most significant formulas. Every node of this graph  contains a formula T(>U A(s1 ) p), and the only node which  might fulfill the until formulas is node n3 , since it contains  T(>U A(s3 ) p), with s3 final, and Tp. However it is easy to  see that not all infinite paths through n3 will be accepting.  For instance, in the path n1 , n2 , n3 , n4 , n3 , n4 , n3 , n4 , . . .  no occurrence of n3 fulfills the formula T(>U A(s1 ) p) in n2 ,  since the distance in this path between node n2 and any occurrence of n3 is odd, while all strings in L(A(s1 )) have  even length.  We present now a different solution, derived from  [6], where some of the nodes will be duplicated to  avoid the above problem. Before describing the construction of the graph, we make the following observation. Let us assume that a node n contains the until formula  TαU A(q) β, such that q is not a final state. Since this formula has been  W expanded with0 (R2), node n will also  contain Thai q0 ∈δ(q,a) αU A(q ) β for some a. Therefore, according to the construction of the successor nodes,  0  each successor node will contain a formula TαU A(q ) β,  where q 0 ∈ δ(q, a). We say that this until formula is derived from formula TαU A(q) β in node n. On the other  hand, if q is a final state, then TαU A(q) β has been expanded with (R1), and two cases are possible: either n  contains Tβ or all successor nodes contain a derived until formula as described above.  If a node contains an until formula which is not derived  from a predecessor node, we will say that the formula is  new. New until formulas are obtained during the expansion  of the tableau procedure. It is easy to see that if TαU A(q) β  is a new formula, then αU A(q) β must be a subformula of  the initial formula. For instance, the formula T(>U A(s1 ) p)  is new in each of the nodes in Figure 1. Note that an until formula in a node might be both a derived and a new formula. In that case we will consider it as a derived formula.  We can now show how the graph can be built and how  the accepting conditions are formulated. Each node of the  graph is a triple (F, x, f ), where √  F is an expanded set of  formulas, x ∈ {0, 1}, and f ∈ {↓, }.  In order to formulate the accepting condition, we must be  able to trace the until formulas along the paths of the graph  to make sure that they satisfy the until condition. Therefore  we extend signed formulas so that all until formulas have  a label 0 or 1, i.e. they have the form Tl αU A(q) β where  l ∈ {0, 1}.  For each node (F, x, f ), the label of an until formula in  F will be assigned as follows. If it is a derived until formula, then its label is the same as that of the until formula  in the predecessor node it derives from. Otherwise, if the  formula is new, it is given the label 1 − x. Of course function tableau must be suitably modified in order to propagate the label from an until formula to its derived formulas  in the successor nodes, and to give the right label to new formulas. To do this we assume that it has two parameters: a  set of formulas and the value of x.  Function create graph in Figure 2 builds a graph G(φ),  given an initial formula φ, by returning the triple hQ, I, ∆i,  where Q is the set of nodes, I the set of initial nodes and  ∆ : Q × Σ × Q the set of labelled edges.  Note that two formulas T0 αU A(q) β and T1 αU A(q) β are  considered to be different. For instance, by applying create graph to the formula of Figure 1, we get two nodes  ({T0 (>U A(s1 ) p), T0 (>U A(s2 ) p), T1 (>U A(s4 ) p)}, ↓, 1)  and  ({T0 (>U A(s1 ) p), T0 (>U A(s2 ) p), T0 (>U A(s4 ) p),  T1 (>U A(s2 ) p)}, ↓, 1).  These two nodes correspond to node n4 in Figure 1.  States and transitions of the Büchi automaton B(φ) are  obtained directly from the nodes and edges of the graph.  The set of accepting states√consists of all states whose associated node contains f = .  Let ρ be a run of B(φ). Since we identify states of the automaton with nodes of the graph, ρ can also be considered  as an infinite path of G(φ), and ρ(τ ) will denote a node of  such a graph. According to the construction of the graph, the  function create graph(φ)  I := ∅  for all F ∈ tableau({Tφ},  0)  √  I := I ∪ {(F, 0, )}  end-for  U := Q := I  ∆ := ∅  while U 6= ∅ do  remove√n = (F, x, f ) from U  if f = then  x0 := 1 − x  else  x0 := x  end-if  for all F 0 ∈ tableau({Tα|Thaiα ∈ F}∪  {Fα|Fhaiα ∈ F}, x0 )  √  if f = then  f 0 :=↓  0  else if there exists  no Tx αU A(q) β ∈ F 0 then  √  f 0 :=  else  f 0 :=↓  end-if  end-if  n0 := (F 0 , x0 , f 0 )  if ∃n00 ∈ Q such that n00 = n0 then  ∆ := ∆ ∪ {(n, a, n00 )}  else  Q := Q ∪ {n0 }  ∆ := ∆ ∪ {(n, a, n0 )}  U := U ∪ {n0 }  end-if  end-for  end-while  return hQ, I, ∆i  √  √  (0, ), (1, ↓), . . . , (1, ↓), (1, ), (0, ↓), . . . , (0, ↓),  √  (0, ), · · ·  Let us call 0-sequences or 1-sequences the sequences of  nodes of ρ with x = 0 or x = 1 respectively. If ρ is an accepting √  run, then it must contain infinitely many nodes containing , and thus all 0-sequences and 1-sequences must  be finite.  Intuitively, every until formula contained in a node of a  0-sequence must be fulfilled within the end of the next 1sequence, and vice versa. In fact, assuming that the formula  has label 1, the label will be propagated to all derived formulas in the following nodes until a node is found fulfilling  the until formula. But, on the other hand, the 1-sequence terminates only when there are no more until formulas with label 1, and thus that node must be met before the end of the  next 1-sequence.  3.3. Correctness of the procedure  The next proposition summarizes what we have already  pointed out in the previous section.  Proposition 1 Assume that a node n of the graph contains  Tl αU A(q) β, and let a be the label of the outgoing edges (remember that all outgoing edges from a node have the same  label). Then the following holds:  if q is not a final state of A  node n contains Tα and each outgoing edge  leads to a node containing an until formula  0  Tl αU A(q ) β derived from Tl αU A(q) β in n, such  0  that q ∈ δ(q, a)  else, if q is a final state of A, either  (a) node n contains Tβ and no successor node  contains a formula derived from Tl αU A(q) β, or  (b) node n contains Tα and each outgoing edge  leads to a node containing a derived until formula  0  Tl αU A(q ) β, such that q 0 ∈ δ(q, a)  Figure 2. Function create graph  x and f values of the nodes of ρ have the following properties:  √  • if a node contains (0, ) then its successor node contains (1, ↓)  √  • if a node contains (1, ) then its successor node contains (0, ↓)  Given a run ρ, we will denote with ρ(τ ).F the F field of  the node ρ(τ ), and similarly for the x and f fields.  • if a node contains (0, ↓)√then its successor node contains either (0, ↓) or (0, )  1. ∀τ 0 s.t. τ τ 0 ∈ prf (σ) : Tl αU A(q ) β ∈ ρ(τ τ 0 ).F and  ∗  q 0 ∈ δA  (q, τ 0 ) 5  • if a node contains (1, ↓)√then its successor node contains either (1, ↓) or (1, )  2. ∃τ 0 s.t. τ τ 0 ∈ prf (σ) : Tl αU A(q ) β ∈ ρ(τ τ 0 ).F, q 0  ∗  is a final state, q 0 ∈ δA  (q, τ 0 ), Tβ ∈ ρ(τ τ 0 ).F and no  Therefore the sequence of the x and f values in ρ will be as  follows:  Proposition 2 Let σ ∈ Σω and ρ : prf (σ) −→ Q be a  (non necessarily accepting) run. For each τ ∈ prf (σ), let  ρ(τ ) = (F, x, f ). Then for each Tl αU A(q) β ∈ F one of  the following holds:  0  0  5  ∗ is the obvious extension of δ to sequences  δA  A  successor node of ρ(τ τ 0 ) contains an until formula de0  rived from Tl αU A(q ) β. Moreover, for every τ 00 such  that ε ≤ τ 00 < τ 0 , Tα ∈ ρ(τ τ 00 ).F.  For each FαU A(q) β ∈ F the following holds:  3. ∀τ 0 s.t. τ τ 0 ∈ prf (σ): if τ 0 ∈ L(A(q)) then either  Fβ ∈ ρ(τ τ 0 ).F or there is τ 00 such that ε ≤ τ 00 <  τ 0 , Fα ∈ ρ(τ τ 00 ).F.  Proof It follows from Proposition 1 and procedure create graph.  In an accepting run, case (2) must hold for all until formulas and all nodes. This is proved in the following theorem, together with its converse.  Theorem 1 Let σ ∈ Σω and ρ : prf (σ) −→ Q be a run.  Then, for each τ ∈ prf (σ) and for each Tl αU A(q) β ∈  ρ(τ ).F, condition (2) of Proposition 2 holds if and only if ρ  is an accepting run.  Proof If part: ρ is an accepting run. As pointed out before  the nodes of ρ are arranged in alternating 0-sequences and  1-sequences of finite length. Then we can have the following cases:  a) l = 0 and ρ(τ ).x = 0. Let us assume that condition  (1) of Proposition 2 holds. Then each node ρ(τ τ 0 ) following ρ(τ ) in the same 0-sequence, will contain a derived formula T0 αU A(q) β (remember that the label of  a derived formula cannot change). On the other hand,  the 0-sequence containing ρ(τ ) is finite, and, by construction, the last node of this sequence does not contain any until formula labelled with 0. Therefore the  assumption is wrong, and condition (2) must hold.  b) l = 1 and ρ(τ ).x = 1. As case (a).  c) l = 1 and ρ(τ ).x = 0. Let us assume again that condition (1) of Proposition 2 holds. Then each node ρ(τ τ 0 )  following ρ(τ ) will contain an until formula derived  from T1 αU A(q) β in ρ(τ ). All derived formulas will be  labelled 1 up to the last node of the 0-sequence. This  label will necessarily propagate to the first node of the  following 1-sequence, and we fall in case (b).  d) l = 0 and ρ(τ ).x = 1. As case (c).  Only if: condition (2) holds. We show that all 0 and  1-sequences of ρ are finite. This is true for the initial 0sequence, which consists only of the first node. Let us assume now that a 0-sequence is finite. We show that the following 1-sequence is also finite. According to the construction, the last node of the 0-sequence can contain only until formulas with label 1. The following 1-sequence goes  on until its nodes contain some until formula with label 1.  Since condition (2) holds, for each of these until formulas  there is a τ 0 such that the successor node of ρ(τ τ 0 ) does not  contain an until formula derived from it. On the other hand  all new until formulas created in this 1-sequence will have  label 0. Therefore, if τ max is the longest among all τ 0 , after node ρ(τ τ max ) there will be no until formula labelled  with 1, and the 1-sequence will terminate. The same holds  by replacing 0 with 1 and vice versa.  Lemma 1 Let s beVa set of  W formulas  V and tableau(s) =  {s1 , . . . , sn }. Then s ↔ 1≤i≤n si .  Proof All rules used by the function tableau correspond to  equivalence formulas.  Lemma 2 Let M = (σ, V ) be a model, τ ∈ prf (σ), and  let  such that M, τ |=  V n = (F, x, f ) be a node of the graph  0  F. Then there exists  a  successor  n  =  (F 0 , x0 , f 0 ) of n  V 0  such that M, τ a |= F , where τ a ∈ prf (σ). Moreover, if  TαU A(q) β ∈ F 0 where q is a final state and M, τ a |= Tβ,  then Tβ ∈ F 0 .  Proof The proof comes from the construction and the previous lemma. In particular the last part holds if, when expanding TαU A(q) β in F 0 with rule (R1), we choose the set  containing Tβ.  Theorem 2 Let M = (σ, V ) and M, ε |= φ. Then σ ∈  L(B(φ)).  Proof We show how to build an accepting run ρ of B(φ)  over σ. The first node of ρ is chosen by taking an initial  V  node n = (F, x, f ) of the graph such that M, ε |= F.  The following nodes of ρ are chosen by repeatedly applying  Lemma 2. To prove that the run is an accepting run, we have  to show that all the until formulas are fulfilled. Assume that  TαU A(q) β occurs on the run at ρ(τ ). Then, for the choice  of the run ρ, it must be that M, τ |= αU A(q) β. By definition of satisfiability we have that there exists τ 0 ∈ L(A(q))  such that τ τ 0 ∈ prf (σ) and M, τ τ 0 |= β. Moreover, for  every τ 00 such that ε ≤ τ 00 < τ 0 , M, τ τ 00 |= α. As  τ 0 ∈ L(A(q)), by the choice of run ρ and the construction  ∗  of the automaton, there must be a final state q 0 ∈ δA  (q, τ 0 )  A(q 0 )  0  such that TαU  β belongs to ρ(τ τ ).F. Moreover for  all τ 00 such that ε ≤ τ 00 < τ 0 , Tα belongs to ρ(τ τ 00 ).F. By  Lemma 2, Tβ also belongs to ρ(τ τ 0 ).F. Hence, condition  (2) of Proposition 2 holds and we can conclude, by Theorem 1, that ρ is an accepting run.  Given a set F of signed formulas, we define the sets  P os(F) and N eg(F) respectively as the sets of positive  and negative propositions in F, i.e. P os(F) = {p ∈  P|Tp ∈ F}, and N eg(F) = {p ∈ P|Fp ∈ F}.  Theorem 3 Let σ ∈ L(B(φ)). Then there is a model M =  (σ, V ) such that M, ε |= φ.  Proof Let ρ be an accepting run. for each τ ∈ prf (σ) let  ρ(τ ) = (Fτ , xτ , fτ ). The model M = (σ, V ) can be obtained by defining V (τ ) ∈ 2P such that V (τ ) ⊇ P os(Fτ )  and V (τ ) ∩ N eg(Fτ ) = ∅.  It is easy to prove by induction on the structure of formulas that, for each τ and for each formula α, if Tα ∈ Fτ  then M, τ |= α, and if Fα ∈ Fτ then M, τ 6|= α. In particular, for until formulas labelled T we make use of Theorem 1 and of Proposition 2, case 2, while for until formulas labelled F we make use of Proposition 2, case 3. From  Tφ ∈ F² , it follows that M, ² |= φ.  3.4. Complexity  It is known that for π ∈ P rg(Σ), we can construct in  polynomial time a non-deterministic finite state automaton  A with L(A) = [[π]] such that the number of states of A is  linear in the size of π [7]. The expansion of each until formula αU A(q) β in the initial formula φ introduces at most  a number of formulas which is linear in the size of A and,  hence, is linear in the size of π. In fact, observe that the expansion of the until formula αU A(q) β (and its descendants)  0  introduces at most |QA | subformulas of the form αU A(q ) β,  with q 0 ∈ QA . Let α1 U π1 β1 ,....,αn U πn βn be all the until  formulas occurring in the initial formula φ. It must be that  |π1 | + . . . + |πn | ≤ |φ|. Hence, the number of until formulas which are introduced in the construction of the automaton is linear in the size of the initial formula φ. Therefore,  in the worst case, the number of states of the Büchi automaton is exponential in the size of |φ|.  4. Conclusions  In this paper we have presented a tableau-based algorithm for constructing a Büchi automaton from a DLT L  formula. The formula is satisfiable if the language recognized by the automaton is nonempty. The construction of  the states of the automaton can be done on-the-fly during  the search that checks for emptiness. As in [6] we make use  of finite automata to verify the fulfillment of until formulas. However, the construction of the automaton given in [6]  is based on the idea of generating all the (maximally consistent) sets of the subformulas of the initial formula. Moreover, rather then introducing the states of the finite automata  in the global states of the Büchi automaton, we stay closer  to the standard construction for LTL [2] and we detect the  point of fulfillment of the until formulas by associating a finite automaton with each until formula (rather than a regular expression) and by keeping track of the evolution of the  state of these (finite) automata during the expansion of temporal formulas.  This construction could be improved in various ways, in  particular by adopting the techniques presented in [1].  5. Acknowledgements  This research has been partially supported by the project  MIUR PRIN 2003 “Logic-based development and verification of multi-agent systems”.  References  [1] M. Daniele, F. Giunchiglia and M.Y. Vardi. Improved automata generation for linear temporal logic. In Proc. 11th  CAV, Springer LNCS vol. 1633, pp. 249–260, July 1999.  [2] R. Gerth, D. Peled, M.Y. Vardi and P. Wolper. Simple on-thefly automatic verification of linear temporal logic. In Proc.  15th work. Protocol Specification, Testing and Verification,  Warsaw, June 1995.  [3] L.Giordano, A.Martelli, and C.Schwind. Reasoning about  actions in dynamic linear time temporal logic. Logic Journal of the IGPL, 9(2):289–303, 2001.  [4] L. Giordano, A. Martelli, and C. Schwind. Specifying and  Verifying Systems of Communicating Agents in a Temporal  Action Logic. In Proc. AI*IA’03, Pisa, Springer LNCS vol.  2829, pp. 262–274, September 2003.  [5] J.G. Henriksen and P.S. Thiagarajan. A Product Version of  Dynamic Linear Time Temporal Logic. In CONCUR’97,  1997.  [6] J.G. Henriksen and P.S. Thiagarajan. Dynamic Linear Time  Temporal Logic. In Annals of Pure and Applied logic, vol.96,  n.1-3, pp.187–207, 1999.  [7] J. Hromkovic, S. Seibert and T. Wilke. Translating Regular  Expressions into Small ε-Free Nondeterministic Finite Automata. In Proc. STACS’97, Springer LNCS vol. 1200, pp.  55–66, 1997.  [8] F. Somenzi and R. Bloem. Efficient Büchi automata from  LTL formulae. In Proc. 12th CAV, Springer LNCS vol. 1855,  pp. 247–263, 2000.  [9] M. Vardi and P. Wolper. Reasoning about infinite computations. In Information and Computation 115,1–37 (1994).  [10] P. Wolper. Temporal logic can be more expressive. In Information and Control 56,72–99 (1983).  [11] P. Wolper. Constructing Automata from Temporal Logic Formulas: A Tutorial. In Proc. FMPA 2000, Springer LNCS vol.  2090, pp. 261–277, July 2000. 