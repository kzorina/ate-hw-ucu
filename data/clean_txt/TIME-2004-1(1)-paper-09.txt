University of Westminster Eprints  WestminsterResearch  http://eprints.wmin.ac.uk  http://www.wmin.ac.uk/westminsterresearch  A clausal resolution method for branching-time logic ECTL.  Alexander Bolotov  Artie Basukoski  Harrow School of Computer Science  Copyright ÂŠ [2004] IEEE. Reprinted 11th International Symposium on Temporal  Representation and Reasoning: (TIME 2004), Tatihou, Normandie, France, 1-3 July  2004, pp. 140-147.  This material is posted here with permission of the IEEE. Such permission of the  IEEE does not in any way imply IEEE endorsement of any of the University of  Westminster's products or services. Internal or personal use of this material is  permitted. However, permission to reprint/republish this material for advertising or  promotional purposes or for creating new collective works for resale or redistribution  must be obtained from the IEEE by writing to pubs-permissions@ieee.org. By  choosing to view this document, you agree to all provisions of the copyright laws  protecting it.  digitalof  archive  at the University  Westminster  The WestminsterResearch  Eprints service at theonline  University  Westminster  aims to of  make  the research  aims toofmake  the research  output of  University  available  to a wider  output  the University  available  to the  a wider  audience.  Copyright  andaudience.  Moral Rights  Copyright  and  Rights  remain  with the  authors and/or copyright owners.  remain  with  theMoral  authors  and/or  copyright  owners.  one  copy  for for  non-commercial  private  Users are  are permitted  permittedtotodownload  downloadand/or  and/orprint  print  one  copy  non-commercial  private  study or  research.  Further  distribution  and  any  use  of  material  from  within  this  or research. Further distribution and any use of material from within this  archive for profit-making enterprises or for commercial gain is strictly forbidden.  Whilst further distribution  distribution ofofspecific  specificmaterials  materialsfrom  fromwithin  within  this  archive  is forbidden,  this  archive  is forbidden,  you may  mayfreely  freely  distribute  the of  URL  of the University of Westminster Eprints  distribute  the URL  WestminsterResearch.  (http://eprints.wmin.ac.uk).  (http://www.wmin.ac.uk/westminsterresearch).  In case of abuse or copyright appearing without permission e-mail wattsn@wmin.ac.uk.  A Clausal Resolution Method for Branching-Time Logic ECTL  Alexander Bolotov and Artie Basukoski  Harrow School of Computer Science,  University of Westminster, HA1 3TP, UK  A.Bolotov,A.Basukoski@wmin.ac.uk  Abstract  We expand the applicability of the clausal resolution  technique to the branching-time temporal logic ECTL .  ECTL is strictly more expressive than the basic computation tree logic CTL and its extension, ECTL, as it allows  Boolean combinations of fairness and single temporal operators. We show that any ECTL formula can be translated  to a normal form the structure of which was initially deďŹned  for CTL and then applied to ECTL. This enables us to apply to ECTL a resolution technique deďŹned over the set of  clauses. Our correctness argument also bridges the gap in  the correctness proof for ECTL: we show that the transformation procedure for ECTL preserves unsatisďŹability.  1. Introduction  CTL type branching-time temporal logics play a signiďŹcant role in potential applications such as speciďŹcation and  veriďŹcation of concurrent and distributed systems [7]. Two  combinations of future time temporal operators  (âsome(âalwaysâ), are useful in expressing fairness  timeâ) and  [6]:   ( is true along the path of the computation except possibly some ďŹnite initial interval of it) and    ( is true along the computation path at inďŹnitely many  moments of time). The logic ECTL (Extended CTL [9])  was deďŹned to enable the use of these simple fairness constraints. The logic ECTL further extends the expressiveness of ECTL by allowing Boolean combinations of elementary temporal operators and ECTL fairness constraints  (but not permitting nesting of temporal operators or fairness constraints). In [2] a clausal resolution method has  been developed for the logic ECTL. The introduction of the  corresponding technique to cope with fairness constraints  enabled the translation of an ECTL formula into the normal form, to which we apply a clausal resolution technique initially deďŹned for the logic CTL. In this paper we  present the translation to the normal form for any ECTL  formula. Similarly to ECTL, as a normal form we utilise  the Separated Normal Form developed for CTL formulae,  called SNF . This enables us to apply the resolution  technique deďŹned over SNF  as the refutation technique  for ECTL formulae.  The main contribution of this paper is the formulation of  the technique to translate ECTL formulae into SNF   and a proof of its correctness. The latter also bridges the  gap in the correctness proof for ECTL: we show that the  transformation procedure for ECTL preserves unsatisďŹability.  The structure of the paper is as follows. In 2 we outline the syntax and semantics of ECTL and those properties that are important for our analysis. In 3 we review  SNF . Next, in 4, we describe the main stages of the algorithm to translate an ECTL formula into SNF  , give  details of rules invoked in this algorithm and provide the example transformation. The core of this paper, the proof of  the correctness of this transformation technique, is given in  5. Further, in 6 we outline the temporal resolution method  deďŹned over SNF  and apply it to a set of SNF   clauses (previously obtained in 4.3). Finally, in 7, we  draw conclusions and discuss future work.  2. Syntax and Semantics of ECTL  In the language of ECTL we extend the language of  linear-time temporal logic, which uses future time  (al(next time),  (until) and   ways),  (sometime),  (unless), by path quantiďŹers A (on all future paths) and E  (on some future path). In the syntax of ECTL , similar to  CTL and ECTL, we distinguish state ( ) and path ( ) formulae, such that well formed formulae are state formulae.  These are inductively deďŹned below (where  is a formula  of classical propositional logic)                     A E                                Examples of ECTL formulae that are not expressible in     , E    a weaker logic ECTL, are A   . These formulae express the Boolean combination  Proceedings of the 11th International Symposium on Temporal Representation and Reasoning (TIMEâ04)  1530-1311/04 $20.00 ÂŠ 2004 IEEE  of fairness properties or temporal operators in the scope of  a path quantiďŹer.  We interpret a well-formed ECTL formula in a tree   , where is a set of  like model structure  states,   is a binary relation over , and  is an  interpretation function mapping atomic propositional symbols to truth values at each state. A path,  , over , is a  sequence of states           such that for all   ,       . A path  Âź is called a fullpath. Given a path   and a state       we term a ďŹnite subsequence                of  a preďŹx of a path   and an inďŹnite sub-sequence             of  a  sufďŹx of a path  abbreviated     .  satisďŹes the folWe assume that an ECTL model  lowing conditions: (i) There is a designated state,    ,  a root of a structure (i.e. for all        ); (ii) Every state belongs to some fullpath and should have a successor state; (iii) Tree structures are of at most countable  branching; (iv) Every path is isomorphic to .  When trees are considered as models for distributed systems, paths through a tree are viewed as computations. The  requirements for ECTL models we are interested in would  be sufďŹx, fusion and limit closures [6].  Below, we deďŹne a relation â â, which evaluates wellomitformed ECTL formulae at a state  in a model  ting standard cases for Booleans.                          Aiff iff                  E iffiff                 iff                                 iff                   iffiff                                                 iff                DeďŹnition 1 An ECTL formula  is satisďŹable if, and  such that        .  only if, there exists a model  Formula  is valid if, and only if, every model satisďŹes it.                                                                           As an example let us consider an ECTL formula  A      (1)  which will be served in our example of the transformation  towards SNF in 4.3. It is straightforward from the semantics, that this formula is unsatisďŹable: take an arbitrary  can not be  fullpath, say , and show that  satisďŹed along  as in the linear-time logic.  2.1. Some useful features of ECTL  Here we summarize those features of ECTL that are  important in our analysis and, thus, will affect both the  translation of ECTL formulae to the normal form and the  clausal resolution method.  In the rest of the paper, let T abbreviate any unary and T   any binary temporal operator and P either of path quantiďŹers. Any formula of the type PT or PT  is called a basic  CTL modality.  Proposition 1 [Negation Normal Form correctness]  Given an ECTL formula  and its Negation Normal  Form Âˇ ,      iff     Âˇ  [6].          Given a CTL formula  , we will abbreviate the expression âa state subformula   with a path quantiďŹer as its  main operatorâ by P-embedded subformula of  . Now for  an ECTL formula  , we deďŹne a notion of the degree of  nesting of its path quantiďŹers, denoted   , as follows.  DeďŹnition 2 (Degree of path quantiďŹer nesting)      T  T  , and  ,  are purely classical  if   formulae then      T    T   ;  if          T  T  and     ,     then      T    and                   T        ;  if  P and     then  P    .                Emerson and Sistla [10] showed that for any CTL ÂŁ  (hence ECTL ) formula  with     ,  can be  transformed into  Âź by a continuous renaming of the P. For exembedded state subformulae such that   Âź   ample, given   A E   E E   we can obtain  A   E   A   E   A  E   A                      Proposition 2 (Correctness of the procedure Red) For      if, and only if, there  any ECTL formula  ,  Âź such that  Âź   exists a model   , where     is introduced in DeďŹnition 2 [10].  Recall that the logic CTL extends CTL by allowing Boolean combinations of temporal operators (but  not any nesting of them). Yet, it is still as expressive as CTL [8]. Hence we can transform any ECTL  formula which is also a formula of CTL into an equivalent CTL formula. Here we give some of the equivalences  used for such reduction, referring the reader to the menand  tioned paper for other cases which involve the  operation. (In the formulae below  and  are purely classical expressions.)  Proceedings of the 11th International Symposium on Temporal Representation and Reasoning (TIMEâ04)  1530-1311/04 $20.00 ÂŠ 2004 IEEE              P     P    P     P     P      P     P     P     E      E  E  A     A A  (2)  Like ECTL, ECTL allows limited nesting of temporal operators to express fairness constraints. For some of them,  and E  cases, the validity of the folnamely, for A  lowing equivalences which we will use in our transformation procedure can be easily shown:    A   E  A A   E E   (3)  Applying procedure NNF  and standard classical logic transformations, we can obtain for any ECTL  formula  (that has the degree of path quantiďŹers nesting 1) its âspecialâ Disjunctive or Conjunctive Normal   E   and  A  .  Form, abbreviated as  DeďŹnition 3 (DNFE and CNFA for ECTL formulae)   ,  Let us call formulae of the type T   ,  T  ,   (where  and  are purely classical) as elemen E is of the type  tary formulae. Now, a formula in    and a formula in   A is of the type  E   A   , where each       is an elementary formula.  For example, the following formula (which we used in     is  in  A . The proof of the following proposition can be  established immediately from the semantics of ECTL .  2 as an unsatisďŹability example) A  Proposition 3 (Correctness of the DNF E and CNFA )  For any ECTL formula  that has the degree of path quanE   and  A    tiďŹers nesting 1, there exist its  such that  is satisďŹable if, and only if,   E   and   A   are satisďŹable respectively.  Similar to ECTL, a class of basic ECTL modalities  consists of basic CTL modalities, enriched by the fairness  constraints, P  and P  . Our translation to SNF   and temporal resolution rules are essentially based upon the  ďŹxpoint characterizations of basic CTL modalities (see [5]).  Next we observe some results on interpreting ECTL  over canonical models, noting that these results cover all  CTL-type logics, including CTL .  DeďŹnition 4 (Branching degree and branching factor)  The number of immediate successors of a state  in a  tree structure is called a branching degree of . Given a set        , of the branching degrees of the states of  a tree structure, the maximal     is called a branching factor of this tree structure.  As we have already mentioned, we assume that underlying ECTL tree models are of at most countable branching. However, following ([6]), trees with arbitrary, even uncountable, branching, âas far as our branching temporal logics are concerned, are indistinguishable from trees with ďŹnite, even bounded, branchingâ.      ,  DeďŹnition 5 (Labelled tree) Given a tree  where is a set of nodes and  is a set of edges, and a ďŹnite alphabet, , a    tree is a structure    where is a mapping  , which assigns for each  state, element of , some label, element of .  In 2 we introduced the notion of satisďŹability and validity of ECTL formulae in relation to    . Now, following [12], we call such a structure a tree interpretation.  Next we recall a notion of a  -ary tree canonical model  which plays a fundamental role in our correctness argument.  For these purposes, again following [12], we will look at  tree interpretations as tree generators: the root of the tree  is understood as an empty string, , and the whole tree is  seen as a result of unwinding of the root applying the suc    cessor function           , where     and    is a set of successors of a state .  DeďŹnition 6 (Tree canonical interpretation) Let       be a  -ary inďŹnite tree such that   denotes the set   , of branching degrees of the states    in and            . Now, given an al    , a  -ary tree canonical interpretaphabet     tion for an ECTL formula  is of the form  , where        such that      .    In a canonical interpretation       the set of  states, the initial state and the successor relation are all    ,  ďŹxed, hence, â...they reduce to a function         that is to a labelled tree over the alphabet   ...â ([12]).  We will refer to this tree as a canonical model. Proposition 4  given below collects the results given in [12] (Lemma 3.5).  Proposition 4 (Existence of a canonical model)  If an  ECTL formula  with  E-quantiďŹers has a model, then it  has an  -ary canonical model.  These results were essentially used in the formulation  of the transformation rule for the ECTL fairness constraint  A  [2]. In this paper we will further extend their applicability in the transformation procedure for ECTL .  3. Normal Form for ECTL  As a normal form for ECTL , similarly to ECTL, we  utilise a clausal normal form, deďŹned for the logic CTL,  SNF , which was developed in [1, 4]. All formulae  of SNF of the type   E  or   E   (see below), where  is a purely classical expression, are  labelled with some index. Indices are used to preserve  Proceedings of the 11th International Symposium on Temporal Representation and Reasoning (TIMEâ04)  1530-1311/04 $20.00 ÂŠ 2004 IEEE  a speciďŹc path context during the translation. The language for indices is based on the set of terms                 where        denote constants. A designated type of indices in  SNF  are indices of the type   which represents  a limit closure of  . Thus, E  means that  holds on  some path labelled as  , for some  .  The alphabet for SNF  language is obtained from  ECTL by omitting the  and  operators, adding classically deďŹned constants  and  and a new operator,   (âat the initial moment of timeâ) deďŹned as         iff  .  )  DeďŹnition 7 (Separated Normal Form SNF   SNF  is a set of formulae A     where  each of the clauses    is further restricted as beis a literal,   low, each     ,     or  or  and     is some index.                A       E       A       E                  an initial clause                    an A step clause  a E step clause  an A sometime clause    a E sometime clause     We obtain the SNF  semantics from the semantics of  ECTL ( 2) by preserving only items for state formulae.  4. Transformation of ECTL formulae into  SNF    In this section we will ďŹrst describe the algorithm to  transform ECTL  formulae into SNF  , some of its rules,  and, ďŹnally, give an example transformation.  4.1. Algorithm to transform ECTL formulae into SNF    As SNF  is a part of the resolution technique, to check  validity of an ECTL  formula , we ďŹrst negate the latter  and translate  into its Negation Normal Form, deriving    NNF   . We introduce the transformation procedure       applied to  , where  and  are  described respectively by the steps 1-2 and 3-10 below.  (1) Anchor  to   and apply the initial renaming  rule obtaining A      A    , where   is a new proposition.  (2) Apply equations (3) and procedure   (see DeďŹnition 2) to  . Thus, we derive a  set of constraints of the following structure    A            where           is a proposition,   is either a purely classical formula or if  contains a path quantiďŹer then the degree of  nesting of path quantiďŹers in   is 1.  Let us call a formula  in pre-clause form  if     i.e. it is of the form      where  is a literal, conjunction of literals, or    ,  is a purely classical formula or any of   P   PÂ˝ T Âž  PTÂ˝    PT P  T  PTÂ˝    T  (for some    ) and   Â˝    are purely classical formulae.  (3) For every pre-clause     :  (3.1) If   is an ECTL formula but not a CTL  formula then do the following:  (3.1.1) obtain its  E   or   A   and apply  equivalences 2-(e) or 2-(f) respectively.  (3.1.2) apply equivalences (3).  (3.1.3) apply procedure  .  (3.2) If   contains Boolean combinations of temporal  operators but does not contain any fairness constraint then  (as it is a CTL formula) apply the procedure to transform  CTL into CTL (see section 2.1).  (4) At this stage, renaming state subformulae (which are  expressed by basic CTL modalities) on the right hand-sides  of the constraints derived at step 3 we obtain the structure  required for a pre-clause.  (5) For every pre-clause     , by continuous renaming of the embedded classical subformulae by auxiliary  propositions together with some classical transformations  we obtain the following conditions.  - If  contains a basic CTL modality then  - If  PT and PT is not P then  is a literal,  else  is a purely classical formula.  - If  E   or   A   then  is a literal,  - If  PÂ˝ T Âž  then Â˝ and Âž are literals.  - If  E       or  A      ,  where each       and       is a temporal operator or a fairness constraint applied to classical formulae (but not literals) we obtain the structure where they  apply to literals.  modality  (6) Label each pre-clause containing the E  by an unique index      and any other pre-clause  containing the E quantiďŹer by an unique index     . Let LIST IND be a list of all indices introduced during  this labelling.  and A  .  (7) Transform pre-clauses with E  (8) Transform pre-clauses containing E        or A        (of the structure obtained at step 5).  (9) Remove all unwanted basic CTL modalities.  (10) Derive the desired form of SNF  clauses. At this  ďŹnal stage we transform pre-clauses     , where   is either P  or a purely classical formula: for every preclause   P  , we obtain the structure where P ap-  Proceedings of the 11th International Symposium on Temporal Representation and Reasoning (TIMEâ04)  1530-1311/04 $20.00 ÂŠ 2004 IEEE  plies either to a literal or to disjunction of literals. This can  be achieved, again, by renaming of the embedded classical  subformulae, applying rules used to obtain conjunctive normal form (CNF), and distributing P over conjunction, together with some classical transformations. Further, for ev , we apery remaining purely classical pre-clause  ply a number of procedures including those that are used in  classical logic in transforming formulae to CNF, some simpliďŹcations and the introduction of a temporal context.  4.2. Transformation rules towards SNF    Indices. Recall that at step 6 of the transformation procedure, we introduce labelling of the SNF  pre-clauses  containing the E quantiďŹer. The justiďŹcation of this labelling is based upon ďŹxpoint characterization of basic CTL  modalities and was explained in [1, 2] except for the new  speciďŹc ECTL formulae in  E form. The latter can  be explained simply based upon the SNF  semantics.  Rules to remove basic CTL modalities. Here we give  those removal rules that will be used in our examples of  the transformation to SNF  ( 4.3) and refutation ( 6). In  the formulation of the rules given below  is a new proposition:    Removal of E        E     E      Removal of E                    E       E              case.                A  E  E            Â˝    E  E          Ă         Â˝      Ă      Managing embedded boolean combinations of path subformulae in ECTL . Recall that on step 8 of the transformation procedure we must further reduce formulae of the    and A    . The correform E   sponding rules are given below where   is   if the   are not , and  otherwise and is the number of indices in LIST IND.     E  A                  A  E         case.    E  E    E            Âź       Âź  case.          A  E        E                      Â˝     Finally, from the rest of the rules previously deďŹned for  CTL/ECTL, we use the following.  Temporising                  A  E  E        Distributivity of E    Managing embedded path subformulae in ECTL .  We incorporate rules to rename purely path formulae embedded in ECTL  fairness constraints from [2]. Let   and  the number of indices in LIST IND be  let      be the constants occurLIST IND  ring in these indices. If for some index   we do not have    LIST IND then we upgrade LIST IND by   (in the formulation below  is the number of indices in LIST IND and     are  new propositions).                Renaming: the A                  E  E  E      The ďŹrst stage of the transformation procedure  outlined above, the procedure  , is taken from the translation  of ECTL formulae to SNF  [2]. Here we describe novel  techniques to cope with Boolean combinations of temporal operators deďŹned in addition to the rules of the procedure  , introduced for ECTL [2]. We also recall some of  those rules that will be used in our example given in 4.3.  For the full set of rules preserved from the CTL the reader  is referred to [1, 4].  In the presentation below we omit the outer âA â connective that surrounds the conjunction of pre-clauses and, for  convenience, consider a set of pre-clauses rather than the  and  will abbreviate purely  conjunction. Expressions  classical formulae.  case.  Renaming: the E        A      E  E  E                       In the rule for E , given that the premise of the rule is labelled by   , we preserve this label for both conclusions, thus, assuring that they refer to the same path.      4.3. Example Transformation  As an example we translate into SNF  the formula:  E  Proceedings of the 11th International Symposium on Temporal Representation and Reasoning (TIMEâ04)  1530-1311/04 $20.00 ÂŠ 2004 IEEE      (4)  To check if (4) is valid negate it and apply procedure NNF   E        A     which was considered as an example of an unsatisďŹable formula in 2. From the translation algorithm, we derive steps 0â2, where  is a new  proposition.            A    A                          We proceed with formula 2, where the right hand side of the  implication is already in   A  . Thus, we apply equation (2)-(f) to distribute the A over conjunction in 2, obtaining 3, and then simplify the latter deriving 4 and 5. Next,  we simplify formula 4 applying (3-(a)) to get 6. The structure of the latter enables us to apply procedure  deducing 7 and 8 and introducing a new variable .     A  A            A         A         A A           A           A        Applying the renaming rule (A  case) to 5 we derive formula 9 and label it with a new index     (since  LIST IND is empty). Applying equation (3-(b)) to 9 we get  E E      which is further reduced by procedure  to 10 and 11, where is a new variable. Apply A removal rule to 7 and E removal rule 11, where   and  are new variables.                                   E  E  E  A                                                      A   A   E   E    E      Next simplifying and temporising formulae 12 and 14 we  obtain 16-19 and 20-23 respectively. Finally, we distribute  in 13 and 15.  A and E over                                                                                      A     A       A  A  A  A  E  E                                                                                           E            E    The normal form of the given ECTL  formula A   is represented by clauses 1, 8, 10, 16â27.    5. Correctness of the Transformation of  ECTL formulae into SNF    Here we provide the correctness argument for our transformation procedure. A signiďŹcant part of this argument is  either similar to the corresponding proofs given in [1, 2]  for CTL and ECTL or extend these proofs for new cases of  ECTL formulae. Therefore, we will only state such claims  referring the reader to [1, 2] while we sketch here proofs  for new techniques used for ECTL  transformations. Note  also that in our previous paper ([2]) we have not established the proof for the claim analogous to Lemma 3 (see  below). Therefore, providing our argument in this paper, we  not only show the desired correctness of the transformation  procedure for ECTL  but also bridge this gap for ECTL.  Theorem 1 An ECTL formula,  only if,   is satisďŹable.  , is satisďŹable if, and  To establish the correctness of this theorem we ďŹrst show  is satisďŹable, if and only if  that an ECTL formula    is satisďŹable (Lemma 1). At the next stage we prove  that the transformation procedure   preserves satisďŹability (Lemma 2). Finally, (Lemma 3), we show that given  an ECTL formula  and its normal form, SNF  ( ),  if SNF ( ) is satisďŹable then is satisďŹable.  Lemma 1 An ECTL formula, , is satisďŹable if, and only  if,   is satisďŹable.  Since  is taken from the translation of ECTL formulae to SNF , the proof of Lemma 1 follows from the correctness argument for ECTL ([2]).  Lemma 2 Given an SNF formula  ďŹable then so is   .  , if      is satis-  Here we must show that the new techniques used in  our transformation procedure preserve satisďŹability. This  includes the correctness argument for   E and  A  and also for the cases of Boolean combinations of temporal operators, E         case and A          case. Corresponding proofs are established straightforwardly from the SNF  semantics, taking into account the  meaning of indices and Proposition 4 ([12]).  Lemma 3 Given an ECTL  formula  satisďŹable then so is .  , if SNF    is  From Lemma 1 it follows that given an ECTL  formula , is satisďŹable if, and only if,    is satisďŹable.  Thus, for the proof of Lemma 3 we must show that the following proposition takes place:  PROOF :  Proposition 5 Given an ECTL  formula , if    satisďŹable then so is  .  Proceedings of the 11th International Symposium on Temporal Representation and Reasoning (TIMEâ04)  1530-1311/04 $20.00 ÂŠ 2004 IEEE   is  Here we sketch the proof for the new core technique introduced in our transformation procedure. We will show   A         and havthat given  A  ing generated   A   E                    A  E                 (where at least one of        has a form of  or  ), if  is satisďŹable then  is satisďŹable.    Consider a model  which satisďŹes . We have        . Following [12], we know  that if a formula with path quantiďŹers has a model, then   âary canonical model. We will now conit has an  struct this canonical model   and show that every state  in the model also satisďŹes . The construction proceeds by  ďŹrst selecting a path, say , from  which satisďŹes one  of the       clauses. This will be a basis path  to construct a canonical model, which is also referred to as  the âleftmostâ path of the canonical model in [12]. Due to  the labelling of the states of this path, each of them satisďŹes  E             . Then inductively construct each of the additional paths (corresponding to     quantiďŹers) from each state along .  Again, we label the states of these paths based on the  original interpretations from M such that each of them also  satisďŹes  E             (for some ). We  then proceed in the same way to take each state of the newly  constructed paths and generate the additional paths from  each of them to derive the completed canonical model.  PROOF :           Â˝     Âž  Figure 1.   Â´    Â˝  Â˝   âary    Âľ  Â˝  Â˝   Âź  Canonical  Model for .  Our ultimate task is to show that for any state in the  canonical model   which satisďŹes , every path emanating from it satisďŹes        . This will ensure that   A         is satisďŹed at every state of  , and,  therefore, it is satisďŹed in the root of   . Consider an arbitrarily chosen path   of  and a state   , see Figure  1. By the construction of   , every one of the paths emanating from   satisďŹes        . What is left is to show  that      (which corresponds to the   path emanating from   ) also satisďŹes        . The latter follows from the labelling of the states of the path   which is  taken from one of the paths of  that satisďŹes one of the         .  6. The Temporal Resolution Method  In order to achieve a refutation, we apply two types of  resolution rules already deďŹned in [1, 4]: step resolution  (SRES) and temporal resolution (TRES). The SRES rules  are used between formulae which refer to the same initial  moment of time or same next moment along some or all  paths. The basic idea of invoking temporal resolution is to  resolve a set of formulae characterizing a loop in , i.e. a  set of SNF clauses indicating a situation when  occurs  at all future moments along every (an A-loop in ) or some  path (a E-loop in ) from a particular point in an ECTL   model, together with the clause containing   [3]. Here  we present those step (SRES 1 and SRES 2) and temporal resolution (TRES 2 and TRES 4) rules which are used  in the example refutation. (For a detailed description of the  resolution technique deďŹned over SNF  see [1, 4].)  SRES 1           TRES 2  A  E  E  SRES 2         A        A       A      TRES 4        E  A              E  E                E          In the rules above  is a literal and the ďŹrst premises in the  TRES rules abbreviate the A and E loops in  respectively  (given that is satisďŹed).  Correctness of the transformation of ECTL  formulae  into SNF ( 5) together with the termination and correctness of the resolution method deďŹned over SNF  (shown  in [1, 4]) enables us to apply the latter as the refutation  method for ECTL  .  Example Refutation. We apply the resolution method to  the set of SNF clauses obtained in section 4.3 for  . We commence  the ECTL formula A  the resolution proof presenting at steps 1 â 13 only those  clauses that are involved in the resolution refutation in the  following order: initial clauses, step clauses and, ďŹnally, any  sometime clauses.          A     A              E               E              A                E         A     A           We apply step resolution rules between 1 and 2, and 1 and 3.  No more SRES rules are applicable. Formula 12 is an eventuality clause, and therefore, we are looking for a loop in  Proceedings of the 11th International Symposium on Temporal Representation and Reasoning (TIMEâ04)  1530-1311/04 $20.00 ÂŠ 2004 IEEE  (see [3] for the formulation of the loop searching procedure). The desired loop, E E    (given that condition  is satisďŹed) can be found considering clauses 10  and 11. Thus, we apply the TRES 4 rule to resolve this loop  and clause 12, obtaining 16. Next we remove E  from 16  deriving a purely classical formula 17 ( is a new variable).  Simplify the latter, apply temporising, obtaining, in particular, 19 and 20, and then a series of SRES rules to newly  generated clauses.                        E          TRES 4           E       E        E                   A                                               A                A              A         Now, as no more SRES rules are applicable, we are looking for a loop in  which can be found considering formulae 9 and 26: A A   given that condition   is satisďŹed. Thus, we can apply TRES 2 to resolve this loop and 13  deriving 27. Then we remove E  from the latter (on step  28, where is a new variable, we use only one of its conclusions). Applying simpliďŹcation and temporising to 28 we  obtain 29. The desired terminating clause      is deduced by applying SRES 1 to steps 1, 15 and 23.                      E                                E             7. Conclusions and Future Work  We have described the extension of the clausal resolution  method to the useful branching-time logic ECTL  . Here  we have followed our general idea to expand the applicability of the clausal resolution technique originally developed for linear-time temporal logic [11], and further extended to branching-time temporal logics CTL and ECTL  [4, 1, 2]. This extension enables us to invoke a variety of  well-developed methods and reďŹnements used in the resolution framework for classical logic. The algorithm to search  for loops needed for temporal resolution has been introduced in [3]. With the proof that SNF  can be served as  the normal form for ECTL  , the algorithm becomes fully  functional for the latter. Another contribution of this paper is completing the proof of the correctness of the transformation procedure in ECTL formulated in [2]: we have  now shown that if the set of clauses generated for an ECTL  formula is satisďŹable then the original formula is satisďŹable. Our results have brought us one step closer to the ďŹnal stage of our long-term project - to deďŹne a clausal resolution method for CTL . Among other obvious tasks are  to reďŹne the presented method and to analyse its complexity which would enable the development of the corresponding prototype systems.  References  [1] A. Bolotov. Clausal Resolution for Branching-Time Temporal Logic. PhD thesis, Department of Computing and Mathematics, The Manchester Metropolitan University, 2000.  [2] A. Bolotov. Clausal resolution for extended computation tree  logic ECTL. In Proceedings of the Time-2003/International  Conference on Temporal Logic 2003, pages 107â117, Cairns,  July 2003. IEEE.  [3] A. Bolotov and C. Dixon. Resolution for Branching Time  Temporal Logics: Applying the Temporal Resolution Rule.  In Proceedings of the 7th International Conference on Temporal Representation and Reasoning (TIME2000), pages  163â172, Cape Breton, Nova Scotia, Canada, 2000. IEEE  Computer Society.  [4] A. Bolotov and M. Fisher. A Clausal Resolution Method  for CTL Branching Time Temporal Logic. Journal of Experimental and Theoretical ArtiďŹcial Intelligence., 11:77â  93, 1999.  [5] J. BradďŹeld. and C. Stirling. Modal logics and mu-calculi. In  J. Bergstra, A. Ponse, and S. Smolka, editors, Handbook of  Process Algebra, pages 293â330. Elsevier, North-Holland,  2001.  [6] E. A. Emerson. Temporal and Modal Logic. In J. van  Leeuwen, editor, Handbook of Theoretical Computer Science: Volume B, Formal Models and Semantics., pages 996â  1072. Elsevier, 1990.  [7] E. A. Emerson. Automated reasoning about reactive systems. In Logics for Concurrency: Structures Versus Automata, Proc. of International Workshop, volume 1043 of  Lecture Notes in Computer Science, pages 41â101. Springer,  1996.  [8] E. A. Emerson and J. Y. Halpern. Decision procedures and  expressiveness in the temporal logic of branching time. In  JCSS 30(1), pages 1â24, 1985.  [9] E. A. Emerson and J. Y. Halpern. âSometimesâ and âNot  neverâ revisited: On branching versus linear time temporal  logic. JACM, 33(1):151â178, 1986.  [10] E. A. Emerson and A. P. Sistla. Deciding full branching time  logic. In Proceedings of STOC 1984, pages 14â24, 1984.  [11] M. Fisher. A Resolution Method for Temporal Logic. In  Proc. of the XII International Joint Conference on ArtiďŹcial  Intelligence (IJCAI), pages 99â104, 1991.  [12] P. Wolper. On the relation of programs and computations to  models of temporal logic. In L. Bolc and A. SzaĹas, editors,  Time and Logic, a computational approach, chapter 3, pages  131â178. UCL Press Limited, 1995.  Proceedings of the 11th International Symposium on Temporal Representation and Reasoning (TIMEâ04)  1530-1311/04 $20.00 ÂŠ 2004 IEEE 