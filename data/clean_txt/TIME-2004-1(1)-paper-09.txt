University of Westminster Eprints  WestminsterResearch  http://eprints.wmin.ac.uk  http://www.wmin.ac.uk/westminsterresearch  A clausal resolution method for branching-time logic ECTL.  Alexander Bolotov  Artie Basukoski  Harrow School of Computer Science  Copyright Ã‚Å  [2004] IEEE. Reprinted 11th International Symposium on Temporal  Representation and Reasoning: (TIME 2004), Tatihou, Normandie, France, 1-3 July  2004, pp. 140-147.  This material is posted here with permission of the IEEE. Such permission of the  IEEE does not in any way imply IEEE endorsement of any of the University of  Westminster's products or services. Internal or personal use of this material is  permitted. However, permission to reprint/republish this material for advertising or  promotional purposes or for creating new collective works for resale or redistribution  must be obtained from the IEEE by writing to pubs-permissions@ieee.org. By  choosing to view this document, you agree to all provisions of the copyright laws  protecting it.  digitalof  archive  at the University  Westminster  The WestminsterResearch  Eprints service at theonline  University  Westminster  aims to of  make  the research  aims toofmake  the research  output of  University  available  to a wider  output  the University  available  to the  a wider  audience.  Copyright  andaudience.  Moral Rights  Copyright  and  Rights  remain  with the  authors and/or copyright owners.  remain  with  theMoral  authors  and/or  copyright  owners.  one  copy  for for  non-commercial  private  Users are  are permitted  permittedtotodownload  downloadand/or  and/orprint  print  one  copy  non-commercial  private  study or  research.  Further  distribution  and  any  use  of  material  from  within  this  or research. Further distribution and any use of material from within this  archive for profit-making enterprises or for commercial gain is strictly forbidden.  Whilst further distribution  distribution ofofspecific  specificmaterials  materialsfrom  fromwithin  within  this  archive  is forbidden,  this  archive  is forbidden,  you may  mayfreely  freely  distribute  the of  URL  of the University of Westminster Eprints  distribute  the URL  WestminsterResearch.  (http://eprints.wmin.ac.uk).  (http://www.wmin.ac.uk/westminsterresearch).  In case of abuse or copyright appearing without permission e-mail wattsn@wmin.ac.uk.  A Clausal Resolution Method for Branching-Time Logic ECTL  Alexander Bolotov and Artie Basukoski  Harrow School of Computer Science,  University of Westminster, HA1 3TP, UK  A.Bolotov,A.Basukoski@wmin.ac.uk  Abstract  We expand the applicability of the clausal resolution  technique to the branching-time temporal logic ECTL .  ECTL is strictly more expressive than the basic computation tree logic CTL and its extension, ECTL, as it allows  Boolean combinations of fairness and single temporal operators. We show that any ECTL formula can be translated  to a normal form the structure of which was initially deÄÅ¹Âned  for CTL and then applied to ECTL. This enables us to apply to ECTL a resolution technique deÄÅ¹Âned over the set of  clauses. Our correctness argument also bridges the gap in  the correctness proof for ECTL: we show that the transformation procedure for ECTL preserves unsatisÄÅ¹Âability.  1. Introduction  CTL type branching-time temporal logics play a signiÄÅ¹Âcant role in potential applications such as speciÄÅ¹Âcation and  veriÄÅ¹Âcation of concurrent and distributed systems [7]. Two  combinations of future time temporal operators  (Ã¢Â€Â˜some(Ã¢Â€Â˜alwaysÃ¢Â€Â™), are useful in expressing fairness  timeÃ¢Â€Â™) and  [6]:   ( is true along the path of the computation except possibly some ÄÅ¹Ânite initial interval of it) and    ( is true along the computation path at inÄÅ¹Ânitely many  moments of time). The logic ECTL (Extended CTL [9])  was deÄÅ¹Âned to enable the use of these simple fairness constraints. The logic ECTL further extends the expressiveness of ECTL by allowing Boolean combinations of elementary temporal operators and ECTL fairness constraints  (but not permitting nesting of temporal operators or fairness constraints). In [2] a clausal resolution method has  been developed for the logic ECTL. The introduction of the  corresponding technique to cope with fairness constraints  enabled the translation of an ECTL formula into the normal form, to which we apply a clausal resolution technique initially deÄÅ¹Âned for the logic CTL. In this paper we  present the translation to the normal form for any ECTL  formula. Similarly to ECTL, as a normal form we utilise  the Separated Normal Form developed for CTL formulae,  called SNF . This enables us to apply the resolution  technique deÄÅ¹Âned over SNF  as the refutation technique  for ECTL formulae.  The main contribution of this paper is the formulation of  the technique to translate ECTL formulae into SNF   and a proof of its correctness. The latter also bridges the  gap in the correctness proof for ECTL: we show that the  transformation procedure for ECTL preserves unsatisÄÅ¹Âability.  The structure of the paper is as follows. In 2 we outline the syntax and semantics of ECTL and those properties that are important for our analysis. In 3 we review  SNF . Next, in 4, we describe the main stages of the algorithm to translate an ECTL formula into SNF  , give  details of rules invoked in this algorithm and provide the example transformation. The core of this paper, the proof of  the correctness of this transformation technique, is given in  5. Further, in 6 we outline the temporal resolution method  deÄÅ¹Âned over SNF  and apply it to a set of SNF   clauses (previously obtained in 4.3). Finally, in 7, we  draw conclusions and discuss future work.  2. Syntax and Semantics of ECTL  In the language of ECTL we extend the language of  linear-time temporal logic, which uses future time  (al(next time),  (until) and   ways),  (sometime),  (unless), by path quantiÄÅ¹Âers A (on all future paths) and E  (on some future path). In the syntax of ECTL , similar to  CTL and ECTL, we distinguish state ( ) and path ( ) formulae, such that well formed formulae are state formulae.  These are inductively deÄÅ¹Âned below (where  is a formula  of classical propositional logic)                     A E                                Examples of ECTL formulae that are not expressible in     , E    a weaker logic ECTL, are A   . These formulae express the Boolean combination  Proceedings of the 11th International Symposium on Temporal Representation and Reasoning (TIMEÃ¢Â€Â™04)  1530-1311/04 $20.00 Ã‚Å  2004 IEEE  of fairness properties or temporal operators in the scope of  a path quantiÄÅ¹Âer.  We interpret a well-formed ECTL formula in a tree   , where is a set of  like model structure  states,   is a binary relation over , and  is an  interpretation function mapping atomic propositional symbols to truth values at each state. A path,  , over , is a  sequence of states           such that for all   ,       . A path  Ã‚Åº is called a fullpath. Given a path   and a state       we term a ÄÅ¹Ânite subsequence                of  a preÄÅ¹Âx of a path   and an inÄÅ¹Ânite sub-sequence             of  a  sufÄÅ¹Âx of a path  abbreviated     .  satisÄÅ¹Âes the folWe assume that an ECTL model  lowing conditions: (i) There is a designated state,    ,  a root of a structure (i.e. for all        ); (ii) Every state belongs to some fullpath and should have a successor state; (iii) Tree structures are of at most countable  branching; (iv) Every path is isomorphic to .  When trees are considered as models for distributed systems, paths through a tree are viewed as computations. The  requirements for ECTL models we are interested in would  be sufÄÅ¹Âx, fusion and limit closures [6].  Below, we deÄÅ¹Âne a relation Ã¢Â€Â˜ Ã¢Â€Â™, which evaluates wellomitformed ECTL formulae at a state  in a model  ting standard cases for Booleans.                          Aiff iff                  E iffiff                 iff                                 iff                   iffiff                                                 iff                DeÄÅ¹Ânition 1 An ECTL formula  is satisÄÅ¹Âable if, and  such that        .  only if, there exists a model  Formula  is valid if, and only if, every model satisÄÅ¹Âes it.                                                                           As an example let us consider an ECTL formula  A      (1)  which will be served in our example of the transformation  towards SNF in 4.3. It is straightforward from the semantics, that this formula is unsatisÄÅ¹Âable: take an arbitrary  can not be  fullpath, say , and show that  satisÄÅ¹Âed along  as in the linear-time logic.  2.1. Some useful features of ECTL  Here we summarize those features of ECTL that are  important in our analysis and, thus, will affect both the  translation of ECTL formulae to the normal form and the  clausal resolution method.  In the rest of the paper, let T abbreviate any unary and T   any binary temporal operator and P either of path quantiÄÅ¹Âers. Any formula of the type PT or PT  is called a basic  CTL modality.  Proposition 1 [Negation Normal Form correctness]  Given an ECTL formula  and its Negation Normal  Form Ã‚Ë‡ ,      iff     Ã‚Ë‡  [6].          Given a CTL formula  , we will abbreviate the expression Ã¢Â€Â˜a state subformula   with a path quantiÄÅ¹Âer as its  main operatorÃ¢Â€Â™ by P-embedded subformula of  . Now for  an ECTL formula  , we deÄÅ¹Âne a notion of the degree of  nesting of its path quantiÄÅ¹Âers, denoted   , as follows.  DeÄÅ¹Ânition 2 (Degree of path quantiÄÅ¹Âer nesting)      T  T  , and  ,  are purely classical  if   formulae then      T    T   ;  if          T  T  and     ,     then      T    and                   T        ;  if  P and     then  P    .                Emerson and Sistla [10] showed that for any CTL Ã‚Å  (hence ECTL ) formula  with     ,  can be  transformed into  Ã‚Åº by a continuous renaming of the P. For exembedded state subformulae such that   Ã‚Åº   ample, given   A E   E E   we can obtain  A   E   A   E   A  E   A                      Proposition 2 (Correctness of the procedure Red) For      if, and only if, there  any ECTL formula  ,  Ã‚Åº such that  Ã‚Åº   exists a model   , where     is introduced in DeÄÅ¹Ânition 2 [10].  Recall that the logic CTL extends CTL by allowing Boolean combinations of temporal operators (but  not any nesting of them). Yet, it is still as expressive as CTL [8]. Hence we can transform any ECTL  formula which is also a formula of CTL into an equivalent CTL formula. Here we give some of the equivalences  used for such reduction, referring the reader to the menand  tioned paper for other cases which involve the  operation. (In the formulae below  and  are purely classical expressions.)  Proceedings of the 11th International Symposium on Temporal Representation and Reasoning (TIMEÃ¢Â€Â™04)  1530-1311/04 $20.00 Ã‚Å  2004 IEEE              P     P    P     P     P      P     P     P     E      E  E  A     A A  (2)  Like ECTL, ECTL allows limited nesting of temporal operators to express fairness constraints. For some of them,  and E  cases, the validity of the folnamely, for A  lowing equivalences which we will use in our transformation procedure can be easily shown:    A   E  A A   E E   (3)  Applying procedure NNF  and standard classical logic transformations, we can obtain for any ECTL  formula  (that has the degree of path quantiÄÅ¹Âers nesting 1) its Ã¢Â€Â˜specialÃ¢Â€Â™ Disjunctive or Conjunctive Normal   E   and  A  .  Form, abbreviated as  DeÄÅ¹Ânition 3 (DNFE and CNFA for ECTL formulae)   ,  Let us call formulae of the type T   ,  T  ,   (where  and  are purely classical) as elemen E is of the type  tary formulae. Now, a formula in    and a formula in   A is of the type  E   A   , where each       is an elementary formula.  For example, the following formula (which we used in     is  in  A . The proof of the following proposition can be  established immediately from the semantics of ECTL .  2 as an unsatisÄÅ¹Âability example) A  Proposition 3 (Correctness of the DNF E and CNFA )  For any ECTL formula  that has the degree of path quanE   and  A    tiÄÅ¹Âers nesting 1, there exist its  such that  is satisÄÅ¹Âable if, and only if,   E   and   A   are satisÄÅ¹Âable respectively.  Similar to ECTL, a class of basic ECTL modalities  consists of basic CTL modalities, enriched by the fairness  constraints, P  and P  . Our translation to SNF   and temporal resolution rules are essentially based upon the  ÄÅ¹Âxpoint characterizations of basic CTL modalities (see [5]).  Next we observe some results on interpreting ECTL  over canonical models, noting that these results cover all  CTL-type logics, including CTL .  DeÄÅ¹Ânition 4 (Branching degree and branching factor)  The number of immediate successors of a state  in a  tree structure is called a branching degree of . Given a set        , of the branching degrees of the states of  a tree structure, the maximal     is called a branching factor of this tree structure.  As we have already mentioned, we assume that underlying ECTL tree models are of at most countable branching. However, following ([6]), trees with arbitrary, even uncountable, branching, Ã¢Â€Âœas far as our branching temporal logics are concerned, are indistinguishable from trees with ÄÅ¹Ânite, even bounded, branchingÃ¢Â€Â.      ,  DeÄÅ¹Ânition 5 (Labelled tree) Given a tree  where is a set of nodes and  is a set of edges, and a ÄÅ¹Ânite alphabet, , a    tree is a structure    where is a mapping  , which assigns for each  state, element of , some label, element of .  In 2 we introduced the notion of satisÄÅ¹Âability and validity of ECTL formulae in relation to    . Now, following [12], we call such a structure a tree interpretation.  Next we recall a notion of a  -ary tree canonical model  which plays a fundamental role in our correctness argument.  For these purposes, again following [12], we will look at  tree interpretations as tree generators: the root of the tree  is understood as an empty string, , and the whole tree is  seen as a result of unwinding of the root applying the suc    cessor function           , where     and    is a set of successors of a state .  DeÄÅ¹Ânition 6 (Tree canonical interpretation) Let       be a  -ary inÄÅ¹Ânite tree such that   denotes the set   , of branching degrees of the states    in and            . Now, given an al    , a  -ary tree canonical interpretaphabet     tion for an ECTL formula  is of the form  , where        such that      .    In a canonical interpretation       the set of  states, the initial state and the successor relation are all    ,  ÄÅ¹Âxed, hence, Ã¢Â€Âœ...they reduce to a function         that is to a labelled tree over the alphabet   ...Ã¢Â€Â ([12]).  We will refer to this tree as a canonical model. Proposition 4  given below collects the results given in [12] (Lemma 3.5).  Proposition 4 (Existence of a canonical model)  If an  ECTL formula  with  E-quantiÄÅ¹Âers has a model, then it  has an  -ary canonical model.  These results were essentially used in the formulation  of the transformation rule for the ECTL fairness constraint  A  [2]. In this paper we will further extend their applicability in the transformation procedure for ECTL .  3. Normal Form for ECTL  As a normal form for ECTL , similarly to ECTL, we  utilise a clausal normal form, deÄÅ¹Âned for the logic CTL,  SNF , which was developed in [1, 4]. All formulae  of SNF of the type   E  or   E   (see below), where  is a purely classical expression, are  labelled with some index. Indices are used to preserve  Proceedings of the 11th International Symposium on Temporal Representation and Reasoning (TIMEÃ¢Â€Â™04)  1530-1311/04 $20.00 Ã‚Å  2004 IEEE  a speciÄÅ¹Âc path context during the translation. The language for indices is based on the set of terms                 where        denote constants. A designated type of indices in  SNF  are indices of the type   which represents  a limit closure of  . Thus, E  means that  holds on  some path labelled as  , for some  .  The alphabet for SNF  language is obtained from  ECTL by omitting the  and  operators, adding classically deÄÅ¹Âned constants  and  and a new operator,   (Ã¢Â€Â˜at the initial moment of timeÃ¢Â€Â™) deÄÅ¹Âned as         iff  .  )  DeÄÅ¹Ânition 7 (Separated Normal Form SNF   SNF  is a set of formulae A     where  each of the clauses    is further restricted as beis a literal,   low, each     ,     or  or  and     is some index.                A       E       A       E                  an initial clause                    an A step clause  a E step clause  an A sometime clause    a E sometime clause     We obtain the SNF  semantics from the semantics of  ECTL ( 2) by preserving only items for state formulae.  4. Transformation of ECTL formulae into  SNF    In this section we will ÄÅ¹Ârst describe the algorithm to  transform ECTL  formulae into SNF  , some of its rules,  and, ÄÅ¹Ânally, give an example transformation.  4.1. Algorithm to transform ECTL formulae into SNF    As SNF  is a part of the resolution technique, to check  validity of an ECTL  formula , we ÄÅ¹Ârst negate the latter  and translate  into its Negation Normal Form, deriving    NNF   . We introduce the transformation procedure       applied to  , where  and  are  described respectively by the steps 1-2 and 3-10 below.  (1) Anchor  to   and apply the initial renaming  rule obtaining A      A    , where   is a new proposition.  (2) Apply equations (3) and procedure   (see DeÄÅ¹Ânition 2) to  . Thus, we derive a  set of constraints of the following structure    A            where           is a proposition,   is either a purely classical formula or if  contains a path quantiÄÅ¹Âer then the degree of  nesting of path quantiÄÅ¹Âers in   is 1.  Let us call a formula  in pre-clause form  if     i.e. it is of the form      where  is a literal, conjunction of literals, or    ,  is a purely classical formula or any of   P   PÃ‚Ë T Ã‚Å¾  PTÃ‚Ë    PT P  T  PTÃ‚Ë    T  (for some    ) and   Ã‚Ë    are purely classical formulae.  (3) For every pre-clause     :  (3.1) If   is an ECTL formula but not a CTL  formula then do the following:  (3.1.1) obtain its  E   or   A   and apply  equivalences 2-(e) or 2-(f) respectively.  (3.1.2) apply equivalences (3).  (3.1.3) apply procedure  .  (3.2) If   contains Boolean combinations of temporal  operators but does not contain any fairness constraint then  (as it is a CTL formula) apply the procedure to transform  CTL into CTL (see section 2.1).  (4) At this stage, renaming state subformulae (which are  expressed by basic CTL modalities) on the right hand-sides  of the constraints derived at step 3 we obtain the structure  required for a pre-clause.  (5) For every pre-clause     , by continuous renaming of the embedded classical subformulae by auxiliary  propositions together with some classical transformations  we obtain the following conditions.  - If  contains a basic CTL modality then  - If  PT and PT is not P then  is a literal,  else  is a purely classical formula.  - If  E   or   A   then  is a literal,  - If  PÃ‚Ë T Ã‚Å¾  then Ã‚Ë and Ã‚Å¾ are literals.  - If  E       or  A      ,  where each       and       is a temporal operator or a fairness constraint applied to classical formulae (but not literals) we obtain the structure where they  apply to literals.  modality  (6) Label each pre-clause containing the E  by an unique index      and any other pre-clause  containing the E quantiÄÅ¹Âer by an unique index     . Let LIST IND be a list of all indices introduced during  this labelling.  and A  .  (7) Transform pre-clauses with E  (8) Transform pre-clauses containing E        or A        (of the structure obtained at step 5).  (9) Remove all unwanted basic CTL modalities.  (10) Derive the desired form of SNF  clauses. At this  ÄÅ¹Ânal stage we transform pre-clauses     , where   is either P  or a purely classical formula: for every preclause   P  , we obtain the structure where P ap-  Proceedings of the 11th International Symposium on Temporal Representation and Reasoning (TIMEÃ¢Â€Â™04)  1530-1311/04 $20.00 Ã‚Å  2004 IEEE  plies either to a literal or to disjunction of literals. This can  be achieved, again, by renaming of the embedded classical  subformulae, applying rules used to obtain conjunctive normal form (CNF), and distributing P over conjunction, together with some classical transformations. Further, for ev , we apery remaining purely classical pre-clause  ply a number of procedures including those that are used in  classical logic in transforming formulae to CNF, some simpliÄÅ¹Âcations and the introduction of a temporal context.  4.2. Transformation rules towards SNF    Indices. Recall that at step 6 of the transformation procedure, we introduce labelling of the SNF  pre-clauses  containing the E quantiÄÅ¹Âer. The justiÄÅ¹Âcation of this labelling is based upon ÄÅ¹Âxpoint characterization of basic CTL  modalities and was explained in [1, 2] except for the new  speciÄÅ¹Âc ECTL formulae in  E form. The latter can  be explained simply based upon the SNF  semantics.  Rules to remove basic CTL modalities. Here we give  those removal rules that will be used in our examples of  the transformation to SNF  ( 4.3) and refutation ( 6). In  the formulation of the rules given below  is a new proposition:    Removal of E        E     E      Removal of E                    E       E              case.                A  E  E            Ã‚Ë    E  E          Ä‚Â’         Ã‚Ë      Ä‚Â’      Managing embedded boolean combinations of path subformulae in ECTL . Recall that on step 8 of the transformation procedure we must further reduce formulae of the    and A    . The correform E   sponding rules are given below where   is   if the   are not , and  otherwise and is the number of indices in LIST IND.     E  A                  A  E         case.    E  E    E            Ã‚Åº       Ã‚Åº  case.          A  E        E                      Ã‚Ë     Finally, from the rest of the rules previously deÄÅ¹Âned for  CTL/ECTL, we use the following.  Temporising                  A  E  E        Distributivity of E    Managing embedded path subformulae in ECTL .  We incorporate rules to rename purely path formulae embedded in ECTL  fairness constraints from [2]. Let   and  the number of indices in LIST IND be  let      be the constants occurLIST IND  ring in these indices. If for some index   we do not have    LIST IND then we upgrade LIST IND by   (in the formulation below  is the number of indices in LIST IND and     are  new propositions).                Renaming: the A                  E  E  E      The ÄÅ¹Ârst stage of the transformation procedure  outlined above, the procedure  , is taken from the translation  of ECTL formulae to SNF  [2]. Here we describe novel  techniques to cope with Boolean combinations of temporal operators deÄÅ¹Âned in addition to the rules of the procedure  , introduced for ECTL [2]. We also recall some of  those rules that will be used in our example given in 4.3.  For the full set of rules preserved from the CTL the reader  is referred to [1, 4].  In the presentation below we omit the outer Ã¢Â€Â˜A Ã¢Â€Â™ connective that surrounds the conjunction of pre-clauses and, for  convenience, consider a set of pre-clauses rather than the  and  will abbreviate purely  conjunction. Expressions  classical formulae.  case.  Renaming: the E        A      E  E  E                       In the rule for E , given that the premise of the rule is labelled by   , we preserve this label for both conclusions, thus, assuring that they refer to the same path.      4.3. Example Transformation  As an example we translate into SNF  the formula:  E  Proceedings of the 11th International Symposium on Temporal Representation and Reasoning (TIMEÃ¢Â€Â™04)  1530-1311/04 $20.00 Ã‚Å  2004 IEEE      (4)  To check if (4) is valid negate it and apply procedure NNF   E        A     which was considered as an example of an unsatisÄÅ¹Âable formula in 2. From the translation algorithm, we derive steps 0Ã¢Â€Â“2, where  is a new  proposition.            A    A                          We proceed with formula 2, where the right hand side of the  implication is already in   A  . Thus, we apply equation (2)-(f) to distribute the A over conjunction in 2, obtaining 3, and then simplify the latter deriving 4 and 5. Next,  we simplify formula 4 applying (3-(a)) to get 6. The structure of the latter enables us to apply procedure  deducing 7 and 8 and introducing a new variable .     A  A            A         A         A A           A           A        Applying the renaming rule (A  case) to 5 we derive formula 9 and label it with a new index     (since  LIST IND is empty). Applying equation (3-(b)) to 9 we get  E E      which is further reduced by procedure  to 10 and 11, where is a new variable. Apply A removal rule to 7 and E removal rule 11, where   and  are new variables.                                   E  E  E  A                                                      A   A   E   E    E      Next simplifying and temporising formulae 12 and 14 we  obtain 16-19 and 20-23 respectively. Finally, we distribute  in 13 and 15.  A and E over                                                                                      A     A       A  A  A  A  E  E                                                                                           E            E    The normal form of the given ECTL  formula A   is represented by clauses 1, 8, 10, 16Ã¢Â€Â“27.    5. Correctness of the Transformation of  ECTL formulae into SNF    Here we provide the correctness argument for our transformation procedure. A signiÄÅ¹Âcant part of this argument is  either similar to the corresponding proofs given in [1, 2]  for CTL and ECTL or extend these proofs for new cases of  ECTL formulae. Therefore, we will only state such claims  referring the reader to [1, 2] while we sketch here proofs  for new techniques used for ECTL  transformations. Note  also that in our previous paper ([2]) we have not established the proof for the claim analogous to Lemma 3 (see  below). Therefore, providing our argument in this paper, we  not only show the desired correctness of the transformation  procedure for ECTL  but also bridge this gap for ECTL.  Theorem 1 An ECTL formula,  only if,   is satisÄÅ¹Âable.  , is satisÄÅ¹Âable if, and  To establish the correctness of this theorem we ÄÅ¹Ârst show  is satisÄÅ¹Âable, if and only if  that an ECTL formula    is satisÄÅ¹Âable (Lemma 1). At the next stage we prove  that the transformation procedure   preserves satisÄÅ¹Âability (Lemma 2). Finally, (Lemma 3), we show that given  an ECTL formula  and its normal form, SNF  ( ),  if SNF ( ) is satisÄÅ¹Âable then is satisÄÅ¹Âable.  Lemma 1 An ECTL formula, , is satisÄÅ¹Âable if, and only  if,   is satisÄÅ¹Âable.  Since  is taken from the translation of ECTL formulae to SNF , the proof of Lemma 1 follows from the correctness argument for ECTL ([2]).  Lemma 2 Given an SNF formula  ÄÅ¹Âable then so is   .  , if      is satis-  Here we must show that the new techniques used in  our transformation procedure preserve satisÄÅ¹Âability. This  includes the correctness argument for   E and  A  and also for the cases of Boolean combinations of temporal operators, E         case and A          case. Corresponding proofs are established straightforwardly from the SNF  semantics, taking into account the  meaning of indices and Proposition 4 ([12]).  Lemma 3 Given an ECTL  formula  satisÄÅ¹Âable then so is .  , if SNF    is  From Lemma 1 it follows that given an ECTL  formula , is satisÄÅ¹Âable if, and only if,    is satisÄÅ¹Âable.  Thus, for the proof of Lemma 3 we must show that the following proposition takes place:  PROOF :  Proposition 5 Given an ECTL  formula , if    satisÄÅ¹Âable then so is  .  Proceedings of the 11th International Symposium on Temporal Representation and Reasoning (TIMEÃ¢Â€Â™04)  1530-1311/04 $20.00 Ã‚Å  2004 IEEE   is  Here we sketch the proof for the new core technique introduced in our transformation procedure. We will show   A         and havthat given  A  ing generated   A   E                    A  E                 (where at least one of        has a form of  or  ), if  is satisÄÅ¹Âable then  is satisÄÅ¹Âable.    Consider a model  which satisÄÅ¹Âes . We have        . Following [12], we know  that if a formula with path quantiÄÅ¹Âers has a model, then   Ã¢Â€Â™ary canonical model. We will now conit has an  struct this canonical model   and show that every state  in the model also satisÄÅ¹Âes . The construction proceeds by  ÄÅ¹Ârst selecting a path, say , from  which satisÄÅ¹Âes one  of the       clauses. This will be a basis path  to construct a canonical model, which is also referred to as  the Ã¢Â€ÂleftmostÃ¢Â€Â path of the canonical model in [12]. Due to  the labelling of the states of this path, each of them satisÄÅ¹Âes  E             . Then inductively construct each of the additional paths (corresponding to     quantiÄÅ¹Âers) from each state along .  Again, we label the states of these paths based on the  original interpretations from M such that each of them also  satisÄÅ¹Âes  E             (for some ). We  then proceed in the same way to take each state of the newly  constructed paths and generate the additional paths from  each of them to derive the completed canonical model.  PROOF :           Ã‚Ë     Ã‚Å¾  Figure 1.   Ã‚Â´    Ã‚Ë  Ã‚Ë   Ã¢Â€Â™ary    Ã‚Ä¾  Ã‚Ë  Ã‚Ë   Ã‚Åº  Canonical  Model for .  Our ultimate task is to show that for any state in the  canonical model   which satisÄÅ¹Âes , every path emanating from it satisÄÅ¹Âes        . This will ensure that   A         is satisÄÅ¹Âed at every state of  , and,  therefore, it is satisÄÅ¹Âed in the root of   . Consider an arbitrarily chosen path   of  and a state   , see Figure  1. By the construction of   , every one of the paths emanating from   satisÄÅ¹Âes        . What is left is to show  that      (which corresponds to the   path emanating from   ) also satisÄÅ¹Âes        . The latter follows from the labelling of the states of the path   which is  taken from one of the paths of  that satisÄÅ¹Âes one of the         .  6. The Temporal Resolution Method  In order to achieve a refutation, we apply two types of  resolution rules already deÄÅ¹Âned in [1, 4]: step resolution  (SRES) and temporal resolution (TRES). The SRES rules  are used between formulae which refer to the same initial  moment of time or same next moment along some or all  paths. The basic idea of invoking temporal resolution is to  resolve a set of formulae characterizing a loop in , i.e. a  set of SNF clauses indicating a situation when  occurs  at all future moments along every (an A-loop in ) or some  path (a E-loop in ) from a particular point in an ECTL   model, together with the clause containing   [3]. Here  we present those step (SRES 1 and SRES 2) and temporal resolution (TRES 2 and TRES 4) rules which are used  in the example refutation. (For a detailed description of the  resolution technique deÄÅ¹Âned over SNF  see [1, 4].)  SRES 1           TRES 2  A  E  E  SRES 2         A        A       A      TRES 4        E  A              E  E                E          In the rules above  is a literal and the ÄÅ¹Ârst premises in the  TRES rules abbreviate the A and E loops in  respectively  (given that is satisÄÅ¹Âed).  Correctness of the transformation of ECTL  formulae  into SNF ( 5) together with the termination and correctness of the resolution method deÄÅ¹Âned over SNF  (shown  in [1, 4]) enables us to apply the latter as the refutation  method for ECTL  .  Example Refutation. We apply the resolution method to  the set of SNF clauses obtained in section 4.3 for  . We commence  the ECTL formula A  the resolution proof presenting at steps 1 Ã¢Â€Â“ 13 only those  clauses that are involved in the resolution refutation in the  following order: initial clauses, step clauses and, ÄÅ¹Ânally, any  sometime clauses.          A     A              E               E              A                E         A     A           We apply step resolution rules between 1 and 2, and 1 and 3.  No more SRES rules are applicable. Formula 12 is an eventuality clause, and therefore, we are looking for a loop in  Proceedings of the 11th International Symposium on Temporal Representation and Reasoning (TIMEÃ¢Â€Â™04)  1530-1311/04 $20.00 Ã‚Å  2004 IEEE  (see [3] for the formulation of the loop searching procedure). The desired loop, E E    (given that condition  is satisÄÅ¹Âed) can be found considering clauses 10  and 11. Thus, we apply the TRES 4 rule to resolve this loop  and clause 12, obtaining 16. Next we remove E  from 16  deriving a purely classical formula 17 ( is a new variable).  Simplify the latter, apply temporising, obtaining, in particular, 19 and 20, and then a series of SRES rules to newly  generated clauses.                        E          TRES 4           E       E        E                   A                                               A                A              A         Now, as no more SRES rules are applicable, we are looking for a loop in  which can be found considering formulae 9 and 26: A A   given that condition   is satisÄÅ¹Âed. Thus, we can apply TRES 2 to resolve this loop and 13  deriving 27. Then we remove E  from the latter (on step  28, where is a new variable, we use only one of its conclusions). Applying simpliÄÅ¹Âcation and temporising to 28 we  obtain 29. The desired terminating clause      is deduced by applying SRES 1 to steps 1, 15 and 23.                      E                                E             7. Conclusions and Future Work  We have described the extension of the clausal resolution  method to the useful branching-time logic ECTL  . Here  we have followed our general idea to expand the applicability of the clausal resolution technique originally developed for linear-time temporal logic [11], and further extended to branching-time temporal logics CTL and ECTL  [4, 1, 2]. This extension enables us to invoke a variety of  well-developed methods and reÄÅ¹Ânements used in the resolution framework for classical logic. The algorithm to search  for loops needed for temporal resolution has been introduced in [3]. With the proof that SNF  can be served as  the normal form for ECTL  , the algorithm becomes fully  functional for the latter. Another contribution of this paper is completing the proof of the correctness of the transformation procedure in ECTL formulated in [2]: we have  now shown that if the set of clauses generated for an ECTL  formula is satisÄÅ¹Âable then the original formula is satisÄÅ¹Âable. Our results have brought us one step closer to the ÄÅ¹Ânal stage of our long-term project - to deÄÅ¹Âne a clausal resolution method for CTL . Among other obvious tasks are  to reÄÅ¹Âne the presented method and to analyse its complexity which would enable the development of the corresponding prototype systems.  References  [1] A. Bolotov. Clausal Resolution for Branching-Time Temporal Logic. PhD thesis, Department of Computing and Mathematics, The Manchester Metropolitan University, 2000.  [2] A. Bolotov. Clausal resolution for extended computation tree  logic ECTL. In Proceedings of the Time-2003/International  Conference on Temporal Logic 2003, pages 107Ã¢Â€Â“117, Cairns,  July 2003. IEEE.  [3] A. Bolotov and C. Dixon. Resolution for Branching Time  Temporal Logics: Applying the Temporal Resolution Rule.  In Proceedings of the 7th International Conference on Temporal Representation and Reasoning (TIME2000), pages  163Ã¢Â€Â“172, Cape Breton, Nova Scotia, Canada, 2000. IEEE  Computer Society.  [4] A. Bolotov and M. Fisher. A Clausal Resolution Method  for CTL Branching Time Temporal Logic. Journal of Experimental and Theoretical ArtiÄÅ¹Âcial Intelligence., 11:77Ã¢Â€Â“  93, 1999.  [5] J. BradÄÅ¹Âeld. and C. Stirling. Modal logics and mu-calculi. In  J. Bergstra, A. Ponse, and S. Smolka, editors, Handbook of  Process Algebra, pages 293Ã¢Â€Â“330. Elsevier, North-Holland,  2001.  [6] E. A. Emerson. Temporal and Modal Logic. In J. van  Leeuwen, editor, Handbook of Theoretical Computer Science: Volume B, Formal Models and Semantics., pages 996Ã¢Â€Â“  1072. Elsevier, 1990.  [7] E. A. Emerson. Automated reasoning about reactive systems. In Logics for Concurrency: Structures Versus Automata, Proc. of International Workshop, volume 1043 of  Lecture Notes in Computer Science, pages 41Ã¢Â€Â“101. Springer,  1996.  [8] E. A. Emerson and J. Y. Halpern. Decision procedures and  expressiveness in the temporal logic of branching time. In  JCSS 30(1), pages 1Ã¢Â€Â“24, 1985.  [9] E. A. Emerson and J. Y. Halpern. Ã¢Â€ÂœSometimesÃ¢Â€Â and Ã¢Â€ÂœNot  neverÃ¢Â€Â revisited: On branching versus linear time temporal  logic. JACM, 33(1):151Ã¢Â€Â“178, 1986.  [10] E. A. Emerson and A. P. Sistla. Deciding full branching time  logic. In Proceedings of STOC 1984, pages 14Ã¢Â€Â“24, 1984.  [11] M. Fisher. A Resolution Method for Temporal Logic. In  Proc. of the XII International Joint Conference on ArtiÄÅ¹Âcial  Intelligence (IJCAI), pages 99Ã¢Â€Â“104, 1991.  [12] P. Wolper. On the relation of programs and computations to  models of temporal logic. In L. Bolc and A. SzaÄ¹Â‚as, editors,  Time and Logic, a computational approach, chapter 3, pages  131Ã¢Â€Â“178. UCL Press Limited, 1995.  Proceedings of the 11th International Symposium on Temporal Representation and Reasoning (TIMEÃ¢Â€Â™04)  1530-1311/04 $20.00 Ã‚Å  2004 IEEE 