Temporal Query Languages Expressive Power: TL vs. T- WHILE  Nicole Bidoit, Matthieu Objois  Laboratoire de Recherche en Informatique  L.R.I. UMR 8623 CNRS  Batiment 490 - UniversitÄ‚Å  Paris Sud  91405 Orsay Cedex - FRANCE  {bidoit,objois}@lri.fr  Abstract  We investigate the expressive power of implicit temporal query languages. The initial motivation was reÄÅ¹Âning  the results of [1] and enrich them with comparison to TL  [17]. Thus, we address two classes of temporal query languages: TL-like languages based on TL and T- WHILE-like  languages based on WHILE. We provide a two-level hierarchy (w.r.t. expressive power) for these temporal query languages. One of the contributions solves an open problem:  the relative expressivity of TL and T- FIXPOINT [1, 11].  1  Introduction  In this paper we focus our attention on temporal  databases and temporal query languages. Two different representations of time are classically considered: the implicit  framework deÄÅ¹Ânes a temporal database as a ÄÅ¹Ânite sequence  of instances; in the explicit framework, tuples in relations  are timestamped. It is now well-known that as far as representing time is concerned, the implicit and explicit representations of time are equally expressive. However, as  far as temporal query languages are concerned, the choice  between implicit and explicit frameworks leads to different  languages w.r.t. expressive power. With implicit time, the  linear temporal logic TL and its extensions are the basic formalisms underlying query languages [8, 7]. When time is  explicitly represented, queries are speciÄÅ¹Âed using the language TS - FO (or extensions) which is simply the relational  calculus FO with timestamps.  As pointed out in [7], temporal logic and their extensions are especially attractive as query languages for temporal databases because of their simplicity and computational  advantages. Indeed, because the references to time are hidden, queries are formulated in an abstract, representationindependent way. As far as computational complexity is  concerned, [15] shows that the satisÄÅ¹Âability problem for  propositional TL is PSPACE-complete (whereas the same  problem for ÄÅ¹Ârst-order theory is non elementary [13]).  The work of [1] (see also [5]) gives new insight to the relative expressive power of TL and TS - FO as query languages:  surprisingly enough1, ÄÅ¹Ârst order TL is strictly less expressive  than TS - FO. Subsequent research work [1, 11, 4] investigate  query languages more expressive than TL. More recently,  [16] has proved (based on the techniques of [5]) that TS - FO  is strictly more expressive than any ÄÅ¹Âxed-dimensional ÄÅ¹Ârstorder temporal logic.  This paper focuses on the implicit languages introduced  in [1] where the authors investigate a classical way to extend FO in order to build implicit temporal languages. These  languages rely on traditional imperative mecanisms namely  assignements, iterations (while statements) and temporal  moves. These languages further denoted T- WHILE-like languages are also extensions of WHILE introduced in [6] to  capture recursive queries in the static framework. In this paper, we address another class of temporal query languages  called TL-like languages. These languages can be viewed  as extensions of TL [17, 11] or alternatively as extensions of  FO with ÄÅ¹Âxpoint formulas [14, 6, 9, 10, 2].  [1] provides an expressive power hierarchy of temporal languages including TL, TS - FO, T- WHILE-like languages  and their explicit counterparts. Surprisingly enough [1, 11]  do not address TL-like languages in their expressive power  comparative study.  The work presented in this paper aims at contributing to  the following open problem pointed out in [7]: Ã¢Â€ÂœFixpoint  temporal logic TL has been extensively used in program  veriÄÅ¹Âcation, although only in the propositional case. The  ÄÅ¹Ârst order version of TL remains to be studied. In particular, its relationship to T- WHILE (...) needs to be elucidated.Ã¢Â€Â  One of the main contributions of our paper is to enrich  the expressive power hierarchy of [1] showing that the ÄÅ¹Ârst  order inÄÅ¹Â‚ationary extension of TL is strictly less expressive than T- FIXPOINT 2 which is roughly the inÄÅ¹Â‚ationary TWHILE -like language with some non-inÄÅ¹Â‚ationary features.  1 This  2 In  result stands in contrast with the propositional case.  the paper, this language is renamed T- WHILE.  Proceedings of the 12th International Symposium on Temporal Representation and Reasoning (TIMEÃ¢Â€Â™05)  1530-1311/05 $20.00 Ã‚Å  2005 IEEE  We also show that T- FIXPOINT is equivalent to the non inÄÅ¹Â‚ationary T- WHILE which entails that T- FIXPOINT is not  PTIME as claimed in [1].  The expressive power results presented in this paper shed  new light on the impact of the features of the two classes  of languages. In the static case, each result holding for a  WHILE -like language also holds for its FO ÄÅ¹Âxpoint counterpart. Surprisingly enough, this symmetry is broken in  the temporal framework: for instance, the inÄÅ¹Â‚ationary TWHILE -like language with some non-inÄÅ¹Â‚ationary features  (already mentionned above as T- FIXPOINT) is strictly more  expressive than its TL-like counterpart. Another interesting impact of our results is that they highlight the frontier  between querying static databases and querying temporal  databases. More precisely, part of our results relies on the  assumption that the temporal instances under consideration  are composed of at least two states as opposed to static ones  composed of a single state.  The paper is organized as follows. Section 2 is devoted  to preliminaries and section 3 to the presentation of the  implicit temporal languages whose comparative expressive  power are investigated in section 4. We conclude the paper  in section 5 by discussing our results and addressing some  open problems.  2  Preliminaries  We assume the reader familiar with both ÄÅ¹Ârst-order logic  and temporal logic TL and with the usual deÄÅ¹Ânitions of  relation schema, database schema and instances. We denote the arity of a relation schema  by  . In the whole  paper, we consider the database schemas  Ã‚Ë     and   Ã‚Ë   and we assume a unique domain  .  An implicit temporal instance over , is a ÄÅ¹Ânite sequence Ã‚Ë    of (ÄÅ¹Ânite) instances over . For each   ,  is called the state of at time point . The  instance of the relation schema  at time point is denoted  by  . The active domain of , denoted  , is  the union of the active domains of the states  . The well  known Ã¢Â€Âœunsafe queryÃ¢Â€Â problem is solved here by restricting variables to range over the active domain of the input  temporal database.  In the paper,  Ã‚Ë    is a temporal instance of size  over ,  represents an unspeciÄÅ¹Âed tuple of variables  whose arity is clear from the context, and  is a valuation  of  ranging over  .  Let   Ã‚Ë    be a temporal instance of size over   . Merging the  the database schema where  instances and  leads to the instance denoted   over the  , deÄÅ¹Âned as Ã‚Ë    where for all  database schema   : 1) for all   ,        and 2) for  all   ,       .  whose  We denote Ä‚ÂŠ any temporal instance over  states are all empty.  FO                            3  Temporal query languages  In this section, we revisit the speciÄÅ¹Âcation of some of the  languages introduced in [17, 1, 11] in order to better identify their features, and we also introduce new languages.  We proceed by introducing two classes of implicit temporal query languages, each one sharing the same paradigm:  TL -like languages presented in section 3.1 are both extensions of TL and of FO ÄÅ¹Âxpoint and T- WHILE-like languages  presented in section 3.2 are temporal extensions of WHILE.  Languages in a class differ by some features (e.g. inÄÅ¹Â‚ationism vs. non inÄÅ¹Â‚ationism) leading to alternative query  languages. We now proceed to the presentation of the languages. The main expressivity results are developed and  discussed in section 4.  3.1  TL -like  languages  All query languages presented in this section are based  on the TL language, introduced in the propositional case  by Vardi in [17] and extended to the ÄÅ¹Ârst order case by Herr  in [11]. These languages can also be seen as temporal extensions of the static query language FO ÄÅ¹Âxpoint, which has a  long history: it has ÄÅ¹Ârst been considered over inÄÅ¹Ânite stuctures in [14], and afterward studied in the ÄÅ¹Ânite case (which  is relevant to the database context) in [6, 9, 10, 12].  Syntax The syntax of TL-like languages over the  is obtained by the formation rules for  database schema  FO , together with the following additional rules:  if  is a formula then    and  are formulas.  suppose that   . We call auxiliary schema any  schema in . We deÄÅ¹Âne a (simultaneous) inductive operator for the auxiliary schemas. Let Ã‚Ë    be formulas  3  . Each formula  has as  over the database schema  many free variables as the arity of  . For all   , the  -expression Ã‚Ë    Ã‚Ë‡Ã‚Ë      can  be used like a relation schema to build a formula  Ã‚Ë    Ã‚Ë‡Ã‚Ë     . The schemas  Ã‚Ë    (resp. Ã‚Ë‡Ã‚Ë    ) are called the checked (resp.  unchecked) auxiliary schemas of the -expression. Note  that -expressions can be nested.  Whether an auxilliary schema is checked or unchecked  has an impact on the semantics of the language (see below).  Intuitively, the former (resp. the latter) enforces the instance  of the auxilliary schema to be used (resp. ignored) when  computing the semantics of a -expression.               E XAMPLE 3.1 Let  (resp. Ã‚Ë , Ã‚Å¾ ) be a binary relation  schema in (resp. ) and consider the formulas 4 :  Ä‚Â‹Ã‚Ë  Ä‚Â‹Ã‚Å¾               Ã‚Ë     ,       Ã‚Ë          Ã‚Å¾  .  Ã‚Ë   Ä‚Â– and Ã‚Ë   Ä‚Â— can appear in the formula Ä‚Â‹ for all    .  4  (resp.  ) stands for      (resp.    ).  3 Both  Proceedings of the 12th International Symposium on Temporal Representation and Reasoning (TIMEÃ¢Â€Â™05)  1530-1311/05 $20.00 Ã‚Å  2005 IEEE  The formula           is referred to as      in the rest of the section. Intuitively,     computes a Ã¢Â€Âœback-and-forth temporal pathÃ¢Â€Â along the temporal  instance, beginning with the value (in the ÄÅ¹Ârst state).  Semantics The satisfaction of a formula over at time  point    given a valuation , denoted      is  deÄÅ¹Âned as follows:   if is obtained by a ÄÅ¹Ârst-order rule,     is deÄÅ¹Âned  as usual   if is ,     iff   and         if is ,     iff  and         if is                , we ÄÅ¹Ârst  need some preliminaries: let  Ä‚Â† be the sequence of  temporal instances of size over  deÄÅ¹Âned by:    is the empty temporal instance     is the temporal instance deÄÅ¹Âned for each time  point     and each auxiliary schema  for      by:                   a valuation.  Intuitively,     is the answer of the query   evaluated over   at time point  .  Next, the sequence     Ä‚Â† is the one obtained from   Ä‚Â† by projection over the checked auxiliary schemas  5      . Suppose that     Ä‚Â† reaches a repetition ,   . Intuand consider the least   such that           itively, the unchecked auxiliary relations are Ã¢Â€ÂœhiddenÃ¢Â€Â when  checking for a repetition.  Thus when is               ,  we have     iff     , that is iff the  tuple  belongs to the relation over  of the temporal  instance  at time point .  If     Ä‚Â† never reaches a repetition, we say that the semantics of both the -expression and the formula it appears  in are undeÄÅ¹Âned.  E XAMPLE 3.2 The table below illustrates the above semantics using the  formula of example 3.1. It gives a temporal instance for  and the sequence  Ä‚Â† .  t  Ä‚Â  Ä‚Â‹  Ä‚Â‹  Ä‚Â‹  Ä‚Â‹  Ä‚Â‹  Ä‚Â‹  Ä‚Â‹  Ä‚Â‹  1                                                            2                                                             3                                               The above computation reaches a repetition at iteration 6,  because   . Thus the evaluation of the instance over  auxiliary schema  (resp.  ) is   (resp.  );  5 We say that  a sequence   Ã‚Å¾  such that      Ã‚Ë .   Ã‚Å¾Ã¢Â€Âœreaches a repetitionÃ¢Â€Â iff there exists  hence the evaluation of  over the above temporal instance  is            .  Let   be obtained from  by declaring  unchecked:                . The computation of     Ä‚Â† is the same for both  and  , but such is not the    case for the sequence   Ä‚Â† . Indeed,     Ä‚Â† reaches a   Ä‚Â† only contains the inrepetition at iteration 3, since     stance over the auxiliary schema  , and      .  Thus the evaluation of   over the above temporal instance  is      .  Query languages We deÄÅ¹Âne queries based on the formulas deÄÅ¹Âned above exactly like for TL. A query  is speciÄÅ¹Âed  by a formula  and the answer of  over is obtained by  evaluating  at time point 1:                      a valuation  Next, we use the notion of inÄÅ¹Â‚ationary formulas. A  formula   is inÄÅ¹Â‚ationary if, considering the sequence   Ä‚Â† deÄÅ¹Âned above,          for all     . Hence an inÄÅ¹Â‚ationary formula is intuitively a  Ã¢Â€ÂœcumulativeÃ¢Â€Â one.  We now deÄÅ¹Âne four TL-like query languages based on  the previous syntax and semantics.  1. TL denotes the language without unchecked auxiliary schemas and where all formulas of -expressions  are inÄÅ¹Â‚ationary.  2. TL denotes the language without unchecked auxiliary  schemas and with arbitrary formulas.  3. TL   denotes the language where auxiliary schemas  can be checked or unchecked, and where all formulas  of -expressions Ã¢Â€ÂœdeÄÅ¹ÂningÃ¢Â€Â some checked relations are  inÄÅ¹Â‚ationary.  4. TL denotes the language where auxiliary schemas  can be checked or unchecked, and with arbitrary formulas.  Note that, in all four languages, -expressions must contain obviously at least one auxiliary schema and moreover  at least one auxiliary schema must be checked.  Repetition vs. limit The semantics of -expressions  is deÄÅ¹Âned using the repetition of the checked sequence      Ä‚Â† . Another classical way to deÄÅ¹Âne such a seman  tics is by using the limit of the sequence. These two definitions lead to different semantics for TL   and TL ,  and they lead to equivalent query languages for TL and    TL. Indeed, TL   repetition and TL limit (resp.  TL repetition and TL limit) are probably not equivalent query languages. Hence, we beleive that only TL  and TL would deserve to be called Ã‚Å¤ ÄÅ¹Âxpoint query languages Ã‚Å¥.  It is easy to show that in the static case, the repetition and  limit deÄÅ¹Ânitions lead to equivalent query languages for both  the inÄÅ¹Â‚ationary and non inÄÅ¹Â‚ationary FOÄÅ¹Âxpoint.  Proceedings of the 12th International Symposium on Temporal Representation and Reasoning (TIMEÃ¢Â€Â™05)  1530-1311/05 $20.00 Ã‚Å  2005 IEEE  Partial query languages There exists formulas belonging  to TL and TL whose semantics is undeÄÅ¹Âned, but every  TL Ã‚Ë‡ and TL Ã‚Ë‡ formula admits a deÄÅ¹Âned semantics. The  facts that on the one hand TL and TL are partial languages and on the other hand TLÃ‚Ë‡ and TLÃ‚Ë‡ are total languages generalize the static case: recall that non inÄÅ¹Â‚ationary FO ÄÅ¹Âxpoint is a partial query language and inÄÅ¹Â‚ationary  FO ÄÅ¹Âxpoint is a total query language.  3.2  T- WHILE -like  languages  All query languages presented in this section are based  on the T- WHILE language introduced in [1]. T- WHILE is  a temporal extension of the well-known WHILE query language for static databases [6]  Syntax We assume w.l.o.g. that the database schema  includes (implicitly) two 0-ary schemas  and  6 .  A program over  is speciÄÅ¹Âed by a sequence of declarations followed by a sequence of instructions.  Declarations enable to specify some new relation schemas  for programs, i.e. schemas not in , called auxiliary  schemas. An auxiliary schema can be declared:  shared or private,  checked or unchecked.  Instances of auxiliary shared schemas are identical in all  states of the temporal instance. Intuitively, such a relation is  common to all states of the database. Instances of auxiliary  private schemas can be different in the states of the temporal  instance.  Declaring an auxiliary schema checked or unchecked has  an impact on the semantics of the language. Intuitively, the  former (resp. the latter) enforces the instance of the auxiliary schema to be used (resp. ignored) when computing the  semantics of a while statement.  From now on, we suppose that is the set of all auxiliary  schemas.  The possible instructions of a program are:  temporal moves left and right,  assignment     , where   and is a FO  formula over  with free variables  .  iterator while   do   end, where    is a closed FO formula and   a sequence of instructions. Clearly, while iterators can be nested.                        E XAMPLE 3.3 Consider the following programs Ã‚Ë (over   ) and Ã‚Å¾ (over   ) whose semantics are  explained later on:        Ã‚Ë: unchecked shared  ;  while  6   do { right ;      } end.   (resp. ) is a boolean whose value is  only in the ÄÅ¹Ârst  (resp. last) state of any temporal instance.  Ã‚Å¾: checked shared  ;           ;  while  do  { right ;                } end ;  while   do  { left ;                } end.  Semantics The evaluation of a program over  is obtained  considering a current time point, which is simply one of the  time points of the instance .  A conÄÅ¹Âguration of a program is composed of:  the current time point,  the instances over all checked auxiliary schemas of  in all states.  Note that when the evaluation starts, the current time  point is the ÄÅ¹Ârst one and the instances of auxiliary schemas  are empty in all states 7 .  left (resp. right) decreases (resp. increases) the current  time point by 1. If the current time point is the ÄÅ¹Ârst (resp.  last) one of the instance, then left (resp. right) has no effect.       changes the value of the instance over  . If  is private then  only changes in the current state  (i.e. the state at current time point); if  is shared then   changes in all states of the temporal instance. When   Ã¢Â€ÂœchangesÃ¢Â€Â, its new value is set to the answer of the query    evaluated at the current time point.  while   do   end executes all instruc becomes false, or until  tions of   until either  the sequence of conÄÅ¹Âgurations observed after each execution of   reaches a repetition. When both the current time point and the checked relations repeat, the computation terminates. Recall that unchecked instances of auxiliary schemas do not belong to conÄÅ¹Âgurations, and thus are  not taken into account when checking for a repetition.  If none of the conditions above is ever fulÄÅ¹Âlled (i.e.   never becomes false and the sequence of conÄÅ¹Âgurations never reaches a repetition), we say that the semantics  of both the while statement and the program it belongs to  are undeÄÅ¹Âned.                E XAMPLE 3.4 We consider the programs of example 3.3.  For Ã‚Ë , the auxiliary schema  is boolean (i.e. of arity 0).  When evaluated, the program executes      in all  states of the temporal instance, from left to right, starting  from the ÄÅ¹Ârst state. Thus the instance over  , whose initial  value is  , returns the parity of the size of the temporal  instance. Note that there is no checked auxiliary schema in  this program.  For Ã‚Å¾ , it can be shown that when the computation is  ÄÅ¹Ânished the instance over  is the same as the evaluation of  formula  from example 3.2.      7 Thus, the initial value of boolean auxiliary schemas is   in all  states. In this paper, we take advantage of this fact by never initializing  booleans with  .  Proceedings of the 12th International Symposium on Temporal Representation and Reasoning (TIMEÃ¢Â€Â™05)  1530-1311/05 $20.00 Ã‚Å  2005 IEEE  Query languages We deÄÅ¹Âne queries based on the programs deÄÅ¹Âned above exactly like for the WHILE language,  i.e. by giving both a program and an auxiliary schema .  The answer of a query on  is the instance over at time  point 1 output by the evaluation of over . Note that  can be either checked or unchecked in .  Next, we use the notion of inÄÅ¹Â‚ationary assignment. An  assignment     is inÄÅ¹Â‚ationary iff it adds all tuples  which satisfy  to . An inÄÅ¹Â‚ationary assignment      is intuitively a Ã¢Â€ÂœcumulativeÃ¢Â€Â one and is equivalent to       .  We now deÄÅ¹Âne four query languages based on the previous syntax and semantics.  1. T- WHILE denotes the language without unchecked  auxiliary schema and where all assignments are inÄÅ¹Â‚ationary.  2. T- WHILE denotes the language without unchecked auxiliary schema and with arbitrary assignments.  3. T- WHILE denotes the language where auxiliary  schemas can be unchecked or checked, and where all  assignments whose left-hand-side is a checked schema  are inÄÅ¹Â‚ationary.  4. T- WHILE denotes the language where auxiliary  schemas can be unchecked or checked, and with arbitrary assignments.  Note that one can specify programs of T- WHILE and  T- WHILE with no checked auxiliary schemas. Indeed one  may write T- WHILE-like programs with no auxiliary schema  at all. This is the case of the following program which ends  up setting the current time point to the last time point  of  the temporal instance: while  do right end.  About language names For the sake of our investigation  and presentation, we choose different names for some of  the languages introduced in [1]. The names given by us to  the languages identify the features which are the key of the  expressive power results provided in this paper. Thus:   the language T- FIXPOINT of [1] is T- WHILE here,   the language T- WHILE of [1] is the same here,   the language called T- WHILE here was brieÄÅ¹Â‚y referred to as the Ã¢Â€Âœpurely inÄÅ¹Â‚ationary restrictionÃ¢Â€Â of T- WHILE  in [1].  Repetition vs. limit The semantics of the while statement  is deÄÅ¹Âned using the repetition of the sequence of conÄÅ¹Âgurations. Another classical way to deÄÅ¹Âne such a semantics is by  using the limit of the sequence. These two deÄÅ¹Ânitions lead  to different semantics for the languages T- WHILE and TWHILE , and they lead to equivalent query languages for  T- WHILE  and T- WHILE . Indeed, T- WHILE  repetition  and T- WHILE limit (resp. T- WHILE repetition and  T- WHILE limit) are probably not equivalent query languages. Hence, we beleive that only T- WHILE and TWHILE would deserve to be called Ã‚Å¤ ÄÅ¹Âxpoint query languages Ã‚Å¥.  It is easy to show that in the static case, the repetition and  limit deÄÅ¹Ânitions lead to equivalent query languages for both  WHILE and WHILE  .  Partial query languages There exists programs, belonging to T- WHILE , T- WHILE, T- WHILE and T- WHILE  whose semantics is undeÄÅ¹Âned. Below we provide a program belonging to all four languages whose semantics is  undeÄÅ¹Âned when the size of the temporal instance is greater  than 3.  right ;  while  do  left ;  while    do  right ; right  end ;  end.  As opposed to TL-like languages, the fact that all TWHILE -like languages are partial query languages (even TWHILE  ) stands in contrast with the static case: recall that  WHILE  is a total query language.  4  Expressive power results  This section begins with an introductory discussion.  Note that all TL-like and T- WHILE-like languages discussed in this section are strictly more expressive than TL.  T- WHILE vs. T- WHILE In [1], the authors show that the  equivalence T- WHILE  T- WHILE is Ã¢Â€ÂœimprobableÃ¢Â€Â. Their  proof proceeds to suppose that T- WHILE  T- WHILE.  Then in particular, T- WHILE is equivalent to T- WHILE  on temporal databases consisting of a single state, and  hence WHILE  WHILE (because it is shown in [1] that  Ã¢Â€ÂœuncheckedÃ¢Â€Â schemas do not increase the expressive power  of WHILE ). However WHILE  WHILE is proved equivalent to PTIME  PSPACE in [3], which is unlikely.  The fact that in this paper we show T- WHILE  TWHILE should not be interpreted as a contradiction. Indeed our proof considers temporal instances containing at  least two states, whereas as pointed out above, the result  in [1] is obtained by restricting temporal instances to static  ones. These two results (the unlikelyness of T- WHILE   T- WHILE for single state temporal instances and the proof  of T- WHILE  T- WHILE for temporal instances of size at  least 2) highlight an essential difference between static and  temporal querying.  Data complexity of T- WHILE As mentioned above, we  show in this paper that T- WHILE  T- WHILE over really  temporal instances. This entails that T- WHILE is PSPACE  which disproves the claim of [1] that T- FIXPOINT is PTIME.  Intuitively, this is due to the non inÄÅ¹Â‚ationary behavior of the  current time point in T- WHILE-like languages.  New expressive power results The expressive power results that are now presented lead to a two-level hierarchy,  as shows the ÄÅ¹Âgure below. Inside each level, we display  Proceedings of the 12th International Symposium on Temporal Representation and Reasoning (TIMEÃ¢Â€Â™05)  1530-1311/05 $20.00 Ã‚Å  2005 IEEE  equivalent query languages (the ÄÅ¹Âgure indicates the way the  equivalences are proved by displaying the inclusions we establish). In order to obtain the hierarchy, we ÄÅ¹Ârst focus on  the lower level, then we show the separation between the  two levels, and ÄÅ¹Ânally turn to the higher one. For the sake  of space, the proofs are sketched and sometimes even not  presented.  Ã¢Â€Âœhigher levelÃ¢Â€Â  T- WHILE  T- WHILE    T- WHILE  (T-FIXPOINT)  TL  TL  TL    TL    To prove this result, we consider propositional temporal  instances (i.e. instances having only relations of arity 0). In  this context, we show that TL  L INTIME and TL expresses the NP-complete problem SAT.  The complexity measure we use here is the size of the  temporal instance 8 . As a matter of fact, we have TL   L INSPACE: the only space needed for the computation of  -expressions is the one to store the auxiliary relations 9 .  We then have TL  L INTIME, because TL is an inÄÅ¹Â‚ationary language: during the Ã¢Â€ÂœevaluationÃ¢Â€Â of a -expression,  each auxiliary relation in each state of the temporal instance,  can either stay empty or become full and stay full thereafter. Finally, it is rather straightforward to encode the wellknown problem SAT (satisÄÅ¹Âability of a propositional formula) in TL, and SAT is NP-complete. The encoding works  by considering a formula in conjonctive normal form ; it encodes each clause of the formula in a state of the temporal  instance, and computes the potential models of the formula  by using as many auxiliary schemas as there are variables in  the formula.  Higher level of the hierarchy  L EMMA 4.4  TL  TL  Ã¢Â€Âœlower levelÃ¢Â€Â  Lower level of the hierarchy Obviously from the deÄÅ¹Ânitions, TL  TL  . Moreover:  L EMMA 4.1  TL   TL   This result shows that unchecked auxiliary relations,  though not inÄÅ¹Â‚ationary, do not increase the expressive  power of the inÄÅ¹Â‚ationary language TL . The proof is done  by means of a translation of TL -expressions into equivalent TL formulas. The key argument is that, due to the  inÄÅ¹Â‚ationary nature of the computation, formulas belonging  to -expressions of TL are only evaluated as long as tuples are inserted in the checked auxiliary relations. Hence,  the contents of the unchecked relations can be simulated  by versioning their tuples with the tuples inserted in the  checked relations since the previous iteration. The versioning is done using cartesian product. The Ã¢Â€ÂœoldÃ¢Â€Â versions are  cumulated in a separate relation, so that the process is fully  inÄÅ¹Â‚ationary, as needed for the query language TL . This  technique is sketched in [1] to show that unchecked relations  do not increase the expressive power of the static query language WHILE .  T HEOREM 4.2  TL     TL   Relation between the two levels of the hierarchy  T HEOREM 4.3  TL   TL  This result shows that unchecked auxiliary relations do  not increase the expressive power of TL. The proof structure is roughly the same as the one for TL  TL ,  though more simple. Indeed, here we do not have to deal  with Ã¢Â€ÂœinÄÅ¹Â‚ationary vs. not inÄÅ¹Â‚ationaryÃ¢Â€Â formulas, hence the  versioning technique is unnecessary.  L EMMA 4.5  TL  T- WHILE   This result is shown only over temporal instances whose  size is at least 2. The proof is done by means of a translation  of TL formulas into T- WHILE programs. This translation  makes use of the fact that the size of the temporal instances  is at least 2 as highlighted below.  We ÄÅ¹Ârst introduce some macros for T- WHILE . They  use special auxiliary schemas called macro schemas: 1) all  macro schemas are boolean and unchecked, 2) when writting a program, it is assumed that each time a macro is used  new names are given to its macro schemas. Let   be a  closed FO formula.   A conditional assignment if   then      is  deÄÅ¹Âned by                   A conditional temporal move if     left right) is deÄÅ¹Âned by:   then  (where  8 Note that the complexity measure for query languages is usually the  number of tuples rather than the number of states of the instance.  9 In the propositional context, each relation is either empty (i.e )  or Ã¢Â€ÂœfullÃ¢Â€Â (i.e. , when its content is the empty tuple).  Proceedings of the 12th International Symposium on Temporal Representation and Reasoning (TIMEÃ¢Â€Â™05)  1530-1311/05 $20.00 Ã‚Å  2005 IEEE      ;  while     do {  ;     } end  where  is a shared macro schema.   The macro goto   with   a boolean schema is  deÄÅ¹Âned by:  while  do left end ;  while   do right end ;  Intuitively, goto   sets the current time point to the  leftmost time point where   is true.   The macro FlipÄÅ¹Â‚op is deÄÅ¹Âned by:  if  then     ;  if  then right ; if    then left ;      ;  where  is a shared macro schema. Intuitively, FlipÄÅ¹Â‚op  changes the current time point as long as the temporal instance contains at least two states.   The macro scan   , where  is  a sequence of instructions is deÄÅ¹Âned by:       ;  while  do left end ;  while  do {  ; right } end ;  goto    ;       ;  where   is a private macro schema. Intuitively  scan    executes  in all states of  the temporal instance from left to right starting from the ÄÅ¹Ârst  state, as long as  is true. The initial instruction of scan  marks the current state (using   ) in order to be able Ã¢Â€Âœgo  back thereÃ¢Â€Â using goto. Hence, scan preserves the current  time point.   A global assignment     is deÄÅ¹Âned by:  scan      ;  Intuitively, a global assignement enforces A to behave like a  shared auxiliary schema for the assignment    .   The macro Repetition    is deÄÅ¹Âned by:      ;  scan            ;  where  is a shared macro schema. Intuitively,  Repetition    checks that the instances over X and Y  are the same in all states.  Sketch of proof: We now proceed to the translation. Let   be a TL formula ; we inductively give a program   and an auxiliary schema  such that for all instance    Ã‚Ë    and for all    , the evaluation over  at time  at time point  point  of  is equal to the instance over   produced by the evaluation of  . In order to build  ,  we inductively build an intermediate program  ;   (where  are declarations and  are instructions) and  a FO formula  .  The program  is given by:   ; checked private   ;     .    ;  where  denotes the number of free variables of a .   If  is obtained through an FO formation rule, then  is  essentially  itself, and  and  are straightforward.   If      , let:     ; unchecked shared ! ;  unchecked private "  ;     "         ;  "    ;  /* resets  in case of nesting */  scan     ;  /* sets  */  where  is:  { right ; !     ; left ; "   !  }  Intuitively, it is Ã¢Â€Âœnot possibleÃ¢Â€Â in T- WHILEÃ‚Ë‡   to grab, at the  current time point, anything from the next state or any other  state. Thus in order to translate    we use !  whose purpose is to move   from the next state to the  current state. Hence ! needs to be shared. It also needs  to be unchecked because we compute    in all states  and this computation is not inÄÅ¹Â‚ationary.   the case    #   is similar to the previous one  and is omitted here.   If        $   10 , where $ is an auxiliary  schema of  , let:     ;  unchecked shared   $  ;  unchecked private $   $       ;     $            ;  $    ;  while $  do  FlipÄÅ¹Â‚op ;  $    $  ;     ;  /* marks the current state */  /* resets         in case of nesting */  /* enforces current time point to change */   to in all states */  /* sets  $    ;  Repetition $ $  ;  if   then $  end ;  goto   to  /* sets  to       ;   iff     */  ;   ; $    ;  Intuitively, since  is not necessarily an inÄÅ¹Â‚ationary formula, it is translated with the unchecked auxiliary schema  $ . This implies that the evaluation of the while block proceeds with conÄÅ¹Âgurations whose single component is the  current time point. Recall that the evaluation of while loops  stops either because their condition is false or because of  conÄÅ¹Âguration repetition. Here our goal is to force the evaluation of the while block to stop when Ã¢Â€Âœ$ reaches a repetitionÃ¢Â€Â. Because $ is unchecked, repetition check over $ is  encoded in the while block. Morerover FlipÄÅ¹Â‚op enforces     10 Here we consider w.l.o.g.  expressions.  Proceedings of the 12th International Symposium on Temporal Representation and Reasoning (TIMEÃ¢Â€Â™05)  1530-1311/05 $20.00 Ã‚Å  2005 IEEE  TL  restricted to single-formula  -  two consecutive conÄÅ¹Âgurations to differ by changing the  current time point and thus the evaluation of while block  only stops when its condition becomes false. Note that  FlipÄÅ¹Â‚op works properly only if the temporal instance size  is at least 2. Of course, if the semantics of the -expression       is undeÄÅ¹Âned, so is the semantics of the above  program.   Obviously T- WHILE    L EMMA 4.6 T- WHILE  T- WHILE  .  Moreover:  T- WHILE  This result shows that unchecked relations do not increase the expressive power of T- WHILE.  Sketch of proof: Let  be a while statement of a TWHILE  program  , such that  contains two auxiliary  schemas  and  , where  (resp  ) is declared checked  (resp. unchecked). We suppose that both  and  appear  as left-hand-sides of assignments within  . Now let  Ã‚Åº be  obtained from the program  by declaring  checked. The  evaluation of  in  Ã‚Åº is necessarily at least as long as its  evaluation in  : if  ,  and the current time point repeat,  then in particular  and current time point repeat. But the  evaluation of  in  Ã‚Åº can be longer, and may not terminate  (e.g. if  never reaches a repetition). Hence a way to have  equivalent evaluations of  in both  and  Ã‚Åº is to observe  when both  and the current time point reach a repetition,  and enforce that the condition of  becomes  at that  moment.   L EMMA 4.7 T- WHILE  TL   Sketch of proof: This proof is decomposed into two parts:  1) partial unnesting of while statements 2) translation of  partially unnested T- WHILE programs into TL formulas.  Both parts are rather technical and intricate, hence for the  sake of space we only sketch them below.  We need to unnest while statements because of a fundamental difference between T- WHILE and TL : in the former, an instance of an auxiliary schema  can be assigned  by more than one instruction, and hence its contents can  change at various nesting levels. This is Ã¢Â€Âœnot possibleÃ¢Â€Â in  TL  because an instance of  is only deÄÅ¹Âned once by a  single formula . Partial unnesting of T- WHILE programs  addresses this issue.  Now, let us try to outline the main ideas behind partial unnesting. Recall that WHILE programs can be fully  unnested. Indeed, consider the following WHILE program:  while  Ã‚Ë do  Ã‚Ë   Ã‚Ë  ;  while  Ã‚Å¾ do Ã‚Å¾   Ã‚Å¾  end ;  end.  This program is equivalent to the following unnested one:  Ã‚Å¾   Ã‚Å¾  ;  while  Ã‚Ë do  if  Ã‚Å¾   Ã‚Å¾  then Ã‚Ë   Ã‚Ë  ;  Ã‚Å¾   Ã‚Å¾  ;  if  Ã‚Å¾ then Ã‚Å¾   Ã‚Å¾  ;  end.  For WHILE programs, the main idea behind unnesting is  to unfold nested while statements by means of Ã¢Â€ÂœconditionalÃ¢Â€Â assignments which are assignments themselves, thus  the process can be iterated until obtaining fully unnested  programs. The above technique can be applied to unnest  T- WHILE programs: assignments and temporal moves in  nested while statements are transformed into conditional assignments and conditional temporal moves. Contrary to the  case of WHILE, the process does not lead to fully unnested  T- WHILE programs for the following reason: a conditional  temporal move is a (simple) while statement 11 . Furthermore, to unnest T- WHILE programs, we need to propagate  the storage instruction Ã‚Å¾   Ã‚Å¾  on all states. This  leads to a global assignment, which is also a while statement. To sum up, the partial unnesting of a T- WHILE program leads to a program whose while statements contain  only conditional temporal moves, conditional assignments,  conditional global assignments, and the conditional variants  of the macros Repetition and Time.  Once a T- WHILE program is partially unnested, translating its conditional instructions listed above turns out to be  technical but rather simple. The main problem raised by the  translation of a T- WHILE program is to deal with time: a major component of the conÄÅ¹Âguration used in deÄÅ¹Âning the semantics of T- WHILE-like languages is the current time point  which introduces some kind of explicit control of time in TWHILE ; no such notion exists for TL -like languages. The  translation manages this difÄÅ¹Âculty as follows: to each instruction we associate a formula aiming at marking its current time point. Such a formula has to be declared checked  in order to take time into account the way T- WHILE does.   T HEOREM 4.8  The languages TL, TL , T- WHILE, TWHILE  , T- WHILE Ã‚Ë‡   are equivalent.  We would like to emphasize once again that this theorem  is valid under the two-states instances assumption only. The  result does not hold for single state instances (see section 4).  5  Discussion  The ÄÅ¹Ârst contribution of this paper is to enrich the expressive power hierarchy of [1] with results for TL-like  languages. In particular, our two-level hierarchy provides  the proof of the claim of [11] that the ÄÅ¹Ârst order extension  11 We  do not succeed in unnesting conditional temporal moves.  Proceedings of the 12th International Symposium on Temporal Representation and Reasoning (TIMEÃ¢Â€Â™05)  1530-1311/05 $20.00 Ã‚Å  2005 IEEE  of TL (denoted TL in our framework) is strictly less expressive than T- FIXPOINT (denoted T- WHILE in this paper). Because T- FIXPOINT is equivalent to T- WHILE over  really temporal instances, T- FIXPOINT is PSPACE.  The second important contribution of this paper is to  highlight the impact of unchecked auxiliary schemas on TWHILE -like and TL -like languages. Allowing one to use  unchecked auxiliary schemas has no impact on the expressive power of non inÄÅ¹Â‚ationary languages of both classes and  on the expressive power of the inÄÅ¹Â‚ationary language TL .  In the static case, the inÄÅ¹Â‚ationary (resp. non inÄÅ¹Â‚ationary)  WHILE language is equivalent to the inÄÅ¹Â‚ationary (resp. non  inÄÅ¹Â‚ationary) FO ÄÅ¹Âxpoint language. The paper shows that  this symmetry is broken in the temporal framework: TL  T- WHILE  .  We do not provide any insight w.r.t. the expressive power  of T- WHILE . However, we have strong reasons (although  not yet proofs) to beleive that:  C ONJECTURE 5.1 T- WHILE  T- WHILE  As in [1] (see section 4), we can use a complexity argument to prove that in case of static instances T- WHILE  T- WHILE probably holds because in that case T- WHILE  reduces to WHILE , T- WHILE reduces to WHILE and WHILE  WHILE iff PTIME  PSPACE . This argument relying on  static instances does not completely satisfy us because  it does not entail that the result holds for really temporal instances (as our result about T- WHILE and T- WHILE  shows). Another direction of investigation is to show that  T- WHILE  and T- WHILE are separated by some query. A  candidate is the query denoted twin which checks wether  there exists two identical states in the temporal instance.  To conclude this discussion, let us comment on the speciÄÅ¹Âc treatment of time in T- WHILE-like languages. Somehow, time is not fully implicit in these languages because  of the deÄÅ¹Ânition of conÄÅ¹Âguration. Moreover, the temporal  moves left and right alone are too Ã¢Â€ÂœpoorÃ¢Â€Â to simulate the   and  modalities of TL-like languages. Roughly,  (see for instance the translation of  in the proof of  lemma 4.5), during the evaluation of a T- WHILE-like program, the computations made at some time point are only  aware of the state at that time point and of the shared auxiliary relations. Thus, without shared auxiliary schemas,  moving to the right does not help to compute queries dependending on data of both the current and next states because  the move allows one to access the next state data and meanwhile prevents from accessing data in the current state. It is  then clear that such queries need to be supported by shared  and non inÄÅ¹Â‚ationary auxiliary schemas.  References  [1] S. Abiteboul, L. Herr and J. Van den Bussche. Temporal  Connectives versus Explicit Timestamps in Temporal Query  Languages. In Journal of Computer and System Science,  58(1):54Ã¢Â€Â“68, 1999.  [2] S. Abiteboul and V. Vianu. Datalog extensions for database  queries and updates. In Journal of Computer and System Science, 43:62Ã¢Â€Â“124, 1991.  [3] S. Abiteboul and V. Vianu. Generic computation and its  complexity. In Proc. ACM SIGACT Symp. on the Theory Of  Computing, pages 209Ã¢Â€Â“219, 1991.  [4] N. Bidoit and S. De Amo. Implicit temporal query languages: towards completeness, In FST&TCS, Chennai, India, LNCS Vol. 1738, 1999, pages 245Ã¢Â€Â“257.  [5] N. Bidoit, S. De Amo, and L. SegouÄÅ¹Ân. Order independent  temporal properties. In Journal of Logic and Computation,  14(2):277Ã¢Â€Â“298, 2004.  [6] A. K. Chandra and D. Harel. Structure and comlexity of relational queries. In Journal of Computer and System Science,  25(1):99Ã¢Â€Â“128, 1982.  [7] J. Chomicki and D. Toman. Temporal Logic in Information  Systems. In Logics for databases and information systems,  Kluwer Academic Publishers, chapter 3, pages 31Ã¢Â€Â“70, 1998.  [8] E. A. Emerson. Temporal and Modal Logic, In Handbook  of Theoretical Computer Science, Volume B: Formal Models and Semantics, Jan van Leeuwen, Ed., Elsevier Science  Publishers (1990) 995Ã¢Â€Â“1072.  [9] Y. Gurevich. Toward a logic tailored for computational complexity. In Computation and Proof Theory, pages 175Ã¢Â€Â“216,  M. M. Ritcher et al editor, Springer Verlag, LNM 1104,  1984.  [10] Y. Gurevich and S. Shelah. Fixed-point extensions of ÄÅ¹Ârstorder logic. In Annals of Pure and Applied Logic, 32:265Ã¢Â€Â“  280,1986.  [11] L. Herr. Langages de RequÄ‚Åte pour les Bases de DonnÄ‚Å es  Temporelles. Ph.D thesis, UniversitÄ‚Å  Paris Sud, 1997.  [12] D. Leivant, Inductive deÄÅ¹Ânitions over ÄÅ¹Ânite structures. In Information and Computation, 89:95Ã¢Â€Â“108, 1990.  [13] A.R. Meyer. Weak monadic second order theory of successor is not elementary recursive. In Proceedings Logic Colloquium, Lecture Notes in Mathematics, Vol. 453, pp. 132Ã¢Â€Â“  154, Springer-Verlag, 1975.  [14] Y. N. Moschovakis. Elementary Induction on Abstract Structures, North Holland, Amsterdam, 1974.  [15] A. P. Sistla and E. M. Clarke. The Complexity of Propositional Linear Temporal Logics. In Journal of the ACM,  32(3):733Ã¢Â€Â“749, 1985.  [16] D. Toman. On Incompleteness of Multi-dimensional Firstorder Temporal Logics. In TIME: 99Ã¢Â€Â“106, 2003.  [17] M. Y. Vardi. A temporal ÄÅ¹Âxpoint calculus. In Proceedings  5th ACM Symposium on Principles of Programming Languages, pages 250Ã¢Â€Â“259, 1988.  Proceedings of the 12th International Symposium on Temporal Representation and Reasoning (TIMEÃ¢Â€Â™05)  1530-1311/05 $20.00 Ã‚Å  2005 IEEE 