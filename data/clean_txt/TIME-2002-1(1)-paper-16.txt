On the Operational Semantics of Timed Rewrite Systems  JeĚreĚmie Blanc  Rachid Echahed  Jeremie.Blanc@imag.fr  Rachid.Echahed@imag.fr  Laboratoire LEIBNIZ â Institut IMAG, CNRS  46, avenue Felix Viallet, F-38031 Grenoble, France  Abstract  time. We assume given a canonical signal or clock, noted  R EF which serves as a reference for other signals.  We propose an efficient operational semantics for a new  class of rewrite systems, namely Timed Rewrite Systems.  This class constitute a conservative extension of first-order  conditional term rewrite systems together with time features  such as clocks, signals, timed terms, timed atoms and timed  rules. We define first Timed Rewrite Systems and illustrate  them through some examples. A naive approach to the operational semantics is very costly in space. We propose, for  a large class of programs, an improved calculus with a linear space complexity. Finally, we show how our framework  compares to related work.  In general, operator definitions within a timed rewrite  system or program may depend on time. Thus, at each  instant , of R EF, a new rewrite system consisting of operator definitions is updated in the same way as in data-flow  languages. We obtain then, a stream of rewrite systems,  . At any instant ,  constitutes a classical rewrite system which may be used as usual, e.g., simplification of expressions or resolution of goals.                        In order to make easier the description of such timed  rewrite systems, we enrich first-order terms by a temporal  operator which is used to refer to past definitions. For example the expression  is meant  three seconds before now and the  to add the value of  value of  at the current instant. On the other hand, we  also enrich classical atoms by allowing the use of the box  and diamond modal operators over intervals. A timed  atom  , respectively  , holds iff the atom holds at  every instant, respectively at one instant at least, of the time  interval . The rewrite rules we consider in this paper have  the following general shape  when  where the term  can be timed,  and  are conjunctions of possibly timed atoms or equations. The role  of tails is to filter at every instant, , the rewrite rules that  constitute the rewrite system .      %  %  Rewrite Systems constitute the foundation of several  declarative (functional and/or logic) programming languages. They benefit from several analysis and proof techniques as well as efficient implementations. However, such  term or graph rewrite systems fail to specify in a natural way real-world applications where time should be described. Consider for instance the boolean operator Alarm  with the following profile device sort bool such that  Alarm(device) is true whenever device has been broken for  the last ten seconds. Unfortunately, such simple programs  cannot be described rigorously using classical rewrite systems.  In this paper, we define timed rewrite systems as a class  of rewrite systems which allows one to specify declaratively  applications where the notion of time, should it be qualitative or quantitative, is involved. Our approach is new  and departs from the proposals already made in order to  add time into some declarative languages such as tcc [12],  Templog [1], and Chronolog [14]. Roughly speaking, a  timed rewrite system is provided with user-defined and incoming signals like in synchronous languages, e.g. [7]. A  signal is a stream of pairs (ticks, values) that happen over          1. Introduction      ,      '          !  "    $  %    '  $  )  %    ,  $  $  $  -  .  -  /  1  /  1  1  .  2    3  4  8  :  6  4  6  <  >  @  B  E  C  F  H  3  1    I  K  "    M  N      O        The rest of the paper is organized as follows. The next  section introduces timed rewrite systems. Then, we briefly  sketch a first semantics based on labelled transition systems  the details of which can be found in [4]. Our intention is  to define efficient and realistic programs which may be interactive and reactive. For that, we describe in section 4 an  optimised operational semantics. In section 5, we compare  our proposal to related work and conclude the paper. Due  to lack of space, proofs have been omitted as well as some  formal definitions. The missing definitions and proofs could  be consulted in a more detailed version [3].  Proceedings of the Ninth International Symposium on Temporal Representation and Reasoning (TIMEâ02)  1530-1311/02 $17.00 ÂŠ 2002 IEEE  2. Timed Rewrite Systems  Â  We define a timed rewrite system or program as a pair  where is a timed first order signature and  is a set of timed conditional rewrite rules.  A timed first order signature is a triple  where is a set of sorts, is an  -sorted family of signals  -sorted family of timed operators.  stands  and is an  for the set of non empty strings over . We assume that  contains at least the sort of booleans, bool, and the sort of  naturals, nat.  The meaning of a signal in our approach is very close  to the ones introduced in some synchronous languages,  , noted S  e.g., [7, 5]. A signal S of sort  is a stream of operator denotations. These  denotations are associated implicitly to some instants over  time. These instants constitute a set called ticks of S. Hence,  our notion of time is linear and multi-form. Every signal S  is associated to a boolean operator noted S which is equal  to true on the ticks of the considered signal S.  The family contains a distinguished signal we call refnat. More precisely,  erence signal of profile R EF  R EF is the finest signal i.e. for all signals S in , the ticks  of S are mapped into those of R EF. At the beginning, the  value of R EF is 0, then it increments by one at each instant.  Its value may be useful as a clock which gives the number  of the current instant.  Starting from a timed signature, we introduce the notion  of timed terms in order to take into account the âtemporizationâ of operators thanks to the presence of signals. The  definition of an operator, say , may change at every instant. We refer to a past definition of an operator by using  a special temporal operator denoted at which extends the  pre operator of Lustre [5] and $ operator of Signal [7].  We write  S  to refer to the operator at the instant corresponding to ticks of signal S before the current  instant. In general, we can use several at-expressions to define the right instant in the past of an operator. For that  we use timed operator expressions or toe for short, as deS  where  fined below:  is an operator, is a positive natural number, S is a signal,  is a toe. The toes of the form  S  are called  past toes. Timed terms extend classical ones by referring to  past definitions of operators. They are defined as follows :  where is a variable,  is a natural number (  ), is a toe and  are  well-sorted timed terms.  Formulas in are timed conditional rewrite rules of the  when  where  following form:  is a first order term,  is a timed term, and are  possibly empty conjunctions of timed atoms.  is called head,  body and  tail. If  is of the form  , we say that the considered timed condi  P  R  T    W  Y  T  W  R  [  ]  _  [  [  [    ]    _  `  [  ...  Â      c    a  b      !  $  Â  y  Â  Â  Â  Â  Â  >  y  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  >  Â  o  Â  Â  Â  1  Â  o  Â  Â  Â  o  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  >  Â  Â  Â  Â  >  o  Â  o  Â  Â  Â  c  h  Â  Â  Â  Â    !  !  Â  Â              O  ÂĄ  3  Â  Â  Â˘  1  h    Â  Â  o  ]    Â  Â  1  ]    Â  Â  e    Â  h  Â    b  Â  tional rewrite rule defines . A timed atom is either an  equation  ==  where  and  are two timed terms,  ..  which holds whenever the timed  a formula  is true at least once during the interval  ,  atom  or a formula  ..  which holds whenever the  is true at every instant of the interval  ..  timed atom  . Atoms of the form  ..  (respectively,  ..  ) are called past-box atoms (respectively, pastdiamond atoms). and stand either for the symbol or  for the symbol indicating if the bounds are included or not  in the interval, and  and  represent pairs noted  S  where is a non null natural number and S is a signal. We  also use ânowâ as a particular form of to indicate the current instant. The role of tails is to filter the rewrite rules  to be considered at each instant. A timed program generates an infinite sequence of classical (atemporal) rewrite  , also called stores in the sequel, as depicted in  systems,  Figure 1. Intuitively, at each instant ,  includes all the  rewrite rules such that when is in and holds at  . We write  to note that atom holds in the classical rewrite system . A timed operator is atemporal  or static, if is defined classically without any reference  to timed syntactic entities. Otherwise, is called dynamic.  Notice that a classical term rewrite systems consists only of  atemporal operator definitions.  Below we give some toy examples in order to illustrate  our framework.      a  Â  Figure 1. Store Generation      Â  [      Â  `  [    ...  Y  `  1      h  h  h  h  !  P  l  b  b  h  o          $  !  l  Example 1 In this example, we give two different definitions of Fibonacci function. This function is often used to  show the abilities of synchronous languages. In our framework, we can define Fibonacci function either by following  synchronous style (fib1) or a pure declarative style (fib2).  However, fib1 is a timed operator whose value will change  during the execution whereas fib2 is an atemporal operator.  h  !  l    P      b  v    b  o  l          !  $  l  v    y  y  {  $  |    |  }  '  l    y  y  {  1. fib1  2. fib1  3. fib1  W    3  4  8  :  6  4  6  <  >  Â  1  O  K      I  K    O    h    y  K  K    c    I  K  {  ÂŁ    1. fib2(0)  2. fib2(1)      y    ÂĽ  1  O    ÂŁ  Â  Â  0 when R EF == 0  1 when R EF == 1  at (  R EF ) fib1 + at (  == true  when R EF    $      0  1  2  Proceedings of the Ninth International Symposium on Temporal Representation and Reasoning (TIMEâ02)  1530-1311/02 $17.00 ÂŠ 2002 IEEE  Â¤  R EF ) fib1  Â´  Âż  Â  3. fib2(x)  fib2(x-1) + fib2(x-2)    ÂŚ  and  is the result of  the elimination of toes and past atoms in  w.r.t. instant .  is not defined on  S  , then we  If  consider = . In addition, if  is not defined on  S  , then is replaced by an atom noted  FALSE which is always false. If the disjunction is empty  then we consider is replaced by FALSE too. The case of  the past-box atoms,  S ..  S  , is similar  to past-diamond atoms: disjunctions become conjunctions  and the atom FALSE becomes an atom noted TRUE which  is always true.  contains neither the definitions of the inNotice that  troduced operators, nor the definitions of the incoming sigconsists to comnals. The second stage which leads to  plete  with additional rewrite rules defining the newly  introduced operators and incoming signals. The third stage  consists in filtering the timed rewrite rules. If a timed  rewrite rule when C of  is such that  holds, then  occurs in  ; otherwise is erased.  is built stepwise  according to a certain stratification of timed operators in .  is  in which the definitions of the timed constants  (i.e. timed operators without arguments) have been simplified. All these stages are performed under the following  assumptions:  Requirement 1 The tails of each timed rewrite rule of a  given stratum are expressed through the operators of lower  strata.  Requirement 2 Simplification of timed constants must  , at each instant. At each instant, the  be terminating in  definition of a timed function (i.e. timed operator with arguments) must not depend on a past definition of .  ÂĽ      1  == true  ÂŁ  <      O  y      !        !      S  Â  !  Â    Â  Ă  $  1  Â  Â    Example 2 In this example, we consider the case of a controller which has to decide automatically whether an item,  sliding over a belt, is to be discarded (because of any fault)  or not. A decision concerning an item is taken when the  item arrives at a particular position, , detected by a laser  ray (laser3 ). An item is to be discarded if a fault is detected  (!reject == true) while the item was sliding between two parand . The controller detects an item  ticular positions  entering position  (resp. ) thanks to a laser ray laser1  (resp. laser2). Below we give a definition of the constant  discard item whose value is computed every time an item  reaches position , i.e. a tick of signal laser3 occurs.  Â    ÂŠ  y  Â  ,  !        !    O  y    !      !      Â    Â  !    Â  Â  !  ÂŽ    c  ÂŻ  ÂŻ  ,    ,  We assume in the sequel that a timed rewrite system  is given with signature  . As depicted in  generates a stream of  Figure 1, a run of a program  stores,  . In this section, we give a brief  overview of a first semantics based on a labelled transition  system. The details of this semantics can be found in [4].  To each instant , corresponds a state of such a transition  system which contains, among other technical entities, a  classical term rewrite system . Roughly speaking, the  computation of  is done in four stages:  ,  ,  and  .  is obtained from  by replacing all toes and  past atoms by classical (atemporal) terms. A past toe  S  is replaced by a new operaof the form  tor noted  where  denotes the absolute instant  corresponding to  S  with respect to instant .  such that  We can define a function  S  . When a past toe  S  S  ,  is of the general form  we proceed likewise by iterating recursively the function  to obtain the instant correspondS  S  . Whenever less than  ing to  ticks of S occurred since the beginning of the execution,  is not defined for  S  . Then,  S  the timed rewrite rule in which the past toe  occurs is eliminated. The elimination of a past atom,  =  S  S  say , of the form  consists in replacing  by a disjunction  [    ]    _  Y                  Âą    3. Labeled Transition System  R    Â°  l  _  Â    Â  Â°  l  -  Â  Â  o  ÂŽ    ÂŞ      1      false  laser1 ..  laser2 !reject == false  when !laser3 == true  Â  $  !  $  Ă  discard item      Â    true  laser1 ..  laser2 !reject == true  when !laser3 == true      o  c  ,    -  ÂŞ      '  1    Â  !  1    .      ÂŠ  discard item      Â  ÂŠ  O  Â    ÂŠ      ÂŠ  ÂŠ        Â°    h    Â°  h  h      The execution model of a timed program can be given  by a labelled transition system the state of which are pairs  where  is the store computed at instant and  , called history, consists of the stores computed before  . Elements of  are used to bring into  the definitions  , of the form  of the new operators, introduced in  with  . The transitions of the labelled transition sys-          ÂŽ    ÂŻ    Â°  R    ÂŽ        Â´    !  $        !  $      y      !        !      O  y    !      O      y            !        !        /  Â  $          !  {  {  $    !        !  y      !                    !  {  {  R  !    1  `    h    !  4. Actual Operational Semantics    $      !  $  1  o      !  Â  !  Â  In this section, we propose some sufficient conditions  under which we can develop an operational semantics using a bounded space memory. As in the previous section,  we will show how current stores are generated following  ,  ,  and  .  four stages,  h  Â  Â  o  Âž  Â´  Âş  Âť  Âž  Âť  Â  Â  Âź  Âš  Â´  Â  Âż    =    Â  Â  Â  where  Y  `    !  1  .  Ă    `  2  1  Â    Ă  c  $    1  Â  Y    $  !  Ă        O  Ă  a  R  $  !  Â      tem are of the form  where  consists of the definition of the incoming signals. The history being not bounded, the definition of the  labelled transition system as sketched above is not realistic. So, we propose in the following section a new tractable  semantics.  !    Âł  R  Â    h  Â      O  Â´      Â    ÂŻ  ÂŽ  Â˛  Â        Â          P  Y  Ă  h  Âł      Â  h    Ă    Â˛  Ă    Âą        O  y      !        !      !  S    $  ,    Â    =  ÂŽ  Â    ÂŻ  3  Proceedings of the Ninth International Symposium on Temporal Representation and Reasoning (TIMEâ02)  1530-1311/02 $17.00 ÂŠ 2002 IEEE    Â°    Âą  Â  The first stage generates a timed program  without  any reference to toes or past atoms just like  . The differis that the past toes such as =  S  ence with  are replaced by a new operator noted  S  of the  same profile as and the past atoms  of the form  S ..  S  or  S ..  S  , are replaced by equations  where  is a new boolean operator. The calculus of the definition of  will be possible at every instant, if the following  requirement is verified by .        ÂŽ  ÂŽ  l  Â˛              !    $    !  h  $  P  !  Â  Â  o  Â  Ă  Ă  Ă  Ă  Ă  Ă  Ă  Ă  Ă  Ă  Ă  Ă  Ă  Ă  Ă  8  Ă  ÂĽ  B  at  o  P    if = 0  8  Ă  Ă  -  h  !  at  h  Âł  1    Ă  ÂŽ  ÂŁ  Ă  Ă  B  Ă  Ă  Ă  Â  B  Â  if  Ă  Ă  ĂĄ  Ă˘  ĂŁ  Â  Ă¤  ĂĽ  P  y  y  .  Â  o      !  P  P  !  Â  Â  o  B  Ă  B  Â  B  S  Â  Â  ĂŚ  ĂŚ  Ă§  F  3  6  Ă¨  Ă  P  Ă  Ă  Ă  8  Ă  Ă  1  y  y  Â  Â˛  Âł    I  y  Ă  ÂĽ  Ă  B  at  1  Â˛  Â¤  Ă  B  Ă  Ă  Ă  Ă  Â  B  Â  Ă˘  ĂĄ  if  Ă  Ă  ĂŁ  ĂŁ  Â  Ă¤  Âł  ĂĽ  Ă  B  Â  Â  B  S  ĂŠ  1  Â˛  8  ĂŚ  :  ĂŚ  Â  Ă¨  Âł  1  where stands for the complete definition of at the previous  in which we replace all the timed operators  instant  without temporal annotation and different from by new  and [  ] is the memory  operators of the form  S  at instant  .  of the past toe  ĂŠ  ĂŤ  8  ÂŁ  Â  ĂŤ  Requirement 3 Every past atom of the form  S ..  S  or  S ..  S  is closed (i.e. it contains no free variable) and is such  can be decided in a sensible computational duration  that  at each instant.  -  1  o  1    !    Â  Â  !  o  Ă˘  Ă  Â  Â  .  o      !  Â  Â  !  o  Ă  Ă  Â  Ă  Â  ĂŤ  Â  Ă  B  Ă  B  Â  B  Â  Ă  Â  1  ĂŤ  ĂŁ  8  8  ÂŁ  Ă  Ă­  ĂŤ  F  Â  Figure 2. Past toe memory rules  In the following, we call new operators the operators  and  in  . Note that the past toes of the  form  S  S  are transformed into  S  where  is  S  , and the  past atom of the form  are transformed into  where  is  . So, all  the new operators are of the form  S  ,  or  where is an operator and an atom.  Â    ÂŽ  1  Â˛  l  Âł  Â˛          $  !          Â  !  Â  Â  Â˛          new operator  is a queue (FIFO) of length  ...  ].  rewrite rules defining noted [  Âł  $  !  $  Â˛  h  h  Â  Âł  h  Â˛          !  Â  Â  $  h  l  Âł  h  "  "  a  Â  of sets of  !  "  Âł  Âž  /  /  1  should contain at each instant, a set of rewrite rules  from which we can define the new operator  S  .  For that, we require that past toe memories satisfy the following invariant.  S  be a past toe. Assume  Definition 2 Let =  =[  ]. The invariant for  that  is the following assertion: âFor all  , if at  least ticks of signal S have occurred since instant 0, is  the definition of , ticks of S ago, otherwise is emptyâ.  Â  .  P  /  1  .  P  P  Âž  1  Â  Â  /  "  P  1  Â  Â˛  .  Âł    I  y  Â˛  .  Âł    I  y  /  Â˛  -  /          !  $  h  Âł  Â˛  .  Âł  1  1  Â˛  h  Âł  Example 3 The application of the first stage to the specification of fib1 given in Example 1 has the following result:  contains the timed rewrite rules , and . 1 and 2 are  copied without any change from the timed program because  they contain neither past toes, nor past atoms. On the other  hand, is the transformation of 3 into  l  Â  Ă        !  $        !  |  Ă  "  a  Â  "  h  Âł  h  "      $  Ă  ÂŽ  ,      Ă  Â    a  Â˛  1  Ă°  Ăą  ,  Ă˛  Ă˛  !  |  Ă  Ăł      "    h    "  Â  In order to preserve the invariant, we give in Figure 2 the  inference rules to be applied on past toe memories at every  instant.  Since the past toes are not defined at the first instant, the  verify the invariant.  memories initialized by Rule at  and Rule at  The two other inference rules Rule at  are rules which update the past toe memories in a rather  straightforward manner according to the cases whether a  ,  tick of signal S occurs or not at the previous instant  i.e., whether  S  . All the sets are finite  since Requirement 2 is verified. The addition of a temporal  annotation to the operators of does not change the value  which represents . It allows one to make the distinction  in  which represents the value of  between  at some instant  and  in  which represents the  current value of i.e. the value of at instant .    at (  R EF ) fib1 + at (  3â. fib1  when R EF  == true    Ă  R EF ) fib1  Ă  ÂŁ  Â¤  Ă  Ă  ÂŁ  ÂĽ  Example 4 In the same way as in the latter example, the  rewrite rules defining discard item given in Example 2 becomes:  discard item  true  laser1 ..  laser2 !reject == true  == true when !laser3 == true  Ă  Â  ÂŁ  Ă  Ă    '  $      ÂŁ  <    Ă    ,  $          discard item  false  laser1 ..  laser2 !reject == false  == true when !laser3 == true  Ă    Â  Ă  Ă  Â˘  P  Ă    $  ,  P  e  ÂŁ  ÂŁ  <  Ă  Ă    I  y  Ăś  Ăś  h  Â´  Ă  Â  Â˛  Â  Â    ÂŻ    ÂŽ  Generation of  consists in adding to  the rewrite  rules defining the new operators and the incoming signals.  Now, we show how the rules concerning the new operators  are synthesized. We tackle at first the new operators of the  S  corresponding to past toes. For such  form  a new operator, we associate a past toe memory, denoted  , defined as follows.  S  Definition 1 Let =  S  be a past toe and be the  current instant. The past toe memory  at for the  Â˛          !  $  h  Ă  |    !  $  h  Ă  Â  h    Â¤  Ă  Ă  Â¤    |  h  Ă  Ă  Ă    Example 5 Consider the memory associated to the new operator at ( R EF ) fib1 occurring in the timed rewrite  rule, say 3â, of Example 3. Figure 3 indicates all the states  of the memory associated to the new operator at ( R EF )  fib1 for the instant 0 until 3. From instant 1, at  is  always applied because !R EF == true is always true. At each  Ă    ÂŻ  Â  a    h    h  Ă    Ăˇ  Â    Âł  l  |  R  Ă  Ă  Â  Âł  Â  Ă  h    4  Proceedings of the Ninth International Symposium on Temporal Representation and Reasoning (TIMEâ02)  1530-1311/02 $17.00 ÂŠ 2002 IEEE      Ă  $  Definition 3 Let and be two instants less than . Assume  . and belong to the same interval iff  Â    Rule    Memory state    ,    Ă        at  at  at  at    '    $  Â  Ă¸  $  Â  Ă¸  Ă    Ă    $  Ă  Â  $  fib1 == 0  fib1 == 1  Ăą  Â  Ă¸  Ăą  Ăł  Ăą  Ăł  Ăą        1. either  Ăł  Ă    Ă  R EF  Â  Ă  Â    Â      Â    Ăł    O  y      !        !      S  Â  !  Â    R  such that  Ăł  Â  Â    Â      ,      Â    $  Â    Â˘  Â´  Â´  P  P  e  %    O    Â    Â˘  P  Ă˝  S  Â  %  R      Â  ,          Â  Â´  O    P  Â˘      and for all instants  S  .  Â    Ăź  Â  .  P  Â´    2. or  Ă  Ă  }    e  |    Â  Â´  P  (with  ) and for all instants  S  and  Â    Â    Figure 3. States of    Â  fib1 == 0  fib1 == 1  fib1 == 1  Ăą    Â    '    R  Â  Â´  Â  R  such that  Â    Â    P  %  e    O    Âž    Â  Ă  Ăž  3. or does not exist (i.e., not enough S ticks) and for  all instants  such that  ,  S  and  S  .  Ăż    Â  Â    R  Ă  Â  Â  Â  Â  Â        Â˘  Â´  Âž  Â  Ă  Ăž  Â  S  Ăż  Â  S  Â  S  Âž  Âž  Â  S  Â  S  S  S  S  S  %    O    P  P  Â˘    P    Â´      Â´  e    P  Â´  Â  e  %    O    Â  Ă  In the previous definition, item (1) suggests to partition  according to the ticks of S or S . That is  the interval  to say,  such that the  consists of all the instants which coincide  set  with a tick of S or S in the interval  . Item (2) suggests  according to the ticks of S .  to partition the interval  such  That is to say,  that the set  consists of all the instants which  . Whenever  coincide with a tick of S in the interval  is not defined, item(3) suggests to partition the interval  according to the ticks of S or S .  , defined  In the sequel we consider that the intervals,  by Definition 3 are numbered from the most recent to the  oldest as depicted in Figure 4. Thus, is the index of the  interval which has the form  where is an instant of  the past, i.e.  . We will denote by , and the  is of  indices of the following intervals of the partition:  the form  , is of the form  and  is of the  form  where  and are instants of  .  interWe can show (see [3]) that at most the last  vals, say,  are sufficient to compute the truthvalue of the past atom .  In practice, we introduce a data structure called past  atom memory and denoted  , which allows us to  evaluate at every instant. Informally, this data structure  intervals of the partition deencodes either the last  fined above as well as the evaluation of  for every  interval, , of the considered partition.  S ..  S  be a past  Definition 4 Let =  atom and be the current instant. The past atom memory  at is a triple  of sequences of  truth values of a 3-valued logic ( -true-, -false-, u  -undefined-). We represent a past atom memory  by  the following figure:    Â  Ă  Ăž  Ăż      Â  Âž  Ă  /  /  /    /    /    /    /  /  /    Â    Â      Â  Â    Â    Ăą  Â  P  Â      Â    Â  Â        Â  Â  Â    {    Â        {  Ăł    Â  Â    Â    Â    Figure 4. Interval partition  Â    Â  P  '  Â    Ăą  Â    Â    Â  Â    '    '    Â  Â      Â    Â  Â  {    Â    Â      {    Ăł    instant, we can verify that element is the definition of fib1  two instants ago, and element  is the definition of fib1 at  the previous instant.  Â  Â  "  Â    Â  Â    "  '    Â  '    Â  Â      For a memory [  ] associated to a past toe  =  S  which verifies the invariant, the definition  of is  in which we replace the timed operator by the  S  . Since the memory verifies the  new operator  invariant at every instant, the calculus of the definition of  is always possible.  Now, we consider how it is possible to compute the truthvalues of past atoms within a bounded space. We illustrate  our algorithm on the case of formulas, , of the form  S ..  S  . Recall that, according to the semanis  tics given in the previous section, the truth-value of  equal to the disjunction  where (resp. )  is the absolute instant corresponding to  S  (resp.  S ).  is not bounded, and so is  The length of  the number of elements occurring in the disjunction  . To overcome this issue, we propose a  way to split the interval  into subintervals so that the  computation of the value of  becomes feasible using  be a partition of  a bounded space memory. Let  . We associate a constant  for every interval .  corresponds to the value  . The value of B is  thus equal to  .  Such a partition changes over time and should be available at every instant. Hence, we should keep preparing the  forthcoming partitions. Our proposal consists in partitionas follows:  ing at every instant , the interval  "  l        l    "  !  $  a  Â  "  "  h  a          !  $  h  Â  Â  Â  Â  Ă  Â  Â˛  Â´  1            !  Â  Â        !  Â    2  Â  Â      1  /  !  Â˛  Âł  Â  Â  !    a  2  |  Ăˇ  )  Â  !  Â    1  Ă  Ă­  Â  Â  Â  Â  Ă  >  Â  |  Ăˇ  *    v    v  Y    !  Â  ,  )  -  Â    Âş  Â˛    )  Ă    Â´  Âš  '  Â    2  Â´  a  R        )  Â  Ă    2    2    Âł    Â  Â  I  Ă­  1    O    O  Â  Â  Â˛  $  Â  1    Â  I  Â    Â  2  Âł    Â  Â    /  Â    Â  Â  .  Âž  Â  '    Â´  1  2  !  Â  Â  Â˛  Â  $  Âş  Â´  Âš  I  %  1      O  Ă  Â  $  Â  $  1  Âł      $  Âž  Â    Â  `  Â  Âł    Â  Âş  Â˛  '    '  2  Ă  Âž  Â´  Â  !  1  Âš  ,  Â  Â    Â  Â  >  Ă°  Â    Ă­  Â    2  1  Ă­  ,    ,  l  Â    Â  Âł  Â  $  ,  Â  h  Â˛    2  Âł  |  Ăˇ      Âş  ./  01  *    Âš    *  Âž  *    Â  `  a  Â  a  v  v  v  Âž  Â  `  Â  a  a  v  v  v  Âž  Â  Â  Â  Â  `  a  a  Â      Â  '    *    v  v  The interpretation of elements , ,  is defined by  the following invariant over the data structure  .      Â  Â  Ă  5  Proceedings of the Ninth International Symposium on Temporal Representation and Reasoning (TIMEâ02)  1530-1311/02 $17.00 ÂŠ 2002 IEEE  |  Ăˇ  Âž  Definition 5 Let =  S  S  be a past atom  and  be the past atom memory for  at . Let  be the interval partition at . The invariant  for  is the conjunction of the following assertions:  1  1  .  Â  !  Â  !  Â  P    *  1  Â    Ă  Âž  Âž  /  2  Âş  Â  `  `  Âš  Â  a  9  :  ;  a  a  ;    a  Ă  Ă  1  Ăą  2  %  |  Ă˛  Ăˇ  Ă˛  if  and    2  Ăł  v  2    !  "      v    !  ,  v    is not defined  is defined,  $  v    Â  2  !  "    Â  !  ,  $  Ă  |  Ăˇ  P  2  %  1. â(if  is defined and  , then        $  $  or (if      O  $  v    "    !  v    Â  ,  is not defined.  $  Â  Ă  Ă    -  P  Ă  Ă    2  ÂŻ    P    v  !      ,    Â  2  Ă  Â  2  2  The calculus of the definition of the new operator B  generated from the past atom B can easily be performed usis B  ing Definition 6. The definition which we add to  true if the truth value of B is true. Otherwise, we add B  false.  is the disjunction of the truth value of  on  the interval ,  if begins with a tick of S and  otherwise,  and  if begins with a tick of S and  otherwise.â  P    Ă  1  v  O  is not defined and      *  2    v  if  1      Â  2  ,  v  2  Example 7 Consider the memory of  Â  P    Â  -  .  2. â  Y    *  iff  $    P  v  P  v  Â  laser1 ..    ,  u.â  P      Â  laser2 !reject == true    ,  Â  v    v    given in Example 6.  = 2 and  = 1. Thus, the truth value of  2  v    v  !  "    ,  ,  $    Â  2  Example 6 Consider Example 4 and suppose that the ticks  of laser1 happened only at the instants 5, 11 and 16, the  ticks of laser2 happened only at 7 and 14, a tick of laser3  happened only at 12.  laser2  =  14. Thus, the interval partition is  . Since the interval partition has to be verified, the  memory for  laser1 ..  laser2 !reject == true must  be:  Â    O  y      !        !      Ăą  4  Â  Â    ,  ,  4    ,  Â  Ă˛  Â  3  ,  6  Â  is  6  ,  '  Â  Ă˛  Â  ,  ,  ,    Â  ,  Â    $  laser1 ..  ,    laser2 !reject == true  ,  Â  , i.e., true.  *  Â  Ă  Ă  ./  ,  is updated at each inWe focus now on the way  stant. In Figure 5, we give the inference rules which are  initialises the data  applied at each instant. Rule  structure with undefined values. Rule  is applied  whenever both signal ticks of  and  are absent. In this  case, interval is augmented by one instant, and thus the  new value  is equal to the value of  at the previous instant augmented -using the operator- by the current value  of , say . Rule  is a bit technical. Informally,  Rule  is applied whenever a tick of signal  octo the right, and no tick of  curs, shifts to next tick of  the signal S happened at the previous . Consider, for instance, the situation as depicted in Figure 4. Assume that  moves to the left bound of interval . In the new interval partition the previous intervals and are unified.  and  indicates the indices of such intervals to be unified. The new data corresponding to the unified interval is  ,  and  . Rule  is used  given by  whenever the three other rules cannot be applied. It creates  a new interval, initialises the corresponding values, namely  ,  and , and shifts all triples one step to the left. In  this case, the values of the preceding instant corresponding  th interval are lost.  to the  Ă˛  ÂŁ  ÂŁ  Ă    $  Ăł  Â      ,  "  .        !    01  |  Ăˇ  .    '  $    ,  -  ,  (1)  -    .    ,  $  Â    2  *  -  ,  Ă  From the definition of  , it is easy to compute  at each instant the indices and by using the sequences  and  and then deduce the value of  from the sequence . We give in Definition 6 a formal definition of  the computation of the value of . For that, we introduce first a couple of technical definitions. We note by  where  N,  ,  and is either  or , the lowest index over such  that there are exactly occurrences of  in  .  Roughly speaking,  is the index of  the interval beginning with  S  where stands for the current instant. Symmetrically,  is the index of the interval beginning  with  S  .  The formal calculus of the truth value of the past atoms  uses an operation, say , of the 3-valued logic. We note ,  the unique extension of the boolean disjunction where u is  the identity.  S  S  be a past atom  Definition 6 Let =  be the past atom memory for  at instant  and  which verifies the invariant (Definition 5). The value of  is defined by  |  v  8  Ăˇ  O  *  1  1  Â    *  v    v        !    !  $  v  v    !  Ă°    ,  '    !  )  v      2  !  "      v    !  ,  $  Â    O  y      !        !        !  v  "      v  ,    O  y      !        !        *  1  .  Â  !  !  Â  Â  Ăˇ  1    *  1    Ă  Âž  Ă  /  /  Â´  `    !  )  !  Â  .      .    Ă  .    $  01  Â  `  :  ;  a  ;  a  9  :  ;  a    ;  Ă  v  if  are defined.  2  !  "    !    v    ,  $  and  Ă  v    v  -  -  -  ,  ,  -    Â  2  !  "    !  Â  ,  ,  $  ./  Â  Âş  9      $  $  Âš  a  .  v      Âž  P        2  v    Example 8 Consider Example 7. At 16, a tick of laser1  occurs. Thus, at 17, the rule  cannot be applied. In  the same way, no tick of laser2 occurs at 16. Thus, at 17,  the rule  cannot be applied. Hence, at 17, the rule  is applied to and transforms the past atom memory  into  Â  Â  1  |  v    Ă  v  Â´  Â  8  1    Â  $  8    `    Â  !  *  Â´  $        8    !  Â  <  `  Â  !  2  ,  Â´  $    2  )  *        Â  2    ,  v  Â  Â    Â  Â´  !    Â  Â    v  $  $  2      Ă  Ăž  v  Â  Â  v  Ă    Â    Â  !    .    Y    "  .    1  !    Â    I  v  2  *  $  6  Proceedings of the Ninth International Symposium on Temporal Representation and Reasoning (TIMEâ02)  1530-1311/02 $17.00 ÂŠ 2002 IEEE  $  store computation. Afterwards, the updated memories verify their invariants, and thus permit a sound computation of  for the instant .  consists of the timed rewrite rules  of  in addition to the definition of the incoming signals  and the definition of the new operators which are calculated  consists of the rewrite  from their associated memories.  whose tail is either true or absent. If all the  rules in  tails of the timed rewrite rules defining a timed operator  are false, we define in  by its remanent definition borrowed from the store of the previous instant. The rules of  or  are obtained from  in the same way as  by  simplifying the rules.  The soundness of this actual operational semantics is  stated in following.  Ă  Ă  if  Ă  Ă  Ă  Ă  ./  01  Â  u  u  u  Ă  Ă  Ă  Ă  Ă  Ă  u  u  u  u  u  u  Ă  Ă  Ă  ĂŚ  Â      ÂŻ    Â  Ă  =  =  01  Âž  Â  Â  ÂŻ    =  ./  8  ?  ÂŽ  Â  Ă  Ă  Â  Ă  Ă    Â  Ă  Âž  Â  Â  Â  Â  ?  Â°  Â  ÂŚ  ÂŚ  Ă  ÂŚ  Ă  Â  Â    Ă  Ă  Ă  Âž  Â  Â  Â  Â  ?  ÂŚ  ÂŚ  ÂŚ  Ă  Ă  Â  Â  Ă  ÂŁ  Ă  Ă  Ă  Ă  =  =  =  =  C  ./  01  Âž  Â  ÂŻ  h  Â  ?  Â    Ă  Ă  Â  Ă  Ă  Â  A  Ă  C  Âž  Â°  h  Â  Â  Â  Â  Â  ?  ÂŚ  A  ÂŚ  ÂŚ  Ă  Ă  Ă  ÂŚ  Â  Â  Ă  Ă  C  Âž  Â  Â  Â  Â  Â  ?  Â  ÂŚ  ÂŚ  Ă  ÂŚ  Ă  A  Â  ÂŚ  Â  Â    ĂĽ  if  ĂĄ  Ă˘  ĂĽ  ĂŁ  ĂĄ  Â  S  Ă¤  Â  ĂŚ  ĂŚ  Ă§  F  3  6  Ă¨  Ă  ĂŁ  D  and  Ă  Â  S  Ă¤  Â  ĂŚ  ĂŚ  Ă§  F  3  6  Ă  ÂĽ  Ă  =  Ă¨  8  Ă  =  ./  Ă˘  E  =  E  =  E  =  Ă  Ă  =  E  01  Âž  Â´  Â  Â´  Â´  ĂŁ  Â´  ?  ?  Ă  ?  Ă  Â  Â  Ă  Ă  Â  Â  Ă  Ă  E  E  E  Ă  Ă  E  Âž  ( -2)  Â  Â  Â  Â´  Â  Â´  Â  Â´  Â  ĂŁ  Â´  Â      Â°    Âą  ?  ?  ÂŚ  Â  Âą  ?  ÂŚ  Ă  ÂŚ  ÂŚ  ÂŚ  ÂŚ  Ă  Â  Â  Ă  Ă  Â  Â  Ă  Ă  E  E  E  Ă  Ă  E  Âž  Â  Â  Â  Â  Â´  Â  Â´  ?  ÂŚ  ĂŁ  Â´  Â  ?  ÂŚ  Ă  ÂŚ  ÂŚ  ÂŚ  ÂŚ    Ă  Ă  Theorem 1 Let be a timed rewrite system satisfying requirements 1, 2 and 3. At each instant , for all timed operators ,  in  and in  represent the same operation.  Â  Â  Ă  Â  Â  Ă  Ă  =  ./  Â  Â´  ?  =  E  =  E  =  E  =  Ă  Ă  =  E  C  =  01  Âž  Â´  Â  Â´  Â´  ĂŁ  Â´  ?  ?  Ă  ?  Ă  Â  A  Â  Ă  Ă  Â  Â  Ă  Ă  Ă  Ă  C  E  E  E    Âž  Â  Â  Â´  Â  Â´  Â  ĂŁ  Â´  Â  Â  Â  Â  ?  ?  ?    ÂŚ  ÂŚ  Ă  ÂŚ  ÂŚ  ÂŚ  ÂŚ  Ă  Â  Â  Ă  Ă  Â  Â  Ă  Ă  Ă  Ă  C  E  E  E  Âž  h  Â  Â  Â  Â  Â´  Â  Â´  ĂŁ  Â´  Â  Â  ?  ?  ÂŚ  ?  ÂŚ  Ă  ÂŚ  ÂŚ  ÂŚ  ÂŚ  Ă  Â  Â  Â  Â  Â˛  h  Âą  Âł    Âą  h  Ă  ĂĽ  if  ĂĄ  Ă˘  is defined  ĂŁ  Â  S  Ă¤  8  :  Â  Ă­  Â  ĂŚ  ĂŚ  Â  Ă¨  D  Ă­  F  B  Ă¨  ÂŁ  ÂŚ  Â  D  ÂŚ  Ă  D  E  Ă  Â  Ă­  Â  H  ĂŚ  Â  Ă­  F  B  Ă¨  ÂŁ  Â  ÂŚ  D  =  ÂŚ  Â´  Ă­  Ă  D  D  ÂŚ  ĂŚ  I  D  Â  H  5. Conclusion and Related work  Ă­  L  Â  N  Â  D  E  u and  Â´  ?  ĂŚ  Â  O  Ă  Ă  8  Ă  ÂĽ  Ă  =  =  =  ./  01  Âž  Â  ?  Ă  Ă  Â  Ă  Ă  We gave the broad outlines of a new kernel framework  allowing conservative extensions of declarative rule-based  programs with time. We proposed an efficient operational  semantics so that we can tackle real-world applications. The  implementation of our formalism is under progress and will  be available soon.  Synchronous languages are specially designed for reactive programming [8]. The most representative synchronous  languages are Lustre [5], Signal [7] and Esterel [2].  All of them are based on the notion of signal and enable  to compile programs into finite state automata. However,  these languages do not handle new abstract data types or  functions as signals. Moreover, they do not provide powerful temporal operators such as and over intervals. The  closest languages to our formalism are the declarative ones,  namely Lustre and Signal. The primitives of theses  languages can be easily expressed in our formalism. As for  Esterel, it rather offers an imperative style of programming and, as in our semantics, its signals are remanent unlike Lustre and Signal. Note that the compilation into  a finite automaton is possible in our case too whenever the  considered applications do not need more expressive machines.  The absence of time notion in ccp has led to the development of a new synchronous paradigm tcc [12] based on  ccp and preserving its good properties. We share with tcc  the principle of a very expressive evolving store. However,  the way of expressing the store changes is completely different. In tcc, the stores are generated from processes and  the process algebra is orthogonal to the formalism expressing formulas of the stores. Moreover, these formulas are  Â  Ă  Âž  Â  Â  Â  Â  ?  ÂŚ  ÂŚ  Ă  ÂŚ  Ă  Â  Ă  Ă  Â  Ă  Âž  Â  Â  Â  Â  ?  ÂŚ  ÂŚ  Ă  ÂŚ  Ă  Â  Â  Ă  P  otherwise  Ă  Ă  Ă  Ă  =  ./  =  C  =  01  Âž  Â  ĂŁ  Â  ?  Ă  Ă  Â  Â  Ă  Ă  Ă  C  Âž  ĂŁ  Â  Â  Â  Â  ?  ÂŚ  ÂŚ  Ă  Ă  ÂŚ  Â  Â  Ă  Ă  Ă  C  Âž  ĂŁ  Â  Â  Â  ÂŚ  Ă  =  Â  ?  ÂŚ  Ă  ÂŚ  Â  Â  C  C  where  stands for the truth value of  in  ,  for the  in  and  for the truth value  truth value of S  in  . So,  is true iff a tick of S occurred at  of S  is true iff a tick of S  the previous instant, and symmetrically,  occurred at the previous instant.  ĂĄ  Ă˘  ĂŁ  Â  >  Â  Â  ÂŚ  C  ĂĽ  ĂĄ  8  Â  ĂŚ  Ă˘  ĂŁ  Â  :  ĂŚ  Â  Â  Ă¨  ÂŚ  C  ĂĽ  Ă˘  ĂĄ  ĂŁ  Â  8  Â  ĂŚ  :  ĂŚ  Â  Â  Ă¨  Â  ÂŚ  C  Â  Â  ÂŚ  Figure 5. Past atom memory rules  -  .  Â  = 14. Thus, at 17, the  interval partition is  ;  ;  ;  ;  . Since  laser1  = 16, the  invariant is still verified.  Now, suppose that, at 16, a tick of laser2 happens instead of a tick of of laser1. At 16, the rule  cannot  =  be applied. On the other hand, since  1,  =  and  u, the rule  is applied and  transforms the past atom memory into the one depicted in  laser2  = 16. Thus, at 17,  (1).  the interval partition is  ;  ;  ;  .  laser1  = 11, the invariSince  ant is still verified.          O  y      !        !      laser2  ,    Ăą  Â  ,  S  4  $    ,  Â  Â    6  ,  '  Â  Â  Ăą  ,  3  Ăł  Ăł  Â  ,  4  ,  ,      O  y      !        !        Â  Â    ,  ,  6  Â      ,  ,    S  .  $    ,  v    $  v    Â  2  v  *  Â  T    Â  O  y      !        !      Â  4  ,  Â  y        !        !      Ă  ,  ,  $  $  ,  S  $    Â    O    ,  Ăą    .  ,            "  P  -    !  Â    6  ,  '  Â  Â  ,  ,  ,  6  Â  Ăą  ,  3  Ăł  Ăł    ,  S  $  The rules given in Figure 2 and Figure 5 must be applied  to the corresponding memories at each instant , before the    7  Proceedings of the Ninth International Symposium on Temporal Representation and Reasoning (TIMEâ02)  1530-1311/02 $17.00 ÂŠ 2002 IEEE  References  atemporal and not remanent. Thus, the data transmission  from an instant to another is performed explicitly by the  combinator next of the process algebra. The timed rewrite  system, we propose, is data-oriented. The mechanisms of  data transmission, which are hidden from the user, could  be rather complicated in the case of past atoms and they  could manipulate definitions of operators which is not possible in tcc. A problem of tcc inherited from ccp is  the negative information detection. At each instant, tcc  may only detect an absence of information at the end of  the store computation, and thus the reaction is put back  one instant later. A solution was presented in [13]. The  new paradigm is called Default Timed cc and enables  to detect an absence of information and to react instantaneously. In compensation, the programs need to be verified  statically to avoid causality loops, whereas it was not necessary for tcc programs (âparadox-freeâ property of [12]).  Our store is a well-defined stratified rewrite system which  may be adapted to a large scope of constraint. A boolean  function may stand for a predicate solving the NOT problem  in the logic programming paradigm and thus the negative information problem of ccp. On the other hand, ntcc [11]  extends tcc by adding non-determinism. This paradigm  has, among others, two operators noted ! and . !P means  âP will be always true in the current store and in the future  onesâ, P means âP will be true in the current store or in  some future oneâ. From a logic point of view, ! and are  the respective duals in the future of our operators and .  From a procedural point of view, ! and can be considered as behavior generators, whereas and are behavior  testers. ! and can be applied just to a specific interval of  time in future. However, this interval is expressed using the  base time unit: no other granularity is provided.  [1] M. Abadi and Z. Manna. Temporal logic programming. J.  of Symbolic Computation, 8(3):277â295, September 1989.  [2] G. Berry and G. Gonthier. The Esterel programming language: Design, semantics and implementation. Science of  Computer Programming, 19(2), 1992.  [3] J. Blanc and R. Echahed.  Synchronous functional logic programming.  Technical report, Laboratoire Leibniz, 2001.  available at http://wwwleibniz.imag.fr/PMP/TIME/Timed-programs.ps.  [4] J. Blanc and R. Echahed.  Timed term  rewrite systems.  ENTCS, (64), 2002.  URL:  http://www.elsevier.nl/locate/entcs/volume64.html.  [5] C. Dumas-Canovas and P. Caspi. A PVS proof obligation  generator for Lustre programs. In 7th Int. Conf. on Logic  for Programming and Automated Reasoning, volume 1955  of LNAI, 2000.  [6] D. Gabbay. Modal and Temporal Logic Programming, chapter 6, pages 197â237. Academic Press, 1987.  [7] P. L. Guernic, T. Gautier, M. L. Borgne, and C. L. Maire.  Programming real time applications with signal. Proceedings of the IEEE, 79(9), 1991.  [8] N. Halbwachs. Synchronous programming of reactive systems. In Computer Aided Verification (CAVâ98), LNAI 1427,  pages 1â16, 1998.  [9] C. Liu and M. A. Orgun. Dealing with multiple granularity of time in temporal logic programming. J. of Symbolic  Computation, 22(5 and 6):699â720, 1996.  [10] M. A. Orgun and W. Ma. An overview of temporal and  modal logic programming. In D. M. Gabbay and H. J.  Ohlbach, editors, First Int. Conf. on Temporal Logic, LNAI  827, pages 445â479, July 1994.  [11] C. Palamidessi and F. Valencia. A temporal concurrent constraint programming calculus. Report RS-01-20, BRICS,  University of Aarhus, June 2001.  [12] V. Saraswat, R. Jagadeesan, and V. Gupta. Constraint Programming, volume 131 of the NATO Advanced Science Institute Series, Series F: Computer and System Sciences,  chapter Programming in Timed Concurrent Constraint Languages. Springer Verlag, 1994.  [13] V. A. Saraswat, R. Jagadeesan, and V. Gupta. Timed default concurrent constraint programming. Journal of Symbolic Computation, 22(5 â 6):475 â 520, Nov â Dec 1996.  [14] K. Zhang and M. A. Orgun. Parallel execution of temporal  logic programs using dataflow computation. In Int. Conf. on  Computing and Information, pages 812â830, 1994.  W  X  W  -  .  W  -  .  W  Another class of programming languages related to our  formalism is the temporal logic programming languages.  An interesting overview is presented in [10]. The meaning  of âtemporalâ for languages like Templog [1] and Temporal Prolog of Gabbay [6] is not the same as the one  in the synchronous world. The time is indeed represented  in a constraint system and does not constraint temporally  the execution of the program. So, the causality of the condition in formulas is not preserved in these extensions of  the logic programming, whereas it is in our paradigm. On  the other hand, these languages have the temporal operators (always) and (eventually) but without scope over  some time interval. Chronolog is a data-flow temporal  logic language [14] designed to do efficient computation.  However, this language only manages one clock. Since the  need for a multi-granular time is very important in temporal  programming, Chronolog(MC) [9] has been developed.  Nevertheless, this language is not synchronous.  -  .  8  Proceedings of the Ninth International Symposium on Temporal Representation and Reasoning (TIMEâ02)  1530-1311/02 $17.00 ÂŠ 2002 IEEE 