2010 17th International Symposium on Temporal Representation and Reasoning  Counting LTL  FrancĚ§ois Laroussinie1  Antoine Meyer2  1  Eudes Petonnet  1  LIAFA, UniversiteĚ Paris Diderot â Paris 7 & CNRS UMR 7089, France  {Francois.Laroussinie,Eudes.Petonnet}@liafa.jussieu.fr  2  LIGM, UniversiteĚ Paris Est â Marne-la-ValleĚe & CNRS UMR 8049, France  Antoine.Meyer@univ-mlv.fr  Abstract  defined with grammars as in [17].  In this paper, we present a counting extension of LTL  in the line of [12], called CLTL, where Until modalities  are equipped with constraints on the number of true occurrences of certain subformulas. For instance, in a mutual exclusion protocol where two processes try to access the same    critical section, the formula G req1 â F[]cs2 â¤5] cs1 ) expresses the fact that whenever process 1 requests access to  the critical section it is eventually granted access, and until  then process 2 can be granted access at most 5 times. More  generally, we allow constraints to be arbitrary  PBoolean combinations of atomic statements of the form i Îąi Âˇ ]Ďi âź c,  where c and each Îąi are positive integers, âź is a comparison operator and each ]Ďi represents the number of states  from which some arbitrary CLTL formula Ďi holds along a  certain prefix of the run.  We show that, even though CLTL formulas can be translated into LTL, this might yield an exponential blow-up  in formula size. We then turn to the satisfiability and  model-checking problems for CLTL, for which we provide  automata-based algorithms running in exponential space.  This complexity is asymptotically optimal, since both problems turn out to be EXPSPACE-complete. We conclude this  algorithmic study by presenting a fragment of CLTL whose  satisfiability and model-checking problems are PSPACEcomplete, and show that any generalization of constraints  with subtraction makes both problems undecidable. Finally,  we show that for a similar counting extension of CTLâ , the  model-checking problem remains solvable in EXPSPACE.  This paper presents a quantitative extension for the  linear-time temporal logic LTL allowing to specify the number of states satisfying certain sub-formulas along paths.  We give decision procedures for the satisfiability and model  checking of this new temporal logic and study the complexity of the corresponding problems. Furthermore we show  that the problems become undecidable when more expressive constraints are considered.  1. Introduction  Temporal logic (TL) is a well-known and well-studied formalism for specifying and verifying properties of automated  systems [13]. Classical temporal logics, such as LTL or  CTL, express properties on the temporal ordering of events  along the executions (see [6] for a survey). Many extensions  of these formalisms have been studied, whose aim is usually  to improve expressivity in order to capture more complex  specifications, or to make properties shorter and easier to  write. Of course there is an important trade-off between the  expressivity of the logic and the efficiency of decision procedures, the ultimate goal being to algorithmically decide  satisfiability or model-checking problems.  Among the well-known extensions of classical temporal logics, we can mention real-time TLs (see for example [2, 3, 7]) where it is possible to add timing constraints in  properties (for example, one can specify that an event A follows an event B in at most 5 time units) or probabilistic TLs  (see [10] for such an extension of CTL) where it is possible  to express properties like âevent A will occur with probability 0.99 or greaterâ. These two extensions are called  quantitative extensions. Another classical variant consists  in adding some form of regular expressions [8] or operators  1530-1311/10 $26.00 ÂŠ 2010 IEEE  DOI 10.1109/TIME.2010.20  This work is related to our previous effort on counting  extensions of CTL [12], where we use the same counting  constraints as described above. By varying the allowed syntax of constraints, we presented a thorough account of the  expressiveness and succinctness of the logic with respect  to CTL, and proposed an algorithmic study of the modelchecking problem, which ranges from P-complete when  51  only atomic constraints are considered to âP2 -complete for  the full logic. Contrary to CLTL, we also managed to characterize decidable fragments with subtractive constraints.  There exist several other works on extensions of LTL  to handle quantitative aspects of systems. In [8], the  authors extend linear-time logic with some simple regular expressions along with quantitative constraints on the  number of occurrences of sub-expressions. They present  model-checking algorithms (satisfiability is not considered)  whose time complexity is exponential in the size of formulas and the value of integer constants (and thus doublyexponential), which is comparable to the complexity we obtain for CLTL. In terms of expressiveness, our logic can easily be used to express complicated quantitative constraints,  but is less well-suited to specifying the order of events. Another interesting specification language is Sugar/PSL [14],  which defines many additional operators above LTL. These  include in particular some counting constraints which are  used together with regular expressions, subsuming CLTL  with atomic constraints. To our knowledge, there is no accurate study of lower complexity bounds for these extensions [4].  Counting LTL. We define a quantitative extension of LTL  able to express constraints over the number of times certain  sub-formulas are satisfied along a run:  Definition 2. Given a set of atomic propositions AP, we  define:  CLTL 3 Ď, Ď ::= P | Ď â§ Ď | ÂŹĎ | ĎU[C] Ď  where P â AP and C is a counting constraint defined as:  P  C 3 C, C 0 ::= > | C â§ C 0 | ÂŹC |  i Îąi Âˇ ]Ďi âź k  where k, Îąi â Nâ , âźâ {<, â¤, =, âĽ, >} and Ďi â CLTL.  In CLTL formulas, we make use of the standard abbreviations â¨, â, â, âĽ, >, as well as the additional modality  def  def  F[C] Ď = >U[C] Ď, and its dual G[C] Ď = ÂŹF[C] ÂŹĎ. Moreover the classical Next operator X is defined as F[]>=1] , the  standard Until U is U[>] (F is F[>] and G is G[>] ). Any formula occurring in a constraint C associated with a modality  in ÎŚ is considered as a sub-formula of ÎŚ. The size |ÎŚ| of  ÎŚ takes the size of these constraints and their sub-formulas  into account, assuming that integer constants are encoded  in binary (unless explicitly stated otherwise). The DAGsize of ÎŚ is the total number of distinct sub-formulas of ÎŚ.  As model-checking algorithms compute only once the truth  value of a sub-formula, this is generally more relevant to the  complexity of model-checking.  The semantics of CLTL formulas is defined over infinite  words in (2AP )Ď :  The paper is organized as follows. Section 2 defines the  logic CLTL, whose expressivity and succinctness are studied in Section 3. Section 4 presents an EXPSPACE satisfiability algorithm based on alternating BuĚchi automata, as  well as the EXPSPACE-hardness proof and a PSPACE algorithm for a fragment of CLTL. Section 5 deals with an  undecidable extension of the constraint language. Finally  Section 6 presents a counting extension of CTLâ .  Definition 3. The following clauses define the conditions  for an infinite word w â (2AP )Ď to satisfy a CLTL formula  Ď â written w |= Ď â by induction over the structure of Ď:  2. Definitions  Models. Let AP be a set of atomic propositions. In lineartime temporal logics, formulas are interpreted over infinite  words in (2AP )Ď . Given such a word w, wi denotes the i-th  letter and wi is the i-th non-empty suffix of w with i âĽ 0.  As we will be considering the model-checking problem, we  also recall the classical notion of Kripke structure:  w |= P  iff P â w0  w |= Ď â§ Ď  iff w |= Ď and w |= Ď  w |= ÂŹĎ  iff w 6|= Ď  w |= ĎU[C] Ď  iff âi âĽ 0, wi |= Ď, w, iâ1 |= C  and â0 â¤ j < i, wj |= Ď  Definition 1. A Kripke structure (or KS) S is a tuple  hQ, qinit , R, `i where Q is a finite set of states, qinit â Q  is the initial state, R â Q Ă Q is a total accessibility relation and ` : Q â 2AP is a labeling of states with atomic  propositions.  The semantics of w, i |= C is based on the interpretation of  ]Ď over the suffixes wj for 0 â¤ j â¤ i, denoted by |w, i|Ď  def  and defined as: |w, i|Ď = |{j | 0 â¤ j â¤ i â§ wj |= Ď}|.  Given these values, C is interpreted in a natural way (and >  is true over every word).  A run (or path) Ď of S is an infinite sequence of states  q0 q1 q2 . . . such that (qi , qi+1 ) â R for every i. We use Ď(i)  to denote the state qi and Ďi to denote the suffix qi Âˇ qi+1 Âˇ Âˇ Âˇ  of Ď. Runs(q) denotes the set of runs starting from some  state q â Q and Runs(S) stands for Runs(qinit ).  In the following, we will be referring to both infinite  words in (2AP )Ď and paths of some KS as runs.  Given a KS S = hQ, qinit , R, `i, we write S |= ÎŚ when  every execution Ď â Runs(S) satisfies ÎŚ (i.e. `(Ď(0)) Âˇ  `(Ď(1)) Âˇ Âˇ Âˇ |= ÎŚ). We use âĄ to denote the standard equivalence between formulas.  Remark 1. Let us denote by C the constraint dual to C obtained by propagating the negation operator in ÂŹC towards  52  (ĎU[C 0 ] Ď v ĎU[C] Ď if C 0 v C). It can be shown that @ is  a well-founded strict partial ordering over CLTL formulas.  atomic constraints (using De Morganâs laws and inverting  comparison operators as required).  Negation and disjunction operators can be eliminated  from constraints using the fact that ĎU[ÂŹC] Ď âĄ ĎU[C] Ď  and ĎU[Câ¨C 0 ] Ď âĄ ĎU[C] Ď â¨ ĎU[C 0 ] Ď. However, even  though ĎU[Câ§C 0 ] Ď â ĎU[C] Ď â§ ĎU[C 0 ] Ď, the converse  does not hold, as can be seen on the simple example  F[]P1 =1â§]P2 =1] > (indeed this formula requires that at some  point both P1 and P2 must have been seen exactly once,  while F[]P1 =1] > â§ F[]P2 =1] > does not: for instance P1 may  occur twice before P2 first occurs).  This implies that any CLTL formula can be translated  into an  Vequivalent formula where all constraints are of the  form i Îąi Âˇ ]Ďi âź k. However, this may yield an exponentially longer formula, since it essentially requires constraints to be put into disjunctive normal form.  3. Expressivity  Unfolding. In classical LTL, a crucial observation is that  formula Ď1 UĎ2 can be âunfoldedâ by distinguishing the  possible cases in the first state of a run, yielding the following equivalence:      Ď1 UĎ2 âĄ Ď2 â¨ Ď1 â§ X(Ď1 UĎ2 )  In order to obtain a similar equivalence for a formula  Ď1 U[C] Ď2 in counting LTL we need to take into account  all the counting expressions occurring in C, and to update  the relevant atomic constraints accordingly. To this end we  make use of the two elementary update operations on constraints defined in the previous section.  Manipulating constraints. We now define two operations on constraints, which will play an important technical  role in the remainder of the paper.  Let C be a counting constraint  P containing m atomic constraints (m > 0) of the form jâ[1,ni ] Îąji Âˇ ]Ďij âź ki for  i â [1, m]. We define SC as the set {Ďij | i â [1, m], j â  [1, ni ]}. For any â â SC , we inductively define the subtractive update C â â of C by â by:  Lemma 1. For all word w in (2AP )Ď and index i âĽ 0,  w, i |= C ââ w1 , i â 1 |= (C â â) â, where  â = {Ď â SC | w |= Ď}.  P  Proof.  any atomic  P Let i Îąi . ]Ď0 i âź k be  P constraint in C,  and i Îąi . ]Ďi âź k with k 0 = k â Ďj ââ Îąj the corresponding constraint in C 0 = C â â. By definition of â, for  every Ď â â we have  def  ÂŹC â â = ÂŹ(C â â)  |w, i|Ď = |{j | 0 â¤ j â¤ i â§ wj |= Ď}|  (C â§ C 0 ) â â = (C â â) â§ (C 0 â â)  P  def P  ( i Îąi Âˇ ]Ďi âź k) â â = i Îąi Âˇ ]Ďi âź k 0  P  def  with k 0 = k â Ďj ââ Îąj .  def  = 1 + |{j | 0 < j â¤ i â§ wj |= Ď}|  = 1 + |{j | 0 â¤ j â¤ iâ1 â§ w1+j |= Ď}|  = 1 + |w1 , iâ1|Ď .  Notice that even though constants in C are defined to be  positive integers, C â â may contain negative constants  as right-hand sides of comparison operators. However, it  can easily be seen that atomic constraints where negative  constants (or possibly 0) occur are either trivially true or  trivially false. We thus define a second update operation,  called simplification.  We define the constraint Câ obtained from C by replacing any (trivially true) atomic constraint of the form S > k  with k < 0 or S âĽ k with k â¤ 0 by > (where S stands  for an arbitrary sum of counting expressions), and any (trivially false) atomic constraint of the form S < k with k â¤ 0  or S â¤ k with k < 0 by âĽ, and simplifying the obtained  constraint in the usual way (as one would simplify a propositional logic formula). Note that Câ is either reduced to >  or âĽ, or does not contain > or âĽ as a sub-formula. Also  note that C and Câ are equivalent.  We will write C 0 v C whenever there exists a set â â  SC such that C 0 = (C â â) â, and C 0 @ C if â 6= â.  This notation is extended to CLTL formulas in a natural way  Similarly for every Ď 6â â, |w, i|Ď = |w1 , iâ1|Ď . Thus  P  P  P  k â i Îąi .|w, i|Ď = k â Ďj ââ Îąj â i Îąi .|w1 , iâ1|Ďi  P  = k 0 â i Îąi .|w1 , iâ1|Ďi .  Since every atomic constraint of C is satisfied over w at position i if and only if the corresponding constraint in C 0 is  satisfied over w1 at position i â 1, and C and C 0 have otherwise identical structures in terms of Boolean combinations,  we get that w, i |= C ââ w1 , i â 1 |= C â â, which  entails the result since the simplification operation does not  change the validity of a constraint.  This enables us to express the effect of the first step in a  run on a formulaâs constraints. We can now come up with  an unfolding property similar to LTL. The intuitive idea is to  guess the subset Î â SC of formulas accounted for in constraint C which hold over the word at position 0, check that  this guess is correct and update C accordingly as described  in the previous lemma.  53  Next, if C 6â {>, âĽ}, it is easy to show that    V  W  ÎŚ âĄ ( ĎâSC ÂŹĎ)U ( ĎâSC Ď) â§ (Ď1 U[C] Ď2 )    V  W  âĄ ( ĎâSC ÂŹĎ)U ( ĎâSC Ď) â§ ÎŚ0 )  Proposition 2 (Unfolding). Let ÎŚ = Ď1 U[C] Ď2 and  Î¨=  W  ÎâSC  V  ĎâÎ  Ďâ§  V  ĎâSC \Î  ÂŹĎ    â§ Ď1 â§ X(Ď1 U[(CâÎ)â] Ď2 ) .  where ÎŚ0 is Î¨0 â¨ Ď2 if w, â1 |= C and Î¨0 otherwise, and  Î¨0 is identical to formula Î¨ in Prop. 2 above, omitting the  disjunct for Î = â. Now the top-most constraints C 0 occurring in Î¨0 are equal to (C â Î)â with some non-empty  Î, and thus Î¨0 @ ÎŚ. By induction hypothesis, Î¨0 can be  translated into LTL, which concludes the proof.  The following equivalence holds:  (  Î¨ â¨ Ď2  if w, â1 |= C,  ÎŚâĄ  Î¨  otherwise.  Proof. ÎŚ â Î¨/Î¨ â¨ Ď2 : If ÎŚ is satisfied over some word  w â (2AP )Ď , then by definition âi âĽ 0, wi |= Ď2 , w, iâ1 |=  C and â0 â¤ j < i, wj |= Ď.  If i = 0, i.e. w, â1 |= C and w |= Ď2 , then Î¨â¨Ď2 holds.  Otherwise (i > 0) it must be that w |= Ď1 and w, iâ1 |= C.  Let â be the set of formulas of SC which hold over w, by  Lemma 1 we have w1 , i â 2 |= (C â â) â. Furthermore  there  V existsVa disjunct in Î¨ (namely when Î = â) such that  ĎâÎ Ď â§ ĎâSC \Î ÂŹĎ holds. Finally, we can deduce from  all of the above that (w1 )iâ1 |= Ď2 , w1 , iâ2 |= (C â â)â  and â0 â¤ j < i â 1, (w1 )j |= Ď, in other words w1 |=  Ď1 U[(Cââ)â] Ď2 . Together with the above observations, this  implies that w |= Î¨.  However, this translation may yield an exponential increase in dag-size, since the number of distinct constraints  C 0 @ C is of the order of M m (with M the largest constant and m the number of atomic constraints occurring in  2  C), hence also in 2O(|ÎŚ| ) . We are as of yet not able to  show that this bound is tight, but there exist CLTL formulas  whose shortest equivalent LTL formula is provably of dagsize at least in O(M ).  Proposition 4 (Succinctness). Any LTL formula equivalent  to the CLTL formula ÎŚk = F(ÂŹbU[]a=k] >) has temporal  depth at least k â 1 (i.e. exponential in |ÎŚk |).  V Î¨ â ÎŚ:VLet w |= Î¨, there must exist Î such that w |=  ĎâÎ Ď â§  ĎâSC \Î ÂŹĎ â§ Ď1 â§ X(Ď1 U[(CâÎ)â] Ď2 ). From  this, we can deduce that (1) âi > 0, w, i + 1 |= Ď2 and  â0 â¤ j â¤ i, w, j |= Ď1 , (2) w1 , i |= (C â Î) â and (3)  Î = {Ď â SC | w |= Ď} which by Lemma 1 entails that  w, i + 1 |= C. Together with item (1) above, we get that  w |= ÎŚ.  Proof. Consider the set AP = {a, b, c}, and the property  S TAIRSk ([9]), which states that there exists a portion of  the path in which proposition a occurs at least k times but  proposition b does not occur. In [9], it is shown that this  property can only be expressed by a LTL formula with at  least k â 1 nested Until modalities. However, this formula  is equivalent to the CLTL formula ÎŚk .  Remark 2. Note that even a single unfolding step as described by the previous proposition may entail an exponential increase in the dag-size of the formula, since the set Î  needs to be guessed explicitly. This blow-up can be kept  polynomial by âscanningâ formulas in SC one at a time and  in a fixed order instead of considering all possible Î â SC .  This technique was used in [12] to study the translation of a  fragment of CCTL into CTL.  4. Decision procedures  We consider two standard decision problems for CLTL,  namely satisfiability (given ÎŚ â CLTL, does there exists a  model for ÎŚ?) and model checking (given ÎŚ â CLTL and  some KS S, do all runs of S satisfy ÎŚ, i.e. S |= ÎŚ? ).  Classical decision procedures for LTL satisfiability are  based on automata constructions. Given some LTL formula  ÎŚ, one can either build an (exponential) non-deterministic  BuĚchi automaton or a (polynomial) alternating BuĚchi automaton accepting exactly the models of ÎŚ. Satisfiability  then consists in checking whether the language of the automaton is empty [15]. We begin this section by recalling  the definition of alternating BuĚchi automata, then extend the  usual automata-based decision procedures for satisfiability  and model-checking to our logic CLTL.  Expressivity and succinctness. Similarly to the corresponding counting CTL logic [12], CLTL is not more expressive than classical LTL.  Proposition 3 (Expressivity). Any CLTL formula can be  translated into LTL.  Proof. We reason by induction on the structure of ÎŚ. The  case of Boolean connectives is trivial. We treat the case ÎŚ =  ĎU[C] Ď by induction on the well-founded partial ordering  @ defined in the previous section.  If ÎŚ is minimal for @ (i.e. C â {>, âĽ}), we can directly use the inductive LTL translations of Ď and Ď, since  ĎU[âĽ] Ď âĄ âĽ and ĎU[>] Ď âĄ ĎUĎ.  4.1. Alternating BuĚchi Automata over Ď -words  An alternating BuĚchi automaton on infinite words is a  tuple A = (ÎŁ, S, s0 , Î´, F ) where ÎŁ is a finite alphabet, S  54  The number of states is in O(|ÎŚ| Âˇ M m ) : every Ď1 U[C] Ď2  subformula may provide (M + 2)m states. Also note that  the transition formula Î¸ above can be expressed in a more  concise way using a more refined unfolding technique (Cf.  Rem. 2), at the cost of roughly duplicating |SC | times  the states corresponding to each U[C] -subformula. This automaton recognizes exactly the models of ÎŚ.  is a finite set of states, s0 â S is the initial state, Î´ : S Ă  ÎŁ â B + (S) is the transition function assigning a positive  Boolean formula over S (including âĽ and >) to every pair  (s, Ď), and F â S is the BuĚchi acceptance condition.  A run over an infinite word w = a0 a1 Âˇ Âˇ Âˇ â ÎŁĎ is an  infinite S-labeled tree T = (T, l) where T is a tree and  l : Nodes(T ) â S assigns an element in S to every node  in T . The root  of T has to be labeled by s0 (i.e. l() =  s0 ) and every node x at depth i (written |x| = i) has k  (k âĽ 0) children x1 ,. . . ,xk such that the formula Î´(l(x), ai )  is interpreted to true when one assigns > to every state in  {l(x1 ), . . . , l(xk )} and âĽ to other states.  The run is accepted when every infinite branch of T contains infinitely often nodes labeled by states in F and every  finite branch ends in a node x such that Î´(l(x), a|x| ) = >.  We use L(A) to denote the set of words accepted by A.  The complexity of this algorithm is in fact asymptotically optimal:  Theorem 6. CLTL satisfiability is EXPSPACE-complete.  Proof. Membership in EXPSPACE is based on Prop. 5:  2  the size of the automaton AÎŚ is in 2O(|ÎŚ| ) and checking  emptiness of an alternating BuĚchi automaton is PSPACEcomplete [5]. This provides an EXPSPACE algorithm.  First note that EXPSPACE-hardness is a consequence of  the complexity of TLTL (i.e. Timed LTL) over discrete time  domains [11]. Nevertheless we give a proof based on the  encoding in CLTL of the execution of a Turing Machine  running in exponential space over some input word (such  an encoding is classical, see for example [3]).  Consider a deterministic 2n -space-bounded Turing machine M = hÎŁ, QM , q0 , qF , RM i, with an initial tape content X = x1 . . . xn . We assume w.l.o.g. ÎŁ = {a, b}. q0  is the initial state and qF is the final state. And as usual  RM â QM Ă ÎŁ Ă ÎŁ Ă {â1, 1} Ă QM .  Now we construct a polynomial-size formula describing  the accepting computation of M on X. The set of atomic  propositions AP is defined as follows: AP contains Pa and  Pb to represent the corresponding symbol on the tape, an additional proposition Ps to separate two consecutive configurations, and propositions Pa,q and Pb,q for every q â QM  to mark the position of the tape head on a cell containing a  symbol a or b respectively.  A configuration of M is encoded as a sequence of 2n  states labeled with propositions in AP to represent the content of the cells. One of these cell is labeled with some Pa,q  or Pb,q , and the sequence is preceded and followed by a  state labeled with Ps .  V In the following we use the abbreviation Pâ to represent  P âAP ÂŹP . This formula is used to represent empty cells.  To specify that the run is the correct and accepting one,  we need a formula of the form (ÎŚi â§ ÎŚm ) â ÎŚa (where  i, m and a stand for init, move and accept respectively),  meaning that if the run starts with the initial configuration  and follows the transitions of M, then it is accepting. These  three formulas can be expressed in CLTL:  4.2. Satisfiability  By using the standard techniques for LTL, one obtains  the following results:  Proposition 5. Given a CLTL formula ÎŚ, one can build an  alternating BuĚchi automaton AÎŚ such that (1) |AÎŚ | is in  O(|ÎŚ| Âˇ M |ÎŚ| ) where M is the maximal constant occurring  in constraints inside ÎŚ, and (2) LĎ (AÎŚ ) is exactly the set  of runs satisfying ÎŚ.  Proof. Let ÎŚ be a CLTL formula. Let M be the maximal  constant occurring in the counting constraints  P in ÎŚ and m  the maximal number of atomic constraints i Îąi Âˇ ]Ďi âź k  occurring in the same constraint in ÎŚ. We define AÎŚ =  (ÎŁ, SÎŚ , s0 , Î´, F ), where ÎŁ is 2AP , SÎŚ is the set of all subformulas of ÎŚ (including those appearing in constraints),  Ď1 U[(Cââ)â] Ď2 for every subformula Ď1 U[C] Ď2 and â â  SC , and their negations, s0 is ÎŚ, Î´ : SÎŚ Ă ÎŁ â B + (SÎŚ ) is  the transition function defined below and F contains every  state in S of the form ÂŹ(Ď1 UĎ2 ) or ÂŹ(Ď1 U[C] Ď2 ).  In the following we use Î¸ to denote the negation normal  form of the formula Î¸ â B+ (SÎŚ ): every conjunction (resp.  disjunction) becomes a disjunction (resp. conjunction), >  (resp. âĽ) becomes âĽ (resp. >), and Î¸ is just Î¸. Negated  states are fine since Ď â SÎŚ â ÂŹĎ â SÎŚ .  For convenience, we define the transition function recursively. Occurrences of Î´(Ď, Ď) in right-hand sides should  be replaced by their definition until a formula in B + (SÎŚ ) is  obtained. We have Î´(P, Ď) = > if P â Ď and âĽ otherwise,  Î´(Ď â§ Ď, Ď) = Î´(Ď, Ď) â§ Î´(Ď, Ď), and Î´(ÂŹĎ, Ď) = Î´(Ď, Ď).  The rule for U is based on the unfolding rule (see Prop. 2):  Î´(Ď1 U[C] Ď2 , Ď) = Î´(Ď2 , Ď) â¨ Î¸ if Ď, â1 |= C and Î¸ otherwise, with  W  V  V  Î¸ = ÎâSC  ĎâÎ Î´(Ď, Ď) â§  ĎâSC \Î Î´(ÂŹĎ, Ď)    â§ Î´(Ď1 , Ď) â§ (Ď1 U[(CâÎ)â] Ď2 ) .  ÎŚi = Ps â§ X(Px1 ,q0 â§  V  2â¤kâ¤n  F[]>=k] Pxk  â§ F[]>=n+1] (Pâ U[]>=2n ân] Ps )  55    ÎŚm = G Ps â X(ÂŹPs )U[]>=2n ] Ps  V  â§ (P1 ,P2 ,P3 )âAP3 G (P1 â§ XP2 â§ XXP3 )    â F[]>=2n +2] fM (P1 , P2 , P3 )  4.4. A PSPACE fragment of CLTL  The EXPSPACE-hardness proof of CLTL satisfiability  only uses counting constraints of the form â]> = kâ: there  is no need for nested formulas in constraints, no Boolean  combinations and no sums. Here we introduce the fragment  CLTLâ defined as the set of CLTL formulas where counting constraints are purely conjunctive terms, and comparison symbols are not mixed inside aVconstraint.  In other  P  terms,  constraints  are  of  the  form  â  Îą  Âˇ  ]Ď  i < kâ,  i i  VP  â  Îą  Âˇ  ]Ď  >  kâ  or  their  non-strict  variants.  Note  that  i  i i  this restriction also applies over subformulas in constraints.  We use Ď1 U[Câş] Ď2 (resp. Ď1 U[C] Ď2 ) to denote an Until-subformula tagged with a constraint of the form âless  thanâ i.e. with â¤ or < (resp. âgreater thanâ with âĽ or >).  In the following theorem, we claim that CLTLâ formulas  admit PSPACE decision procedures:  ÎŚa = F(Pa,qF â¨ Pb,qF ),  where the function fM (P1 , P2 , P3 ) refers to the transition  rules of M: fM (P1 , P2 , P3 ) gives the value of the cell  containing P2 in the next configuration given the definition of the left cell (P1 ) and the right cell (P3 ). For instance, for every rule (q, a, b, +1, q 0 ) in RM we will have:  fM (P1 , Pa,q , P2 ) = Pb for any P1 â AP and any P2 6= Ps .  Moreover we have for any P1 â AP, the two values:  fM (Pa,q , Pa , P1 ) = Pa,q0 and fM (Pa,q , Pb , P1 ) = Pb,q0 .  And we also define fM (P1 , P2 , P3 ) = P2 if neither P1 or  P3 are of the form Pa,q or Pb,q for some q.  The lengths of formulas ÎŚi , ÎŚm and ÎŚa are polynomial,  since constants are encoded in binary, which implies the  EXPSPACE-hardness of CLTL satisfiability.  Theorem 7. The satisfiability and model-checking problems for CLTLâ are PSPACE-complete.  Note that if constraints are atomic (i.e. without Boolean  combinations in subscripts), then m is equal to 1 and the  size of AÎŚ is in O(|ÎŚ| Âˇ M ). If in addition, constants are  assumed to be encoded in unary, the satisfiability algorithm  becomes PSPACE.  Proof. PSPACE-hardness comes from LTL satisfiability.  PSPACE membership is based on the fact that given a  CLTLâ formula ÎŚ and AÎŚ the corresponding automaton  as built in Proposition 5, for any accepting run over some  model w of ÎŚ, there exists a âsmallâ accepting run over w.  By small, we mean a tree with a width (i.e. the maximal  number of nodes at the same level) bounded by |ÎŚ|.  Let ÎŚ be a CLTLâ formula. First we can assume that  ÎŚ only contains atomic constraints (with no conjunction):  indeed every CLTLâ formula Ď1 U[Câ§C 0 ] Ď2 is equivalent to  Ď1 U[C] Ď2 â§ Ď1 U[C 0 ] Ď2 . This translation can be done efficiently and the dag-size of the resulting formula is linear  in the size of the original one. Let Subf(ÎŚ) be the set of  subformulas of ÎŚ.  Now consider AÎŚ as defined in Proposition 5. The number of states of AÎŚ is in O(|ÎŚ| Âˇ M ) where M is the size  of the maximal constant occurring in ÎŚ. Thus this number  is exponential in |ÎŚ| (this blow-up is due to the rewriting  of Ď1 U[C] Ď2 subformulas into Ď1 U[CâÎ] Ď2 subformulas in  the function Î´).  Now consider an accepting run T = (T, l) of AÎŚ over  an infinite word w that is a model of ÎŚ. At every level i  of the tree T , the nodes {x1 , . . . , xk } are labeled with the  set of formulas {l(x1 ), . . . , l(xk )} â SÎŚ (see the definition  of SÎŚ in Prop. 5) and every formula l(xj ) holds over the  word wi . For every Ď â Subf(ÎŚ) of the form Ď1 U[C] Ď2 ,  it is possible to have several formulas Ď1 U[CâÎ] Ď2 for different subsets Î of SC . But we clearly only need to verify  one formula of this set: if Ď is a âless thanâ (resp. a âgreater  thanâ) formula, we consider the one containing the minimal (resp. maximal) constant k in the constraint. Indeed we  clearly have Ď1 U[C<k] Ď2 â Ď1 U[C<k0 ] Ď2 for any k â¤ k 0  and Ď1 U[C>k] Ď2 â Ď1 U[C>k0 ] Ď2 for any k âĽ k 0 .  4.3. Model-checking  Corollary 1. The model-checking problem for CLTL is  EXPSPACE-complete.  Proof. Hardness for EXPSPACE comes from that of satisfiability, which can be reduced to a model-checking problem  using some kind of universal Kripke structure Su able to  generate any possible word in (2AP )Ď : ÎŚ is satisfiable iff  Su 6|= ÂŹÎŚ. Let AP be {P1 , . . . , Pn }. Instead of considering  a complete KS whose states are labeled with every possible  subset of AP (which would yield an exponential structure),  we use a succinct KS Su0 that encodes every valuation of a  state in Su as a sequence of n states labeled respectively by  â or Pi . . . It then remains to sligthtly modify ÎŚ to take into  account this encoding. Let ÎŚ0 be the modified formula, we  can reduce Su |= ÎŚ to Su0 |= ÎŚ0 .  Membership in EXPSPACE is obtained following the  idea for classical LTL model-checking. Given a Kripke  Structure S and a CLTL formula ÎŚ, one builds as previously  an alternating BuĚchi automaton A for the formula ÂŹÎŚ. It is  then straightforward to compute the product of A with the  structure S in such a way that the obtained automaton has  an accepting infinite run if and only if there exists a path in  S violating ÎŚ.  Note that the program complexity of model-checking for  CLTL (i.e. the complexity of model-checking a fixed formula) is (like for LTL) NL-complete [16].  56  by replacing the constraint language C with the language  C 0 of constraints of the form ]Ď1 â ]Ď2 âź k (i.e. with no  Boolean combination), which we call diagonal constraints.  It turns out that, unlike CCTL where model-checking remains polynomial for this restricted case, this constraint  language yields undecidability in the case of CLTL.  Then at every level of the tree, we only need to keep one  formula among this subset of formulas {Ď1 U[CâÎ] Ď2 | Î â  SC }. Thus we can ensure the number of formulas labeling states at some level to be bounded by |ÎŚ|. This remark  leads to an NSPACE algorithm for satisfiability (and model  checking). It works as follows.  Let Si be the set of SÎŚ formulas labeling states of level  i: we have |Si | â¤ |ÎŚ| and this set can be encoded in polynomial space (w.r.t. |ÎŚ|). Now the procedure guesses nondeterministically a letter wi and a subset Si+1 and verifies  that it may correspond to the level i + 1. For this, the algorithm has to check Si+1 |= Î´(Ď, wi ) for every Ď â Si :  this is done again with a non-deterministic choice of subsets  Î in the function Î´ and by interpreting Ď1 U[Câş] Ď2 (resp.  Ď1 U[C] Ď2 ) as true if there is some formula Ď1 U[CâÎ] Ď2  in Si+1 (resp. Ď1 U[C 0 ] Ď2 in Si+1 with C = C 0 â Î).  Moreover as usual for this kind of algorithms, the procedure will guess non-deterministically that some level ` is  the first state of a cycle and will verify that there is a future  level labeled with the same set of formulas S` : to do this we  simply need to memorize S` .  Finally we need to verify that the acceptance condition  is satisfied by the final cycle from level `. This is done  by checking that every formula Ď1 U[C] Ď2 â S` is satisfied  somewhere along the cycle (there must be no branch along  which the label Ď1 U[C] Ď2 ultimately appears forever). For  this, we need to store (and update) the Until-subformulas  that have not yet been satisfied along the cycle, and mark  each of them as soon as the corresponding Ď2 holds, which  can be done step by step by analyzing the function Î´. Once  the set of formulas S` is repeated, we need to have succesfully asserted this fact for every formula (or one of its descendants with constraint C âÎ). Note that every Ď1 U[C] Ď2  that does not occur at level ` but appears inside the cycle  will be either satisfied before the next occurrence of S` , or  will yield a subformula Ď1 U[C 0 ] Ď2 in S` and then will be  treated as in the previous case.  This yields an NSPACE procedure and by Savitchâs theorem one can deduce the existence of a PSPACE algorithm.  The model-checking algorithm is based on the same technique for analyzing the alternating automaton.  Theorem 8. The model-checking and satisfiability problems for CLTL with atomic diagonal constraints are undecidable.  Proof. This is done by reduction from the halting problem  of a two-counter machine M with counters C and D, and  n instructions I1 , . . . , In . Each Ii is either a decrement  hif X=0 then j else X--, ki where X stands for  C or D, an increment hX++, ji, or the halting instruction  hhalti. We define a Kripke structure SM = (Q, R, `),  where Q = {q1 , . . . , qn } âŞ {ri , ti | Ii = hif ...i}. The  transition relation is defined as follows:  â˘ if Ii = hX++, ji, then (qi , qj ) â R ; and  â˘ if Ii = hif X=0 then j else X--,ki, then  (qi , ri ), (ri , qk ), (qi , ti ) and (ti , qj ) in R.  The labeling ` is defined over the set {halt, C + , C â , C 0 ,  D+ , Dâ , D0 } as `(qi ) = {X + } if Ii is an increment of X,  `(ri ) = {X â } and `(ti ) = {X 0 } if Ii is a decrement for  X, and `(qi ) = {halt} if Ii is the halting instruction.  A run going through ti for some i will simulate the positive test âX = 0â: we use the proposition X 0 to observe  this fact. Indeed along any run in SM , a state satisfies X 0  if and only if that state is some ti state, which witnesses the  fact that the counterâs value was deemed equal to zero. The  propositions on the other states are self-explanatory, witnessing increments and decrements of counters.  Checking CLTL with atomic diagonal constraints on this  structure solves the halting problem, since M halts if and  only if SM |= ÎŚ with:  ÎŚ = F[(]haltâĽ1)] >    W  â¨ Xâ{C,D} F[(]X + â]X â <0)] > â¨ F[(]X + â]X â >0)] X 0  The formula ÎŚ is satisfied by a run because either SM halts,  or the run does not simulate correctly M because the number of decrements is at some point larger than the number  of increments, or because some counter was incorrectly assumed to be zero while simulating a test. Thus, if ÎŚ is true  for every run, it is in particular the case of the path simulating the behavior of M.  This result is another illustration of the potential complexity cost of equality in quantitative constraints as in the  timed case [1].  5. Extension with diagonal constraints  In [12], we presented several decidable fragments of  CCTL in which atomic constraints with subtraction were  allowed. In this section, we show that even a simple extension of LTL with such constraints leads to undecidability.  More formally, we consider the logic obtained from CLTL  6. CCTLâ  Using similar modalities in a branching framework, one  can define a counting extension of the logic CTLâ .  57  Definition 4. Let AP be a set of atomic propositions, we  distinguish:  we are working on different (cumulative) semantics for constraints, which evaluate counting expressions over the full  history of runs.  CCTLâ 3 Ďs , Ďs ::= P | Ďs â§ Ďs | ÂŹĎs | EĎp  CCTLâp 3 Ďp , Ďp ::= Ďs | Ďp â§ Ďp | ÂŹĎp | Ďp U[C] Ďp  References  where C denotes a counting constraint as in Def. 2 with  subformulas in CCTLâ âŞ CCTLâp .  [1] R. Alur, T. Feder, and T. A. Henzinger. The benefits of relaxing punctuality. J. ACM, 43(1):116â146, 1996.  [2] R. Alur and T. A. Henzinger. Logics and models of real  time: A survey. In Proc. REX Workshop, volume 600 of  LNCS, pages 74â106. Springer, 1992.  [3] R. Alur and T. A. Henzinger. A really temporal logic.  J. ACM, 41(1):181â203, 1994.  [4] D. Bustan, D. Fisman, and J. Havlicek. Automata construction for psl. Technical report, The Weizmann Institute of  Science, 2005. Available as Tech. Report MCS05- 04.  [5] A. K. Chandra, D. C. Kozen, and L. J. Stockmeyer. Alternation. J. ACM, 28(1):114â133, 1981.  [6] E. A. Emerson. Temporal and modal logic. In Handbook of  Theoretical Computer Science, volume B, chapter 16, pages  995â1072. Elsevier Science, 1990.  [7] E. A. Emerson, A. K. Mok, A. P. Sistla, and J. Srinivasan. Quantitative temporal reasoning. Real-Time Systems,  4(4):331â352, 1992.  [8] E. A. Emerson and R. J. Trefler. Generalized quantitative  temporal reasoning: An automata-theoretic approach. In  Proc. 7th TAPSOFT, volume 1214 of LNCS, pages 189â200.  Springer, 1997.  [9] K. Etessami and T. Wilke. An until hierarchy and other  applications of an Ehrenfeucht-FraÄąĚsseĚ game for temporal  logic. Inf. Comput., 160(1-2):88â108, 2000.  [10] H. Hansson and B. Jonsson. A logic for reasoning about  time and reliability. Formal Asp. Comput., 6(5):512â535,  1994.  [11] F. Laroussinie, N. Markey, and Ph. Schnoebelen. Efficient  timed model checking for discrete-time systems. Theor.  Comput. Sci., 353(1-3):249â271, 2006.  [12] F. Laroussinie, A. Meyer, and E. Petonnet. Counting CTL.  In Proc. 13th FoSSaCS, volume 6014 of LNCS, pages 206â  220. Springer, 2010.  [13] A. Pnueli. The temporal logic of programs. In Proc. 18th  FOCS, pages 46â57. IEEE Comp. Soc. Press, 1977.  [14] Property Specification Language Reference Manual, Version 1.1, 2003. http://www.eda-stds.org/vfv/  docs/PSL-v1.1.pdf.  [15] M. Y. Vardi. An automata-theoretic approach to linear temporal logic. In Logics for Concurrency: Structure Versus  Automata, volume 1043 of LNCS, pages 238â266. Springer,  1996.  [16] M. Y. Vardi and P. Wolper. An automata-theoretic approach  to automatic program verification. In Proc. 1st LICS, pages  332â344. IEEE Comp. Soc. Press, 1986.  [17] P. Wolper. Temporal logic can be more expressive. Inf. and  Control, 56(1/2):72â99, 1983.  The semantics of CCTLâ formulas is defined over states  of Kripke structures as follows:  Definition 5. The following clauses (Boolean cases are  omitted) define the conditions for a state q (resp. a run Ď) of  some KS S = hQ, qinit , R, `i to satisfy a CCTLâ formula Ďs  (resp. a CCTLâp formula Ďp ) by induction over the structure  of Ďs (resp. Ďp ):  q |=S P  iff P â `(q)  q |=S EĎp  iff âĎ â Runs(q), Ď |=S Ďp  Ď |=S Ďs  iff Ď(0) |=S Ďs  Ď |=S ĎU[C] Ď  iff âi âĽ 0, Ďi |=S Ď, Ď, iâ1 |=S C  and â0 â¤ j < i, Ďj |=S Ď  We use A to denote the dual of E. The model-checking  problem consists in deciding whether a given CCTLâ formula holds for a given state in a KS S.  Theorem 9. The model-checking problem for CCTLâ is  EXPSPACE-complete.  Proof. EXPSPACE-hardness comes from the corresponding problems for CLTL. EXPSPACE membership is obtained thanks to the EXPSPACE procedure for CLTL formulas. One can design a polynomial-time algorithm that  calls an oracle for CLTL subformulas, which provides a  PEXPSPACE procedure (hence also in EXPSPACE).  7. Conclusion  We have proposed new extensions for LTL and CTLâ  which, together with our related results for CTL [12], provide a general overview of expressivity and complexity for  a natural class of quantitative temporal logics.  There are several possible continuations to this work,  some of which we are currently exploring. It would be interesting to evaluate the succinctness and algorithmic properties of the unary fragment of CLTL (i.e. CLTL with unaryencoded constants), for which we believe better algorithms  may exist despite the fact that it is not clear how to avoid an  exponential blow-up in the dag-size of the LTL translation.  It would also be natural to consider the addition of past  modalities, which bring exponential succinctness improvements to LTL with no significant complexity cost. Finally,  58 