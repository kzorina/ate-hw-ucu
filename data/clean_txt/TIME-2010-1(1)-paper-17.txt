2010 17th International Symposium on Temporal Representation and Reasoning  Counting LTL  FrancÄšÂ§ois Laroussinie1  Antoine Meyer2  1  Eudes Petonnet  1  LIAFA, UniversiteÄšÂ Paris Diderot Ã¢Â€Â“ Paris 7 & CNRS UMR 7089, France  {Francois.Laroussinie,Eudes.Petonnet}@liafa.jussieu.fr  2  LIGM, UniversiteÄšÂ Paris Est Ã¢Â€Â“ Marne-la-ValleÄšÂe & CNRS UMR 8049, France  Antoine.Meyer@univ-mlv.fr  Abstract  defined with grammars as in [17].  In this paper, we present a counting extension of LTL  in the line of [12], called CLTL, where Until modalities  are equipped with constraints on the number of true occurrences of certain subformulas. For instance, in a mutual exclusion protocol where two processes try to access the same    critical section, the formula G req1 Ã¢Â‡Â’ F[]cs2 Ã¢Â‰Â¤5] cs1 ) expresses the fact that whenever process 1 requests access to  the critical section it is eventually granted access, and until  then process 2 can be granted access at most 5 times. More  generally, we allow constraints to be arbitrary  PBoolean combinations of atomic statements of the form i ÃÄ…i Ã‚Ë‡ ]ÄÂ•i Ã¢ÂˆÅº c,  where c and each ÃÄ…i are positive integers, Ã¢ÂˆÅº is a comparison operator and each ]ÄÂ•i represents the number of states  from which some arbitrary CLTL formula ÄÂ•i holds along a  certain prefix of the run.  We show that, even though CLTL formulas can be translated into LTL, this might yield an exponential blow-up  in formula size. We then turn to the satisfiability and  model-checking problems for CLTL, for which we provide  automata-based algorithms running in exponential space.  This complexity is asymptotically optimal, since both problems turn out to be EXPSPACE-complete. We conclude this  algorithmic study by presenting a fragment of CLTL whose  satisfiability and model-checking problems are PSPACEcomplete, and show that any generalization of constraints  with subtraction makes both problems undecidable. Finally,  we show that for a similar counting extension of CTLÃ¢ÂˆÂ— , the  model-checking problem remains solvable in EXPSPACE.  This paper presents a quantitative extension for the  linear-time temporal logic LTL allowing to specify the number of states satisfying certain sub-formulas along paths.  We give decision procedures for the satisfiability and model  checking of this new temporal logic and study the complexity of the corresponding problems. Furthermore we show  that the problems become undecidable when more expressive constraints are considered.  1. Introduction  Temporal logic (TL) is a well-known and well-studied formalism for specifying and verifying properties of automated  systems [13]. Classical temporal logics, such as LTL or  CTL, express properties on the temporal ordering of events  along the executions (see [6] for a survey). Many extensions  of these formalisms have been studied, whose aim is usually  to improve expressivity in order to capture more complex  specifications, or to make properties shorter and easier to  write. Of course there is an important trade-off between the  expressivity of the logic and the efficiency of decision procedures, the ultimate goal being to algorithmically decide  satisfiability or model-checking problems.  Among the well-known extensions of classical temporal logics, we can mention real-time TLs (see for example [2, 3, 7]) where it is possible to add timing constraints in  properties (for example, one can specify that an event A follows an event B in at most 5 time units) or probabilistic TLs  (see [10] for such an extension of CTL) where it is possible  to express properties like Ã¢Â€Âœevent A will occur with probability 0.99 or greaterÃ¢Â€Â. These two extensions are called  quantitative extensions. Another classical variant consists  in adding some form of regular expressions [8] or operators  1530-1311/10 $26.00 Ã‚Å  2010 IEEE  DOI 10.1109/TIME.2010.20  This work is related to our previous effort on counting  extensions of CTL [12], where we use the same counting  constraints as described above. By varying the allowed syntax of constraints, we presented a thorough account of the  expressiveness and succinctness of the logic with respect  to CTL, and proposed an algorithmic study of the modelchecking problem, which ranges from P-complete when  51  only atomic constraints are considered to Ã¢ÂˆÂ†P2 -complete for  the full logic. Contrary to CLTL, we also managed to characterize decidable fragments with subtractive constraints.  There exist several other works on extensions of LTL  to handle quantitative aspects of systems. In [8], the  authors extend linear-time logic with some simple regular expressions along with quantitative constraints on the  number of occurrences of sub-expressions. They present  model-checking algorithms (satisfiability is not considered)  whose time complexity is exponential in the size of formulas and the value of integer constants (and thus doublyexponential), which is comparable to the complexity we obtain for CLTL. In terms of expressiveness, our logic can easily be used to express complicated quantitative constraints,  but is less well-suited to specifying the order of events. Another interesting specification language is Sugar/PSL [14],  which defines many additional operators above LTL. These  include in particular some counting constraints which are  used together with regular expressions, subsuming CLTL  with atomic constraints. To our knowledge, there is no accurate study of lower complexity bounds for these extensions [4].  Counting LTL. We define a quantitative extension of LTL  able to express constraints over the number of times certain  sub-formulas are satisfied along a run:  Definition 2. Given a set of atomic propositions AP, we  define:  CLTL 3 ÄÂ•, ÄÂˆ ::= P | ÄÂ• Ã¢ÂˆÂ§ ÄÂˆ | Ã‚Å¹ÄÂ• | ÄÂ•U[C] ÄÂˆ  where P Ã¢ÂˆÂˆ AP and C is a counting constraint defined as:  P  C 3 C, C 0 ::= > | C Ã¢ÂˆÂ§ C 0 | Ã‚Å¹C |  i ÃÄ…i Ã‚Ë‡ ]ÄÂˆi Ã¢ÂˆÅº k  where k, ÃÄ…i Ã¢ÂˆÂˆ NÃ¢ÂˆÂ— , Ã¢ÂˆÅºÃ¢ÂˆÂˆ {<, Ã¢Â‰Â¤, =, Ã¢Â‰Ä½, >} and ÄÂˆi Ã¢ÂˆÂˆ CLTL.  In CLTL formulas, we make use of the standard abbreviations Ã¢ÂˆÂ¨, Ã¢Â‡Â’, Ã¢Â‡Â”, Ã¢ÂŠÄ½, >, as well as the additional modality  def  def  F[C] ÄÂ• = >U[C] ÄÂ•, and its dual G[C] ÄÂ• = Ã‚Å¹F[C] Ã‚Å¹ÄÂ•. Moreover the classical Next operator X is defined as F[]>=1] , the  standard Until U is U[>] (F is F[>] and G is G[>] ). Any formula occurring in a constraint C associated with a modality  in ÃÅš is considered as a sub-formula of ÃÅš. The size |ÃÅš| of  ÃÅš takes the size of these constraints and their sub-formulas  into account, assuming that integer constants are encoded  in binary (unless explicitly stated otherwise). The DAGsize of ÃÅš is the total number of distinct sub-formulas of ÃÅš.  As model-checking algorithms compute only once the truth  value of a sub-formula, this is generally more relevant to the  complexity of model-checking.  The semantics of CLTL formulas is defined over infinite  words in (2AP )ÄÂ‰ :  The paper is organized as follows. Section 2 defines the  logic CLTL, whose expressivity and succinctness are studied in Section 3. Section 4 presents an EXPSPACE satisfiability algorithm based on alternating BuÄšÂˆchi automata, as  well as the EXPSPACE-hardness proof and a PSPACE algorithm for a fragment of CLTL. Section 5 deals with an  undecidable extension of the constraint language. Finally  Section 6 presents a counting extension of CTLÃ¢ÂˆÂ— .  Definition 3. The following clauses define the conditions  for an infinite word w Ã¢ÂˆÂˆ (2AP )ÄÂ‰ to satisfy a CLTL formula  ÄÂ• Ã¢Â€Â“ written w |= ÄÂ• Ã¢Â€Â“ by induction over the structure of ÄÂ•:  2. Definitions  Models. Let AP be a set of atomic propositions. In lineartime temporal logics, formulas are interpreted over infinite  words in (2AP )ÄÂ‰ . Given such a word w, wi denotes the i-th  letter and wi is the i-th non-empty suffix of w with i Ã¢Â‰Ä½ 0.  As we will be considering the model-checking problem, we  also recall the classical notion of Kripke structure:  w |= P  iff P Ã¢ÂˆÂˆ w0  w |= ÄÂ• Ã¢ÂˆÂ§ ÄÂˆ  iff w |= ÄÂ• and w |= ÄÂˆ  w |= Ã‚Å¹ÄÂˆ  iff w 6|= ÄÂˆ  w |= ÄÂ•U[C] ÄÂˆ  iff Ã¢ÂˆÂƒi Ã¢Â‰Ä½ 0, wi |= ÄÂˆ, w, iÃ¢ÂˆÂ’1 |= C  and Ã¢ÂˆÂ€0 Ã¢Â‰Â¤ j < i, wj |= ÄÂ•  Definition 1. A Kripke structure (or KS) S is a tuple  hQ, qinit , R, `i where Q is a finite set of states, qinit Ã¢ÂˆÂˆ Q  is the initial state, R Ã¢ÂŠÂ† Q Ä‚Â— Q is a total accessibility relation and ` : Q Ã¢Â†Â’ 2AP is a labeling of states with atomic  propositions.  The semantics of w, i |= C is based on the interpretation of  ]ÄÂ• over the suffixes wj for 0 Ã¢Â‰Â¤ j Ã¢Â‰Â¤ i, denoted by |w, i|ÄÂ•  def  and defined as: |w, i|ÄÂ• = |{j | 0 Ã¢Â‰Â¤ j Ã¢Â‰Â¤ i Ã¢ÂˆÂ§ wj |= ÄÂ•}|.  Given these values, C is interpreted in a natural way (and >  is true over every word).  A run (or path) ÄÂ of S is an infinite sequence of states  q0 q1 q2 . . . such that (qi , qi+1 ) Ã¢ÂˆÂˆ R for every i. We use ÄÂ(i)  to denote the state qi and ÄÂi to denote the suffix qi Ã‚Ë‡ qi+1 Ã‚Ë‡ Ã‚Ë‡ Ã‚Ë‡  of ÄÂ. Runs(q) denotes the set of runs starting from some  state q Ã¢ÂˆÂˆ Q and Runs(S) stands for Runs(qinit ).  In the following, we will be referring to both infinite  words in (2AP )ÄÂ‰ and paths of some KS as runs.  Given a KS S = hQ, qinit , R, `i, we write S |= ÃÅš when  every execution ÄÂ Ã¢ÂˆÂˆ Runs(S) satisfies ÃÅš (i.e. `(ÄÂ(0)) Ã‚Ë‡  `(ÄÂ(1)) Ã‚Ë‡ Ã‚Ë‡ Ã‚Ë‡ |= ÃÅš). We use Ã¢Â‰Ä„ to denote the standard equivalence between formulas.  Remark 1. Let us denote by C the constraint dual to C obtained by propagating the negation operator in Ã‚Å¹C towards  52  (ÄÂ•U[C 0 ] ÄÂˆ v ÄÂ•U[C] ÄÂˆ if C 0 v C). It can be shown that @ is  a well-founded strict partial ordering over CLTL formulas.  atomic constraints (using De MorganÃ¢Â€Â™s laws and inverting  comparison operators as required).  Negation and disjunction operators can be eliminated  from constraints using the fact that ÄÂ•U[Ã‚Å¹C] ÄÂˆ Ã¢Â‰Ä„ ÄÂ•U[C] ÄÂˆ  and ÄÂ•U[CÃ¢ÂˆÂ¨C 0 ] ÄÂˆ Ã¢Â‰Ä„ ÄÂ•U[C] ÄÂˆ Ã¢ÂˆÂ¨ ÄÂ•U[C 0 ] ÄÂˆ. However, even  though ÄÂ•U[CÃ¢ÂˆÂ§C 0 ] ÄÂˆ Ã¢Â‡Â’ ÄÂ•U[C] ÄÂˆ Ã¢ÂˆÂ§ ÄÂ•U[C 0 ] ÄÂˆ, the converse  does not hold, as can be seen on the simple example  F[]P1 =1Ã¢ÂˆÂ§]P2 =1] > (indeed this formula requires that at some  point both P1 and P2 must have been seen exactly once,  while F[]P1 =1] > Ã¢ÂˆÂ§ F[]P2 =1] > does not: for instance P1 may  occur twice before P2 first occurs).  This implies that any CLTL formula can be translated  into an  Vequivalent formula where all constraints are of the  form i ÃÄ…i Ã‚Ë‡ ]ÄÂ•i Ã¢ÂˆÅº k. However, this may yield an exponentially longer formula, since it essentially requires constraints to be put into disjunctive normal form.  3. Expressivity  Unfolding. In classical LTL, a crucial observation is that  formula ÄÂ•1 UÄÂ•2 can be Ã¢Â€ÂœunfoldedÃ¢Â€Â by distinguishing the  possible cases in the first state of a run, yielding the following equivalence:      ÄÂ•1 UÄÂ•2 Ã¢Â‰Ä„ ÄÂ•2 Ã¢ÂˆÂ¨ ÄÂ•1 Ã¢ÂˆÂ§ X(ÄÂ•1 UÄÂ•2 )  In order to obtain a similar equivalence for a formula  ÄÂ•1 U[C] ÄÂ•2 in counting LTL we need to take into account  all the counting expressions occurring in C, and to update  the relevant atomic constraints accordingly. To this end we  make use of the two elementary update operations on constraints defined in the previous section.  Manipulating constraints. We now define two operations on constraints, which will play an important technical  role in the remainder of the paper.  Let C be a counting constraint  P containing m atomic constraints (m > 0) of the form jÃ¢ÂˆÂˆ[1,ni ] ÃÄ…ji Ã‚Ë‡ ]ÄÂ•ij Ã¢ÂˆÅº ki for  i Ã¢ÂˆÂˆ [1, m]. We define SC as the set {ÄÂ•ij | i Ã¢ÂˆÂˆ [1, m], j Ã¢ÂˆÂˆ  [1, ni ]}. For any Ã¢ÂˆÂ† Ã¢ÂŠÂ† SC , we inductively define the subtractive update C Ã¢ÂˆÂ’ Ã¢ÂˆÂ† of C by Ã¢ÂˆÂ† by:  Lemma 1. For all word w in (2AP )ÄÂ‰ and index i Ã¢Â‰Ä½ 0,  w, i |= C Ã¢Â‡ÂÃ¢Â‡Â’ w1 , i Ã¢ÂˆÂ’ 1 |= (C Ã¢ÂˆÂ’ Ã¢ÂˆÂ†) Ã¢Â†Â“, where  Ã¢ÂˆÂ† = {ÄÂ• Ã¢ÂˆÂˆ SC | w |= ÄÂ•}.  P  Proof.  any atomic  P Let i ÃÄ…i . ]ÄÂ•0 i Ã¢ÂˆÅº k be  P constraint in C,  and i ÃÄ…i . ]ÄÂ•i Ã¢ÂˆÅº k with k 0 = k Ã¢ÂˆÂ’ ÄÂ•j Ã¢ÂˆÂˆÃ¢ÂˆÂ† ÃÄ…j the corresponding constraint in C 0 = C Ã¢ÂˆÂ’ Ã¢ÂˆÂ†. By definition of Ã¢ÂˆÂ†, for  every ÄÂ• Ã¢ÂˆÂˆ Ã¢ÂˆÂ† we have  def  Ã‚Å¹C Ã¢ÂˆÂ’ Ã¢ÂˆÂ† = Ã‚Å¹(C Ã¢ÂˆÂ’ Ã¢ÂˆÂ†)  |w, i|ÄÂ• = |{j | 0 Ã¢Â‰Â¤ j Ã¢Â‰Â¤ i Ã¢ÂˆÂ§ wj |= ÄÂ•}|  (C Ã¢ÂˆÂ§ C 0 ) Ã¢ÂˆÂ’ Ã¢ÂˆÂ† = (C Ã¢ÂˆÂ’ Ã¢ÂˆÂ†) Ã¢ÂˆÂ§ (C 0 Ã¢ÂˆÂ’ Ã¢ÂˆÂ†)  P  def P  ( i ÃÄ…i Ã‚Ë‡ ]ÄÂ•i Ã¢ÂˆÅº k) Ã¢ÂˆÂ’ Ã¢ÂˆÂ† = i ÃÄ…i Ã‚Ë‡ ]ÄÂ•i Ã¢ÂˆÅº k 0  P  def  with k 0 = k Ã¢ÂˆÂ’ ÄÂ•j Ã¢ÂˆÂˆÃ¢ÂˆÂ† ÃÄ…j .  def  = 1 + |{j | 0 < j Ã¢Â‰Â¤ i Ã¢ÂˆÂ§ wj |= ÄÂ•}|  = 1 + |{j | 0 Ã¢Â‰Â¤ j Ã¢Â‰Â¤ iÃ¢ÂˆÂ’1 Ã¢ÂˆÂ§ w1+j |= ÄÂ•}|  = 1 + |w1 , iÃ¢ÂˆÂ’1|ÄÂ• .  Notice that even though constants in C are defined to be  positive integers, C Ã¢ÂˆÂ’ Ã¢ÂˆÂ† may contain negative constants  as right-hand sides of comparison operators. However, it  can easily be seen that atomic constraints where negative  constants (or possibly 0) occur are either trivially true or  trivially false. We thus define a second update operation,  called simplification.  We define the constraint CÃ¢Â†Â“ obtained from C by replacing any (trivially true) atomic constraint of the form S > k  with k < 0 or S Ã¢Â‰Ä½ k with k Ã¢Â‰Â¤ 0 by > (where S stands  for an arbitrary sum of counting expressions), and any (trivially false) atomic constraint of the form S < k with k Ã¢Â‰Â¤ 0  or S Ã¢Â‰Â¤ k with k < 0 by Ã¢ÂŠÄ½, and simplifying the obtained  constraint in the usual way (as one would simplify a propositional logic formula). Note that CÃ¢Â†Â“ is either reduced to >  or Ã¢ÂŠÄ½, or does not contain > or Ã¢ÂŠÄ½ as a sub-formula. Also  note that C and CÃ¢Â†Â“ are equivalent.  We will write C 0 v C whenever there exists a set Ã¢ÂˆÂ† Ã¢ÂŠÂ†  SC such that C 0 = (C Ã¢ÂˆÂ’ Ã¢ÂˆÂ†) Ã¢Â†Â“, and C 0 @ C if Ã¢ÂˆÂ† 6= Ã¢ÂˆÂ….  This notation is extended to CLTL formulas in a natural way  Similarly for every ÄÂ• 6Ã¢ÂˆÂˆ Ã¢ÂˆÂ†, |w, i|ÄÂ• = |w1 , iÃ¢ÂˆÂ’1|ÄÂ• . Thus  P  P  P  k Ã¢ÂˆÂ’ i ÃÄ…i .|w, i|ÄÂ• = k Ã¢ÂˆÂ’ ÄÂ•j Ã¢ÂˆÂˆÃ¢ÂˆÂ† ÃÄ…j Ã¢ÂˆÂ’ i ÃÄ…i .|w1 , iÃ¢ÂˆÂ’1|ÄÂ•i  P  = k 0 Ã¢ÂˆÂ’ i ÃÄ…i .|w1 , iÃ¢ÂˆÂ’1|ÄÂ•i .  Since every atomic constraint of C is satisfied over w at position i if and only if the corresponding constraint in C 0 is  satisfied over w1 at position i Ã¢ÂˆÂ’ 1, and C and C 0 have otherwise identical structures in terms of Boolean combinations,  we get that w, i |= C Ã¢Â‡ÂÃ¢Â‡Â’ w1 , i Ã¢ÂˆÂ’ 1 |= C Ã¢ÂˆÂ’ Ã¢ÂˆÂ†, which  entails the result since the simplification operation does not  change the validity of a constraint.  This enables us to express the effect of the first step in a  run on a formulaÃ¢Â€Â™s constraints. We can now come up with  an unfolding property similar to LTL. The intuitive idea is to  guess the subset ÃÂ“ Ã¢ÂŠÂ† SC of formulas accounted for in constraint C which hold over the word at position 0, check that  this guess is correct and update C accordingly as described  in the previous lemma.  53  Next, if C 6Ã¢ÂˆÂˆ {>, Ã¢ÂŠÄ½}, it is easy to show that    V  W  ÃÅš Ã¢Â‰Ä„ ( ÄÂˆÃ¢ÂˆÂˆSC Ã‚Å¹ÄÂˆ)U ( ÄÂˆÃ¢ÂˆÂˆSC ÄÂˆ) Ã¢ÂˆÂ§ (ÄÂ•1 U[C] ÄÂ•2 )    V  W  Ã¢Â‰Ä„ ( ÄÂˆÃ¢ÂˆÂˆSC Ã‚Å¹ÄÂˆ)U ( ÄÂˆÃ¢ÂˆÂˆSC ÄÂˆ) Ã¢ÂˆÂ§ ÃÅš0 )  Proposition 2 (Unfolding). Let ÃÅš = ÄÂ•1 U[C] ÄÂ•2 and  ÃÂ¨=  W  ÃÂ“Ã¢ÂŠÂ†SC  V  ÄÂˆÃ¢ÂˆÂˆÃÂ“  ÄÂˆÃ¢ÂˆÂ§  V  ÄÂˆÃ¢ÂˆÂˆSC \ÃÂ“  Ã‚Å¹ÄÂˆ    Ã¢ÂˆÂ§ ÄÂ•1 Ã¢ÂˆÂ§ X(ÄÂ•1 U[(CÃ¢ÂˆÂ’ÃÂ“)Ã¢Â†Â“] ÄÂ•2 ) .  where ÃÅš0 is ÃÂ¨0 Ã¢ÂˆÂ¨ ÄÂ•2 if w, Ã¢ÂˆÂ’1 |= C and ÃÂ¨0 otherwise, and  ÃÂ¨0 is identical to formula ÃÂ¨ in Prop. 2 above, omitting the  disjunct for ÃÂ“ = Ã¢ÂˆÂ…. Now the top-most constraints C 0 occurring in ÃÂ¨0 are equal to (C Ã¢ÂˆÂ’ ÃÂ“)Ã¢Â†Â“ with some non-empty  ÃÂ“, and thus ÃÂ¨0 @ ÃÅš. By induction hypothesis, ÃÂ¨0 can be  translated into LTL, which concludes the proof.  The following equivalence holds:  (  ÃÂ¨ Ã¢ÂˆÂ¨ ÄÂ•2  if w, Ã¢ÂˆÂ’1 |= C,  ÃÅšÃ¢Â‰Ä„  ÃÂ¨  otherwise.  Proof. ÃÅš Ã¢Â‡Â’ ÃÂ¨/ÃÂ¨ Ã¢ÂˆÂ¨ ÄÂ•2 : If ÃÅš is satisfied over some word  w Ã¢ÂˆÂˆ (2AP )ÄÂ‰ , then by definition Ã¢ÂˆÂƒi Ã¢Â‰Ä½ 0, wi |= ÄÂ•2 , w, iÃ¢ÂˆÂ’1 |=  C and Ã¢ÂˆÂ€0 Ã¢Â‰Â¤ j < i, wj |= ÄÂ•.  If i = 0, i.e. w, Ã¢ÂˆÂ’1 |= C and w |= ÄÂ•2 , then ÃÂ¨Ã¢ÂˆÂ¨ÄÂ•2 holds.  Otherwise (i > 0) it must be that w |= ÄÂ•1 and w, iÃ¢ÂˆÂ’1 |= C.  Let Ã¢ÂˆÂ† be the set of formulas of SC which hold over w, by  Lemma 1 we have w1 , i Ã¢ÂˆÂ’ 2 |= (C Ã¢ÂˆÂ’ Ã¢ÂˆÂ†) Ã¢Â†Â“. Furthermore  there  V existsVa disjunct in ÃÂ¨ (namely when ÃÂ“ = Ã¢ÂˆÂ†) such that  ÄÂˆÃ¢ÂˆÂˆÃÂ“ ÄÂˆ Ã¢ÂˆÂ§ ÄÂˆÃ¢ÂˆÂˆSC \ÃÂ“ Ã‚Å¹ÄÂˆ holds. Finally, we can deduce from  all of the above that (w1 )iÃ¢ÂˆÂ’1 |= ÄÂ•2 , w1 , iÃ¢ÂˆÂ’2 |= (C Ã¢ÂˆÂ’ Ã¢ÂˆÂ†)Ã¢Â†Â“  and Ã¢ÂˆÂ€0 Ã¢Â‰Â¤ j < i Ã¢ÂˆÂ’ 1, (w1 )j |= ÄÂ•, in other words w1 |=  ÄÂ•1 U[(CÃ¢ÂˆÂ’Ã¢ÂˆÂ†)Ã¢Â†Â“] ÄÂ•2 . Together with the above observations, this  implies that w |= ÃÂ¨.  However, this translation may yield an exponential increase in dag-size, since the number of distinct constraints  C 0 @ C is of the order of M m (with M the largest constant and m the number of atomic constraints occurring in  2  C), hence also in 2O(|ÃÅš| ) . We are as of yet not able to  show that this bound is tight, but there exist CLTL formulas  whose shortest equivalent LTL formula is provably of dagsize at least in O(M ).  Proposition 4 (Succinctness). Any LTL formula equivalent  to the CLTL formula ÃÅšk = F(Ã‚Å¹bU[]a=k] >) has temporal  depth at least k Ã¢ÂˆÂ’ 1 (i.e. exponential in |ÃÅšk |).  V ÃÂ¨ Ã¢Â‡Â’ ÃÅš:VLet w |= ÃÂ¨, there must exist ÃÂ“ such that w |=  ÄÂˆÃ¢ÂˆÂˆÃÂ“ ÄÂˆ Ã¢ÂˆÂ§  ÄÂˆÃ¢ÂˆÂˆSC \ÃÂ“ Ã‚Å¹ÄÂˆ Ã¢ÂˆÂ§ ÄÂ•1 Ã¢ÂˆÂ§ X(ÄÂ•1 U[(CÃ¢ÂˆÂ’ÃÂ“)Ã¢Â†Â“] ÄÂ•2 ). From  this, we can deduce that (1) Ã¢ÂˆÂƒi > 0, w, i + 1 |= ÄÂ•2 and  Ã¢ÂˆÂ€0 Ã¢Â‰Â¤ j Ã¢Â‰Â¤ i, w, j |= ÄÂ•1 , (2) w1 , i |= (C Ã¢ÂˆÂ’ ÃÂ“) Ã¢Â†Â“ and (3)  ÃÂ“ = {ÄÂ• Ã¢ÂˆÂˆ SC | w |= ÄÂ•} which by Lemma 1 entails that  w, i + 1 |= C. Together with item (1) above, we get that  w |= ÃÅš.  Proof. Consider the set AP = {a, b, c}, and the property  S TAIRSk ([9]), which states that there exists a portion of  the path in which proposition a occurs at least k times but  proposition b does not occur. In [9], it is shown that this  property can only be expressed by a LTL formula with at  least k Ã¢ÂˆÂ’ 1 nested Until modalities. However, this formula  is equivalent to the CLTL formula ÃÅšk .  Remark 2. Note that even a single unfolding step as described by the previous proposition may entail an exponential increase in the dag-size of the formula, since the set ÃÂ“  needs to be guessed explicitly. This blow-up can be kept  polynomial by Ã¢Â€ÂœscanningÃ¢Â€Â formulas in SC one at a time and  in a fixed order instead of considering all possible ÃÂ“ Ã¢ÂŠÂ† SC .  This technique was used in [12] to study the translation of a  fragment of CCTL into CTL.  4. Decision procedures  We consider two standard decision problems for CLTL,  namely satisfiability (given ÃÅš Ã¢ÂˆÂˆ CLTL, does there exists a  model for ÃÅš?) and model checking (given ÃÅš Ã¢ÂˆÂˆ CLTL and  some KS S, do all runs of S satisfy ÃÅš, i.e. S |= ÃÅš? ).  Classical decision procedures for LTL satisfiability are  based on automata constructions. Given some LTL formula  ÃÅš, one can either build an (exponential) non-deterministic  BuÄšÂˆchi automaton or a (polynomial) alternating BuÄšÂˆchi automaton accepting exactly the models of ÃÅš. Satisfiability  then consists in checking whether the language of the automaton is empty [15]. We begin this section by recalling  the definition of alternating BuÄšÂˆchi automata, then extend the  usual automata-based decision procedures for satisfiability  and model-checking to our logic CLTL.  Expressivity and succinctness. Similarly to the corresponding counting CTL logic [12], CLTL is not more expressive than classical LTL.  Proposition 3 (Expressivity). Any CLTL formula can be  translated into LTL.  Proof. We reason by induction on the structure of ÃÅš. The  case of Boolean connectives is trivial. We treat the case ÃÅš =  ÄÂ•U[C] ÄÂˆ by induction on the well-founded partial ordering  @ defined in the previous section.  If ÃÅš is minimal for @ (i.e. C Ã¢ÂˆÂˆ {>, Ã¢ÂŠÄ½}), we can directly use the inductive LTL translations of ÄÂ• and ÄÂˆ, since  ÄÂ•U[Ã¢ÂŠÄ½] ÄÂˆ Ã¢Â‰Ä„ Ã¢ÂŠÄ½ and ÄÂ•U[>] ÄÂˆ Ã¢Â‰Ä„ ÄÂ•UÄÂˆ.  4.1. Alternating BuÄšÂˆchi Automata over ÄÂ‰ -words  An alternating BuÄšÂˆchi automaton on infinite words is a  tuple A = (ÃÅ, S, s0 , ÃÂ´, F ) where ÃÅ is a finite alphabet, S  54  The number of states is in O(|ÃÅš| Ã‚Ë‡ M m ) : every ÄÂ•1 U[C] ÄÂ•2  subformula may provide (M + 2)m states. Also note that  the transition formula ÃÂ¸ above can be expressed in a more  concise way using a more refined unfolding technique (Cf.  Rem. 2), at the cost of roughly duplicating |SC | times  the states corresponding to each U[C] -subformula. This automaton recognizes exactly the models of ÃÅš.  is a finite set of states, s0 Ã¢ÂˆÂˆ S is the initial state, ÃÂ´ : S Ä‚Â—  ÃÅ Ã¢Â†Â’ B + (S) is the transition function assigning a positive  Boolean formula over S (including Ã¢ÂŠÄ½ and >) to every pair  (s, ÄÂƒ), and F Ã¢ÂŠÂ† S is the BuÄšÂˆchi acceptance condition.  A run over an infinite word w = a0 a1 Ã‚Ë‡ Ã‚Ë‡ Ã‚Ë‡ Ã¢ÂˆÂˆ ÃÅÄÂ‰ is an  infinite S-labeled tree T = (T, l) where T is a tree and  l : Nodes(T ) Ã¢Â†Â’ S assigns an element in S to every node  in T . The root  of T has to be labeled by s0 (i.e. l() =  s0 ) and every node x at depth i (written |x| = i) has k  (k Ã¢Â‰Ä½ 0) children x1 ,. . . ,xk such that the formula ÃÂ´(l(x), ai )  is interpreted to true when one assigns > to every state in  {l(x1 ), . . . , l(xk )} and Ã¢ÂŠÄ½ to other states.  The run is accepted when every infinite branch of T contains infinitely often nodes labeled by states in F and every  finite branch ends in a node x such that ÃÂ´(l(x), a|x| ) = >.  We use L(A) to denote the set of words accepted by A.  The complexity of this algorithm is in fact asymptotically optimal:  Theorem 6. CLTL satisfiability is EXPSPACE-complete.  Proof. Membership in EXPSPACE is based on Prop. 5:  2  the size of the automaton AÃÅš is in 2O(|ÃÅš| ) and checking  emptiness of an alternating BuÄšÂˆchi automaton is PSPACEcomplete [5]. This provides an EXPSPACE algorithm.  First note that EXPSPACE-hardness is a consequence of  the complexity of TLTL (i.e. Timed LTL) over discrete time  domains [11]. Nevertheless we give a proof based on the  encoding in CLTL of the execution of a Turing Machine  running in exponential space over some input word (such  an encoding is classical, see for example [3]).  Consider a deterministic 2n -space-bounded Turing machine M = hÃÅ, QM , q0 , qF , RM i, with an initial tape content X = x1 . . . xn . We assume w.l.o.g. ÃÅ = {a, b}. q0  is the initial state and qF is the final state. And as usual  RM Ã¢ÂŠÂ† QM Ä‚Â— ÃÅ Ä‚Â— ÃÅ Ä‚Â— {Ã¢ÂˆÂ’1, 1} Ä‚Â— QM .  Now we construct a polynomial-size formula describing  the accepting computation of M on X. The set of atomic  propositions AP is defined as follows: AP contains Pa and  Pb to represent the corresponding symbol on the tape, an additional proposition Ps to separate two consecutive configurations, and propositions Pa,q and Pb,q for every q Ã¢ÂˆÂˆ QM  to mark the position of the tape head on a cell containing a  symbol a or b respectively.  A configuration of M is encoded as a sequence of 2n  states labeled with propositions in AP to represent the content of the cells. One of these cell is labeled with some Pa,q  or Pb,q , and the sequence is preceded and followed by a  state labeled with Ps .  V In the following we use the abbreviation PÃ¢ÂˆÂ… to represent  P Ã¢ÂˆÂˆAP Ã‚Å¹P . This formula is used to represent empty cells.  To specify that the run is the correct and accepting one,  we need a formula of the form (ÃÅši Ã¢ÂˆÂ§ ÃÅšm ) Ã¢Â‡Â’ ÃÅša (where  i, m and a stand for init, move and accept respectively),  meaning that if the run starts with the initial configuration  and follows the transitions of M, then it is accepting. These  three formulas can be expressed in CLTL:  4.2. Satisfiability  By using the standard techniques for LTL, one obtains  the following results:  Proposition 5. Given a CLTL formula ÃÅš, one can build an  alternating BuÄšÂˆchi automaton AÃÅš such that (1) |AÃÅš | is in  O(|ÃÅš| Ã‚Ë‡ M |ÃÅš| ) where M is the maximal constant occurring  in constraints inside ÃÅš, and (2) LÄÂ‰ (AÃÅš ) is exactly the set  of runs satisfying ÃÅš.  Proof. Let ÃÅš be a CLTL formula. Let M be the maximal  constant occurring in the counting constraints  P in ÃÅš and m  the maximal number of atomic constraints i ÃÄ…i Ã‚Ë‡ ]ÄÂˆi Ã¢ÂˆÅº k  occurring in the same constraint in ÃÅš. We define AÃÅš =  (ÃÅ, SÃÅš , s0 , ÃÂ´, F ), where ÃÅ is 2AP , SÃÅš is the set of all subformulas of ÃÅš (including those appearing in constraints),  ÄÂ•1 U[(CÃ¢ÂˆÂ’Ã¢ÂˆÂ†)Ã¢Â†Â“] ÄÂ•2 for every subformula ÄÂ•1 U[C] ÄÂ•2 and Ã¢ÂˆÂ† Ã¢ÂŠÂ†  SC , and their negations, s0 is ÃÅš, ÃÂ´ : SÃÅš Ä‚Â— ÃÅ Ã¢Â†Â’ B + (SÃÅš ) is  the transition function defined below and F contains every  state in S of the form Ã‚Å¹(ÄÂ•1 UÄÂ•2 ) or Ã‚Å¹(ÄÂ•1 U[C] ÄÂ•2 ).  In the following we use ÃÂ¸ to denote the negation normal  form of the formula ÃÂ¸ Ã¢ÂˆÂˆ B+ (SÃÅš ): every conjunction (resp.  disjunction) becomes a disjunction (resp. conjunction), >  (resp. Ã¢ÂŠÄ½) becomes Ã¢ÂŠÄ½ (resp. >), and ÃÂ¸ is just ÃÂ¸. Negated  states are fine since ÄÂ• Ã¢ÂˆÂˆ SÃÅš Ã¢Â‡Â’ Ã‚Å¹ÄÂ• Ã¢ÂˆÂˆ SÃÅš .  For convenience, we define the transition function recursively. Occurrences of ÃÂ´(ÄÂ•, ÄÂƒ) in right-hand sides should  be replaced by their definition until a formula in B + (SÃÅš ) is  obtained. We have ÃÂ´(P, ÄÂƒ) = > if P Ã¢ÂˆÂˆ ÄÂƒ and Ã¢ÂŠÄ½ otherwise,  ÃÂ´(ÄÂ• Ã¢ÂˆÂ§ ÄÂˆ, ÄÂƒ) = ÃÂ´(ÄÂ•, ÄÂƒ) Ã¢ÂˆÂ§ ÃÂ´(ÄÂˆ, ÄÂƒ), and ÃÂ´(Ã‚Å¹ÄÂ•, ÄÂƒ) = ÃÂ´(ÄÂ•, ÄÂƒ).  The rule for U is based on the unfolding rule (see Prop. 2):  ÃÂ´(ÄÂ•1 U[C] ÄÂ•2 , ÄÂƒ) = ÃÂ´(ÄÂ•2 , ÄÂƒ) Ã¢ÂˆÂ¨ ÃÂ¸ if ÄÂ, Ã¢ÂˆÂ’1 |= C and ÃÂ¸ otherwise, with  W  V  V  ÃÂ¸ = ÃÂ“Ã¢ÂŠÂ†SC  ÄÂˆÃ¢ÂˆÂˆÃÂ“ ÃÂ´(ÄÂˆ, ÄÂƒ) Ã¢ÂˆÂ§  ÄÂˆÃ¢ÂˆÂˆSC \ÃÂ“ ÃÂ´(Ã‚Å¹ÄÂˆ, ÄÂƒ)    Ã¢ÂˆÂ§ ÃÂ´(ÄÂ•1 , ÄÂƒ) Ã¢ÂˆÂ§ (ÄÂ•1 U[(CÃ¢ÂˆÂ’ÃÂ“)Ã¢Â†Â“] ÄÂ•2 ) .  ÃÅši = Ps Ã¢ÂˆÂ§ X(Px1 ,q0 Ã¢ÂˆÂ§  V  2Ã¢Â‰Â¤kÃ¢Â‰Â¤n  F[]>=k] Pxk  Ã¢ÂˆÂ§ F[]>=n+1] (PÃ¢ÂˆÂ… U[]>=2n Ã¢ÂˆÂ’n] Ps )  55    ÃÅšm = G Ps Ã¢Â‡Â’ X(Ã‚Å¹Ps )U[]>=2n ] Ps  V  Ã¢ÂˆÂ§ (P1 ,P2 ,P3 )Ã¢ÂˆÂˆAP3 G (P1 Ã¢ÂˆÂ§ XP2 Ã¢ÂˆÂ§ XXP3 )    Ã¢Â‡Â’ F[]>=2n +2] fM (P1 , P2 , P3 )  4.4. A PSPACE fragment of CLTL  The EXPSPACE-hardness proof of CLTL satisfiability  only uses counting constraints of the form Ã¢Â€Âœ]> = kÃ¢Â€Â: there  is no need for nested formulas in constraints, no Boolean  combinations and no sums. Here we introduce the fragment  CLTLÃ¢ÂˆÂ’ defined as the set of CLTL formulas where counting constraints are purely conjunctive terms, and comparison symbols are not mixed inside aVconstraint.  In other  P  terms,  constraints  are  of  the  form  Ã¢Â€Âœ  ÃÄ…  Ã‚Ë‡  ]ÄÂˆ  i < kÃ¢Â€Â,  i i  VP  Ã¢Â€Âœ  ÃÄ…  Ã‚Ë‡  ]ÄÂˆ  >  kÃ¢Â€Â  or  their  non-strict  variants.  Note  that  i  i i  this restriction also applies over subformulas in constraints.  We use ÄÂ•1 U[CÃ¢Â‰ÅŸ] ÄÂ•2 (resp. ÄÂ•1 U[C] ÄÂ•2 ) to denote an Until-subformula tagged with a constraint of the form Ã¢Â€Âœless  thanÃ¢Â€Â i.e. with Ã¢Â‰Â¤ or < (resp. Ã¢Â€Âœgreater thanÃ¢Â€Â with Ã¢Â‰Ä½ or >).  In the following theorem, we claim that CLTLÃ¢ÂˆÂ’ formulas  admit PSPACE decision procedures:  ÃÅša = F(Pa,qF Ã¢ÂˆÂ¨ Pb,qF ),  where the function fM (P1 , P2 , P3 ) refers to the transition  rules of M: fM (P1 , P2 , P3 ) gives the value of the cell  containing P2 in the next configuration given the definition of the left cell (P1 ) and the right cell (P3 ). For instance, for every rule (q, a, b, +1, q 0 ) in RM we will have:  fM (P1 , Pa,q , P2 ) = Pb for any P1 Ã¢ÂˆÂˆ AP and any P2 6= Ps .  Moreover we have for any P1 Ã¢ÂˆÂˆ AP, the two values:  fM (Pa,q , Pa , P1 ) = Pa,q0 and fM (Pa,q , Pb , P1 ) = Pb,q0 .  And we also define fM (P1 , P2 , P3 ) = P2 if neither P1 or  P3 are of the form Pa,q or Pb,q for some q.  The lengths of formulas ÃÅši , ÃÅšm and ÃÅša are polynomial,  since constants are encoded in binary, which implies the  EXPSPACE-hardness of CLTL satisfiability.  Theorem 7. The satisfiability and model-checking problems for CLTLÃ¢ÂˆÂ’ are PSPACE-complete.  Note that if constraints are atomic (i.e. without Boolean  combinations in subscripts), then m is equal to 1 and the  size of AÃÅš is in O(|ÃÅš| Ã‚Ë‡ M ). If in addition, constants are  assumed to be encoded in unary, the satisfiability algorithm  becomes PSPACE.  Proof. PSPACE-hardness comes from LTL satisfiability.  PSPACE membership is based on the fact that given a  CLTLÃ¢ÂˆÂ’ formula ÃÅš and AÃÅš the corresponding automaton  as built in Proposition 5, for any accepting run over some  model w of ÃÅš, there exists a Ã¢Â€ÂœsmallÃ¢Â€Â accepting run over w.  By small, we mean a tree with a width (i.e. the maximal  number of nodes at the same level) bounded by |ÃÅš|.  Let ÃÅš be a CLTLÃ¢ÂˆÂ’ formula. First we can assume that  ÃÅš only contains atomic constraints (with no conjunction):  indeed every CLTLÃ¢ÂˆÂ’ formula ÄÂ•1 U[CÃ¢ÂˆÂ§C 0 ] ÄÂ•2 is equivalent to  ÄÂ•1 U[C] ÄÂ•2 Ã¢ÂˆÂ§ ÄÂ•1 U[C 0 ] ÄÂ•2 . This translation can be done efficiently and the dag-size of the resulting formula is linear  in the size of the original one. Let Subf(ÃÅš) be the set of  subformulas of ÃÅš.  Now consider AÃÅš as defined in Proposition 5. The number of states of AÃÅš is in O(|ÃÅš| Ã‚Ë‡ M ) where M is the size  of the maximal constant occurring in ÃÅš. Thus this number  is exponential in |ÃÅš| (this blow-up is due to the rewriting  of ÄÂ•1 U[C] ÄÂ•2 subformulas into ÄÂ•1 U[CÃ¢ÂˆÂ’ÃÂ“] ÄÂ•2 subformulas in  the function ÃÂ´).  Now consider an accepting run T = (T, l) of AÃÅš over  an infinite word w that is a model of ÃÅš. At every level i  of the tree T , the nodes {x1 , . . . , xk } are labeled with the  set of formulas {l(x1 ), . . . , l(xk )} Ã¢ÂŠÂ† SÃÅš (see the definition  of SÃÅš in Prop. 5) and every formula l(xj ) holds over the  word wi . For every ÄÂˆ Ã¢ÂˆÂˆ Subf(ÃÅš) of the form ÄÂ•1 U[C] ÄÂ•2 ,  it is possible to have several formulas ÄÂ•1 U[CÃ¢ÂˆÂ’ÃÂ“] ÄÂ•2 for different subsets ÃÂ“ of SC . But we clearly only need to verify  one formula of this set: if ÄÂˆ is a Ã¢Â€Âœless thanÃ¢Â€Â (resp. a Ã¢Â€Âœgreater  thanÃ¢Â€Â) formula, we consider the one containing the minimal (resp. maximal) constant k in the constraint. Indeed we  clearly have ÄÂ•1 U[C<k] ÄÂ•2 Ã¢Â‡Â’ ÄÂ•1 U[C<k0 ] ÄÂ•2 for any k Ã¢Â‰Â¤ k 0  and ÄÂ•1 U[C>k] ÄÂ•2 Ã¢Â‡Â’ ÄÂ•1 U[C>k0 ] ÄÂ•2 for any k Ã¢Â‰Ä½ k 0 .  4.3. Model-checking  Corollary 1. The model-checking problem for CLTL is  EXPSPACE-complete.  Proof. Hardness for EXPSPACE comes from that of satisfiability, which can be reduced to a model-checking problem  using some kind of universal Kripke structure Su able to  generate any possible word in (2AP )ÄÂ‰ : ÃÅš is satisfiable iff  Su 6|= Ã‚Å¹ÃÅš. Let AP be {P1 , . . . , Pn }. Instead of considering  a complete KS whose states are labeled with every possible  subset of AP (which would yield an exponential structure),  we use a succinct KS Su0 that encodes every valuation of a  state in Su as a sequence of n states labeled respectively by  Ã¢ÂˆÂ… or Pi . . . It then remains to sligthtly modify ÃÅš to take into  account this encoding. Let ÃÅš0 be the modified formula, we  can reduce Su |= ÃÅš to Su0 |= ÃÅš0 .  Membership in EXPSPACE is obtained following the  idea for classical LTL model-checking. Given a Kripke  Structure S and a CLTL formula ÃÅš, one builds as previously  an alternating BuÄšÂˆchi automaton A for the formula Ã‚Å¹ÃÅš. It is  then straightforward to compute the product of A with the  structure S in such a way that the obtained automaton has  an accepting infinite run if and only if there exists a path in  S violating ÃÅš.  Note that the program complexity of model-checking for  CLTL (i.e. the complexity of model-checking a fixed formula) is (like for LTL) NL-complete [16].  56  by replacing the constraint language C with the language  C 0 of constraints of the form ]ÄÂ•1 Ã¢ÂˆÂ’ ]ÄÂ•2 Ã¢ÂˆÅº k (i.e. with no  Boolean combination), which we call diagonal constraints.  It turns out that, unlike CCTL where model-checking remains polynomial for this restricted case, this constraint  language yields undecidability in the case of CLTL.  Then at every level of the tree, we only need to keep one  formula among this subset of formulas {ÄÂ•1 U[CÃ¢ÂˆÂ’ÃÂ“] ÄÂ•2 | ÃÂ“ Ã¢ÂŠÂ†  SC }. Thus we can ensure the number of formulas labeling states at some level to be bounded by |ÃÅš|. This remark  leads to an NSPACE algorithm for satisfiability (and model  checking). It works as follows.  Let Si be the set of SÃÅš formulas labeling states of level  i: we have |Si | Ã¢Â‰Â¤ |ÃÅš| and this set can be encoded in polynomial space (w.r.t. |ÃÅš|). Now the procedure guesses nondeterministically a letter wi and a subset Si+1 and verifies  that it may correspond to the level i + 1. For this, the algorithm has to check Si+1 |= ÃÂ´(ÄÂˆ, wi ) for every ÄÂˆ Ã¢ÂˆÂˆ Si :  this is done again with a non-deterministic choice of subsets  ÃÂ“ in the function ÃÂ´ and by interpreting ÄÂ•1 U[CÃ¢Â‰ÅŸ] ÄÂ•2 (resp.  ÄÂ•1 U[C] ÄÂ•2 ) as true if there is some formula ÄÂ•1 U[CÃ¢ÂˆÂ’ÃÂ“] ÄÂ•2  in Si+1 (resp. ÄÂ•1 U[C 0 ] ÄÂ•2 in Si+1 with C = C 0 Ã¢ÂˆÂ’ ÃÂ“).  Moreover as usual for this kind of algorithms, the procedure will guess non-deterministically that some level ` is  the first state of a cycle and will verify that there is a future  level labeled with the same set of formulas S` : to do this we  simply need to memorize S` .  Finally we need to verify that the acceptance condition  is satisfied by the final cycle from level `. This is done  by checking that every formula ÄÂ•1 U[C] ÄÂ•2 Ã¢ÂˆÂˆ S` is satisfied  somewhere along the cycle (there must be no branch along  which the label ÄÂ•1 U[C] ÄÂ•2 ultimately appears forever). For  this, we need to store (and update) the Until-subformulas  that have not yet been satisfied along the cycle, and mark  each of them as soon as the corresponding ÄÂ•2 holds, which  can be done step by step by analyzing the function ÃÂ´. Once  the set of formulas S` is repeated, we need to have succesfully asserted this fact for every formula (or one of its descendants with constraint C Ã¢ÂˆÂ’ÃÂ“). Note that every ÄÂ•1 U[C] ÄÂ•2  that does not occur at level ` but appears inside the cycle  will be either satisfied before the next occurrence of S` , or  will yield a subformula ÄÂ•1 U[C 0 ] ÄÂ•2 in S` and then will be  treated as in the previous case.  This yields an NSPACE procedure and by SavitchÃ¢Â€Â™s theorem one can deduce the existence of a PSPACE algorithm.  The model-checking algorithm is based on the same technique for analyzing the alternating automaton.  Theorem 8. The model-checking and satisfiability problems for CLTL with atomic diagonal constraints are undecidable.  Proof. This is done by reduction from the halting problem  of a two-counter machine M with counters C and D, and  n instructions I1 , . . . , In . Each Ii is either a decrement  hif X=0 then j else X--, ki where X stands for  C or D, an increment hX++, ji, or the halting instruction  hhalti. We define a Kripke structure SM = (Q, R, `),  where Q = {q1 , . . . , qn } Ã¢ÂˆÅ {ri , ti | Ii = hif ...i}. The  transition relation is defined as follows:  Ã¢Â€Ë˜ if Ii = hX++, ji, then (qi , qj ) Ã¢ÂˆÂˆ R ; and  Ã¢Â€Ë˜ if Ii = hif X=0 then j else X--,ki, then  (qi , ri ), (ri , qk ), (qi , ti ) and (ti , qj ) in R.  The labeling ` is defined over the set {halt, C + , C Ã¢ÂˆÂ’ , C 0 ,  D+ , DÃ¢ÂˆÂ’ , D0 } as `(qi ) = {X + } if Ii is an increment of X,  `(ri ) = {X Ã¢ÂˆÂ’ } and `(ti ) = {X 0 } if Ii is a decrement for  X, and `(qi ) = {halt} if Ii is the halting instruction.  A run going through ti for some i will simulate the positive test Ã¢Â€ÂœX = 0Ã¢Â€Â: we use the proposition X 0 to observe  this fact. Indeed along any run in SM , a state satisfies X 0  if and only if that state is some ti state, which witnesses the  fact that the counterÃ¢Â€Â™s value was deemed equal to zero. The  propositions on the other states are self-explanatory, witnessing increments and decrements of counters.  Checking CLTL with atomic diagonal constraints on this  structure solves the halting problem, since M halts if and  only if SM |= ÃÅš with:  ÃÅš = F[(]haltÃ¢Â‰Ä½1)] >    W  Ã¢ÂˆÂ¨ XÃ¢ÂˆÂˆ{C,D} F[(]X + Ã¢ÂˆÂ’]X Ã¢ÂˆÂ’ <0)] > Ã¢ÂˆÂ¨ F[(]X + Ã¢ÂˆÂ’]X Ã¢ÂˆÂ’ >0)] X 0  The formula ÃÅš is satisfied by a run because either SM halts,  or the run does not simulate correctly M because the number of decrements is at some point larger than the number  of increments, or because some counter was incorrectly assumed to be zero while simulating a test. Thus, if ÃÅš is true  for every run, it is in particular the case of the path simulating the behavior of M.  This result is another illustration of the potential complexity cost of equality in quantitative constraints as in the  timed case [1].  5. Extension with diagonal constraints  In [12], we presented several decidable fragments of  CCTL in which atomic constraints with subtraction were  allowed. In this section, we show that even a simple extension of LTL with such constraints leads to undecidability.  More formally, we consider the logic obtained from CLTL  6. CCTLÃ¢ÂˆÂ—  Using similar modalities in a branching framework, one  can define a counting extension of the logic CTLÃ¢ÂˆÂ— .  57  Definition 4. Let AP be a set of atomic propositions, we  distinguish:  we are working on different (cumulative) semantics for constraints, which evaluate counting expressions over the full  history of runs.  CCTLÃ¢ÂˆÂ— 3 ÄÂ•s , ÄÂˆs ::= P | ÄÂ•s Ã¢ÂˆÂ§ ÄÂˆs | Ã‚Å¹ÄÂ•s | EÄÂ•p  CCTLÃ¢ÂˆÂ—p 3 ÄÂ•p , ÄÂˆp ::= ÄÂ•s | ÄÂ•p Ã¢ÂˆÂ§ ÄÂˆp | Ã‚Å¹ÄÂ•p | ÄÂ•p U[C] ÄÂˆp  References  where C denotes a counting constraint as in Def. 2 with  subformulas in CCTLÃ¢ÂˆÂ— Ã¢ÂˆÅ CCTLÃ¢ÂˆÂ—p .  [1] R. Alur, T. Feder, and T. A. Henzinger. The benefits of relaxing punctuality. J. ACM, 43(1):116Ã¢Â€Â“146, 1996.  [2] R. Alur and T. A. Henzinger. Logics and models of real  time: A survey. In Proc. REX Workshop, volume 600 of  LNCS, pages 74Ã¢Â€Â“106. Springer, 1992.  [3] R. Alur and T. A. Henzinger. A really temporal logic.  J. ACM, 41(1):181Ã¢Â€Â“203, 1994.  [4] D. Bustan, D. Fisman, and J. Havlicek. Automata construction for psl. Technical report, The Weizmann Institute of  Science, 2005. Available as Tech. Report MCS05- 04.  [5] A. K. Chandra, D. C. Kozen, and L. J. Stockmeyer. Alternation. J. ACM, 28(1):114Ã¢Â€Â“133, 1981.  [6] E. A. Emerson. Temporal and modal logic. In Handbook of  Theoretical Computer Science, volume B, chapter 16, pages  995Ã¢Â€Â“1072. Elsevier Science, 1990.  [7] E. A. Emerson, A. K. Mok, A. P. Sistla, and J. Srinivasan. Quantitative temporal reasoning. Real-Time Systems,  4(4):331Ã¢Â€Â“352, 1992.  [8] E. A. Emerson and R. J. Trefler. Generalized quantitative  temporal reasoning: An automata-theoretic approach. In  Proc. 7th TAPSOFT, volume 1214 of LNCS, pages 189Ã¢Â€Â“200.  Springer, 1997.  [9] K. Etessami and T. Wilke. An until hierarchy and other  applications of an Ehrenfeucht-FraÃ„Ä…ÄšÂˆsseÄšÂ game for temporal  logic. Inf. Comput., 160(1-2):88Ã¢Â€Â“108, 2000.  [10] H. Hansson and B. Jonsson. A logic for reasoning about  time and reliability. Formal Asp. Comput., 6(5):512Ã¢Â€Â“535,  1994.  [11] F. Laroussinie, N. Markey, and Ph. Schnoebelen. Efficient  timed model checking for discrete-time systems. Theor.  Comput. Sci., 353(1-3):249Ã¢Â€Â“271, 2006.  [12] F. Laroussinie, A. Meyer, and E. Petonnet. Counting CTL.  In Proc. 13th FoSSaCS, volume 6014 of LNCS, pages 206Ã¢Â€Â“  220. Springer, 2010.  [13] A. Pnueli. The temporal logic of programs. In Proc. 18th  FOCS, pages 46Ã¢Â€Â“57. IEEE Comp. Soc. Press, 1977.  [14] Property Specification Language Reference Manual, Version 1.1, 2003. http://www.eda-stds.org/vfv/  docs/PSL-v1.1.pdf.  [15] M. Y. Vardi. An automata-theoretic approach to linear temporal logic. In Logics for Concurrency: Structure Versus  Automata, volume 1043 of LNCS, pages 238Ã¢Â€Â“266. Springer,  1996.  [16] M. Y. Vardi and P. Wolper. An automata-theoretic approach  to automatic program verification. In Proc. 1st LICS, pages  332Ã¢Â€Â“344. IEEE Comp. Soc. Press, 1986.  [17] P. Wolper. Temporal logic can be more expressive. Inf. and  Control, 56(1/2):72Ã¢Â€Â“99, 1983.  The semantics of CCTLÃ¢ÂˆÂ— formulas is defined over states  of Kripke structures as follows:  Definition 5. The following clauses (Boolean cases are  omitted) define the conditions for a state q (resp. a run ÄÂ) of  some KS S = hQ, qinit , R, `i to satisfy a CCTLÃ¢ÂˆÂ— formula ÄÂ•s  (resp. a CCTLÃ¢ÂˆÂ—p formula ÄÂ•p ) by induction over the structure  of ÄÂ•s (resp. ÄÂ•p ):  q |=S P  iff P Ã¢ÂˆÂˆ `(q)  q |=S EÄÂ•p  iff Ã¢ÂˆÂƒÄÂ Ã¢ÂˆÂˆ Runs(q), ÄÂ |=S ÄÂ•p  ÄÂ |=S ÄÂ•s  iff ÄÂ(0) |=S ÄÂ•s  ÄÂ |=S ÄÂ•U[C] ÄÂˆ  iff Ã¢ÂˆÂƒi Ã¢Â‰Ä½ 0, ÄÂi |=S ÄÂˆ, ÄÂ, iÃ¢ÂˆÂ’1 |=S C  and Ã¢ÂˆÂ€0 Ã¢Â‰Â¤ j < i, ÄÂj |=S ÄÂ•  We use A to denote the dual of E. The model-checking  problem consists in deciding whether a given CCTLÃ¢ÂˆÂ— formula holds for a given state in a KS S.  Theorem 9. The model-checking problem for CCTLÃ¢ÂˆÂ— is  EXPSPACE-complete.  Proof. EXPSPACE-hardness comes from the corresponding problems for CLTL. EXPSPACE membership is obtained thanks to the EXPSPACE procedure for CLTL formulas. One can design a polynomial-time algorithm that  calls an oracle for CLTL subformulas, which provides a  PEXPSPACE procedure (hence also in EXPSPACE).  7. Conclusion  We have proposed new extensions for LTL and CTLÃ¢ÂˆÂ—  which, together with our related results for CTL [12], provide a general overview of expressivity and complexity for  a natural class of quantitative temporal logics.  There are several possible continuations to this work,  some of which we are currently exploring. It would be interesting to evaluate the succinctness and algorithmic properties of the unary fragment of CLTL (i.e. CLTL with unaryencoded constants), for which we believe better algorithms  may exist despite the fact that it is not clear how to avoid an  exponential blow-up in the dag-size of the LTL translation.  It would also be natural to consider the addition of past  modalities, which bring exponential succinctness improvements to LTL with no significant complexity cost. Finally,  58 