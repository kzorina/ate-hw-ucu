Temporalising Tractable Description Logics  A. Artale  Faculty of Computer Science  Free University of Bozen-Bolzano  I-39100 Bozen-Bolzano, Italy  artale@inf.unibz.it  R. Kontchakov  C. Lutz  School of CS and IS  Department of Computer Science  Birkbeck College  Dresden University of Technology  London WC1E 7HX, U.K.  01062 Dresden, Germany  roman@dcs.bbk.ac.uk  lutz@tcs.inf.tu-dresden.de  F. Wolter  Department of Computer Science  University of Liverpool  Liverpool L69 3BX, U.K.  frank@csc.liv.ac.uk  Abstract  It is known that for temporal languages, such as ďŹrstorder LT L, reasoning about constant (time-independent)  relations is almost always undecidable. This applies to temporal description logics as well: constant binary relations  together with general concept subsumptions in combinations of LT L and the basic description logic ALC cause  undecidability. In this paper, we explore temporal extensions of two recently introduced families of âweakâ description logics known as DL-Lite and EL. Our results are  twofold: temporalisations of even rather expressive variants of DL-Lite turn out to be decidable, while the temporalisation of EL with general concept subsumptions and  constant relations is undecidable.  M. Zakharyaschev  School of Comp. Sci. and Inf. Syst.  Birkbeck College  London WC1E 7HX, U.K.  michael@dcs.bbk.ac.uk  of the ďŹow of time (the natural numbers N for LT L) and the  domains of the DL interpretations. Thus, a model for the  combined language consists of a ďŹow of snapshots that represent the domains of interest at various time points. This  semantics corresponds to the semantics of ďŹrst-order temporal logics (more precisely, to ďŹrst-order temporal models with constant domains; varying and expanding domains  have been considered as well in temporalised DLs, but they  are not within the scope of this paper). In fact, the translation of standard DLs into ďŹrst-order logic can be extended  to a translation of temporalised DLs into ďŹrst-order temporal logics. For this semantics, the expressivity and computational complexity of combinations of LT L and DLs  extending the standard Boolean DL ALC have been completely classiďŹed [14, 4]. Instead of trying to summarise all  the available results here, we only point out one of the main  insights from this investigation:  â˘ combinations of LT L and ALC, which allow general  concept inclusions (GCIs) C1  C2 , are decidable (in  fact, usually E XP S PACE-complete) if, and only if, the  temporal operators are not applied to binary relations  (roles) and, more generally, no constraints are imposed  on the binary relations.  1. Introduction  Over the last 15 years, many temporalised versions of  description logics (DLs) have been suggested and investigated. We refer the reader to the survey papers and monograph [6, 14, 4] where the history of the development of  both interval and point-based temporal extensions of DLs  is discussed in full detail. Our main concern in this paper are extensions of DLs by point-based temporal logics,  in particular the standard linear time temporal logic LT L  (see [13] and references therein). The current state of the  art in this ďŹeld can be summarised as follows: it is generally agreed that the semantics of combined temporal description logics should be based on the Cartesian products  In other words, as long as one only wants to reason about the  temporal behaviour of axioms (corresponding to closed formulas) and concepts (corresponding to unary predicates),  the resulting combination is likely to be decidable; but as  soon as the combination allows reasoning about the temporal behaviour of binary relations it becomes undecidable.  This phenomenon is well understood and reďŹected in the  deďŹnition of, e.g., the monodic fragments of ďŹrst-order tem-  14th International Symposium on Temporal Representation and Reasoning (TIME'07  0-7695-2836-8/07 $20.00 ÂŠ 2007  poral logics [17, 12]. In particular, the undecidability results  hold for the most important temporal constraint on binary  relations, namely, that a role is constant over time: even  a single constant role results in an undecidable combination of ALC and LT L with GCIs. Without GCIs, temporal description logics may be decidable even with constant  roles [14].  Unfortunately, many applications of temporal description logics (say, temporal data modelling, which will be  brieďŹy discussed in Section 3, or dynamic ontologies) require both GCIs and temporal constraints on roles, in particular constant roles. It was this problem that motivated  the research which resulted in this paper. More precisely,  our main aim was to ďŹnd out whether it is possible to design useful combinations of LT L and DLs with GCIs and  constant roles that are still decidable.  Recent developments in description logic have opened a  new path to follow in designing such languages. First, the  recognition of the importance of tractable reasoning and, in  particular, query answering over DL ontologies with GCIs  has given rise to the investigation of the new DL-Lite family  of DLs [10, 11, 2]. And second, the use of huge DL-based  ontologies with GCIs in bio- and medical informatics has  led to the introduction and investigation of âweakâ DLs (reďŹecting the expressive power of existing ontologies) with  tractable subsumption algorithms, namely, the EL-family  of DLs [5, 7, 8]. Both families of DLs lack some of the  expressive power of ALC but have nevertheless proved expressive enough for a number of applications. In this paper,  we explore to which extent these new families of DLs can  provide basis for useful and still decidable combinations of  LT L and DLs with GCIs and constant roles.  The obtained results are twofold. On the one hand, we  prove in Section 4 that the combination of one of the most  expressive versions DL-Litebool of DL-Lite with LT L is indeed decidable (in E XP S PACE), even with GCIs and constant roles. Moreover, its Krom fragment turns out to be  decidable in PS PACE. The proofs are based on an embedding into the one-variable fragment of ďŹrst-order temporal  logic. This means, in particular, that reasoning in temporal  DL-Lite can be supported by available temporal provers;  see, e.g., [12]. On the other hand, we show in Section 7 that  the corresponding combination of EL and LT L is undecidable. The meaning of these results is analysed in Section 8.  combinations of GCIs and ABox assertions. Moreover,  we will distinguish between local and global role names.  Thus, TDL-Litebool contains object names a0 , a1 , . . . , concept names A0 , A1 , . . . , local role names P0 , P1 , . . . , and  global role names T0 , T1 , . . . . Roles R, basic concepts B  and concepts C of TDL-Litebool are deďŹned as follows:  R  B  C  |  Pi  âĽ  B  |  |  Piâ  Ti | Tiâ ,  Ai | âĽ q R,  ÂŹC | C1  C2 |  C  | C1 U C2 ,  |  where q âĽ 1 is a natural number (note that the results of  this paper do not depend on whether q is given in unary or  in binary). TDL-Litebool formulas are built from atoms of  the form  C1  C2 ,  C(ai ),  R(ai , aj )  with the help of the Boolean connectives (say, ÂŹ and â§) and  the temporal operators  and U. The atoms C1  C2 are  often called general concept inclusions (GCIs), while the  atoms C(ai ) and R(ai , aj ) are called ABox assertions.  A TDL-Litebool interpretation I is a function      I(n)  I(n)  I(n)  I(n)  I(n) = Î, a0 , . . . , A0 , . . . , P0 , . . . , T0 , . . . ,  I(n)  I(n)  where Î is a nonempty set, n â N, ai  â Î, Ai  â Î,  I(n)  I(n)  I(n)  I(m)  Pi  â Î Ă Î, Ti  â Î Ă Î, with ai  = ai  I(n)  I(m)  I(n)  I(n)  and Ti  = Ti  , for all n, m â N, and ai  = aj ,  for all i = j and all n â N (the last condition means the  unique name assumption, which standard in DL). The role  and concept formation constructors are interpreted in I as  follows (where Ri is either a local or global role name):  (Riâ )I(n) =  I(n)  âĽ  I(n)  (âĽ q R)    I(n)   (y, x) | (x, y) â Ri  ,  = â,      = x â Î | {y | (x, y) â RI(n) } âĽ q ,  (ÂŹC)I(n) = Î \ C I(n) ,  I(n)  (C1  C2 )I(n) = C1  (C)  I(n)  (C1 U C2 )I(n)  2. Temporal extension of DL-Litebool  We begin by introducing the temporal extension  TDL-Litebool of one of the most expressive description logics DL-Litebool of the DL-Lite family [2]. It combines the  temporal operators of LT L,  (âat the next momentâ) and  U (âuntilâ), with the language of DL-Litebool in a straightforward manner by applying them to concepts and Boolean  ::=  ::=  ::=  I(n)  âŠ C2  ,  I(n+1)  = C  ,    I(k)  C2  =  âŠ  k>n    I(m)  C1  .  n<m<k  The standard abbreviations  âĄ ÂŹâĽ, âR âĄ (âĽ 1 R),  C1  C2 âĄ ÂŹ(ÂŹC1  ÂŹC2 ), â¤ q R âĄ ÂŹ(âĽ q + 1 R),  U C (âsome  (= q R) âĄ (â¤ qR)  (âĽ q R), 3F C âĄ  time in the futureâ) and 2F C âĄ ÂŹ3F ÂŹC (âalways in the  futureâ) we need in what follows are self-explanatory and  correspond to the intended semantics.  14th International Symposium on Temporal Representation and Reasoning (TIME'07  0-7695-2836-8/07 $20.00 ÂŠ 2007  The satisfaction relation (I, n) |= Ď, for a TDL-Litebool  formula Ď, is deďŹned inductively:  I(n)  (I, n) |= C1  C2 iff C1  (I, n) |= C(ai ) iff  (I, n) |= R(ai , aj ) iff  (I, n) |= ÂŹĎ  (I, n) |= Ď1 â§ Ď2  (I, n) |= Ď  (I, n) |= Ď1 U Ď2  I(n)  â C2  ,  I(n)  ai  â C I(n) ,  I(n) I(n)  (ai , aj ) â  RI(n) ,  iff (I, n) |= Ď,  iff (I, n) |= Ď1 and (I, n) |= Ď2 ,  iff (I, n + 1) |= Ď,  iff there is k > n with (I, k) |= Ď2  and (I, m) |= Ď1 for all n < m < k.  We will also freely use the Booleans â and â¨ and the temporal operators 2F and 3F for formulas. A formula Ď is  satisďŹable if there is an interpretation I and a time point n  such that (I, n) |= Ď.  Observe that the interpretation of object names and  global role names is time-independent, while the interpretation of local role names and concepts is allowed to vary  over time. Time-independent   can be introduced     concepts  A and 2+ A  A ,  A    by means of the axioms 2+  F  F  where 2+  F Ď âĄ Ď â§ 2F Ď.  At ďŹrst sight one might think that the satisďŹability problem for this logic is undecidable because using a single  global functional role T (functionality can be ensured by  the axiom âĽ 2 T  âĽ) with functional T â one can easily  enforce the existence of a N Ă N grid, which could possibly  be used to encode the undecidable N Ă N tiling problem.  However, the language is not capable of expressing the requirements on colour matching in the domain âdimension,â  i.e., that if (x, y) â T I(n) then the colours of tiles covering  x and y match (which can be easily expressed with the qualiďŹed existential quantiďŹer âT.C). In fact, as we shall see  in the next section, TDL-Litebool can be embedded in the  one-variable fragment of ďŹrst-order temporal logic, which  is known to be decidable, actually, E XP S PACE-complete;  see, e.g., [14]. Note that satisďŹability in DL-Litebool is NPcomplete [2].  3. Temporal data modelling with TDL-Litebool  Here we brieďŹy discuss how TDL-Litebool can be used  for temporal data modelling. It was argued in [10] that the  underlying DL DL-Litebool can represent atemporal conceptual data models like UML class diagrams and EntityRelationship models. For example, one maps entities E,  denoting sets of abstract objects, into concept names AE .  Then one can represent the subclass relation (ISA) and  disjointness between E1 and E2 by AE1  AE2 and  AE1  ÂŹAE2 , respectively, and to express that E is covered by E1 , . . . , En one can use AE  AE1  Âˇ Âˇ Âˇ  AEn  and AE1  AE , . . . , AEn  AE . To capture an n-ary relationship R over entities E1 , . . . , En , one reiďŹes the relationship. First, take a concept name AR and n role names  R1 , . . . , Rn . The GCIs AR  (= 1 Ri ) ensure that every  instance of AR gives rise to a unique tuple in R; the GCIs  âRiâ  AEi guarantee that only instances of E1 , . . . , En  may be connected by R. Participation constraints are  captured by cardinality restrictions AEi  (âĽ k Riâ ) and  AEi  (â¤ m Riâ ). An attribute P of an entity E, associating values of a concrete domain D to instances of E, is considered as a binary relationship linking E with D: this can  be captured by a concept AP and a pair of functional roles  P1 and P2 with the GCIs AP  (= 1 P1 ), AP  (= 1 P2 ),  âP1â  AE and âP2â  D.  In the temporal context, we can express all those constraints using 2+  F (C1  C2 ) instead of the atemporal  C1  C2 . Below we write C1 â C2 for 2+  F (C1  C2 ).  However, even at this basic level, global roles are already  required: when reifying relationships, to ensure that every  instance of AR represents the same tuple at different times,  the roles Ri should be global; similarly, the roles P1 and  P2 introduced for an attribute P should be global. Moreover, concrete domains should be constant and disjoint: this  is captured by (D â D) â§ (D â D), for all D, and  D â ÂŹD , for all distinct concrete domains D, D .  In addition, the temporal constructors of TDL-Litebool  are able to represent dynamic aspects of conceptual models. Timestamping is the basic temporal constraint used to  model the temporal behaviour of entities, relationships and  attributes [18, 3]. It is implemented either by marking entities, relationships and attributes as snapshot or temporary,  or leaving them unmarked. An object belongs to a snapshot entity either never or at all times, no object may belong  to a temporary entity at all times, and there are no temporal assumptions about instances of unmarked entities. The  meaning of timestamps for relationships and attributes is  analogous. In TDL-Litebool timestamps are expressed by  the following formulas: (AE â AE ) â§ (AE â AE )  for a snapshot/global entity and (  3+  F ÂŹAE ) for a temporary entity. Timestamping formulas for a relationship R  involve the concept name AR that reiďŹes the relationship;  then we need (AR â AR ) â§ (AR â AR ) for the  snapshot/global relationship, and (  3+  F ÂŹAR ) for the  temporary relationship. Attributes are treated similarly.  Finally, TDL-Litebool is capable of capturing dynamic  transitions between entities where objects of a source entity,  E1 , migrate to a target entity, E2 , with the help of the GCI  AE1 â 3F AE2 .  It was observed in [1] that temporal conceptual models  with timestamping and evolution constraints can be translated into the DL DLRU S and that reasoning with temporal  models with both timestamping and dynamic constraints is  undecidable. The main difference here is that TDL-Litebool  14th International Symposium on Temporal Representation and Reasoning (TIME'07  0-7695-2836-8/07 $20.00 ÂŠ 2007  lacks the ability to represent sub-relationships which is an  essential part in the undecidability proof.  where A is a concept name and R a role. Next, we extend  this translation to TDL-Litebool -formulas:  (C1  C2 )â  (C(ai ))â  (ÂŹĎ)â  (Ď)â  4. TDL-Litebool is E XP S PACE-complete  This result is proved by providing a satisďŹability preserving translation of TDL-Litebool formulas into the onevariable fragment QT L1 of ďŹrst-order temporal logic without function symbols and equality. To deďŹne the syntax of  QT L1 , ďŹx one variable x. Then the formulas of QT L1 are  constructed from unary predicates P (x) and P (ai ) (where  ai is a constant) and propositional variables p using the  standard connectives of ďŹrst-order logic (with quantiďŹers  âx and âx) and the temporal operators  and U. QT L1 models and the satisfaction relation between formulas and  time points are deďŹned in the obvious way by modifying the  deďŹnition of TDL-Litebool interpretations (however, there is  no unique name assumption in this case); for details we refer the reader to [14], where the following is also shown:  1  Theorem 1. The satisďŹability problem for QT L -formulas  is E XP S PACE-complete.  Now we deďŹne a translation Âˇâ  of TDL-Litebool formulas into QT L1 . Let Ď be a TDL-Litebool formula. Denote by role(Ď) the set of both local and global role names  occurring in Ď, by g-role(Ď) the set of global role names  in Ď, and by ob(Ď) the set of object names in Ď. Let  roleÂą (Ď) = {R, Râ | R â role(Ď)} and g-roleÂą (Ď) =  {T, T â | T â g-role(Ď)}. Denote by qĎ the maximum  numerical parameter in Ď.  With every object name ai â ob(Ď) we associate the individual constant ai of QT L1 and with every concept name  Ai the unary predicate Ai (x) from the signature of QT L1 .  For each R â roleÂą (Ď), we also introduce qĎ fresh unary  predicates Eq R(x), for 1 â¤ q â¤ qĎ . Intuitively, for each  n, E1 R(x) and E1 Râ (x) represent the domain and range  of R at moment n (i.e., E1 R(x) and E1 Râ (x) are interpreted by the sets of points with at least one R-successor  and at least one R-predecessor at moment n, respectively),  while Eq R(x) and Eq Râ (x) represent the sets of points  with at least q distinct R-successors and at least q distinct R-predecessors at moment n. Additionally, for each  pair ai , aj â ob(Ď) and each role R â roleÂą (Ď), we take  a fresh propositional variable Rai aj of QT L1 to encode  R(ai , aj ).  By induction on the construction of a TDL-Litebool concept C we deďŹne the QT L1 - formula C â :  âĽâ  (A)â  (ÂŹC)â  (C)â  = âĽ,  = A(x),  = ÂŹC â (x),  = C â (x),  = âx (C1â (x) â C2â (x)),  = C â (ai ),  (R(ai , aj ))â = Rai aj ,  = ÂŹĎ â ,  (Ď1 â§ Ď2 )â = Ď1â â§ Ď2â ,  = Ď â ,  (Ď1 U Ď2 )â = Ď1â U Ď2â ,  where C, C1 , C2 are concepts, R is a role and ai , aj are  object names.  The following formulas express some natural properties  of the role domains and ranges. For every R â roleÂą (Ď),  we need two QT L1 -sentences:  Îľ(R) = âx E1 R(x) â âx inv(E1 R)(x),  qĎ â1  Î´(R) =      âx Eq+1 R(x) â Eq R(x) ,  (2)  q=1  where inv(E1 R) is the predicate E1 Rkâ if R = Rk and  E1 Rk if R = Rkâ . Sentence (1) says that if the domain  of R is not empty then its range is not empty either.  We also need formulas representing the relation of the  Rai aj with the unary predicates for the role domain and  range. For a role R â roleÂą (Ď), let    qĎ  q  Ď(R) =  q=1  Raaji â Eq R(a) , (3)  i=1  aâob(Ď)  aj1 ,...,ajq âob(Ď)  ji =ji for i=i      Rai aj â inv(R)aj ai ,  Îš(R) =  (4)  ai ,aj âob(Ď)  where inv(R)aj ai is the propositional variable Rkâ aj ai if  R = Rk and Rk aj ai if R = Rkâ .  For every global role T â g-roleÂą (Ď) we need two additional sentences:  qĎ  Îł1 (T ) =      âx Eq T (x) â Eq T (x) ,  (5)  (T ai aj â T ai aj ).  (6)  q=1  Îł2 (T ) =  ai ,aj âob(Ď)  Finally, we set  Ďâ  = Ďâ      2+  F Îľ(R)â§Î´(R)â§Ď(R)â§Îš(R)  â§  RâroleÂą (Ď)  â§  (âĽ q R)â = Eq R(x),  (C1  C2 )â = C1â (x) â§ C2â (x),  (C1 U C2 )â = C1â (x) U C2â (x),  (1)      2+  F Îł1 (T ) â§ Îł2 (T ) .  T âg-roleÂą (Ď)  Theorem 2. A TDL-Litebool formula Ď is satisďŹable iff Ďâ  is satisďŹable.  14th International Symposium on Temporal Representation and Reasoning (TIME'07  0-7695-2836-8/07 $20.00 ÂŠ 2007  Proof. (â) Let M be a ďŹrst-order temporal model with a  countable domain D and let (M, 0) |= Ďâ  . We denote the  interpretation of unary predicates P and propositional variables p in M at moment n by P M,n and pM,n . The interpretation of constants a in M is denoted by aM . Let      W0 = aM | a â ob(Ď) â D.  Without loss of generality we may assume that all the aM  are distinct.  We are going to construct a TDL-Litebool interpretation  I satisfying Ď that is based on the domain  Î = W0 âŞ (D Ă N).  The interpretations of object names in I are given by their  interpretations in M: aI(n) = aM â W0 . The interpretations AI(n) of concept names A in I are deďŹned by taking      (7)  AI(n) = w â Î | (M, n) |= Aâ [cp(w)] ,  where the function cp : Î â D is deďŹned as follows:  cp(w) =  w,  d,  if w â W0 ,  if w = (d, n) â D Ă N.  (8)  We will call w a copy of cp(w). Now, for each R â role(Ď)  and each n â N, we introduce inductively the interpretation  RI(n) . (For global R this can be done for some ďŹxed n, say  0, and then copied for all other n.) RI(n) will be deďŹned as  the union  â    Rn,m ,  RI(n) =  m=0  where, for all m âĽ 0, Rn,m â WRn,m Ă WRn,m ,  WRn,m â WRn,m+1 and  â    m=0  WRn,m = Î.  We start with WRn,0 = W0 . The set WRn,m \ WRn,mâ1 , for  m âĽ 0, will be denoted by VRn,m ; for convenience, we let  WRn,â1 = â, so that VRn,0 = W0 .  First we deďŹne the required R-rank rn (R, d) of d â D  at moment n:  â§  0,  if (M, n) |= ÂŹE1 R[d],  âŞ  âŞ  âŞ  â¨q,  if  (M, n) |= Eq R â§ ÂŹEq+1 R[d],  rn (R, d) =  âŞ  for 1 â¤ q < qĎ ,  âŞ  âŞ  âŠ  qĎ , if (M, n) |= EqĎ R[d].  It follows from (2) that rn (R, d) is a function and that if  d â D and rn (R, d) = q then (M, n) |= Eq R[d] whenever  1 â¤ q  â¤ q, and (M, n) |= ÂŹEq R[d] for q < q  â¤ qĎ .  n  (R, w) of w â Î at  We also deďŹne the actual R-rank rm  moment n and step m by taking  â§  n,m  n,m  âŞ  â¨q, if w â âĽ q R .Î\âĽ q + 1 R .Î,  n  rm (R, w) =  for 0 â¤ q < qĎ ,  âŞ  âŠ  n,m  qĎ , if w â âĽ qĎ R .Î,      where âĽ q S.Î = x â Î | {y | (x, y) â S} âĽ q , for a  binary relation S.  For the basis of induction we set      M  Rn,0 = (aM  i , aj ) â W0 Ă W0 | (M, n) |= Rai aj . (9)  By (3) and (4), for both R and Râ (where Rââ = R) and  all w â W0 ,  r0n (R, w) â¤ rn (R, cp(w)).  (10)  Suppose that the WRn,m and Rn,m have already been den  (R, w) = rn (R, cp(w)),  ďŹned for m âĽ 0. If we had rm  â  for both R and R and all w â WRn,m , then the interpretation Rn,m we need for RI(n) would have been constructed.  However, in general this is not the case because there may  be some âdefectsâ in the sense that the actual rank of some  points is smaller than the required rank. Consider the following two sets of defects in Rn,m :      n  În,m  = w â VRn,m | rm  (R, w) < rn (R, cp(w)) ,  R      n  w â VRn,m | rm  (Râ , w) < rn (Râ , cp(w)) .  În,m  Râ =  The purpose of, say, În,m  is to identify those âdefectiveâ  R  points w â VRn,m from which precisely rn (R, cp(w)) distinct R-arrows should start (according to M), but some arn  (R, w) many arrows exist).  rows are still missing (only rm  To âcureâ these defects, we extend WRn,m to WRn,m+1 and  Rn,m to Rn,m+1 according to the following rules:  n,m  n  n  (În,m  R ) Let w â ÎR . Denote q = r (R, d) â rm (R, w)  and d = cp(w). Then (M, n) |= Eq R[d] for some  q  âĽ q > 0. By (2), (M, n) |= E1 R[d] and, by (1),  there is d â D such that (M, n) |= E1 Râ [d ]. In  this case we take q fresh copies w1 , . . . , wq of d ,  i.e., w1 , . . . , wq â ({d } Ă N) \ WRn,m , add them to  WRn,m+1 and add the pairs (w, wi ), 1 â¤ i â¤ q, to  Rn,m+1 .  n,mâ  n  â  n  â  (În,m  Râ ) Let w â ÎRâ . Denote q = r (R , d)ârm (R , w)  â  and d = cp(w). Then (M, n) |= Eq R [d] for some  q  âĽ q > 0. By (2), (M, n) |= E1 Râ [d] and,  by (1), there is d â D with (M, n) |= E1 R[d ].  In this case we take q fresh copies w1 , . . . , wq of d ,  i.e., w1 , . . . , wq â ({d } Ă N) \ WRn,m , add them to  WRn,m+1 and add the pairs (wi , w), 1 â¤ i â¤ q, to  Rn,m+1 .  14th International Symposium on Temporal Representation and Reasoning (TIME'07  0-7695-2836-8/07 $20.00 ÂŠ 2007  (ÎŠ) Finally, if all defects for R in WRn,m have already  been cured we take, for every d â D, a fresh copy  (d, l) â ({d} Ă N) \ WRn,m with minimal l and add it  to WRn,m+1 .  It  be clear that the rule (ÎŠ) guarantees that  âshouldn,m  W  = Î. Now we observe the following imR  m=0  portant property of the construction: for all m0 âĽ 0 and  w â VRn,m0 ,  â§  0, if m < m0 ,  âŞ  âŞ  âŞ  â¨  q, if m = m0 , for some  n  (11)  (R, w) =  rm  âŞ  q â¤ rn (R, cp(w)),  âŞ  âŞ  âŠ n  r (R, cp(w)), if m > m0 .  To prove this property, consider all possible cases. If  m < m0 then w has not been added to WRn,m yet, i.e.,  n  (R, w) = 0. If m = m0 and  w â  / WRn,m , and so rm  n  m0 = 0 then rm (R, w) â¤ rn (R, cp(w)) follows from (10).  If m = m0 and m0 > 0 then w was added at step m0  either to cure a defect of some point w â WRn,m0 â1 or  n  (R, w) = 0,  by (ÎŠ). In the latter case we clearly have rm  n  n  and so rm (R, w) â¤ r (R, cp(w)). In the former case this  n,m0 â1  or  means that either (w , w) â Rn,m0 and w â ÎR  n,m0 â1    n,m0    and w â ÎRâ  . In the ďŹrst case  (w, w ) â R  (M, n) |= E1 Râ [cp(w)].  (12)  Since fresh witnesses w are picked up every time the rule  n,m0 â1  ) is applied and those witnesses satisfy (12),  (ÎR  n  n  (R, w) = 0, rm  (Râ , w) = 1 and  we obtain rm  0  0  n  â  r (R , cp(w)) âĽ 1. The second case is similar. If  m = m0 + 1 then all defects of w are cured at step m0 + 1  0  0  ) and (În,m  by applying the rules (În,m  R  Râ ). Therefore,  n  n  rm0 +1 (R, w) = r (R, cp(w)). If m > m0 + 1 then (11)  follows from the observation that new arrows involving w  can only be added at step m0 + 1, that is, for all m âĽ 0,  Rn,m+1 \ Rn,m  n  (R, w) =  w â VRn,m0 . Then, by (11), we have q â¤ rm  n  r (R, cp(w)), for all m > m0 . So, by the deďŹnition of  rn (R, cp(w)) and (2), we have (M, n) |= Eq R[cp(w)].  Now we show by induction on the construction of concepts C in Ď that, for all n â N and w â Î,  (M, n) |= C â [cp(w)]  (M, n) |= Ď â  iff  VRn,m+1 Ă VRn,m .  (M, n) |= Eq R[cp(w)] iff w â âĽ q RI(n) .Î.  (16)  The translation Ďâ  of Ď is obviously too lengthy to provide us with reasonably low complexity results. However, it  follows from the proof above that in fact a lot of information  in this translation is redundant and can be safely omitted.  We deďŹne now a more concise translation of Ď into QT L1 .  For R â roleÂą (Ď), let QR  Ď be the set of natural numbers  containing 1 and all the numerical parameters q for which  âĽ q R occurs in Ď. Then we set  Ď = Ďâ          2+  F Îľ(R) â§ Î´ (R) â§ Ď (R) â§ Îš(R)  â§  RâroleÂą (Ď)       2+  F Îł1 (T ) â§ Îł2 (T ) ,  T âg-roleÂą (Ď)  (13)  Finally, recall that if R is global then, by (5) and (6),  the above inductive procedure does not depend on n and  RI(n) = RI(m) , for all n, m â N.  It follows that, for all R â roleÂą (Ď), 1 â¤ q â¤ qĎ , n â N  and w â Î,  (I, n) |= Ď.  For Ď = C1  C2 and Ď = C(ai ), this follows from (15).  I(n)  For Ď = Rk (ai , aj ), (aIi , aIj ) â Rk  iff, by (13),  (aIi , aIj ) â Rkn,0 iff, by (9), (M, n) |= Rk ai aj . The case  Ď = Rkâ (ai , aj ) is similar. The induction step for the  Booleans (Ď = ÂŹĎ1 and Ď = Ď1 â§ Ď2 ) and the temporal operators (Ď = Ď1 and Ď = Ď1 U Ď2 ) follows from the  induction hypothesis.  Thus, we obtain (I, 0) |= Ď. The implication (â) is  straightforward.  â§  âŞ  (15)  The basis of induction is trivial for B = âĽ and follows  from (7) if B = Ai and (14) if B = âĽ q R. The induction  step for the Booleans (C = ÂŹC1 and C = C1  C2 ) and the  temporal operators (C = C1 and C = C1 U C2 ) follows  from the induction hypothesis.  Finally, we show that for each subformula Ď of Ď,  â  VRn,m Ă VRn,m+1  w â C I(n) .  iff  where Îľ(R), Îš(R) and Îł2 (T ) are as before (see (1), (4) and  (6), respectively),      Î´  (R) =  âx Eq R(x) â Eq R(x) ,  (17)  (14)  Indeed, if (M, n) |= Eq R[cp(w)] then, by deďŹnition,  rn (R, cp(w)) âĽ q. Let w â VRn,m0 . Then, by (11),  n  (R, w) = rn (R, cp(w)) âĽ q, for all m > m0 . It  rm  n  (R, w) and RI(n) that  follows from the deďŹnition of rm  I(n)  .Î. Conversely, let w â âĽ q RI(n) .Î and  w â âĽ qR  14th International Symposium on Temporal Representation and Reasoning (TIME'07  0-7695-2836-8/07 $20.00 ÂŠ 2007    q,q  âQR  Ď , q >q    q >q >q for no q  âQR  Ď      Ď  (R) =  qâQR  Ď  q  Raaji â Eq R(a) , (18)  aâob(Ď) i=1  aj1 ,...,ajq âob(Ď)  ji =ji for i=i      âx Eq T (x) â Eq T (x) .  Îł1 (T ) =  qâQT  Ď  (19)  Corollary 3. A TDL-Litebool formula Ď is satisďŹable iff the  QT L1 -sentence Ď is satisďŹable.  Proof. Follows from the fact that Ďâ  is satisďŹable iff Ď is  satisďŹable. Indeed, if (M, 0) |= Ďâ  then (M, 0) |= Ď .  Conversely, if (M, 0) |= Ď then one can construct a new  model M based on the same domain D as M by taking    â˘ AM ,n = AM,n , for all concept names A and n â N;    â˘ Eq RM ,n = Eq RM,n , for R â roleÂą (Ď), 1 â¤ q â¤ qĎ  and n â N, where q  is the maximum number from QR  Ď  with q  â¤ q;  â˘ Rai aj to be true in M at n iff (M, n) |= Rai aj , for  all R â roleÂą (Ď), all ai , aj â ob(Ď) and all n â N;    â˘ aM = aM , for all a â ob(Ď).  It follows immediately from the deďŹnition that we have  (M , 0) |= Ďâ  . (For example, (M , 0) |= Ďâ follows from  the fact that for every concept (âĽ q R) from Ď we have    Eq RM ,n = Eq RM,n , for all n â N.)  This observation makes it possible to prove the following  result:  Theorem 4. The satisďŹability problem for TDL-Litebool is  E XP S PACE-complete.  Proof. As we know, satisďŹability for QT L1 is E XP S PACEcomplete. However, we cannot use this result directly because the size of Ď is exponential in the number of object names (in fact, double exponential, if qĎ is given in  binary): |Ď | â¤ const Âˇ |Ď| + |ob(Ď)|qĎ +1 . Instead, we use  the E XP S PACE algorithm presented in [14, Theorem 11.30]  (see also [16]) which, given a QT L1 -sentence Ď, decides  whether Ď is satisďŹable or not by guessing an ultimately periodical quasimodel such that the lengths of its preďŹx and  its period are bounded by some numbers l1 and l2 , respectively. In general, both l1 and l2 are double exponential in  the length |Ď| of Ď. Hence, the algorithm requires single  exponential space to write down the two numbers. The algorithm also requires exponential space to store at most 3  state candidates. Clearly, every realisable state candidate C  for Ď is uniquely determined by the following parameters:  â˘ the set of propositional variables and the set of closed  subformulas of the form âx Ď(x) that belong to the  types of C;  by p1 (|Ď|), where p1 is a polynomial. Next, for each type  for Ď , the number of open subformulas that belong to this  type is bounded by |Ď|, and the number of types in every  state candidate is bounded by 2|Ď| . Therefore, the âtypeâ  part of a state candidate can be stored in space bounded by  2|Ď| Âˇ |Ď|, and so the overall space required to store a state  candidate for Ď is bounded by 2p2 (|Ď|) , for some polynomial p2 . Now, [14, Theorem 11.26] provides more precise  upper bounds on l1 and l2 :  l1 â¤ (Ď ) and l2 â¤ kĎ Âˇ (Ď ) Âˇ  (Ď ) + (Ď ),  where (Ď ) is the number of distinct state candidates, (Ď )  the number of distinct types, and kĎ the number of âeventualities,â i.e., subformulas of Ď of the form Ď1 U Ď2 . It  p2 (|Ď|)  follows from the above argument that (Ď ) â¤ 22  and  (Ď ) â¤ 2p1 (|Ď|) Âˇ 2|Ď| (every type for Ď is uniquely determined by its âpropositionalâ part and the subset of open  subformulas that belong to it). Finally, the number kĎ of  âeventualitiesâ is bounded by |Ď|+2Âˇ|roleÂą (Ď)|. This shows  that although the length of Ď is (double) exponential in |Ď|,  the numbers l1 and l2 are only double exponential in |Ď|  (not triple exponential as one would expect). Therefore, the  algorithm of [14, Theorem 11.30] runs in E XP S PACE.  The E XP S PACE lower bound follows from the fact that  there is a satisďŹability preserving polynomial translation  from QT L1 to TDL-Litebool . First, by introducing new  unary predicates one can transform, in a satisďŹability preserving way, each QT L1 -formula into a QT L1 -sentence  containing neither âx nor nested âx. Such a sentence Ď can  be translated into TDL-Litebool by ďŹrst associating with every unary predicate P (x) a concept name (P (x))âĄ = AP .  For every subformula Ď of Ď with free x, we obtain a concept Ď âĄ by distributing the translation ÂˇâĄ over the connectives , U, ÂŹ and â§, e.g., (Ď1 â§ Ď2 )âĄ = Ď1âĄ  Ď2âĄ . For each  subformula of the form âx Ď, set (âx Ď)âĄ = (  Ď âĄ ).  Now, for QT L1 -sentences, the translation ÂˇâĄ again distributes over the connectives , U, ÂŹ and â§. It is easily  seen that Ď is satisďŹable iff ĎâĄ is satisďŹable.  The same lower bound follows also from Theorem 10  below.  5. TDL-Litekrom is PS PACE-complete  Consider now the Krom fragment TDL-Litekrom of  TDL-Litebool with atomic formulas of the form  D1  D2 ,  â˘ for every type in C, the set of all open subformulas that  belong to this type.  It is easy to compute that Ď contains |roleÂą (Ď)| Âˇ |ob(Ď)|2  propositional variables and |Ď|+3Âˇ|roleÂą (Ď)| closed subformulas of the form âx Ď(x). Therefore, the âpropositionalâ  part of a state candidate can be stored in space bounded  2  ÂŹD1  D2 ,  D1  ÂŹD2 ,  R(ai , aj ),  D(ai ),  where concepts D1 , D2 are formed from basic concepts B  by means of  only:  14th International Symposium on Temporal Representation and Reasoning (TIME'07  0-7695-2836-8/07 $20.00 ÂŠ 2007  D  ::=  B  |  D.  (20)  We can still apply all temporal operators and the Booleans  to formulas. (Note that spatio-temporal logics of a similar  kind were considered in [15] and [9]. Note also that satisďŹability for the underlying DL DL-Litekrom is NL OG S PACEcomplete [2].)  It is readily seen that the Âˇ -translations of TDL-Litekrom  formulas can be transformed in a satisďŹability preserving  way (by introducing abbreviations for nested  operators)  to formulas of the following fragment QT L1krom of QT L1 :  Q(x)  L(x)  Ď  ::= Pi (x) | ÂŹPi (x),  ::= Q(x) | Q(x),      | L(aj ) |  ::= âx L1 (x) â¨ L2 (x)  ÂŹĎ | Ď1 â§ Ď2 | Ď | Ď1 U Ď2 ,  where the Pi are unary predicate symbols and the aj are  constants. Predicates Pi (x) and their negations ÂŹPi (x) will  be called literals; literals Q(x) and -preďŹxed literals will  be called temporal literals.  In this section we establish (using the quasimodel technique from [14]) a PS PACE upper bound for satisďŹability of  QT L1krom formulas from which we obtain the following result (using Lemma 8 and an argument similar to the proof  of Theorem 4):  Theorem 5. The satisďŹability problem for TDL-Litekrom  formulas is PS PACE-complete.  We denote by ÂŹL(x)  Ë  the formula equivalent to ÂŹL(x)  in the above restricted syntax, e.g., ÂŹË Pi (x) is ÂŹPi (x)  and ÂŹË ÂŹPi (x) is Pi (x). For every formula of the form  Q(x), we reserve a unary predicate Q (x) called the surrogate of Q(x). Note that we introduce surrogates only  for temporal literals (unlike âstandardâ quasimodels, here  we do not need to explicitly introduce surrogates for other  temporal subformulas). Given a formula Ď, denote by Ď the  result of replacing all subformulas of Ď of the form Q(x)  by their surrogates.  For a QT L1krom sentence Ď, let cl Ď be the union of  sub0 Ď, ÎŁĎ and the ÎaĎ , for a â con Ď, where sub0 Ď is the  set of closed subformulas of Ď, con Ď the set of all constants  in Ď, and    ÎĎ = Pi (x), ÂŹPi (x), Pi (x), ÂŹPi (x) |    Pi (x) a predicate in Ď ,      ÎŁĎ = âx (L1 (x) â¨ L2 (x)) | L1 (x), L2 (x) â ÎĎ ,      ÎaĎ = L(a) | L(x) â ÎĎ , for a â con Ď.  A state candidate C for Ď is any subset of cl Ď satisfying the  properties    (qs0K ) ĎC = ĎâCâŠÎŁĎ Ď is satisďŹable;  (qs1K ) for every Ď â ÎŁĎ ,  if ĎC |= Ď then Ď â C;  (qs0c ) for every L(a) â ÎaĎ ,  ÂŹL(a)  Ë  â C iff L(a) â  / C;  (qs1c )  for every L1 (a), L2 (a) â ÎaĎ ,  Ë 1 (x) â¨ ÂŹL  Ë 2 (x)) â C;  if L1 (a), L2 (a) â C then âx (ÂŹL  (qsÂŹ ) for every ÂŹĎ â sub0 Ď,  ÂŹĎ â C iff Ď â  / C;  â§  (qs ) for every Ď1 â§ Ď2 â sub0 Ď,  Ď1 â§ Ď2 â C iff Ď1 , Ď2 â C.  Let q be a map associating with every w â N a state  candidate q(w) for Ď. We call q a quasimodel for Ď if the  following conditions hold:  (qm0 ) Ď â q(w0 ), for some w0 âĽ 0;  (qm1 ) for every âx (Q1 (x) â¨ Q2 (x)) â ÎŁĎ ,  âx (Q1 (x) â¨ Q2 (x)) â q(w)  iff âx (Q1 (x) â¨ Q2 (x)) â q(w + 1);  (qm2 ) for every Q(a) â ÎaĎ ,  Q(a) â q(w) iff Q(a) â q(w + 1);  (qm3 ) for every Ď â sub0 Ď,  Ď â q(w) iff Ď â q(w + 1);  (qm4 ) for every Ď1 U Ď2 â sub0 Ď, Ď1 U Ď2 â q(w)  iff there is k > 0 such that Ď2 â q(w + k) and  Ď1 â q(w + n), for all 0 < n < k.  Lemma 6. A QT L1krom sentence Ď is satisďŹable iff there is  a quasimodel for Ď.  Proof. Suppose (M, w0 ) |= Ď. Then      q(w) = Ď â cl Ď | (M, w) |= Ď  deďŹnes a quasimodel for Ď. Conversely, suppose that q is a  quasimodel for Ď.  Claim 7. If {L1 (x), . . . , Lk (x)} â ÎĎ and C is a state  candidate for Ď, then      (21)  ĎC â§ âx L1 (x) â§ Âˇ Âˇ Âˇ â§ Lk (x)  is satisďŹable iff there are no 1 â¤ i, j â¤ k such that  Ë j (x)) â C.  âx (ÂŹL  Ë i (x) â¨ ÂŹL  Proof of claim. As formula (21) is a conjunction of the  form âx Ď1 (x) â§ âx Ď2 (x), it is satisďŹable iff the formula  Ď1 [a] â§ Ď2 [a] is satisďŹable, where a is a constant symbol.  Now, if Ď1 [a] â§ Ď2 [a] is satisďŹable then there are no i, j  Ë j (x)) â C. Conversely, suppose  such that âx (ÂŹL  Ë i (x) â¨ ÂŹL  that there are no such i, j, but Ď1 [a] â§ Ď2 [a] is not satisďŹable. Then Ď1 [a] |= ÂŹĎ2 [a]. By (qs0K ), Ď1 [a] is satisďŹable.  Moreover as it is a 2-CNF,  Ď1 [a] |= ÂŹL1 [a] â¨ Âˇ Âˇ Âˇ â¨ ÂŹLk [a]  implies that there are i, j with Ď1 [a] |= ÂŹLi [a] â¨ ÂŹLj [a].  It follows from (qs1K ) that ÂŹLi [a] â¨ ÂŹLj [a] is a conjunct of  Ď1 [a], contrary to our assumption.  14th International Symposium on Temporal Representation and Reasoning (TIME'07  0-7695-2836-8/07 $20.00 ÂŠ 2007  Say that t â ÎĎ is a type for a state candidate C if  â˘ L(x) â t iff ÂŹL(x)  Ë  â  / t, for every L(x) â ÎĎ ;  â˘ if L1 (x), L2 (x) â t then âx (ÂŹL  Ë 1 (x) â¨ ÂŹL  Ë 2 (x)) â C,  for every L1 (x), L2 (x) â ÎĎ .    By Claim 7, if t is a type for C then ĎC â§âx t is satisďŹable.  Denote by Tw the set of all types for q(w). A pair of types  (t, t ) is called suitable if Q(x) â t iff Q(x) â t . Then  the following two properties hold:  (succ) for each t â Tw there is t â Tw+1 such that (t, t )  is a suitable pair;  (pred) for each t â Tw+1 there is t â Tw such that (t, t )  is a suitable pair.  To show (succ), suppose that t â Tw , but there is no  t â Tw+1 such that (t, t ) is a suitable pair. Let  Q1 (x), . . . , Qk (x) be all temporal literals of the form  Q(x) in t. Then      Ďq(w+1) â§ âx Q1 (x) â§ Âˇ Âˇ Âˇ â§ Qk (x)  is not satisďŹable. By Claim 7, there are i, j such that  âx (ÂŹQ  Ë i (x) â¨ ÂŹQ  Ë j (x)) â q(w + 1). Then, by (qm1 ),  7,  âx (ÂŹË Qi (x) â¨ ÂŹË Qj (x))   â q(w), and so, by Claim    the formula Ďq(w) â§ âx Q1 (x) â§ Âˇ Âˇ Âˇ â§ Qk (x) is not  satisďŹable, contrary to our assumption. Property (pred) is  proved analogously.  Now we deďŹne a set R of ârunsâ through q by taking all    r â wâN Tw  such that (r(w), r(w + 1)) is a suitable pair for every w. By  (succ) and (pred), for every w and every type t â Tw there  is r â R such that r(w) = t.  For a â con Ď and w â N, let      tw  a = L(x) â ÎĎ | L(a) â q(w) .  It follows from (qs0c ) and (qs1c ) that the tw  a are types. Morew+1  ) is a suitable pair for every w.  over, by (qm2 ), (tw  a , ta  , for every w.  Thus, there is ra â R with ra (w) = tw   a    M,w  Consider the model M = R, aM  ,... ,  0 , . . . , P0      M,w  = r â R | Pi â r(w) .  where aM  j = raj and Pi  It is readily checked that (M, w0 ) |= Ď.  Lemma 8. A QT L1krom -sentence Ď is satisďŹable iff there  is an ultimately periodical quasimodel q for Ď such that  q(l1 + w) = q(l1 + l2 + w), for every w â N and some  l1 , l2 with l1 â¤ (Ď) and l2 â¤ kĎ Âˇ (Ď) + (Ď), where (Ď)  is the number of distinct state candidates for Ď and kĎ the  number of eventualities in Ď.  Theorem 9. The satisďŹability problem for QT L1krom is  PS PACE-complete.  Proof. The upper bound follows from Lemma 8 using an  algorithm that ďŹrst guesses l1 and l2 and then tries to construct an ultimately periodical quasimodel (see [14, Theorem 11.30]). The lower bound follows from PS PACEhardness of LT L (which is a fragment of QT L1krom ).  6. TDL-Litehorn is E XP S PACE-complete  Consider the Horn fragment TDL-Litehorn  TDL-Litebool whose atomic formulas are of the form  D1  Âˇ Âˇ Âˇ  Dk  D,  D(ai ),  of  R(ai , aj ),  where D, D1 , . . . , Dk are formed from basic concepts B by  means of  only as in (20). Again we can apply all temporal operators and the Booleans to formulas. (Note that satisďŹability for the underlying DL DL-Litehorn is P-complete  [2].)  Theorem 10. The satisďŹability problem for TDL-Litehorn  is E XP S PACE-complete.  Proof. The upper bound follows from Theorem 4. The  lower one is proved by reduction of the N Ă 2n corridor  tiling problem that is known to be E XP S PACE-complete  (for details see, e.g., [19, 16]): given an instance (T, Ď0 , n),  where T is a ďŹnite set of tile types, Ď0 â T is a tile type, and  n â N is given in unary, decide whether T tiles the N Ă 2n corridor {(x, y) | x â N, 0 â¤ y < 2n } in such a way that  Ď0 is placed at (0, 0) and the top and bottom sides of the  corridor are of some ďŹxed colour, say, white. We construct  a TDL-Litehorn formula ĎT,Ď0 ,n such that (i) its length is  polynomial in |T | and n, and (ii) T tiles the N Ă 2n corridor  (with Ď0 on (0, 0) and with white top and bottom sides) iff  ĎT,Ď0 ,n is satisďŹable.  The formula ĎT,Ď0 ,n will be constructed in a number of  steps. To explain the meaning of its subformulas, let us ďŹx  some interpretation I with some domain Î.  Let SĎ , for Ď â T , be role names and suppose that the  following formula holds in I at 0:          2+  2+   âSĎ â§  F  F âSĎ  âSĎ   âĽ . (22)  Ď =Ď   Ď âT  Then there is a uniquely determined sequence Ď0 , Ď1 , . . . of  I(m)  tile types such that âSĎm = Î and (âSĎâm )I(m) = â, for  every m â N; see Fig. 1.  Suppose also that the following formulas hold in I at 0:  n     â  2+    Qj  N ,  (23)  âS  Ď  F  Proof. Similar to the proof of [14, Theorem 11.26].  14th International Symposium on Temporal Representation and Reasoning (TIME'07  0-7695-2836-8/07 $20.00 ÂŠ 2007  Ď âT  Ď âT  j=1     â  2+  F âSĎ  N  âĽ ,  (24)      N .  2+  F N   (25)  .  Ď0 Ď1 Ď2 Ď3 Ď4 Ď5 Ď6 Ď7 Ď8 Ď9 Ď10 Ď11 Ď12 ...  no âSĎâ , for all Ď  d11  N and no âSĎâ , for all Ď  d10  d9  WĎi  d8  âSĎâi  d7  d6  Qj , for some 1 â¤ j â¤ n  d5  n  d4  j=1  Qj  d3  d2  d1  d0  . 0  1  2  3  4  5  6  7  8  9      10 11 12 ...   N Ă 22 corridor  Figure 1. A model I satisfying ĎT,Ď0 ,2 .  (Formulas of the form D1  Âˇ Âˇ Âˇ  Dk  D1  Âˇ Âˇ Âˇ  Dj  are just syntactic sugar.) It follows that at every moment of  time m one can select a point dm â (âSĎâm )I(m) such that  dm â N I(m+1) and dm â (Qn Âˇ Âˇ ÂˇQ1 )I(m) . The former  implies, by (24) and (25), that the dm are all distinct, and  the latter will be used to encode a 2n counter on dm .  The formulas encoding the 2n counter on elements of  the domain are more or less standard (taking into account  that Qi stands for the i-th bit being 0 and Qi for the i-th bit  being 1):      2+  F Qi  Qi  âĽ ,  1â¤iâ¤n  However, on every dm , the counter is initialised at moment  m and, therefore, is deďŹned correctly on it.  Let B and the WĎ , for Ď â T , be concept names. Then  the following formulas ensure correctness of tiling:  (  (âSĎâ0  Ď âT  down(Ď )=white  Ď,Ď  âT  up(Ď )=down(Ď  )        Qi  2+  F Qi  Qj  Qjâ1  Âˇ Âˇ Âˇ  Q1       1â¤j<iâ¤n  Qi ,  â§ 2+  F Qi  Qj  Qjâ1  Âˇ Âˇ Âˇ  Q1        Qj  2+  F Qj  Qjâ1  Âˇ Âˇ Âˇ  Q1       1â¤jâ¤n      Q    Âˇ  Âˇ  Âˇ    Q    Q  Q  â§ 2+  j  jâ1  1  j .  F  Ď,Ď  âT  right(Ď )=left(Ď  )  Ď âT  n  It follows, in particular, that if the counter is âinitialisedâ on  some d, i.e., d â (Qn  Âˇ Âˇ Âˇ  Q1 )I(k) , for some k â N, then  â˘ d â (Qn  Âˇ Âˇ Âˇ  Q1 )I(j) iff j âĄ k (mod 2n );  â˘ there is 1 â¤ i â¤ n such that d â  (mod 2n ).  I(k)  I(k)  I(j)  Qi  iff j âĄ k  Note also that if d â  / Qi  âŞ Qi , for some 1 â¤ i â¤ n  and k â N, then the counter may not behave properly on d.   âSĎ0 ),  Ď âT i=1  2+  F (B  (26)   B) â§  n    2+  F (B  j=1    B),  Qj  âSĎ  âĽ),  (27)  (28)        2+  F âSĎ  âSĎ   âĽ ,  (29)   â    WĎ  ,  2+  F âSĎ   (30)  n    2+  F WĎ   j=1    Qj  âSĎ  âĽ , (31)      WĎ .  2+  F WĎ  Qi   (32)  Indeed, (26) ensures that Ď0 is placed at (0, 0) and (27) that  d0 â B I(k) , for all k â N. It follows that we have a âmaster counterâ (distinguished by the concept B), which is initialised on d0 at 0 and has value 0 at every moment of time,  when a tile for the bottom row is being selected. Then (28)  guarantees that the bottom of the corridor is coloured white.  14th International Symposium on Temporal Representation and Reasoning (TIME'07  0-7695-2836-8/07 $20.00 ÂŠ 2007  By (29), the adjacent colours of tiles in the same column  match. It also follows from (29) that the top of the corridor  is also white: the up-colour of a tile in the top row matches  the down-colour of the tile at the bottom of the next column,  which is white by (28). To make the colours of adjacent tiles  in the same row match (such tiles are 2n moments of time  apart) we use the 2n counters. Take dm â (âSĎâm )I(m) .  I(m+1)  , for every tile Ď  that cannot be  By (30), dm â WĎ   put to the right of Ďm in a correct tiling. As the counter is  initialised on dm at moment m, it has value 1 at m + 1.  I(m+2)  , for every tile Ď   Then, by (32), we have dm â WĎ   that cannot be put to the right of Ďm . The same argument  iteratively applies until the moment m + 2n â 1 and thereI(m+2n )  , for every tile Ď  that cannot  fore, we have dm â WĎ   be put to the right of Ďm . But then, by (31), no such tile Ď   can be selected as Ďm+2n .  It follows that if ĎT,Ď0 ,n is satisďŹable then T tiles the  N Ă 2n -corridor. The converse implication is clear. Note  that ĎT,Ď0 ,n does not use any number restriction.  7. Temporalised EL is undecidable  In contrast to the positive results above we now show that  even a rather weak temporalisation T LEL of EL with global  roles and GCIs is undecidable. To prove this we do not need  ABox assertions. Moreover, 3F will be the only temporal  concept constructor, and 2+  F the only operator applied to  formulas. Besides, no local roles are required. Formally,  T LEL concepts C are deďŹned as follows:  C ::=  | Ai | C1  C2 | âTi .C | 3F C,  where the Ti are global role names. A T LEL GCI is  a formula of the form 2+  F (C1  C2 ) (often written as  C1 â C2 ), where C1 , C2 are T LEL concepts. Observe  that every set of T LEL GCIs is satisďŹable: they are satisďŹed  in the model where all concepts and roles are interpreted by  the whole domain at every time point.  In fact, the interesting reasoning problem for T LEL is  whether a GCI is a logical consequence of a set of GCIs.  Without the temporal operators, this problem is known to  be decidable in polynomial time [5]. We are now going to  show that it is undecidable for T LEL .  Theorem 11. It is undecidable whether a T LEL GCI is a  consequence of a ďŹnite set of T LEL GCIs.  Proof. The proof is by reduction of the following version  of the undecidable satisďŹability problem for temporalised  ALC. DeďŹne the concepts C of T LALC as follows:  C ::=  | âĽ | Ai | ÂŹC | C1  C2 |  C1  C2 | âTi .C |  3F C.  We introduce , âĽ and  as primitive connectives because  this will be useful in the reduction below. A T LALC GCI  is of the form 2+  F (C1  C2 ), where C1 , C2 are T LALC  concepts. Say that an ALC concept C is satisďŹable relative  to a set of GCIs if there exists a model satisfying C and the  set of GCIs. The following is proved in [14]:  Theorem 12. SatisďŹability of ALC concepts relative to sets  of T LALC GCIs is undecidable.  Suppose now that a set of T LALC GCIs and a concept in  ALC are given. First, we perform a number of satisďŹability  preserving operations.  (a) Ensure that negation ÂŹ occurs in front of concept  names only: for every concept ÂŹC with complex C, introduce a fresh concept name A, replace ÂŹC with ÂŹA, and  add A â C and C â A to the set of GCIs. The resulting  concept is satisďŹable relative to the resulting set of GCIs if  the original one was satisďŹable relative to the original set of  GCIs.  (b) Ensure that ÂŹ does not occur at all in the set of GCIs  nor in the concept: for every concept ÂŹA, introduce a fresh  concept name A, replace every occurrence of ÂŹA with A,  and add â A  A and A  A â âĽ to the set of GCIs.  (c) Ensure that disjunction  does not occur at all in the  set of GCIs nor in the concept: ďŹrst, modulo introduction of  new concept names, we may assume that  does not occur  in the concept and that the only occurrences of  in the set  of GCIs are of the form (i) AB â C and (ii) C â AB,  where A and B are concept names and C is disjunction free.  Denote the resulting set of GCIs by T and the concept by  C0 . Now we replace in T the former kind of GCI with  A â C and B â C. The latter one is replaced with four  GCIs  C â âR. (M  3F X  3F Y ),  âR. (M  3F (X  3F Y )) â A,  âR. (M  3F (Y  3F X)) â A,  âR. (M  3F (X  Y )) â B,  where R is a fresh global role name and X, Y , M are fresh  concept names (for each concept inclusion C â A  B).  Denote by T  the new set of GCIs. Clearly, if C0 is satisďŹable relative to T  , then C0 is satisďŹable relative to T . Conversely, suppose that C0 is satisďŹable relative to T . We may  assume that the witness interpretation has an inďŹnite domain  Î. Consider a GCI C â A  B. Interpret R in such a way  that RI(n) is a forest of inďŹnite outdegree, i.e., RI(n) is  acyclic, for each w â Î there exist inďŹnitely many w â Î  such that (w, w ) â RI(n) , and for each w there exists  at most one w with (w, w ) â RI(n) . Now interpret M by  choosing for each w â C I(n) exactly one node w â M I(n)  with (w, w ) â RI(n) . This can be done in such a way that  M I(n) âŠ M I(m) = â for n = m. Finally, interpret X and  14th International Symposium on Temporal Representation and Reasoning (TIME'07  0-7695-2836-8/07 $20.00 ÂŠ 2007  Y as follows: suppose (w, w ) â RI(m) , w â C I(m) , and  w â M I(m) , for some m. Then w â (A  B)I(m) . If  w â B I(m) , then include w in X I(m+1) and Y I(m+1) .  If w â AI(m) \ B I(m) , then include w in X I(m+1) and  Y I(m+2) . It can be shown that the extended interpretation  I satisďŹes T  and C0 .  Observe that T  and the concept C0 only contain the operators , â, , âĽ, and 3F . We now reduce satisďŹability  of C0 relative to T  to subsumption in T LEL . Introduce a  fresh concept name L, replace every occurrence of âĽ with  L and extend T  with âT.L â L, for every role T from  T  and C0 , and 3F L â L. Then C0 is satisďŹable relative  to T  iff C0 â L does not follow from the new set T  of  GCIs, for the new concept C0 : clearly, if C0 is satisďŹable  relative to T  , then we obtain an interpretation I satisfying  I(0)  = â. Conversely, if  T  in which LI(0) = â but C0  C0 is not satisďŹable relative to T  , then for every interpreI(0)  tation I with w â C0 , there exists a w reachable from  w following a path along global roles T I(0) (from T  and  C0 ) such that w â LI(m) . But then, by the new GCIs,  w â LI(0) .  8. Conclusion  We have shown that temporalisations of various dialects  of DL-Lite are decidable with global roles and GCIs, while  temporalisations of EL are not. The crucial difference between the two languages is the absence of âqualiďŹedâ quantiďŹcation in DL-Lite. As there is no constructor âR.C in  DL-Lite, we can actually encode global roles using temporal constraints on unary predicates. Although we obtain unintended models where roles are not global, the language is  too âweakâ to notice this. Note, however, that these decidability results can easily be ruined by role inclusions. We  have also seen that, in contrast to qualiďŹed quantiďŹcation,  the presence of Boolean operators does not have any impact  on the decision problem: although EL does not contain   and ÂŹ, its temporal dimension together with GCIs is perfectly capable of reintroducing them.  Acknowledgements. The work on this paper was partially supported by the U.K. EPSRC grants GR/S61966,  GR/S63182, GR/S63175, GR/S61973 and Tones, KnowledgeWeb and InterOp projects. We would like to thank the  anonymous referees for their comments.  References  [1] A. Artale. Reasoning on temporal conceptual schemas with  dynamic constraints. In Proc. of TIME 2004, pages 79â86.  IEEE Computer Society, 2004.  [2] A. Artale, D. Calvanese, R. Kontchakov, and M. Zakharyaschev. DL-Lite in the light of ďŹrst-order logic. 2007.  Proc. of AAAI.  [3] A. Artale, C.Parent, and S. Spaccapietra. Modeling the evolution of objects in temporal information systems. In Proc.  of FoIKS-06, volume 3861 of LNCS, pages 22â42. Springer,  2006.  [4] A. Artale and E. Franconi. Temporal description logics.  In M. Fisher, D. Gabbay, and L. Vila, editors, Handbook  of Time and Temporal Reasoning in ArtiďŹcial Intelligence,  pages 375â388. 2005.  [5] F. Baader, S. Brandt, and C. Lutz. Pushing the EL envelope.  In Proc. of IJCAI 2005, pages 364â369, 2005.  [6] F. Baader, R. KuĚsters, and F. Wolter. Extensions to description logics. In Description Logic Handbook, pages 219â261.  Cambridge University Press, 2003.  [7] F. Baader, C. Lutz, and B. Suntisrivaraporn. Is tractable reasoning in extensions of the description logic EL useful in  practice? In Proc. of the Methods for Modalities Workshop  (M4M 2005), 2005.  [8] F. Baader, C. Lutz, and B. Suntisrivaraporn. CELâa  polynomial-time reasoner for life science ontologies. In  Proc. of IJCARâ06, volume 4130 of LNAI, pages 287â291.  Springer, 2006.  [9] P. Balbiani and J.-F. Condotta. Computational complexity  of propositional linear temporal logics based on qualitative  spatial or temporal reasoning. In Proc. of FroCoS 2002, volume 2309 of LNCS, pages 162â176. Springer, 2002.  [10] D. Calvanese, G. De Giacomo, D. Lembo, M. Lenzerini,  and R. Rosati. DL-Lite: Tractable description logics for  ontologies. In Proc. of AAAI 2005, pages 602â607, 2005.  [11] D. Calvanese, G. De Giacomo, D. Lembo, M. Lenzerini, and  R. Rosati. Data complexity of query answering in description logics. In Proc. of KR 2006, pages 260â270, 2006.  [12] A. Degtyarev, M. Fisher, and B. Konev. Monodic temporal resolution. ACM Transactions in Computational Logic,  7:108â150, 2006.  [13] D. Gabbay, I. Hodkinson, and M. Reynolds. Temporal  Logic: Mathematical Foundations and Computational Aspects, Volume 1. Oxford University Press, 1994.  [14] D. Gabbay, A. Kurucz, F. Wolter, and M. Zakharyaschev.  Many-Dimensional Modal Logics: Theory and Applications. Elsevier, 2003.  [15] D. Gabelaia, R. Kontchakov, A. Kurucz, F. Wolter, and  M. Zakharyaschev. Combining spatial and temporal logics:  expressiveness vs. complexity. JAIR, 23:167â243, 2005.  [16] I. Hodkinson, R. Kontchakov, A. Kurucz, F. Wolter, and  M. Zakharyaschev. On the computational complexity of decidable fragments of ďŹrst-order linear temporal logics. In  M. Reynolds and A. Sattar, editors, Proc. of TIME-ICTL  2003, pages 91â98. IEEE Computer Society, 2003.  [17] I. Hodkinson, F. Wolter, and M. Zakharyaschev. Decidable  fragments of ďŹrst-order temporal logics. Annals of Pure and  Applied Logic, 106:85â134, 2000.  [18] C. S. Jensen, J. Clifford, R. Elmasri, S. K. Gadia, P. Hayes,  and S. Jajodia. The consensus glossary of temporal database  concepts. SIGMOD Record, 23(1):52â64, 1994.  [19] P. van Emde Boas. The convenience of tilings. In A. Sorbi,  editor, Complexity, Logic and Recursion Theory, volume  187 of Lecture Notes in Pure and Applied Mathematics,  pages 331â363. Marcel Dekker Inc., 1997.  14th International Symposium on Temporal Representation and Reasoning (TIME'07  0-7695-2836-8/07 $20.00 ÂŠ 2007 