2012 19th International Symposium on Temporal Representation and Reasoning  A Tableau for the Combination of CTL and BCTL*  John C. Mc Cabe-Dansted  School of Computer Science and Software Engineering  University of Western Australia  Perth, Australia  Email: john@csse.uwa.edu.au  quantiﬁes over a bundle of paths. Although this bundle is  sufﬁx and fusion closed it need not be limit closed. For  example, it may be the case that all paths include a right  branch even though at every world there is a path where  the next branch goes left; which violates the limit closure  property. An argument for the 2-EXPTIME hardness of  the decision problem could be made for BCTL* in a way  similar to the argument for CTL* so from a computational  complexity point of view, BCTL* is no easier to deal  with than CTL*; however, the BCTL* logic is traditionally  presented of being of theoretical interest as it is in some  ways easier to reason with than CTL*; for example the  speciﬁcation for the tableau for BCTL* proposed by [6]  was much simpler than the CTL* tableau [4] that was  developed from it. Another example of BCTL* being easier  (though not less computationally complex) to reason with  was the discovery of a simple natural deduction system for  a fragment of BCTL* [7].  In some cases we are interested only in futures that satisfy  some fairness property. For example, when reasoning about  some randomised algorithm it may be desirable to state that  a fair coin could always come up either heads or tails but that  any plausible future would not have an inﬁnite series of tails.  With BCTL*, we can construct a model with some fairness  constraint on the bundle, while in CTL* the obvious attempt  to formalise the fair coin would be a paradox. Every theorem  of BCTL* is a theorem of CTL*. Proving a statement in  BCTL* demonstrates that it is true not only in CTL* but  would also be true if there was some form of fairness  constraint on allowable paths.  Model checking formula CTL* with a bounded number of  non-CTL properties is trivially polynomial. model checking.  Model checking CTL* formulae is most naturally performed  by recursively running a Linear Temporal Logic (LTL)  model checker [8]. While model checking LTL is PSPACE  in general, when the length of the input formula is bounded  the complexity it is linear. For this reason, it is clear that so  long as we place any ﬁnite bound on the length of the pathformulae, that need to be sent to LTL model-checker, we can  model check such CTL* formulae in time linear in the length  of the formula (see for example [9], but note that their main  result is subtly different). This is convenient, as it means that  we do not need to rigidly adhere to any particular syntactic  Abstract—It is known that there is an exponential decision  procedure for CTL. Given that important properties cannot  be expressed in CTL, we seek a pure tableau based decision  procedure (that does not rely on translations into automata)  that is exponential for formulas that have only a bounded  number of non-CTL properties. In this paper we present such  a tableau for a combination of CTL and a bundled variant  (BCTL*) of CTL* that is singly exponential for formulae with  a bounded number of path-subformulae. The existing pure  tableau for CTL* was built upon the pure tableau for BCTL*,  so this paper is also a natural ﬁrst step towards a pure tableau  technique for CTL* that is singly exponential when similarly  restricted.  Keywords-Bundled; Exptime; Logic; Tableaux; Temporal;  I. I NTRODUCTION  There has been recent renewed interest in decision procedures for the branching time Full Computation Tree Logic  (CTL*). It has long been known that CTL* is decidable and  is 2EXPTIME complete, [1] provides a doubly exponential  automaton based satisﬁability checker, and [2] gives a lowerbound. These automaton based satisﬁability checkers are  expected to have performance close to their worst case  on average and have not been implemented [3]. Recently,  tableau based decision procedures have been proposed that  have greater potential for reasonable real world performance,  and that have publicly accessible implementations [3], [4].  However, the worst case performance is clearly still 2EXPTIME, whereas Computation Tree Logic (CTL) has a singly  exponential decision procedure (see for example [5]). CTL  is similar to CTL*, but the syntax of CTL is more restricted,  as CTL pairs each temporal operator with a path-quantiﬁer  in such a way that the truth of a CTL formula does not  depend on which of many possible futures occurs.  CTL is popular and can express many useful properties,  unfortunately CTL cannot represent some important fairness  related properties. Many interesting CTL* formulae are  rather close to being CTL formulae, for example most of  the sample formulae used in [4]. Thus is it natural to seek  decision procedures that are exponential for formulas that  are CTL-like, but that do not need to rigidly adhere to the  syntactic restrictions of CTL.  The BCTL* logic (also known as ∀LT F C) is similar to  the CTL* but instead of quantifying over all paths, instead  1530-1311/12 $26.00 © 2012 IEEE  DOI 10.1109/TIME.2012.17  29  II. BCTL* AND CTL  restriction of CTL* to get model checking performance  asymptotically similar to that of CTL. For example, we can  add any property that can be represented by a CTL* formula  φ to the syntax of CTL and the resulting language can still  be model checked in polynomial time.  A. Syntax  Bundles affect the semantics rather than the syntax. CTL*  and CTL have the same syntax as the corresponding BCTL*  and BCTL logics.  Where p varies over V the set of variables (or atomic  propositions), we deﬁne CTL* formulæ according to the  following abstract syntax:  For formulae with a bounded number of non-CTL properties the decision procedure of [3] already runs in a singly  exponential amount of time, as does the tableau for plain  CTL of [5]. Both the pure tableau of [4], [6] and the hybrid  tableau of [3] have to deal with sets of sets of formulae  leading to doubly exponential running time in the worst case.  In the case of [3] the sets of formulae are called “blocks”  and represent a disjunction (or conjunction) of formulae that  must hold on all (some) futures leaving from a particular  state. It appears that it would be easy for the authors of  [3] to show that CTL-like blocks have a unique derivation,  and so if we limit the number of non-CTL subformulae  we eliminate one exponential from the running time of the  hybrid tableau. However, [3] do not explicitly make this  claim or present such a proof.  φ := p | ¬φ | (φ ∧ φ) | (φU φ) | N φ | Aφ .  The ¬, ∧, N, U and A operators are read as “not”, “and”,  “next”, “until” and “all paths”. We deﬁne the other operators  as abbreviations: ⊥ ≡ (p ∧ ¬p),  ≡ ¬⊥, α ∨ β ≡  ¬ (¬α ∧ ¬β), “Finally” F α = U α, “Globally/Always”  Gα ≡ ¬F ¬α, “Weak Until” αW β ≡ αU β ∨ Gα, “Exists  a Path” Eα ≡ ¬A¬α, α → β ≡ ¬α ∨ β and α ↔ β ≡  (α → β) ∧ (β → α).  The syntax of CTL is as follows:  φ ::= p | ¬φ | (φ ∧ φ) | A (φU ψ) | AN φ | E (φU ψ) .  When combining CTL and BCTL* it can be ambiguous  whether we are using the bundled or unbundled semantics.  To address this, whenever using the unbundled semantics  we will use underlining, so a CTL “AN ” is written instead  “AN ”. To emphasise the difference further we will put the  path quantiﬁer together with the until operator, as in CTL  they cannot be separated. Thus the CTL A (φU ψ) will be  written as φAU ψ, and similarly for the E operator. The  syntax of our combination of CTL and BCTL* is as follows:  Unlike our paper, [3] uses a hybrid automata based  approach. The pure tableau based decision procedure of [6]  for BCTL* requires a doubly exponential amount of time  even when the non-CTL properties are bounded. These two  tableau based techniques are very different and are expected  to have different real-world running times. In particular, the  requirement of the hybrid automata to build parity games  may limit its ability to prove that large but simple formulae  are satisﬁable quickly [10]. As pure tableau work directly  on subformulae of the formulae input by the user, the  proofs generated by a pure tableau technique may be more  meaningful to the user than a proof generated by translation  into automata.  φ := ψ | ¬φ | (φ ∧ φ) | (φU φ) | N φ  ψ := p | ¬ψ | (ψ ∧ ψ) | Aφ | AN ψ | (ψEU ψ) | (ψAU ψ)  Formulae of the form ψ are called state formulae. Formulae  not of the form ψ are called path formulae. We use the following abbreviations for CTL formulae: EN α ≡ ¬AN ¬α,  EF α ≡ EU α, AF α ≡ AU α, EGα ≡ ¬AF ¬α.  In this paper we present a tableau for deciding a combination of CTL and BCTL*. The combination of CTL and  BCTL* allows this tableau to reason about combinations of  bundled and unbundled properties (for examples of these, see  Section II-D). We choose this combination for two reasons.  Firstly, we can combine the tableau for CTL and BCTL*  in a relatively natural way, unlike some other combinations  we have considered. Secondly, it preserves EXPTIME-ness  when the number of path-subformulae is bounded. The  BCTL* tableau considered here can also be considered a  simpliﬁcation of the rather complex tableau for CTL* found  in the 42 page paper [4].  B. BCTL-Structures  In this section we will deﬁne a number of basic terms  that we will then use to deﬁne BCTL-structures. Note that  BCTL*-structures and BCTL-structures are the same, we  will omit the “*” for aesthetic reasons and consistency.  Deﬁnition 1. We say that a binary relation R on S is serial  (total) if for every a in S there exists b in S such that aRb. A  transition frame is a pair (W, ), where W is a non-empty  set of states and  is a serial relation on W .  We note that when only ﬁnite periods of time are considered the bundled and unbundled semantics are equivalent  (see for example [11]). In this case, we can replace pairs of  BCTL* operators with the corresponding CTL operators to  minimise the number of path subformulae and maximise the  performance of this tableau based decision procedure.  Deﬁnition 2. A valuation g is a map from a set of states W  to the power set 2V of the variables. The statement p ∈ g(w)  means roughly “the variable p is true at state w”.  We will now formalize some notation relating to paths,  and which sets of paths can be called bundles.  30  ¬p  Deﬁnition 3. For any relation R we let R∗ (respectively  Rω ) be the set of ﬁnite (resp. inﬁnite) paths through R. We  call an ω-sequence σ = w0 , w1 , . . . of states a fullpath  iff σ ∈ω , that is for all non-negative integers i we have  wi  wi+1 . For all i in N we deﬁne σ≥i to be the fullpath  wi , wi+1 , . . . , we deﬁne σi to be wi and we deﬁne σ≤i  to be the sequence w0 , w1 , . . . , wi . We say that a set of  fullpaths B is fusion closed iff for all non-negative integers  i, j and σ, π ∈ B we have σ0 , σ1 , . . . , σi , πj , πj+1 , . . . ∈  B if σi+1 = πj . We say that a set of fullpaths B is sufﬁx  closed iff for all integers i and σ ∈ B we have σ≥i ∈ B.  We say a set of fullpaths is a bundle if it is non-empty,  sufﬁx closed and fusion closed. We say a bundle B is on a  transition frame (W, ) if B ⊆ω and every edge in   appears in B.  ¬p  ¬p  Figure 1.  p  p  Structure on which AF p is false, but AF p can be true.  Although AGF h ∧ AGEN ¬h is not satisﬁable in CTL* it  is satisﬁable in BCTL*. This can be easy veriﬁed by, for  example, entering the formula (AGFh&AGEX-h) into the  BCTL* web applet [12].  Although a major reason this combination of BCTL* and  CTL was chosen was as a stepping stone to ﬁnding an  efﬁcient pure tableau decision procedure for CTL*, we now  give a number of example formulae that can be reasoned  with using this tableau. One of the possible uses of this  tableau is for testing intuitions of the difference between  bundled and unbundled semantics. For example, we would  expect EN p ↔ EN p to be valid as every edge in   appears in B. As B is sufﬁx and fusion closed, we would  expect EF p ↔ EF p. Since every path in the bundle B is  clearly a path, we would expect EGp → EGp to also be  valid. However, since the difference between bundled and  unbundled logics is that the bundle B need not contain all  paths, we would expect EGp → EGp to be falsiﬁable. In  addition to these trivial examples, the tableau we will deﬁne  in this paper could also reason about more complex examples; such as verifying that E (pU A (pU q)) → (pEU q) is  valid. One example that is good for visualising the difference  between bundled and unbundled semantics is ¬AF p ∧ AF p.  This would be satisﬁed on a binary tree where only the  leftmost branch satisﬁes G¬p. We can construct a bundle  which only includes paths that follow the left edge a ﬁnite  number of times, and so ¬AF p ∧ AF p is satisﬁable (see  Figure 1).  The tableau we will deﬁne can be used to efﬁciently reason about some BCTL* formulae. For a BCTL* formula ψ,  let ψ represent the formula resulting when BCTL operators  are replaced with CTL operators. In many cases ψ and ψ are  equivalent (and we can test whether they are equivalent by  testing whether ψ ↔ ψ is valid). Say we are attempting  to determine whether a BCTL* formula φ is satisﬁable.  We can improve the performance of the decision procedure  by recursively replacing each subformula ψ with ψ when  these are known to be equivalent. In general, for any set  Φ of BCTL* formula consisting only of BCTL* formulae  which are computationally easy to transform into equivalent  formulae with only a bounded number of path-subformulae,  We complete this section with our deﬁnition of BCTLstructures.  Deﬁnition 4. A BCTL-structure M = (W, , g, B) is a  4-tuple containing a set of states W , a serial binary relation   on W , a valuation g on the set of states W , and B is a  bundle on (W, ).  C. Semantics  The semantics of the classical operators is similar to the  deﬁnition in classical logic, although we will use fullpaths  in place of worlds, that is:  M, σ  ¬φ iff M, σ  φ  M, σ  φ ∧ ψ iff M, σ  φ ∧ M, σ  ψ ,  Both CTL* and BCTL* use the operators from propositional  Linear Temporal Logic (LTL),  M, σ  N φ iff M, σ≥1  φ  M, σ  φU ψ iff ∃i ∈ N s.t. M, σ≥i  ψ  and ∀j ∈ N s.t. j < i =⇒ M, σ≥j  φ .  We deﬁne the semantics of the BCTL* Bundled All Paths  operators A and the CTL* All Paths operator A as follows:  M, σ  Aφ iff ∀π ∈ B s.t. π0 = σ0 , M, π  φ  M, σ  Aφ iff ∀π s.t. π0 = σ0 , M, π  φ .  The semantics of the CTL operators are deﬁned in terms of  the CTL* A operator and the LTL operators as follows:  AN ψ ≡ AN ψ, (φEU ψ) ≡ ¬A¬ (φU ψ) , (φAU ψ) ≡  A (φU ψ).  D. Examples of Formulae  Now that we have deﬁned the logic, we can revisit the  fair coin example. We can encode the idea that on all paths  we expect to always ﬁnally have a head toss as AGF h  (and the reverse, that we always expect to have have a  tail as AGF ¬h). We can encode the idea that it is always  possible that the next toss is a tail by the formula AGEN ¬h.  31  CTL Tableau  BCTL* Tableau  Formulas  Formulas  State  Formulas  Colours  Hues  CCols  Linear  Exponential  Doubly Exponential  Path  Formulas  Hues  Colours  Exponential (State subformulae) X Doubly Exponential (Path)  Figure 2.  For all ψ ∈ clφ, if δ ≤ ψ then δ ∈ clφ.  For all ψ ∈ clφ, if ψ is not of the form ¬δ then  ¬ψ ∈ clφ.  (Cl4)  For all (αAU β) ∈ clφ we have AN (αAU β) ∈  clφ.  (Cl5)  For all (αEU β) ∈ clφ we have EN (αEU β) ∈  clφ.  For simplicity, we will only consider sets of formulae that  are Maximally Propositionally Consistent, as deﬁned below.  (Cl2)  (Cl3)  Combined Tableau  XCols  Shades  Deﬁnition 6. We say that h ⊆ clφ is Maximally Propositionally Consistent MPC iff for all α, β ∈ clφ  Comparison of Tableau  if β = ¬α then β ∈ h iff α ∈  / h.  if α ∧ β ∈ clφ then (α ∧ β) ∈ h ↔  (α ∈ h and β ∈ h).  Since the BCTL* tableau requires doubly exponential time,  we wish to avoid using the BCTL* half of the combined  tableau technique when possible. However, the BCTL* part  is required to reason about path formula, and to do so it  has to be aware of the truth of direct subformulae of pathformulae. We call the formulae that need to be considered  by the BCTL* part of the combined tableau path-sensitive  formulae.  (M1)  (M2)  testing the satisﬁability of the formulae in Φ is at worst  singly exponential.  III. A P RE -TABLEAU FOR BCTL* AND CTL  Here we deﬁne a tableau CTAB for deciding this combination of CTL and BCTL*. This tableau is derived from  Reynolds’ [6] tableau for BCTL* and the decision procedure  for CTL deﬁned in [5].  As this paper uses a number of terms, we show how these  terms relate in Figure 2, and how they relate to the terms in  the tableaux this paper extends. It is traditional to call the  labels of nodes of a tableau colours. As is common colours  of the existing CTL tableaux are sets of state formulae, we  call this type of colour a CTL Colour (CCol). In BCTL* the  truth of a formula can depend not only on the initial state  σ0 but also on the remainder of the path σ. For this reason  the existing BCTL* tableau needs to consider not only what  set of formulae are true along a particular path, but also  what types of path start from each world. For this reason the  colours of the BCTL* tableaux are sets of sets of formulae,  we call this type of colour an eXtended colour (XCol). As we  will be discussing a number of different types of colours, to  reduce ambiguity we will refer the colours used to label the  nodes of our new combined tableau as Shades. The shades  are a combination of a CCol and an XCol.  We now ﬁx a formula φ that we are attempting to  determine the satisﬁability of. Note that α is satisﬁable  iff Eα is satisﬁable, so we can assume without loss of  generality that φ is a state formula.  An important tool in developing a tableau technique that  requires a ﬁnite amount of space is identifying a ﬁnite set  of formulae, called the closure set, such that the technique  never has to reason about formulae outside this set.  Deﬁnition 7. We deﬁne the set P of path-sensitive formulae  as the minimal set that satisﬁes the following:  If ψ ∈ clφ and ψ is a path formula then ψ ∈ P .  if N ψ ∈ clφ then ψ ∈ P and N ψ ∈ P .  if ψU θ ∈ clφ then ψU θ ∈ P , ψ ∈ P and  θ ∈ P.  A hue is roughly speaking a set of formulae that could  plausibly hold along a single fullpath. As mentioned in  [6] some hues are not satisﬁed on any fullpath, but every  path corresponds to some hue. After deﬁning hues we will  deﬁne XCols (sets of hues roughly representing paths that  could start at the same world), and CCols (representing state  formulae that could plausibly hold at the same state).  (P1)  (P2)  (P2)  Deﬁnition 8. A set h ⊆ P of path-sensitive formulae is a  hue for φ iff  (H1)  (H2)  (H3)  (H4)  is MPC;  αU β ∈ h then α ∈ h or β ∈ h;  ¬ (αU β) ∈ h then β ∈  / h; and  Aα ∈ h and α ∈ P then α ∈ h.  h  h  Deﬁnition 9 (RN  ). The temporal successor RN  relation on  hues below is deﬁned as in Reynolds [6]; For all hues a, b  h  iff the following conditions are satisﬁed:  put (a, b) in RN  Deﬁnition 5. We use α ≤ β to indicate that α is a  subformula of β, and we consider two formulae to be equal if  they have the same representation (e.g. p∧q = p∧q = q∧p).  The closure clφ of the formula φ is deﬁned as the smallest  set that satisﬁes the following requirements:  (Cl1)  h  if  if  if  (R1)  (R2)  (R3)  (R4)  N α ∈ a implies α ∈ b.  ¬N α ∈ a implies α ∈  / b.  αU β ∈ a and β ∈  / a implies αU β ∈ b.  ¬(αU β) ∈ a and α ∈ a implies ¬(αU β) ∈ b.  Deﬁnition 10. We call a set of hues a XCol. We deﬁne a  φ ∈ clφ  32  X  temporal successor function RN  on XCols as follows: given  X  Y iff  a pair of XCols X and Y , we have XRN  (X1)  for all hues g ∈ X there exists h ∈ Y such that  h  gRN  h.  q  Deﬁnition 11. A set of state formulae a is a CCol of φ iff  (C1)  (C2)  (C3)  (C4)  (C5)  Figure 3.  (CN3)  (Z4)  Full vs. Pseudo Hintikka Structure.  1) there exists a hue x in X such that for every (D, Y ) ∈  h  / RN  ; or  {L} (w ) and every y ∈ Y , the pair (x, y) ∈  2) there exists a formula of the form ¬AN α in C such  that for every (D, Y ) ∈ {L} (w ) we have α ∈ D.  Deﬁnition 13. We call Z = (C, X) a shade if X is a XCol  and C is a CCol which satisfy the following conditions.  (Z2)  (Z3)  r  Deﬁnition 16. We say that a node w labelled with the shade  (C, X) is stepwise-unfulﬁlled if we cannot ﬁnd successors  for every hue in X and every state formula in C. That is w  is stepwise-unfulﬁlled if:  For all αAU β ∈ C , either β ∈ C or αAU β ∈  D.  For all ¬ (αEU β) ∈ C, either ¬α ∈ C or  ¬ (αEU β) ∈ D.  For all AN α ∈ C, we have α ∈ D.  Note that is CN2 above, we do not need to explicitly state  that ¬β ∈ C, as that is ensured by C5.  (Z1)  q  all labels of (u ), that is Z ∈ {L} (u ) iff there exists  v ∈ u such that L (v) = Z.  Informally, it is obvious that if say EN p occurs in a node  but we cannot ﬁnd a temporal successor p then there is  something wrong, and that to ﬁx this we need to remove  the original node.  C  ). We deﬁne a temporal successor relation  Deﬁnition 12 (RN  C  C  RN on CCols as follows: for all C, D ∈ C, put (C, D) ∈ RN  iff  (CN2)  r  p’  a ⊆ clφ and;  a is MPC;  if αAU β ∈ a then αEU β ∈ a;  if αEU β ∈ a then α ∈ a or β ∈ a;  if ¬ (αAU β) ∈ a then ¬β ∈ a.  Let C be the CCols of φ. We deﬁne a successor relation  on C as follows:  (CN1)  p  p  Z  and being stepwiseNote the difference between RN  unfulﬁlled above. The ﬁrst implements properties that every  successor must have, while the second implements properties  that some successor must have.  For every hue h in X and for all state formulae  α in P we have α ∈ h iff α in C.  If Aψ ∈ C then for all h ∈ X, we have ψ ∈ h.  If ¬Aψ ∈ C then there exists h ∈ X such that  ¬ψ ∈ h.  If p is a path-sensitive variable, then for all h ∈  X, we have p ∈ h iff p ∈ C.  Deﬁnition 17. A frontier node is a node w that has no  successors, that is w is empty. An interior node is a  node that is not a frontier node. A fragment is a pre-tableau  such that every node w of the pre-tableau is either stepwisefulﬁlled or a frontier node. We say that a pre-tableau        W, , L is a fragment of a pre-tableau   W ,  , L if  T  T  W, , L is contained in W,  , L a tree-unwinding  of W  ,  , L ; that is if ⊆T and L(w) = LT (w) for  all w ∈ W .  Z  ). We deﬁne a temporal successor relation  Deﬁnition 14 (RN  Z  RN on shades as follows: for all pairs of CCols C, D and  Z  iff (C, D) ∈  XCols X, Y we put ((C, X) , (D, Y )) ∈ RN  C  X  RN and (X, Y ) ∈ RN .  In [5] they deﬁne Hintikka structures, which in essence  provide a model for the formula under consideration. However, it is convenient to label every node in the tableau with  a unique set (or set of sets) of formulae. This is easy with  the BCTL* tableau of [6]; however, with CTL collapsing  nodes with the same label can break a model. For example,  say we have (p → AN ¬p) ∧ (¬p → AN p) ∧ AF q ∧ AF r.  Then we see that the structure on the left of Figure 3 models  this formula and that the nodes p and p satisfy the same  subformulae and so they would have the same label. Thus  collapsing duplicated labels as is done in [6] would result in  the structure on the right which does not model the formula.  The solution in [5] is to deﬁne pseudo-Hintikka structures,  which do not model the formula, but which can be unwound  Deﬁnition 15. Let W be a set of nodes,  be a binary  relation on W and the function L from W to shades be a  labelling of W with shades. Then we say W, , L is a  pre-tableau iff for all u, v in W , we have u  v =⇒  Z  Z  L (v). We call the pre-tableau W, RN  , I CTAB0  L (u) RN  when W is the set of shades and I is the identity function  on W .  IV. P RUNING THE TABLEAU  We now show how to prune the tableau.  We now ﬁx a pre-tableau W, , L . For shorthand we  deﬁne (u ) to be the set of all successors of u, that is all  v ∈ W such that u  v. We let {L} (u ) be the set of  33  Let n be the number of state-subformulae. The number  of CCols is at most 2kn for some constant k. A shade is  a combination of a CCol and a XCol. Thus the number of  3m  shades is at most 2kn 22 . Note that each node in CTAB0  3m  is labelled with a unique shade, so it has at most 2kn 22  nodes. This is singly exponential when the number of path  subformulae is bounded (or of order ln n).  For a sketch of how to test that a fragment satisfying pHf3  exists in time polynomial to the number of nodes/shades, see  [5]. The remainder of the tests are clearly polynomial. As  with other tableaux, we expect the average case performance  to be much better than the theoretical worst case performance. This worst case bound suggests that the performance  of the tableau will be similar to the tableau for CTL when  the number of path subformulae is bounded and small.  into a model; the structure on the right can be unwound into  a similar to the one on the left. The only difference between  Hintikka structures and pseudo-Hintikka structures relates  to the handling of formulae like AF q. In a pseudo-Hintikka  structure we do not require that the structure actually satisfy  AF q we only require that we can ﬁnd some fragment of the  structure that can satisfy AF q.  Deﬁnition 18. We say that a hue h is inside a node labelled  with a shade Z = (C, X) if h ∈   X. We say that a formula  φ is inside the node if φ ∈ C ∪ ( X).  Deﬁnition 19. We say that a node w labelled with a shade  Z = (C, X) is pseudo-Hintikka-fulﬁlled (pHf) if it is  stepwise-fulﬁlled and satisﬁes the following three requirements:  (pHf1)  (pHf2)  (pHf3)  for every hue h in X and formula of the form  αU β ∈ h there exists a sequence of nodes  w, w1 , . . . , wm ∈ (∗ ) and sequence of hues  h ∗  such that:  h, h1 , . . . , hm ∈ RN  1) the sequence fulﬁls αU β, that is, β ∈ hm .  2) each hue hi is inside the node wi .  For every formula of the form (αEU β)  in C there exists a sequence of nodes  w, w1 , . . . , wm ∈ (∗ ) such that β is inside  wm .  For every formula of the form (αAU β) in C  there exists a fragment of Z such that the CCols  in the frontier shades of the fragment all contain  β and the interior shades all contain α. (Note  that we can use König’s lemma to show that this  fragment is ﬁnite.)  VI. S OUNDNESS  CTAB is sound, that is, if it succeeds on φ then φ is  satisﬁable.  We will now show how to construct a model for the  formula from the tableau CTAB. The details are as in [5]  and [6]. Similarly to [5] (but unlike [6]) we will have to  unwind the tableau into a tree to ensure that formulae such  as AF α are satisﬁed at the worlds corresponding to nodes  w where AF α ∈ w. We assume some arbitrary ordering on  the shades, fragments and formulae.  Consider a tableau S, R, L where S is the set of nodes,  each labelled with a shade, the relation R forms a tree and  all interior nodes of the tree are stepwise-fulﬁlled.  We deﬁne an eventuality in the tree as a tuple w, h, ψ  where w is a node in the tree and ψ is a formula of the form  αAU β, αEU β, αU β. We say w, h, αAU β is fulﬁlled if  β is inside some node of every path starting at w; note  that as the interior nodes are stepwise-fulﬁlled we do not  need to consider α in our deﬁnition of fulﬁlled, as we know  that α will remain in the tableau until we reach β. We say  w, h, αEU β is fulﬁlled if β is inside some node reachable  from w. The deﬁnition of fulﬁlled for w, h, αU β is similar  but we have to follow the hues, or formally there must exist  a sequence of nodes w0 , w1 , . . . , wm through the tree and  h  such that  hues h0 , h1 , . . . , hm that form a path through RN  for each non-negative integer i ≤ m we have hi inside wi ,  have w0 = w and h0 = h.  We will now deﬁne an unwinding of CTAB into a tree.  Let S  be the set of labels of the nodes in CTAB, that is  the shades remaining after pruning. Consider the following  algorithm:  1) We start with S † = {w0 } and R† = ∅, where w0 is  a node labelled with a shade Z = (C, X) satisfying  φ ∈ C.  2) We navigate the tree breadth-wise. When we come  across a frontier node w labelled with a shade Z =  (C, X) we consider the oldest unfulﬁlled AU or EU  eventuality.  Deﬁnition 20. We say that a pre-tableau is a tableau iff all  its nodes are pHf, when S  is taken to be the set of all nodes  in the tableau.  The decision procedure is as follows: we begin with the pretableau CTAB0 from Deﬁnition 15. We iteratively remove  all nodes that are not pHf until all nodes are pHf. Note that  removing one node may cause another node to become nonpHf, and so one pass is not sufﬁcient. We say that CTAB  succeeds if the resulting tableau contains a node labelled  with a shade (C, X) where φ ∈ C.  V. C OMPLEXITY  Let m be the number of path-subformulae of φ. We see  the number of path-sensitive formulae is at most 3m. This is  because each sensitive formula is either a path formula or a  direct subformula of φ, and a formula has at most two direct  subformulae (αU β has α and β as direct subformulae).  Since hues are power-sets of sensitive formulae, the number  of hues is a most 23m . Likewise, the XCols are power-sets  3m  of hues and we have at most 22 XCols.  34  The tableau is ﬁnite so CTAB will halt.  Say that φ is satisﬁable. Then there exists a BCTLstructure (W, , g, B) and path π 0 in B such that π 0  φ.  We will deﬁne a translation ρ from worlds to shades, and  show that for each world w in W , the shade ρ (w) will not  be pruned from the tableau. Hence the set S  of unpruned  nodes will be non-empty when CTAB halts, and so CTAB  will succeed.  a) If there is no such eventuality, or the eventuality  is of the form αU β or αEU β, then for each  temporal successor Z  of Z (that is, each Z  ∈ S   Z  such that (Z, Z  ) ∈ RN  ) we add a successor to    w labelled Z .  b) If the eventuality is of the form αAU β, we add  the ﬁrst fragment satisfying pHf3.  We see that at each step of the algorithm, all of the interior  nodes are stepwise fulﬁlled. Since there are a ﬁnite number  of unfulﬁlled eventualities on each branch of the tree, and the  algorithm iteratively fulﬁls the oldest eventuality ﬁrst, each  eventuality will be fulﬁlled. As the algorithm never ends, we  deﬁne the ﬁnal tree (ST , RT ) as containing all nodes and  edges that are ever added by the algorithm.  Where (ST , RT ) is our ﬁnal tree we deﬁne a BCTLstructure (W, , g, B) as follows: the transition frame  (W, R) is simply (ST , RT ), and the valuation g (w) of a  world is precisely those atoms p that are inside w. We now  deﬁne the set of bundled paths B, in a similar fashion to  how they were deﬁned in [6].  Deﬁnition 25. We deﬁne a function h on paths such that  h (π) = {α : α ∈ clφ and π  α}  As H1–4 are simply properties that any set of formulae  that hold along the same path must satisfy, it is clear that  the following lemma holds.  Lemma 26. From the semantics of BCTL*, we see that for  each π ∈ B, h(π) is a hue.  Proof: (H1) Since the semantics of the ∧ and ¬  operators in BCTL* come from classical logic, it is clear  that h (π) is MPC.  (H2) If αU β ∈ h (π) then π  αU β and we see that  either β is satisﬁed immediately and so π  β or π  α;  hence α ∈ h (π) or β ∈ h (π).  (H3) Likewise if ¬ (αU β) ∈ h (π) then we see that π   / h (π), demonstrating that H3  αU β and so π  β and so β ∈  is satisﬁed.  (H4) If Aα ∈ h (π) then π  Aα and so all paths starting  at π0 , including π, satisfy α.  We will now deﬁne a function from worlds to shades.  This deﬁnition uses the function from paths to hues deﬁned  in Deﬁnition 25.  Deﬁnition  21.  We  call  an  ω-sequence  (w0 , h0 ) , (w1 , h1 ) , . . . a thread through ST iff for  all i ≥ 0: each wi ∈ ST , each hue hi is inside wi ,  h  . We say  (wi , wi+1 ) ∈ RT , and each (hi , hi+1 ) ∈ RN  that this is a fulﬁlling thread iff for all i ≥ 0 and for all  formulae of the form (αU β) in hi , there exists j ≥ i such  that β ∈ hj .  We include a fullpath σ = w0 , w1 , . . . in B iff there  exists a fulﬁlling thread (w0 , h0 ) , (w1 , h1 ) , . . . , and we  say that this thread justiﬁes σ being in B. It is easy to  show that B is a bundle. Since every αU β eventuality is  fulﬁlled it is easy to see every hue has a fulﬁlling thread.  Deﬁnition 27. We deﬁne a function ρX on worlds to sets of  hues, ρC to sets of state formulae, ρZ to shades as follows:  Lemma 22. For all ψ in clφ, for all threads μ =  (w0 , h0 ) , (w1 , h1 ) , . . . justifying σ = w0 , w1 , . . . we  have  ρX (w) = {h(π) : π ∈ B and π0 = w}  ρC (w) = {α : α is a state-formula in clφ  (W, , g, B), σ  ψ iff ψ is inside w0 .  , ∃σ ∈ B with σ0 = w ∧ M, σ  α}  ρZ (w) = (ρC (w), ρX (w))  ρS = {ρZ (w) : w ∈ W } .  The proof of this lemma is rather mechanical, given the  previous results it is easy to prove this recursively, see [6]  and [5] for details. One minor point not covered in [6]  or [5] is that the formulae in the [6] style hues and [5]  style CCols need to be consistent, for example if we had  (qEU p) U (pAU q) in a hue of a node w then we would  clearly want to have either (pAU q) or (qEU p) in the CCol  of the same node. This is ensured by P2, P3 and Z1.  We see that for each w ∈ W , ρX (w). Likewise ρC (w)  is a CCol and ρZ(w) = (ρC (w), ρX (w))   is a shade. We  Z  ∩ (ρS × ρS ) . It is trivial to see  let the tableau be ρS , RN  the tableau is stepwise-fulﬁlled. Showing that the tableau is  pHf is also easy, for details on pHf1 see [6] and see [5] for  details on pHf2 and pHf3. Thus no nodes in ρS are pruned.  Theorem 23. The tableau is sound, that is if the tableau  succeeds, φ is satisﬁable.  VIII. C ONCLUSIONS AND F UTURE R ESEARCH  We have presented a tableau for a combination of CTL  and BCTL*. This tableau is singly exponential when the  number of non-CTL operators is bounded; a pure CTL  formula will not have any path subformulae. While this  combination has some advantages, it is presented as a step  Obvious from lemma above.  VII. C OMPLETENESS  Lemma 24. CTAB is complete, that is, if φ is satisﬁable  then CTAB halts and succeeds on φ.  35  towards ﬁnding a pure tableau for a similar combination of  CTL and CTL*.  R EFERENCES  [1] E. A. Emerson and A. P. Sistla, “Deciding branching time  logic,” in Proceedings of the 16th annual ACM symposium  on Theory on computing (STOC). New York, NY, USA:  ACM Press, 1984, pp. 14–24.  The BCTL* tableau used in this paper can be extended to  a CTL* tableau, as was done in [4]. A simple replacement of  the BCTL* with the tableau CTL* is not challenging though  we note that the speciﬁcation of the CTL* tableau alone is  more lengthy than this paper. This expansion would provide  better performance for CTL-like CTL* formulae; however a  simple replacement may not preserve the singly exponential  running time for CTL-like formulas. The worst case bound  on the running time of the CTL* tableau is based on a bound  on the size of models for CTL* like formulae. To preserve  the singly exponential running time we would need to ﬁnd  a better halting condition.  [2] M. Y. Vardi and L. Stockmeyer, “Improved upper and lower  bounds for modal logics of programs,” in Proceedings of  the 17th annual ACM symposium on Theory of computing  (STOC). New York, NY, USA: ACM, 1985, pp. 240–251.  [3] O. Friedmann, M. Latte, and M. Lange, “A decision  procedure for CTL* based on tableaux and automata,” in  5th International Joint Conference on Automated Reasoning  (IJCAR), ser. LNCS, J. Giesl and R. Hähnle, Eds.  Springer, 2010, vol. 6173, pp. 331–345. [Online]. Available:  http://dx.doi.org/10.1007/978-3-642-14203-1 28  Another important optimisation would be to convert these  tableaux into conventional tableaux rooted with a single  formula. This tableau begins by creating all possible shades.  We deﬁne the tableau this way as it simpliﬁes the deﬁnition  and it does not affect that the worst-case performance results  that are the focus of this paper. However, this form of  tableaux for CTL and BCTL* also tends to perform much  worse than conventional tableau in the average case [5], [10].  To see why, consider a formula of the form p ∧ ¬p ∧ φ.  A conventional tableau would end as soon as it found the  contradiction, while our tableau would always take longer  to reason about p∧¬p∧φ than φ. Although not discussed in  this paper, it is known how to implement both the CTL and  BCTL* tableaux in a traditional rooted way [5], [10]. We  would recommend converting this tableau to a conventional  tableau prior to implementation.  [4] M. Reynolds, “A tableau for CTL*,” in Proceedings of the  16th International Symposium on Formal Methods (FM),  ser. Lecture Notes in Computer Science, A. Cavalcanti and  D. Dams, Eds., vol. 5850. Springer, 2009, pp. 403–418.  [5] E. A. Emerson and J. Y. Halpern, “Decision procedures  and expressiveness in the temporal logic of branching time,”  in STOC. ACM, 1982, pp. 169–180. [Online]. Available:  http://dx.doi.org/10.1145/800070.802190  [6] M. Reynolds, “A Tableau for Bundled CTL*,” J  Logic Computation, vol. 17, no. 1, pp. 117–132,  2007. [Online]. Available: http://logcom.oxfordjournals.org/  cgi/content/abstract/17/1/117  [7] A. Masini, L. Viganò, and M. Volpe, “A labeled natural  deduction system for a fragment of CTL*,” in Proceedings  of the 2009 International Symposium on Logical Foundations  of Computer Science, ser. LFCS ’09. Berlin, Heidelberg:  Springer-Verlag, 2009, pp. 338–353. [Online]. Available:  http://dx.doi.org/10.1007/978-3-540-92687-0 23  Continued research into pure tableaux is important. [3]  note that their hybrid implementation tends to perform better  than that of [4]; however, they start with a rooted tableau  it is not clear whether this is due to their approach or because they begin with conventional tableaux. Converting the  approach of Reynolds to a conventional tableau, that begins  with a single formula, greatly increases the performance a related tableau for BCTL* [10]. This suggests than even when  performance is the only concern, research into pure-tableau  is still worthwhile. As pure-tableaux based algorithms work  directly on subformulae of the input formula, they have an  important advantage over the hybrid technique of [3]: the  workings of the algorithm is more easily understood by the  user than a parity game solver.  [8] E. A. Emerson and C.-L. Lei, “Modalities for model checking  (extended abstract): branching time strikes back,” in POPL  ’85: Proceedings of the 12th ACM SIGACT-SIGPLAN symposium on Principles of programming languages. New York,  NY, USA: ACM, 1985, pp. 84–96.  [9] O. Kupferman and O. Grumberg, “Buy one, get one  free!! !” J. Log. Comput., vol. 6, no. 4, pp. 523–539, 1996.  [Online]. Available: http://logcom.oxfordjournals.org/content/  6/4/523.full.pdf  [10] J. C. Mc Cabe-Dansted, “A rooted tableau for BCTL*,” 2011,  Expanded Version, Availiable: http://www.csse.uwa.edu.au/  ∼john/papers/Rooted BCTL Tableau.pdf.  [11] ——, “A temporal logic of robustness,” Ph.D. dissertation,  The University of Western Australia, 2011. [Online].  Available: http://tinyurl.com/RoCTL11  There has been research into parallelisation of automated  reasoning for CTL. For example, [13] propose a tableau for  CTL that is intended to provide good average case performance and is easy to parallelise. The current CTL* tableaux  do not yet exploit parallelisation. Single core performance  of modern CPUs has plateaued. To exploit future advances  in computation power, we will examine the potential to  parallelise these tableau based techniques.  [12] ——, “Improved BCTL* applet,” 2011, http://www.csse.uwa.  edu.au/∼john/BCTL2/.  [13] P. Abate, R. Goré, and F. Widmann, “One-pass tableaux for  computation tree logic,” in Logic for Programming, Artiﬁcial  Intelligence, and Reasoning. Springer, 2007, pp. 32–46.  36 