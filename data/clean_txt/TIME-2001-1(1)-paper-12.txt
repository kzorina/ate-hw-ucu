A Linguistic Framework for Querying Dimensional Data  Elisa Bertino  Tsz S. Cheng  Shashi K. Gadia    DSI - Universitaƒö¬Ä di Milano  Milano - Italy          Giovanna Guerrini  IBM Global E-Business  Solution Center, Dallas - Texas          Department of Computer Science  Iowa State University - Iowa        DISI - Universitaƒö¬Ä di Genova  Genova - Italy         Abstract  ity√¢¬Ä¬ù of queries. A uniform handling of dimensional data is  achieved through dimension alignment, that automatically  allows lower dimensional data and queries to be used in  higher dimensional contexts.  Object database systems (both the pure object-oriented  systems and the object-relational ones) are currently replacing conventional relational database systems. The notion of  dimensional data is orthogonal to the specific data model  considered. In this paper, we present a rigorous treatment  of dimensional objects, that is suitable for object-oriented  databases. This formal treatment entails addressing several  interesting issues. First, parametric non-1NF data need to  be considered. In the object model attribute values can be  of any type of the (complex) type system, including, for  instance, set and tuple constructors. A dimensional object  thus requires the introduction, in the type system, of the notion of dimensional type, in order to type in a uniform way  dimensional and non-dimensional data. We consider a simple object model, that is a simplified version of the ODMG  standard data model [3].  We then investigate how dimensional objects can be used  together in queries. We do not develop a full query language, rather we focus on how objects with different dimensions can be mixed together in the same queries. Specifically, we consider both associative queries (based on classical comparison operators) and navigational queries (based  on the notion of path expression). The basic goal of the  constructs we define is to allow a user to query dimensional  objects without having to worry about the dimensions of the  various data elements involved in the query. The constructs  we introduce in this paper will form the basis for query languages for dimensional object collections.  Note that, though several different temporal objectoriented data models ([13, 14]) and query languages (e.g.  This paper deals with dimensional data. Examples of  dimensions are space and time. Thus, temporal, spatial,  spatiotemporal values are examples of dimensional data.  We define the notion of dimensional object, extending an  object-oriented ODMG-like type system to include dimensional types. We then address the problem of querying dimensional objects. Linguistic constructs are introduced that  allow objects with different dimensions to be mixed in the  same phrases. This allows the user to formulate both associative and navigational accesses seamlessly without having to worry about the dimensions of the various data elements involved.  1 Introduction  The notion of parametric or dimensional data has been  proposed in [12] to model in a uniform way ordinary, temporal, spatial, spatiotemporal data. That notion has also  been applied to multilevel security [10] and to model multiple beliefs. However, a formal treatment of dimensional  data has not been given. The basic notion beyond dimensional data is that of dimensional element, that is, a finite  union of points in the dimensional space; attribute values  are functions with dimensional elements as domains. The  parametric data model is based on dimensional relations,  such that all values in the attributes of a tuple have the same  dimensional domain and a key is declared for each relation, in such a way that no key attribute value of a tuple  can change from one point in the dimensional space to another. An algebra for the parametric model has been defined, with the main goal of minimizing the √¢¬Ä¬úuser complex1  [7, 8, 15]) have been proposed, the emphasis of this paper  is on a uniform handling of several dimensions, and on dimension alignment at the data and language levels.  The remainder of the paper is structured as follows. Section 2 introduces the notion of dimensional object, whereas  Section 3 is devoted to queries on dimensional objects. Section 4 concludes the work and discusses some issues that are  currently under investigation.    , then the dimensional eleis the spatial domain  ments are spatial elements [5]. In a two-dimensional space,  a dimensional element will be a union of cross-products of  one-dimensional elements. Specifically, if the dimensional    we get spatiotempodomain is       ral elements. An example of spatiotemporal element is                       .  denote the set of dimensional elements of  Let   the dimensional space  . Moreover, given a set       ,   , of dimension names, denoting a  subset √ÇÀù      of , let  √ÇÀù  denote the  set of dimensional elements with dimensions  √ÇÀù     .  of  Given a dimensional element    , and a set  dimension names, let   denote the projection of  on  dimensions in D. As a particular case, given a dimension  name ,   denotes the component of  corresponding  to dimension .  Note that, whenever a dimension is missing in a dimensional element, the whole corresponding dimensional domain is assumed. In our model, indeed, each value is dimensional; if a value has no explicitly specified element for  a given dimension it refers to every point of that dimension.  Thus, given a dimensional element    √ÇÀù  , and  a set    , its completion to is a dimensional ele√Ç≈∫  √Ç≈∫ , such that,   ment      :  2 Dimensional Object Model  In this section we briefly introduce the dimensional type  system which constitutes the basis of the dimensional object  model.  2.1 Dimensional Elements  We assume a set        of dimensions and  an underlying universal dimensional domain  as the cartesian product          of these dimensions. The  user can view it as a set of points in the dimensional space.  Let  denote the set of names of dimensions in .  We postulate that certain subsets of  , called dimensional elements, are of interest to users, and they are  closed under union (), intersection ( ), difference ( ), and  complementation (  ). Dimensional values will be modeled  as functions from dimensional elements, such that if a  function maps a dimensional element  to a given value   this means that it assigns  to every dimensional point in  . We are indeed interested in modeling functions with sets  of dimensional points as domains. The general principles  for identifying legitimate domains for dimensional values  are: (i) a real world object should correspond to a single  object in the database; (ii) whatever domains users consider  important, should be admitted as dimensional element; (iii)  the domains should allow easy and flexible queries. Applying these principles to temporal databases means: (i) an  interval is not enough, but a finite union of intervals is; (ii)  users like to compute the state of an object at a point, thus  a point should be a temporal element; (iii) queries will require dimensional elements to be closed under set-theoretic  operations (since conjunction corresponds to intersection, disjunction to union, negation to complementation).  Therefore, temporal elements are finite unions of intervals.  Note that, by this definition, an instant is also a temporal  element. Thus, if the dimensional domain is the set of time          , then the  instants       dimensional elements are temporal elements [9]. For in    is a temporal element. In spatial  stance,   databases users will like to use certain elementary spatial  domains. Then dimensional spatial elements will be finite  unions of those domains. Thus, if the dimensional domain  √Ç≈∫   √Ç≈∫     if     otherwise        As a particular case, the completion to the whole set of  dimensions, namely,      is simply denoted as  .  For instance, if           ,    1         , then             .  2.2 Types  The types of the dimensional object model are obtained as an extension of the usual set of types of an  object model. We postulate the existence of a set of  predefined basic literal types   (containing the types          and   ). Moreover,  class names are also basic types, referred to as object types.  We consider a set  of class names. Finally, we consider  structured types obtained by applying the set and record  constructors to existing types. The following definition introduces non-dimensional types.  Definition 1 (Non-dimensional Types). The set of nondimensional literal types   is recursively defined as follows:  1 We  2  denote the name of dimensions in typewriter font.   the predefined basic literal types are literal types  (    );  2.3 Values   if  is a literal type or an object type then   is a  We now introduce the set of legal values of our model.  Oids in  are handled as values. Thus, an object identifier i is a value of an object type in  . The set of objects  instances of a class depends on the point of the dimensional  space we refer to. Thus, to define the extension, that is,  the set of legal values for each type, we introduce a function  :      2 , assigning an extent to each  class, for each dimensional element . For each    ,  for each    ,    is the set of the identifiers  of objects that, at the dimensional points in , belong to  class . By contrast, the set of instances of a literal type  does not vary over dimensions (e.g, the set of instances of    is always , the set of instances of   is  always   ). Given a literal type  , let     denote this invariant set of instances.  non-dimensional literal type;   if       are distinct labels and   literal or object types, then     a non-dimensional literal type.        are   is  The set of non-dimensional types   is defined as the   .  union of literal types   and object types   This set of types is extended with a collection of dimensional types. Dimensional types are introduced to type in  a uniform way dimensional (e.g., temporal) variables, and  non-dimensional variables, that is, variables with which no  dimension is associated.    Definition 2 (Dimensional Types). Let     be a nondimensional type,        be dimension names,  then        is a dimensional type.  Definition 4 (Non-dimensional Type Legal Values). Let        be a non-dimensional type and    be  a dimensional element, then    denotes the extension  (i.e., the set of legal values) of type  at :  Example 1 If we consider     and    as dimenand   as non-dimensional types,  sions, and                   are examples of dimensional types.  √Ç≈∫    Intuitively, instances of type   are partial functions  from dimensional elements of dimension  to instances of  type  , as discussed in the following section. Note that  dimensional types cannot be nested; note moreover that the  set of legal values for     would correspond to the  set of legal values of    .  Let  be the set of dimensional types as defined by  Definition 2. In our model, dimensional types can be used  in the definition of set and struct literal types, as stated by  the following definition.  Definition 3 (Literal Types). The set of literal types  recursively defined as follows:                                 √ÇÀù  √ÇÀù               if    if    if        if      √ÇÀù √ÇÀù       The set of instances of a dimensional type  , formally specified by the following definition, is the set of partial functions from dimensional elements of  to instances  of type  . Note that this set does not vary over the dimensional space, that is, for a dimensional type       ,           is the same for all    √ÇÀù  ,  thus it will be denoted simply as          .  Definition 5 (Dimensional Type Legal Values).  Let          be a dimensional type, then           denotes the set of legal values of type         :      is      non-dimensional literal types are literal types  (    );   if  is a literal type, or an object type, or a dimensional  type then   is a literal type;              √ÇÀù       such that, for each    √ÇÀù   if   is defined then                     Note that we will denote a function in this set as a set of  pairs   ,   ,   , where      are legal  values for type  , and      are dimensional elements  in  √ÇÀù  such that the function assumes value   for  dimensional element   ,      .  Given a dimensional value  , operator    denotes  its dimensional domain. Thus, the dimensional domain      of the spatial value     ,   if         are distinct labels and    are literal, object, or dimensional types, then         is a literal type.  The set of types  of our dimensional model is defined  as the union of literal types  , object types  , and dimensional types  .  3  as         is          , whereas the domain of the temporal    is   . Morevalue       over, given a dimensional value  , let ƒÇ¬Ü     be                                                          denoted  the set of dimensions of value  . That is, if  is a value       . We also  of type       , ƒÇ¬Ü    define the notion of restriction of a dimensional value to a  dimensional element, formalized as follows.                    Definition 6 (Restriction of a Dimensional Value to a Dimensional Element). Given a dimensional value  , of  type       , and a dimensional element     √ÇÀù√Ç≈∫ √Ç≈∫ , such that             ,  the restriction of  to , denoted as   , is a dimensional     value of type        such that        and !     √ÇÀù   !   ! .   √ÇÀù    For        instance,  given  the  spatiotemporal  value                                ,  and  the  temporal element        !                                        ! !                """      !     !       """                         !       !  .         #$%  &$%                                 '  '       2.4 Classes and Objects  Here we will focus only on the signature of a class, that  contains all the information for the use of the class and its  instances, and, specifically, on the information about the attributes contained in the signature of a class. Each attribute  is characterized by its name and its type. Consider the following example. Note that, because of the homogeneity assumption, all the attributes of a class must have the same dimensions, thus, it is most convenient to specify the dimension in the class declaration. Thus, only non-dimensional  types are used in the definition of attribute domains, and a  dimensional attribute  of type        is specified  by means of the pair   , once the corresponding class  has been declared as dimensional in      .  A dimensional object is an object whose value (state) is a  dimensional value. Thus, we adopt a rather standard notion  of object, formalized as follows.  Definition 7 (Object).  where      Example 2 In what follows we sketch the definition of some  dimensional classes, inspired from [12]. Non-relevant attributes are omitted and substituted by dots. These classes  refer to: persons (the information about persons are time  dependent); lands (owned by persons, with a soil with a certain texture and a specific crop grown, these information are  space dependent); monitors (referring to the concentration  of chemicals in up-gradient and down-gradient wells, these  information are both time and space dependent). Moreover,  there are non-dimensional classes related to soil textures,  crops, and chemicals (with the environmentally acceptable  range of chemicals in the soil).    An object  is a triple    ,        is the oid of ;    is a struct value of the form:        ,  where        are the names of the attributes  of , and        are their values;  is the most specific class to which belongs  such that          , that is, all the object attributes have the same dimensional domain 2 (homogeneity  assumption [9]), and  is in accordance with the attribute  specification given in class .  The dimensional domain of an object , denoted  simply the domain of any of its attributes.    , is  2 Note that, however, the attributes can assume different values in different dimensional elements of that domain, thus our model is based on  attribute timestamping rather than on object timestamping.  4  3 Querying Dimensional Objects  Example 3 The following are examples of objects, referring to the classes of Example 2 3 .   √ÇÀù      (    (   +    (   ))        #%    &%     =      √Ç≈æ       #%    &%     =       √ÇÀù      0       =    √Ç≈æ        =        !√ÇÀù                       =    √ÇÀù             =     0  In this section we address the problem of querying dimensional objects. The query language we refer to combines features typical of associative query languages, features typical of navigational query languages proposed for  object models, and features typical of dimensional data.  The definition of a full query language is beyond the scope  of this paper, in what follows we introduce and illustrate  through examples the most interesting/peculiar aspects of  dimensional data handling.  Before introducing the various kinds of expressions that  can be used to assemble a query, let us first briefly discuss  how dimensional values can be used together, combined,  and compared in expressions. Classical operators extends to  a dimensional context in a straightforward way: they simply operate pointwise. For instance, given two expressions   and  of type    their sum   has type     and the corresponding value is a function  such that, if  and  are the values denoted by  and  ,  respectively,          . Similarly, their comparison  "  has type    and the corresponding value is a function  such that          "  .  !√ÇÀù  (  !√Ç≈æ  √ÇÀù  ,  !√ÇÀù  ) ( ( * !√Ç≈æ  ) *  !√Ç≈æ  , *  !√ÇÀù  ( - ( )( !√Ç≈æ  ) .  !√Ç≈æ  / -     (  !√ÇÀù  √Ç≈æ  ,   ( - !√ÇÀù  )( )(   (  !√ÇÀù  - /      ,  '  , (,  '  ( (*)   ,  '  ,* (  '  ( (*)   * . * 1   ,   * ,(   )/   ,) . *   .   !√ÇÀù  )/ /        Example 4 Referring to the database schema of Example 2, given variables "# $ of type   and  $%  variable % of type  , "%  is an expression of type   , whereas  %&#'    %(#'   " is an expression of type   )#*. Referring to the objects of Example 3, this expression evaluated on % returns     " ,  whereas evaluated on %  it returns     " .         * /( )((( /) . ( )*((  . ) . * /(((    * . *     * . (   . ) . * √ÇÀù    The only further point to consider is what happens when  values with different dimensions are used together. Following [12] we take the approach that, when a dimension is missing in a value, the whole dimension domain  is intended. Thus, two expressions  and  of types          and        ,      , can    be combined through operator $ if operator $ can be applied to non-dimensional values of types   , producing  a result of type  . The resulting expression will have type          with                    .  are  are extended to dimensions       simply associating with them the whole dimension domain for missing dimensions, as already discussed.   √ÇÀù √Ç≈æ √Ç≈º  !√ÇÀù  ,   √ÇÀù  . ( √Ç≈æ  2( √Ç≈º  ,(  As in any object-oriented data model, classes are related  by a user-defined ISA hierarchy, that induces a subtype hierarchy on types of our type system. For a subclass both substitutability (the subclass must have all the attributes of the  superclass, and optionally some additional ones) and extent  inclusion (the instances of the subclass are also instances  of the superclass) are required. Due to space limitations,  we do not discuss issues related to inheritance in this paper. Moreover, in this preliminary work, we do not consider  attribute refinement, nor any subtype relationship holding  among dimensional types with different dimensions.  Example 5 Referring to the database schema of Example 2, given variable  of type +, and variable " of  type  ,   " "% is an expression of type    .  3 Only the attributes of object  √ÇÀù that are used in the following are reported, for the sake of conciseness.  5  3.2 Boolean Expressions  We do not detail the set of operators we consider to combine dimensional values; however, they surely include classical arithmetic, set, and comparison operators.  A boolean expression is an expression that evaluates in  a non-dimensional boolean value. Boolean expressions are  defined as follows.  3.1 Dimensional Expressions   if  type    if   if   if  ,  is a boolean expression;  are dimensional expressions in  , such that  ƒÇ¬Ü ! ,   ! is a boolean expression;   !    is an expression of a boolean dimensional type       ,  is a boolean expression, that  is used as a shorthand for      4    is an expression of a dimensional type   ,    is a dimensional expression, denoting a dimensional element    √ÇÀù  corresponding to the points in which  is defined;      ƒÇ¬Ü   constant  dimensional  element  in  is  a  dimensional  expression;        √ÇÀù         of   if  is an expression of the boolean non-dimensional  Definition 8 (Dimensional Expressions). The set  of dimensional expressions is defined as follows:   a    Definition 9 (Boolean Expressions).  The set  boolean expressions is defined as follows:  A dimensional expression is an expression that evaluates  in a dimensional element. Dimensional expressions derive  from temporal expressions proposed in [12] and are defined  as follows.   if      is an expression of a boolean dimensional type       ,  is a boolean expression, that     ;5  is used as a shorthand for              if     are boolean expressions, then so are   !  , " .  is an expression of a boolean dimensional  type        ,    is a dimensional  expression, denoting a dimensional element     √ÇÀù  corresponding to the points in which   has value ;      ,  Example 7 Referring to the database schema of Example  2, given variable  of type  % and variable % of  type  , the following are examples of boolean expressions:   if  !   are dimensional expressions, then so are      !,   !,   !,  .   %-  .  " %  . ;   %&#'    %(#'   "  We extend function ƒÇ¬Ü introduced in Section 2.1 to work  on dimensional expressions, thus, given a dimensional expression , ƒÇ¬Ü    returns its dimensions. We remark  that whenever two dimensional expressions  ,  with different dimensions are used together in a more complex expression, they are aligned to a common set of dimensions  ƒÇ¬Ü    ƒÇ¬Ü  , by considering the whole dimensional  domain for the missing dimensions.   %&#'    %(#'   "    %&   #  '   "   ;   ;      %(#'   "     .    3.3 Path Expressions  A path expression is an expression that allows one to  navigate through aggregation hierarchies on objects. Navigational access to temporal objects has been investigated in  OOTempSQL [4], and revisited in [2]. The notion of path  expression we propose here, besides being generalized to  a multidimensional context, actually combines and extends  the two notions. In particular, we distinguish among simple path expressions (inspired by [4]), that navigate through  the object aggregation hierarchy, aligning the dimensions  of the traversed objects; qualified path expressions (inspired  by [2]), in which the portion of the dimensional space one is  interested in navigating can be restricted; and single-valued  Example 6 Referring  to  the  database  schema  of Example 2,  given variable " of type    and variable % of type  ,   "%   %&#'    %(#'   "   is  a dimensional expression denoting a dimensional element with dimensions #, corresponding  to the spatiotemporal points in which the value of the  U/G well of % is greater then the value of its D/G well  plus one, and in whose time components the income  of " is defined. Note that ƒÇ¬Ü   "%    ,  whereas ƒÇ¬Ü   %&#'    %(#'   "     . Referring to objects % and " of  Example 3 the dimensional expression above denotes          "      " .  4 is a shorthand for sometimes, since it corresponds to the fact that the  boolean expression is sometimes true.  5  is a shorthand for always, since it corresponds to the fact that the  boolean expression is always true.  6  qualified path expression (also inspired by [2]) in which the  dimensional value obtained through the navigation can be  instantiated to a single dimensional point, thus obtaining a  non-dimensional value. The two latter notions also allow  one to specify a boolean condition to hold for the path expression to be defined, this is another extension with respect  to the notions of path expressions previously proposed.  A path expression evaluates in a value  , that can be used  in other expressions provided that type correctness is ensured. Path expressions are defined as follows.  Example 9 Referring to the database schema of Example  2, given variable  of type +, and variable % of type   , the following are examples of qualified path expressions:   %(#'   # % %%   0   %(#&   " % %%-  .   ,  whose type is  )#*, and that, evaluated on object % of Example 3, denotes the value     "     " !;  #     "   % , whose type  is   )#*, and that, evaluated on object  of Example 3, denotes the value     Definition 10 (Path Expressions). If  is an expression of type       ,    ,     ,  is an attribute of  with type % &           ,     ,  is a path expression.  This expression, whose type is       , where                     , denotes the value such that    √ÇÀù√Ç≈∫√Ç≈∫ √Ç≈∫√Ç≈∫    √ÇÀù    √Ç≈∫  √Ç≈∫ .  √ÇÀù    Example 8 Consider  an  of  expression                         / denotes the  )#*:  then                                                         type        value  of           Definition 12 (Single-Valued Qualified Path Expressions).  If  is a path expression of type       ,  is a  boolean expression,  is a dimensional expression such that  ƒÇ¬Ü        ,  ##   is a single-valued  qualified path expression. This expression, whose type is   , denotes the value denoted by  if  holds and   assumes a single value over , it is undefined otherwise.       following          .      Finally, when a path expression evaluates to a value   and is qualified by a dimensional element , such that   assigns a single value to , the user can be interested in  simply obtaining that (non-dimensional) value. This can be  achieved through the notion of single-valued qualified path  expression, formalized as follows.  )*, such that in class  attribute  has type    )#*. Suppose that denotes the value          and suppose moreover that       type                   Example 10 Referring to the database schema of Example  2, given variable " of type   the following is an example of single-valued qualified path expression:  Often, however, a user is not interested in navigating  through the whole set of values taken by a dimensional  value over the dimensional space, rather it is interested to  restrict them to a specific dimensional element. This can  be achieved through the notion of qualified path expression,  formalized as follows.  ",,  ##  1"     "% $   2  whose type is   , and that, evaluated on object " of  Example 3, denotes the value 2 .  Definition 11 (Qualified Path Expressions). If  is a  path expression of type       ,  is a boolean expression,  is a dimensional expression such that ƒÇ¬Ü         ,  #   is a qualified path expression. This expression, whose type is       , where        ƒÇ¬Ü       , denotes the value  denoted by   if  holds, it is undefined otherwise.  4 Conclusions  In this paper we have proposed a notion of dimensional  object, and we have investigated some issues at the basis for  queries on dimensional objects. This work can be regarded  as an important stepping stone for a dimensional object data  model and query language.  In extending the proposed framework to model and  query collections several issues will have to be revisited. We  will investigate the implications of removing the homogeneity assumption, that is, the requirement that all the attributes  When the boolean expression  is missing in a qualified path expression, the boolean constant  is implicitly  assumed, and when the dimensional expression  is missis implicitly asing, the null dimensional element in   sumed.  7  of an object must have the same dimensional domain. Removing this assumption will require to deal with null values. Moreover, we assume that if a dimension is missing  in a value, then that value is intended to be valid for all the  elements in that dimension. Thus, there is no equivalent of  the notion of static attribute nor of that of static object with  the meaning in [1]: each value and each object are dimensional; if no dimension is specified, the whole dimensional  space is assumed. Note that static values in a temporal context naturally refer to now; for other dimensions, however,  it could not be possible to identify such a default point to  associate with (static) data for which the dimension is missing. Finally, we are also interested in extending our model  to a multigranularity context, in which granularities are seen  as dimensions, and dimension alignment as a way to reveal  granularities.  For what concerns the query language, the basic idea is  that of extending with the essential constructs of the parametric relational algebra at the basis of TempSQL [12] (i.e.  dimension alignment and restructuring) the object query  language of the ODMG standard, OQL [3], and to investigate how that language can be employed to query dimensional data. One of the main consequences of an OQL-like  query language is that the result of a query is a set of either  values or objects of the appropriate type; in particular, the  result of a projection can be a set of record values (tuples).  Since, however, algebraic optimization is crucial also for  object databases, a dimensional object algebra will be defined. This algebra is obtained as a dimensional extension  of object algebras that are the formalisms under OQL [6].  √¢¬Ä¬úClassical√¢¬Ä¬ù algebraic identities will be revisited, to obtain  a set of identities still holding between dimensional object  algebra expressions, and to clarify how the new constructs  dealing with data dimensionality interact with existing ones  [11].  [5] T. S. Cheng and S. K. Gadia. A Pattern Matching Language for Spatio-Temporal Databases. In Proc. of the  Third Int√¢¬Ä¬ôl Conf. on Information and Knowledge Management, pages 288√¢¬Ä¬ì295, 1994.  [6] S. Cluet and C. Delobel. A General Framework for  the Optimization of Object-Oriented Queries. In Proc.  of the ACM SIGMOD Int√¢¬Ä¬ôl Conf. on Management of  Data, pages 383√¢¬Ä¬ì392, 1992.  [7] C. Combi and G. Cucchi. GCH-OSQL: A TemporallyOriented Object-Oriented Query Language Based on  a Three-Valued Logic. In Proc. of the Fourth Int√¢¬Ä¬ôl  Workshop on Temporal Representation and Reasoning, pages 119√¢¬Ä¬ì127, 1997.  [8] L. Fegaras and R. Elmasri. A Temporal Object Query  Language. In Proc. of the Fifth Int√¢¬Ä¬ôl Workshop on  Temporal Representation and Reasoning, pages 51√¢¬Ä¬ì  59, 1998.  [9] S. K. Gadia. A Homogeneous Relational Model  and Query Language for Temporal Databases. ACM  Transactions on Database Systems, 13(4):418√¢¬Ä¬ì448,  1988.  [10] S. K. Gadia. Applicability of Temporal Data Models to Query Multilevel Security Databases: A Case  Study. In Temporal Databases: Research and Practice, LNCS 1399, pages 238√¢¬Ä¬ì256, 1997.  [11] S.K. Gadia and S.S. Nair. Algebraic Identities and  Query Optimization in a Parametric Model for Relational Temporal Databases. IEEE Transactions on  Knowledge and Data Engineering, 10(5):793√¢¬Ä¬ì807,  1998.  [12] S.K. Gadia and S.S. Nair. Temporal Databases: A Prelude to Parametric Data. In A. Tansel et al, editors,  Temporal Databases: Theory, Design, and Implementation, pages 28√¢¬Ä¬ì66. Benjamin/Cummings, 1993.  References  [13] I. Goralwalla, M. Oƒö¬àzsu, and D. Szafron. An ObjectOriented Framework for Temporal Data Models. In  Temporal Databases: Research and Practice, LNCS  1399, pages 1√¢¬Ä¬ì35, 1997.  [1] E. Bertino, E. Ferrari, and G. Guerrini. T Chimera:  A Temporal Object-Oriented Data Model. Theory and  Practice of Object Systems, 3(2):103√¢¬Ä¬ì125, 1997.  [2] E. Bertino, E. Ferrari, and G. Guerrini. Navigational Accesses in a Temporal Object Model. IEEE  Transactions on Knowledge and Data Engineering,  10(4):656√¢¬Ä¬ì665, 1998.  [14] R. T. Snodgrass.  Temporal Object-Oriented  Databases: A Critical Comparison. In W. Kim,  editor, Modern Database Systems: The Object  Model, Interoperability and Beyond, pages 386√¢¬Ä¬ì408.  Addison-Wesley/ACM Press, 1995.  [3] R. Cattel et al The Object Database Standard:  ODMG 3.0. Morgan-Kaufmann, 1999.  [15] S. Su, S. Hyun, and H. Chen. Temporal Association Algebra: A Mathematical Foundation for Processing Object-Oriented Temporal Databases. IEEE  Transactions on Knowledge and Data Engineering,  10(3):389√¢¬Ä¬ì408, 1998.  [4] T. S. Cheng and S. K. Gadia. An Object-Oriented  Model for Temporal Databases. In Proc. of the  Int√¢¬Ä¬ôl Workshop on an Infrastructure for Temporal  Databases, 1993.  8 