2012 19th International Symposium on Temporal Representation and Reasoning  Guarded Ord-Horn: A Tractable Fragment of  Quantiﬁed Constraint Satisfaction  Hubie Chen  Departament de Tecnologies  Universitat Pompeu Fabra  Barcelona, Spain  hubie.chen@upf.edu  Michał Wrona  Department of Computer and Information Science  Linköpings universitet  SE-581 83 Linköping, Sweden  michal.wrona@liu.se  as the quantiﬁed constraint satisfaction problem (QCSP). A  structure over which the CSP or the QCSP is studied is  typically referred to as a constraint language.  Classical examples of problems that follow this paradigm  are the 2-SAT and Horn-SAT fragments of propositional logic,  and their quantiﬁed analogs, Quantiﬁed 2-SAT [5] and Quantiﬁed Horn-SAT [6]; all of these problems are polynomial-time  tractable. One obtains these problems within the presented  framework in particular by taking the constraint language to  contain all relations deﬁnable by 2-clauses or, respectively,  all relations deﬁnable by Horn clauses. Another example of  this paradigm is the positive ﬁrst-order theory of equality [7],  which can be obtained by taking the quantiﬁed constraint  satisfaction problem on the constraint language containing all  positively deﬁnable relations over equality.  As examples of this paradigm with respect to dense linear  orders < without endpoints, consider the following.  • The constraint language with relations {<, ≤, =} is  known as the point algebra in temporal reasoning; it and  extensions thereof have been studied intensely (see for  example [8], [4], [9] and the references therein), and both  the CSP and QCSP over it are known to be polynomialtime tractable [10].  • Constraints on relations of the form (x < y1 )∨. . .∨(x <  yk ) are known as AND/OR precedence constraints, and  arise naturally in scheduling applications [3].  • Constraint solving over Ord-Horn clauses is of outstanding importance in temporal and spatial reasoning, as  several tractability results there are based into translations  into such clauses. (As a starting point for information on  Ord-Horn, we suggest the references [11], [12], [9]).  Ord-Horn clauses are deﬁned as clauses of the form  (x1 = y1 ∨ · · · ∨ xk = yk ∨ xRy),  where R ∈ {<, ≤, =, =} and it is permitted that k = 0  or that xRy is not present.  A structure whose relations are ﬁrst-order deﬁnable over the  ordered rationals (Q; <) will here be called a temporal constraint language. A complete CSP complexity classiﬁcation  of temporal constraint languages was presented by Bodirsky  and Kára [13]. This classiﬁcation result gives a description  Abstract—The ﬁrst-order theory of dense linear orders without  endpoints is well-known to be PSPACE-complete. We present  polynomial-time tractability results for fragments of this theory  which are deﬁned by syntactic restriction; in particular, our  fragments can be described using the framework of quantiﬁed  constraint satisfaction over Ord-Horn clauses.  I. I NTRODUCTION  The ﬁrst-order theory of dense linear orders without endpoints is a classical object of study in model theory; it  is well-known that this theory is exactly equivalent to the  concrete theory of the ordered rationals (Q; <). The corresponding computational problem of deciding if a sentence  belongs to this theory is PSPACE-complete [1, Lecture 21].  This decision problem appears naturally in various areas of  computer science: for instance, it forms part of the ﬁrst-order  theories of the rationals and of the reals, which are of interest  in computational algebra [2], and many temporal reasoning  and related problems studied in scheduling [3] and artiﬁcial  intelligence [4] admit formulation in this problem. This theory  can also be viewed as the base of and a prototype for (not  necessarily linear) orders possessing further structure, such as  time intervals, branching time, and spatial regions under the  subset ordering.  A natural way to syntactically restrict ﬁrst-order theories  that has proven fruitful in recent complexity studies, and which  we pursue in the present work, is the following. First, expand  the structure(s) of interest by ﬁrst-order deﬁnable relations to  obtain a structure B; as an example, in the case of the ordered  rationals (Q; <), ﬁrst-order deﬁnable relations include those  deﬁned by x ≤ y and (x = y) ∨ (y < z). Then, consider sentences over the expanded structure, but restrict their syntax so  that conjunction (∧) is the only permitted boolean connective.  In the case where only existential quantiﬁcation is permitted,  this problem is the constraint satisfaction problem (CSP) on  B: an instance can be essentially viewed as a prenex formula  with only existential quantiﬁcation, followed by a conjunction  of atomic B-formulas, and the problem is to decide if there  is an assignment to the variables satisfying all of the atomic  formulas, which can be viewed as constraints on the variables.  When both quantiﬁers are present, this problem is known  1530-1311/12 $26.00 © 2012 IEEE  DOI 10.1109/TIME.2012.19  99  into LOGSPACE, NLOGSPACE-complete, P-complete, NPcomplete and PSPACE-complete problems.  of the constraint languages whose CSP is polynomial-time  tractable, and shows that the remaining languages have an NPcomplete CSP. The tractable languages include those examples  just described.  In contrast to the CSP, where Ord-Horn is tractable, it is  known that for the QCSP, there are simple Ord-Horn clauses  that (viewed as constraint languages) are intractable [14]; an  example is the clause (x = y) ∨ (y = z). In this paper, we  present polynomial-time tractability results for the QCSP on  temporal constraint languages deﬁned by Ord-Horn clauses,  thus giving extremely positive complexity results on the  ﬁrst-order theory of dense linear orders without endpoints.  We begin by presenting a class of Ord-Horn clauses called  Basic Ord-Horn Formulas. It has been shown algebraically that  constraint languages deﬁned by such formulas enjoy the socalled local-to-global property [15]. This is an algorithmically  desirable property which (essentially) holds that performing  local consistency, a iterative, tractable method of performing  local inferences on a conjunction of constraints, results in a  computationally wieldy characterization of the global solution  space of the constraints. This property has been intensely  studied and is robust in that it admits formulations from  multiple viewpoints (see the discussion in [10]); in the ﬁnite,  this property is exactly the one for which the classical BakerPixley theorem gives logical and algebraic characterizations.  We then deﬁne a class of formulas called Guarded OrdHorn (GOH) formulas; these formulas generalize the class  of Basic Ord-Horn formulas, and each such formula can be  written as the conjunction of Ord-Horn clauses. The formulas  in this class are described using a recursive syntactic deﬁnition  with Basic Ord-Horn at the base. Our main tractability result  is that constraint languages deﬁnable by GOH formulas have  a polynomial-time decidable QCSP; in developing this result,  we make crucial use of an algebraic characterization of the  local-to-global property for Basic Ord-Horn. An attractive  aspect of this tractability result is that the polynomial-time  algorithm that we present is conceptually simple and based  on novel pebble games. These pebble games generalize local  consistency methods, which have recently received focused  attention for the CSP (see [16] for a state-of-the-art result);  we believe that this paper will help to bring the study of local  consistency methods into focus for the QCSP.  Related work: Quantiﬁed constraint satisfaction problems of temporal constraint languages augmented with relations deﬁned by linear inequalities have been studied in [17].  One example of such a problem is the quantiﬁed version of  the feasibility problem for linear programs. It is shown that  this QCSP is coNP-hard, and contained in PSPACE, but the  precise complexity remains open. The paper presents also a  tractable QCSP; the corresponding constraint language does  not contain any of the tractable languages presented here.  Charatonik and Wrona [18], [19] studied the QCSP for  temporal constraint languages where all relations have a positive ﬁrst-order deﬁnition over the reﬂexive dense linear order  ≤. They showed the complete complexity characterization for  the QCSP on these constraint languages and organized them  II. P RELIMINARIES  A. Quantiﬁed Constraint Satisfaction  Throughout, we assume that each signature is a ﬁnite set of  relation symbols. Let τ be such a signature. A ﬁrst-order τ sentence is a quantiﬁed constraint sentence if it has the form  Q1 v1 . . . Qn vn (ψ1 ∧ . . . ∧ ψm ), where each Qi is a quantiﬁer  from {∀, ∃}, and each ψi is an atomic τ -formula of the form  R(x1 , . . . , xk ) where R ∈ τ .  Let B be a τ -structure with domain B; that is, B has for  each relation symbol R in τ a relation RB ⊆ B k where  k is the arity of R; see for example [20]. The quantiﬁed  constraint satisfaction problem for B, denoted by QCSP(B),  is the problem of deciding, given a quantiﬁed constraint τ sentence Φ, whether or not B |= Φ.  In this paper, we use (Q; <) as a concrete model whose  theory is the one of interest. A temporal relation [13] is  a relation R ⊆ Qk with a ﬁrst-order deﬁnition in (Q; <);  that is, there exists a ﬁrst-order formula φ(x1 , . . . , xk ) with  free variables x1 , . . . , xk such that (a1 , . . . , ak ) ∈ R if and  only if φ(a1 , . . . , ak ) is true in (Q; <). A temporal constraint  language is a relational structure B with domain Q where  each relation RB of B is a temporal relation. In this paper we  study QCSP(B) only for structures B with a ﬁnite signature.  It is well-known and follows from the theorem of RyllNardzewski (see [20]) that all temporal constraint languages  are ω-categorical.  We say that a k-ary function (also called operation)  f : B k → B preserves an m-ary relation R ⊆ B m if  whenever  R(ai1 , . . . , aim ) holds for all 1 ≤ i ≤ k, then    R f (a11 , . . . , ak1 ), . . . , f (a1m , . . . , akm ) holds as well. Let B  be a structure, and let φ be a ﬁrst-order formula with free  variables x1 , . . . , xk . Then we say that f preserves φ (over  B) if f preserves the k-ary relation deﬁned by φ over B. If  f preserves all relations of a relational structure B, we say  that f is a polymorphism of B (see e.g. [21] for background  on the role of polymorphisms in the study of CSPs). Unary  polymorphisms are called the endomorphisms of B; bijective  endomorphisms of B whose inverse is also an endomorphism  are called automorphisms of B. In this paper, use of the term  automorphism is assumed to refer to automorphisms of (Q; <),  unless otherwise speciﬁed. An orbit is a subset of Q-tuples  that is equal to the closure of a tuple t ∈ Qk under all  automorphisms.  Example: The operation min : Q2 → Q that maps two  rational numbers to the minimum of the two numbers is a  polymorphism of the temporal constraint language (Q; ≤, <).  It is not a polymorphism of the temporal constraint language  (Q; =), since it maps for instance the tuples (1, 0) ∈ = and  (0, 1) ∈ = to (0, 0) ∈  / =. An interesting relation that is  preserved by min is the ternary relation deﬁned by the formula  x1 > x2 ∨ x1 > x3 , and the ternary relation U with U (x, y, z)  deﬁned by  (x = y ∧ y < z) ∨ (x = z ∧ z < y) ∨ (x = y ∧ y = z).  100  Deﬁnition 2.1: Let B be any set. A k-ary operation f :  B k → B is called a quasi near-unanimity function (or QNUF)  if for all x, y ∈ B we have  Theorem 2.4: [15] For any ﬁnite set F of basic OH formulas, there exists a main-injective surjective oligopotent QNUF  preserving all formulas in F .  f (x, x, . . . , x, y) = f (x, x, . . . , y, x) =  . . . = f (y, x, . . . , x, x) = f (x, . . . , x) .  III. T RACTABILITY OF G UARDED O RD -H ORN  A. Deﬁnitions  Throughout, we will use GOH as short for Guarded OrdHorn.  Deﬁnition 3.1: The set of GOH formulas over a variable  set V is deﬁned inductively as follows.  1) Basic OH formulas are GOH.  2) If ψ1 and ψ2 are GOH formulas, then ψ1 ∧ ψ2 is a GOH  formula.  3) If ψ is a GOH formula, then  (x1 ≤ y1 ) ∧ . . . ∧ (xm ≤ ym )∧  (x1 = y1 ∨ . . . ∨ xm = ym ∨ ψ)  is a GOH formula. Here, it is assumed that the variables  xi , yi are contained in V .  We refer to GOH formulas formed according to these rules  as formulas of type 1, 2, and 3, respectively.    Deﬁnition 3.2: A relation R ⊆ Qn is GOH if there exists  a GOH formula φ over the variables {v1 , . . . , vn } such that  R(v1 , . . . , vn ) ≡ φ(v1 , . . . , vn ). A structure B is GOH if it is  over a ﬁnite signature and each of its relations is GOH, that  is, if for every relation symbol S from the signature of B, it    holds that S B is GOH.  We now introduce a normal form for GOH formulas.  Deﬁnition 3.3: A GOH formula φ is normal if for each  subformula of type 3, it holds that, for each i ∈ [m], the  variables xi and yi are different.    Proposition 3.4: Each GOH formula φ is logically equivalent to a normal GOH formula N (φ).  Proof. We show how to construct inductively, from any GOH  formula φ, a normal GOH formula N (φ). We consider the  three types of GOH formulas in turn.  1) N (φ) = φ  2) N (ψ1 ∧ ψ2 ) = N (ψ1 ) ∧ N (ψ2 )  3) When φ = (x1 ≤ y1 ) ∧ . . . ∧ (xm ≤ ym ) ∧ (x1 =  y1 ∨ . . . ∨ xm = ym ∨ ψ), let i1 , . . . , in be a list of the  elements of D = {i | xi , yi are different variables }.  Let N (φ) be the formula (xi1 ≤ yi1 ) ∧ . . . ∧ (xin ≤  yin ) ∧ (xi1 = yi1 ∨ . . . ∨ xin = yin ∨ ψ), where it is  understood that N (φ) = ψ if D = ∅.  It is clear that any GOH formula φ is equivalent to a normal  GOH formula N (φ), over (Q, <).   Deﬁnition 3.5: Let φ be a normal GOH formula. We deﬁne  the guards formula of φ, denoted by G(φ), inductively as  follows. We consider the three types of GOH formulas in turn.  1) For a basic OH formula φ: G(φ) = φ  2) G(ψ1 ∧ ψ2 ) = G(ψ1 ) ∧ G(ψ2 )  3) G((x1 ≤ y1 ) ∧ . . . ∧ (xm ≤ ym ) ∧ (x1 = y1 ∨ . . . ∨ xm =  ym ∨ ψ)) = (x1 ≤ y1 ) ∧ . . . ∧ (xm ≤ ym )  For an arbitrary GOH formula φ, we deﬁne the guards  formula of φ as G(φ) = G(N (φ)), where N (φ) is the operator  from Proposition 3.4.      A polymorphism f : B k → B of B is called oligopotent  (wrt B) if the mapping f ∗ : B → B deﬁned by f ∗ (x) :=  f (x, . . . , x) preserves all ﬁrst-order deﬁnable relation of B.  This deﬁnition is different from the deﬁnition in [22], but  equivalent to it (see Proposition 12 in that paper), and more  convenient for our purposes.  Theorem 2.2 (follows from Theorem 19 in [22]): Let B be  an ω-categorical relational structure with an oligopotent k +1ary polymorphism that is a quasi near-unanimity operation, for  some k ≥ 2. Then every n-ary relation R in B contains all  tuples t such that for every subset I of {1, . . . , n} with |I| ≤ k  there is a tuple s ∈ R such that t[i] = s[i] for all i ∈ I.  A simple example of an oligopotent QNUF is the ternary  median operation median: Q3 → Q which maps its three  arguments to the middle value of those arguments; if two  or more arguments are equal to a value c, then the median  operation returns c. In particular, median(x, x, x) = x for all  x ∈ Q, and hence median is oligopotent.  Let B be a structure with domain B over signature τ .  If E ⊆ B 2 is an equivalence relation, we write B/E for  the factor structure A with signature τ , deﬁned as follows.  The domain of A consists of the equivalence classes of  E, and for each relation symbol R ∈ τ we have RA =  {([c1 ], . . . , [ck ]) | (c1 , . . . , ck ) ∈ RB }, where [c] denotes the  E-equivalence class of c ∈ D.  B. Basic Ord-Horn  Throughout, we use OH as short for Ord-Horn.  Deﬁnition 2.3: The set of basic OH formulas over a variable set V is the set containing the following formulas:  • x = y,  • x ≤ y,  • (x1 = y1 ∨ . . . ∨ xp = yp ),  • (x1 = x2 ∨. . . x1 = xq )∨(x1 < y1 )∨(y1 = y2 ∨. . . y1 =  yq ).    It is assumed that the variables x, y, xi , yi are in V .  It has been demonstrated that an oligopotent QNUF with  certain desirable properties can be constructed for basic OH  formulas. We describe the result by making use of the following notions from [10, Section 4], adapted to the current  context. Let t ∈ Qk be a tuple, where k ≥ 3, and let  π : [k] → [k] be a permutation such that tπ(1) ≤ · · · ≤ tπ(k) .  If it holds that tπ(2) = · · · = tπ(k−1) , we say that this value  is the main value of t. Not every tuple t ∈ Qk has a main  value, but when a tuple has a main value, it is unique. We  deﬁne the equivalence relation ≡m on Qk as follows: t ≡m t  if and only if t = t or t, t have the same main value. We  say that an operation h : Qk → Q is main-injective if for all  t, u ∈ Qk , it holds that h(t) = h(u) if and only if t ≡m u.  101  Clearly, every guards formula is the conjunction of basic  OH formulas.  Deﬁnition 3.6: Let B be a GOH structure over signature σ,  and let R(w1 , . . . , wn ) be an atomic formula over σ (where the  variables w1 , . . . , wn are not necessarily distinct). We deﬁne  R(w1 , . . . , wn ) as the formula G(φ(w1 , . . . , wn )), where φ  is a GOH formula for RB (as in Deﬁnition 3.2). We extend  this notation to quantiﬁed constraint sentences by deﬁning, for  such a sentence Φ = Qv1 v1 . . . Qvn vn ∧m  i=1 ψi , where the ψi  are atomic formulas, Φ = Qv1 v1 . . . Qvn vn ∧m    i=1 ψi .  We observe that if the sentence Φ is true with respect to a  GOH structure B, then the sentence Φ is also true: one can  conceive of Φ as a relaxation of Φ.  We will make use of the following consequence of Theorem 2.4.  Corollary 3.7: Let B be a GOH structure over signature  σ. There exists a main-injective surjective oligopotent QNUF  preserving all formulas of the form R(w1 , . . . , wn ), where  R(w1 , . . . , wn ) is an atomic formula over σ.  Proof. There are clearly a ﬁnite number of such formulas of  the described form, up to renaming of variables. Each such  formula is the conjunction of basic OH formulas; letting F  be the set of all basic formulas that can appear in such a  conjunction, the result follows directly from Theorem 2.4.   corresponding structure pebble is removed. At the start of the  game, no pebbles are in play. The Duplicator wins if he can  play forever in such a way that the mapping from variables to  B-elements determined by pebbles is always a partial solution.  The notion of partial solution that we use in formalizing  the pebble games used is that of projective homomorphism.  We say that a function f deﬁned on a subset of VΦ is a  projective homomorphism of Φ if for each atomic formula  R(v1 , . . . , vk ) of Φ, there exists an extension of f that satisﬁes  R(v1 , . . . , vk ) over B. Equivalently, such a function f is a  projective homomorphism of Φ if for each atomic formula  R(v1 , . . . , vk ), there exists a tuple (b1 , . . . , bk ) ∈ RB such  that for all vi ∈ dom(f ), it holds that f (vi ) = bi . We use  dom(f ) to denote the domain of a function f . Similarly, we  say that a function f deﬁned on a subset of VΦ is a projective  homomorphism of Φ if for each formula R(v1 , . . . , vk ) in  Φ corresponding to an atomic formula of Φ, there exists an  extension of f that satisﬁes R(v1 , . . . , vk ) over B.  The notion of a (Duplicator) winning strategy for the kpebble game can be formalized in the following way.  Deﬁnition 3.8: A winning strategy for the k-pebble game  (on Φ) is a set S of projective homomorphisms, each having  domain of size less than or equal to k, that satisﬁes the  following conditions.  (1) The partial function with empty domain is an element  of S,  (2) If f ∈ S and g is a restriction of f , then g ∈ S.  (3) If f ∈ S, |dom(f )| < k, v ∈ VΦ , and dom(f ) <Φ v,  then f can be (v, Qv )-extended in S.  We say that an operation f can be (v, Q)-extended in a set  of operations S if:  • when Q = ∃, there exists an extension g ∈ S of f with  domain dom(g) = dom(f ) ∪ {v}, and  • when Q = ∀, every extension g of f with domain  dom(g) = dom(f ) ∪ {v} is in S.    We next introduce an extension of the k-pebble game where  the Spoiler can perform “backmoves” or “backpebbling”: he  can place a pebble on a variable that does not come after all  pebbled variables, and the Duplicator must respond.  Deﬁnition 3.9: A winning strategy for the k-pebble game  with backmoves (on Φ) is a set S of projective homomorphisms, each having domain of size less than or equal to k, that  is a winning strategy for the k-pebble game (Deﬁnition 3.8)  and in addition satisfy the following condition.  (4) If f ∈ S, |dom(f )| < k, v ∈ Vφ , and dom(f ) <Φ v,  then there exists an extension g ∈ S of f with domain  dom(g) = dom(f ) ∪ {v}.    The deﬁnition of the k-pebble game with backmoves naturally gives rise to an algorithm for deciding whether or not  there is a winning strategy for this game. The algorithm is as  follows.  It is clear that, for each ﬁxed k, and any ﬁnite structure  B, the algorithm runs in polynomial time, measured with  B. Pebble games  Throughout this subsection, Φ denotes a quantiﬁed constraint sentence Φ = Qv1 v1 . . . Qvn vn φ in prenex form. We  use VΦ to denote the set of variables {v1 , . . . , vn } of Φ, and for  each variable v ∈ VΦ , we use Qv to denote its corresponding  quantiﬁer. We write u <Φ v to indicate that u occurs strictly  before v in the quantiﬁer preﬁx of Φ; we write u ≤Φ v to  indicate that u <Φ v or u = v. We extend this notation to  sets of variables U, W ; we write, for instance, that U <Φ W  if u <Φ w for all u ∈ U, w ∈ W , and that U <Φ w for a  variable w if U <Φ {w}. We assume that B is a relational  structure and that Φ is a quantiﬁed constraint sentence that is  an instance of QCSP(B). Much of the development is relative  to the structure B, but we will generally suppress explicitly  mentioning the structure B.  In order to establish our tractability result, we will consider  a number of pebble games (for more on pebble games in  the context of constraint satisfaction, see e.g. [23]). The most  basic pebble game that we will consider is here referred to  simply as the k-pebble game, and is based on the pebble  game for quantiﬁed constraint sentences deﬁned by Chen  and Dalmau [24]. The k-pebble game is played between  two players, Spoiler and Duplicator. Spoiler can use up to  k pebbles, and can perform two actions. First, Spoiler can  place a pebble on a variable of the sentence that comes after  all variables having pebbles; if it is an existentially quantiﬁed  variable, Duplicator has to respond by placing a pebble on  an element b of the structure B, and if it is a universally  quantiﬁed variable, the Spoiler also places a pebble on an  element b of B of his choosing. Second, Spoiler can remove a  pebble that is on a variable of the sentence, in which case the  102  of S.  (2’) If f ∈ S and g is a restriction of f to a set of the form  {v1 , v2 , . . . , vi }, then g ∈ S.  (3’) If f ∈ S, dom(f ) = {v1 , v2 , . . . , vi }, and i < n, then f  can be (vi+1 , Qvi+1 )-extended in S.    Proposition 3.12: A quantiﬁed constraint sentence Φ is true  if and only if there exists a winning strategy for the truth  pebble game on Φ.  We now show that the maximal winning strategy for the  k-pebble game with backmoves fully supports any winning  strategy for the truth pebble game, in the following sense.  Proposition 3.13: Let Φ be a quantiﬁed constraint sentence.  Let S be the strategy computed by the algorithm for the  k-pebble game with backmoves (on Φ). If there exists a  winning strategy T for the truth pebble game (on Φ), then  S is nonempty and contains all restrictions of operations in T  to domains of size less than or equal to k.  Proof. We prove that, at each stage of the algorithm, all such  restrictions of operations in T are contained in S. It is clear  that, after step (1) is performed, this holds. We thus show that  if this holds, then no such restriction of an operation in T can  be removed from S by one of the removal rules in step (2),  as follows.  In each of the following arguments, we suppose that f ∈ S  is the restriction of an operation h ∈ T .  • All restrictions of f are restrictions of h, and are hence  all contained in S.  • Let vj ∈ VΦ with |dom(f )| < k and dom(f ) <Φ vj . We  make use of properties (2’) and (3’) of Deﬁnition 3.11.  By property (2’), there exists a restriction h1 ∈ T of h  / dom(h1 ). By  such that dom(f ) ⊆ dom(h1 ) but vj ∈  possibly repeated application of property (3’), one can  obtain h2 ∈ T with domain {v1 , . . . , vj−1 } such that  h2 extends h1 , and f is a restriction of h2 . Since h2  can be (vj , Qvj )-extended in T , the operation f can be  (vj , Qvj )-extended in S.  • Let v ∈ VΦ with |dom(f )| < k and dom(f ) <Φ v. We  have that h is deﬁned on v, and hence the restriction of  h to dom(f ) ∪ {v} is contained in S.    Algorithm for k-pebble game with backmoves.  Input: a quantiﬁed constraint sentence Φ  1. Let S be the set of all projective homomorphisms  of Φ having domain of size less than or equal to k,  relative to the structure B of interest.  2. Repeat until no changes are possible:  •  If there exists f ∈ S having a restriction g not  in S, then remove f from S.  •  If there exists f ∈ S and v ∈ VΦ with  |dom(f )| < k and dom(f ) <Φ v such that  f cannot be (v, Qv )-extended in S, then  remove f from S.  •  If there exists f ∈ S and v ∈ VΦ with  |dom(f )| < k and dom(f ) <Φ v such that  there is no extension g ∈ S of f with domain  dom(g) = dom(f ) ∪ {v}, then remove f  from S.  3. Return S.  respect to the input Φ. This algorithm can be applied to  temporal constraint languages B by maintaining, at all times,  an orbit representative for each orbit that is present in S, and  then performing the described computations using the orbit  representatives; this is justiﬁed by the fact that the set of  all projective homomorphisms is closed under automorphism.  Again, for each ﬁxed k and any temporal constraint language  B, the algorithm runs in polynomial time in the input Φ.  In the case that, when the algorithm terminates, the set S  is nonempty, we call this resulting strategy S the maximal  winning strategy. The following proposition is straightforward  to verify.  Proposition 3.10: Let S be the set returned by the algorithm for the k-pebble game with backmoves on a quantiﬁed  constraint sentence Φ.  • For any winning strategy T for this game (on Φ), it holds  that T ⊆ S.  • If S = ∅, then there is no winning strategy for this game  (on Φ).  We consider one more pebble game, the truth pebble  game, which characterizes the truth of a quantiﬁed constraint  sentence.  Deﬁnition 3.11: A winning strategy for the truth pebble  game (on Φ = Qv1 v1 . . . Qvn vn φ) is a set S of projective homomorphisms, each having domain of the form  {v1 , v2 , . . . , vi } for some i ≥ 0, that satisfy the following  conditions.  (1) The partial function with empty domain is an element  It is straightforward to verify that, for an instance Φ of  QCSP(B) and a winning strategy S for one of the pebble  games considered in this subsection, the closure of S under  the surjective polymorphisms of B is also a winning strategy  for the pebble game. In what follows, we will tacitly assume  that winning strategies are closed under such polymorphisms.  C. Algorithm  In this subsection, we present our algorithm for Guarded  Ord-Horn, and prove its correctness.  Before presenting our algorithm, we introduce a couple of  notions. Let us say that a winning strategy S for the k-pebble  game with backmoves (on Φ) implies the equality u = v,  where u, v are distinct variables in VΦ , if every operation f ∈  103  S with domain dom(f ) = {u, v} has the property that f (u) =  f (v). Our algorithm will detect implied equalities and simplify  quantiﬁed sentences; the notion of simpliﬁcation used is as  follows. Let u <Φ v be two variables in VΦ . We use Φ[u ← v]  to denote the sentence obtained from Φ by eliminating v and  its quantiﬁer from the quantiﬁer preﬁx, and by replacing every  instance of v in the quantiﬁer-free part with u.  with backmoves that does not imply any equalities, then the  sentence Φ has a winning strategy for the truth pebble game.  We establish Theorem 3.14 via a sequence of lemmas. In  what follows, we assume that the hypotheses of Theorem 3.14  are in effect. We will make use of the following notion. Relative to a sentence Φ, let us say that a projective homomorphism  f is exinjective (“existentially injective”) when for all pairs  of variables u, v ∈ dom(f ), if u <Φ v and Qv = ∃, then  f (u) = f (v). We say that a set of projective homomorphisms  is exinjective if all of the projective homomorphisms it contains are exinjective.  Lemma 3.15: If the sentence Φ has a winning strategy S  for the k-pebble game with backmoves that does not imply  any equalities, then this sentence has an exinjective winning  strategy for the k-pebble game.  In the proof of this lemma, we will use the notation c,  where c ∈ Q, to denote the k-tuple (c, . . . , c) ∈ Qk having  all entries equal to c. We will also make use of the following  type of operation. For a constant c ∈ Q, deﬁne pc : Q2 → Q  to be a surjective operation such that pc (x, y) < pc (x , y  ) if  and only if either (1) x < x , or (2) x = x = c and y < y  ;  it is easy to see that such operations exist.  See Fig. 1 for an illustration of such an operation. In this  illustration, if we link (x, y), (u, v) ∈ Q2 by an arc from (x, y)  to (u, v) then this means that f (x, y) < f (u, v); if (x, y) is  linked to (u, v) by an undirected line, then f (x, y) = f (u, v).  Algorithm for QCSP(B) where B is a GOH-structure.  Input: a quantiﬁed constraint sentence Φ  1. Run the algorithm for the k-pebble game with  backmoves on Φ, where k is the arity of the QNUF  from Corollary 3.7; let S be the result.  2. If S = ∅, return FALSE.  Otherwise, check to see if S implies any equalities.  If it does, let u = v be an implied equality, with  u <Φ v; replace Φ with Φ[u ← v];  and return to step 1.  3. Return TRUE.  Clearly, this algorithm runs in polynomial time: each time it  performs a replacement of Φ, one variable is eliminated (and  the sentence is shortened), and so it loops at most |VΦ | times;  and, as previously discussed, the algorithm for the k-pebble  game with backmoves runs in time polynomial in the size of  the input sentence. We thus turn to discuss the correctness of  the algorithm.  When the algorithm detects an implied equality u = v,  with u <Φ v, the variable v must be existentially quantiﬁed,  since a function with domain {u} can be (v, Qv )-extended in  a winning strategy for the pebble game. Also, in this case,  by Proposition 3.13, all functions f contained in winning  strategies for the truth pebble game on Φ that are deﬁned on  {u, v} set f (u) = f (v). Since a winning strategy for the truth  pebble game on Φ must be a winning strategy for the truth  pebble game for Φ, this property also holds for all functions  f contained in winning strategies for the truth pebble game  on Φ, and so the sentence Φ[u ← v] is true if and only if the  sentence Φ is true.  We have thus shown that the replacement step preserves  the truth of the sentence; it follows by Proposition 3.13 that if  the algorithm returns “FALSE”, then the input sentence was  indeed false. It remains to show that if the algorithm returns  “TRUE”, then the sentence is true. To demonstrate this, it  sufﬁces to provide a proof of the following theorem.  Theorem 3.14: Let B be a GOH structure, let k be the arity  of the QNUF from Corollary 3.7, and let Φ be a quantiﬁed  constraint sentence that is an instance of QCSP(B). If the  sentence Φ has a winning strategy for the k-pebble game  c  Fig. 1.  An illustration of an operation pc .  Observe that all such operations pc preserve all basic OH  formulas. We present the following sub-lemma.  Lemma 3.16: Let R be a relation deﬁned by a basic OH  formula and c ∈ Q be a constant. Then pc preserves R.  Proof. In what follows, we write φR for a GOH formula  deﬁning R. Moreover, tx denotes a coordinate of t ∈ R that  corresponds to a variable x occurring in φR .  A basic OH formula is in one of four forms. If φR is an  equality, then R is preserved by all functions and hence by  pc . We now consider the case where φR is of the form x ≤ y.  Let t, u ∈ R. Then, by the deﬁnition of pc , it is not hard to  see that pc (tx , ux ) ≤ pc (ty , uy ). Thus pc (t, u) is in R and pc  preserves R.  If φR is of the form (x1 = y1 ∨ . . . ∨ xp = yp ) and t ∈ R,  then there is i ∈ [p] such that txi = tyi . Assume without loss  104  of generality that txi < tyi . Let u ∈ R be any tuple. We now  show that pc (t, u) is in R and thereby that R is preserved by  pc . To see this observe that pc (txi , uxi ) < pc (tyi , uyi ).  Finally, let φR be of the form (x1 = x2 ∨ . . . ∨ x1 =  xq ) ∨ (x1 < y1 ) ∨ (y1 = y2 ∨ . . . ∨ y1 = yq ). If t ∈ R, then  we have one of the following situations:  • there is i ∈ [q] such that tx1 = txi ;    • there is i ∈ [q ] such that ty1 = tyi ;  • tx1 < ty1 .  Let u ∈ R. To show that pc (t, u) ∈ R regardless of the reason  why t ∈ R we use the same argument as in the case where  φR is of the form (x1 = y1 ∨ . . . ∨ xp = yp ).  For each type of a basic OH formula φR we showed that  R is preserved by pc . Thus we proved the lemma.   By making use of automorphisms and the fact that S is a  winning strategy, we can obtain a homomorphism a1 ∈ S  with dom(a1 ) = dom(f ) where a1 (y) = −α and a1 = α  elsewhere. Observe that a1 is exinjective, and hence any  restriction thereof is also exinjective. We claim that there is  an extension c1 of a1 with dom(c1 ) = dom(a1 ) ∪ {v} where  / {−α, α}. Let b ∈ S be an extension of a1 with  c1 (v) ∈  dom(b) = dom(a1 ) ∪ {v}. If b does not satisfy the desired  property, then b(v) ∈ {−α, α}. Let b1 ∈ S be the restriction  of a1 to the set J = {w ∈ dom(a1 ) | a1 (w) = b(v)}. By  the induction hypothesis, b1 can be extended to an exinjective  b1 ∈ S with dom(b1 ) = dom(b1 ) ∪ {v}. By backpebbling,  b1 can be extended to an operation b2 ∈ S with dom(b2 ) =  dom(f )∪{v}. Consider the function pb(v) (b, b2 ). The function  b is equal to b(v) at J ∪ {v}; on that set, the function b2 is  equal to b(v) on J, and to a different value at v. We can thus  take c1 = pb(v) (b, b2 ).  After application of an automorphism, we have obtained an  operation c1 having dom(c1 ) = dom(f ) ∪ {v} where c1 (y) =  / {−α, α}, and c1 = α elsewhere. By a similar  −α, c1 (v) ∈  argument, we can obtain an operation c2 having dom(c2 ) =  / {−α, α}, and c2 =  dom(f ) ∪ {v} where c2 (y) = α, c2 (v) ∈  −α elsewhere.  Suppose that one of the values c1 (v), c2 (v) is strictly greater  than α, and that the other is strictly less than −α. Let d1 , d2 ∈  {c1 , c2 } be such that d1 (v) > α and d2 (v) < −α. We can  ﬁnd automorphisms γ1 , γ2 such that γ1 (d1 ) is positive on v,  and negative elsewhere; and, γ2 (d2 ) is positive everywhere.  Consider the function g = q(γ1 (d1 ), γ2 (d2 ), h, . . . , h), where  q is the QNUF from the formulation of Theorem 3.14. On  dom(f ), this g is equal to q(0), since on these variables the  values that q is applied to yield the main value 0. On the other  hand, g(v) is not equal to q(0), since on v both γ1 (d1 ), γ2 (d2 )  are positive, and hence there is no main value.  In other cases, we will demonstrate that there are automorphisms γ1 , γ2 each of which ﬁxes both −α and α such that  g = q(γ1 (d1 ), γ2 (d2 ), h, . . . , h) is not equal to q(0) on v;  this sufﬁces, since for such automorphisms g is equal to q(0)  elsewhere. If both d1 (v), d2 (v) are strictly greater than α, then  one can take both γ1 , γ2 to be the identity automorphisms,  as then the tuple q is applied to will have no main value.  Similarly, if both d1 (v), d2 (v) are strictly less than −α, then  one can take both γ1 , γ2 to be the identity automorphisms.  The remaining case is where one or both of d1 (v), d2 (v)  is in the interval (−α, α). Suppose that d1 (v) ∈ (−α, α).  The automorphism γ2 can be deﬁned so that γ2 (d2 (v)) = 0.  Then, γ1 can be deﬁned so that γ1 (d1 (v)) is positive if  γ2 (d2 (v)) is positive, and negative if γ2 (d2 (v)) is negative.  The argumentation for the subcase where d2 (v) ∈ (−α, α) is  similar.   Proof. (Lemma 3.15) Let S  be the set containing all projective  homomorphisms in S that are exinjective. We will show that S   gives the desired exinjective winning strategy. Let us consider  the properties of Deﬁnition 3.8. It is clear that S  inherits  properties (1) and (2) from S. Also, S  inherits the property  (3) in the case that Qv = ∀. It thus sufﬁces to prove the  following claim.  Claim: if f ∈ S is exinjective, |dom(f )| < k, v ∈ VΦ ,  Qv = ∃, and dom(f ) <Φ v, then there is an exinjective  extension g ∈ S of f with dom(g) = dom(f ) ∪ {v}.  We prove the claim by induction on |dom(f )|. For  |dom(f )| = 0, the claim is obvious. For |dom(f )| = 1,  the claim follows from the hypothesis that S does not imply  any equalities. So, we suppose that |dom(f )| ≥ 2. As S is  a winning strategy for the k-pebble game, there exists an  extension h ∈ S of f with dom(h) = dom(f ) ∪ {v}. Let  I = {w ∈ dom(f ) | h(v) = f (w)}. We now consider two  cases; it can be remarked that if I = ∅, then one can simply  take g = h.  Case I = dom(f ): let u ∈ dom(f ) \ I, that is, let u ∈  dom(f ) be a variable such that h(v) = f (u). Let h1 be the  restriction of h to dom(f ) \ {u}. By the induction hypothesis,  there exists an exinjective extension h2 of h1 whose domain  dom(h2 ) is equal to dom(h) \ {u} = (dom(f ) ∪ {v}) \ {u}.  By applying a backmove to h2 , we obtain an extension h3 of  h2 with dom(h3 ) = dom(h).  Consider the function ph(v) (h, h3 ). Recall that the deﬁnition  of the polymorphism pc , where c ∈ Q, is above Lemma 3.16.  The function h is equal to h(v) at I ∪ {v}; on I ∪ {v},  the function h3 is equal to h(v) on I, but equal to a value  different from h(v) at v. Hence, the function ph(v) (h, h3 )  is exinjective, but there exists an automorphism β such that  β(ph(v) (h, h3 )) = f on dom(f ), and so we can take g =  β(ph(v) (h, h3 )).  Case I = dom(f ): let us assume that h is equal to 0  everywhere on its domain; for other values, the same argument  will apply under translation by an automorphism. Observe  that, since f is exinjective, all variables of dom(f ), except  for possibly the earliest one, are universally quantiﬁed. Let  y be the latest occurring variable in dom(f ), which must be  universally quantiﬁed. Fix α > 0 to be a positive constant.  Lemma 3.17: If the sentence Φ has an exinjective winning  strategy for the k-pebble game then this sentence has an  exinjective winning strategy for the truth pebble game.  Proof. Let S be an exinjective winning strategy for the kpebble game. Let T be the set containing all exinjective  105  functions f from a subset of VΦ to Q such that every restriction  of f to a set of size ≤ k is contained in S. Every function in  T is a projective homomorphism by Theorem 2.2. Clearly, T  is non-empty, as S ⊆ T , and is closed under restriction. We  will prove the following claim.  Claim: for every function f ∈ T and variable v ∈ VΦ with  dom(f ) <Φ v, the function f can be (v, Qv )-extended in T .  This claim sufﬁces to give the lemma, as then the set of  functions in T having domain of the form {v1 , v2 , . . . , vi }  forms the desired exinjective winning strategy for the truth  pebble game.  The claim is clear when Qv = ∀ by the deﬁnition of T , so  let Qv = ∃. We prove the claim by induction on |dom(f )|. The  base case |dom(f )| < k is clear by deﬁnition of T , so suppose  that |dom(f )| ≥ k. Let u1 , . . . , uk be distinct elements from  dom(f ), and for each i ∈ [k] deﬁne fi to be the restriction of  f to dom(f ) \ {ui }. Each fi has, by induction, an exinjective  extension gi ∈ T deﬁned on (dom(f ) \ {ui }) ∪ {v}. Let g be  the function on dom(f )∪(v) deﬁned by g(u) = q(f (u)) for all  u ∈ dom(f ), and g(v) = q(g1 (v), . . . , gk (v)). By the QNUF  identities and the fact that each gi is in T , we obtain that g is  in T . Since each of the gi is exinjective, for all i, j ∈ [k] with  j = i, it holds that gj (v) = gj (ui ) = f (ui ). It follows that the  tuple (g1 (v), . . . , gk (v)) cannot have as main value any of the  values f (u1 ), . . . , f (uk ). Hence, the function g is exinjective.    Lemma 3.18: If the sentence Φ has an exinjective winning  strategy for the truth pebble game then that strategy is a  winning strategy for the truth pebble game on Φ.  Proof. Let R(t) be an atomic formula from the quantiﬁer-free  part of Φ, where t is a tuple of variables, and let φ(t) be  the normal GOH formula for R(t). Let φ (t) be the guards  formula of φ(t); the formula φ (t) is the formula for R(t).  The formula φ(t) can be viewed as the conjunction of GOH  formulas of types 1 and 3. We show that each such formula is  satisﬁed by any f ∈ S whose domain contains the variables  of t, which sufﬁces.  A basic OH formula is satisﬁed by f because f satisﬁes the  corresponding identical subformula in φ (t).  Now consider a formula  Proof. If the algorithm returns “FALSE”, falsity of the input sentence follows directly from Proposition 3.13. If the  algorithm returns “TRUE”, truth of the input sentence follows  directly from Theorem 3.14 and Proposition 3.12.   ACKNOWLEDGMENT  Hubie Chen is supported by the Spanish program ”Ramon  y Cajal” and MICINN grant TIN2010-20967-C04-02.  R EFERENCES  [1] D. Kozen, Theory of Computation. Springer, 2006.  [2] S. Basu, R. Pollack, and M.-F. Roy, Algorithms in Real Algebraic  Geometry, 2nd edition. Springer-Verlag, 2009.  [3] R. H. Möhring, M. Skutella, and F. Stork, “Scheduling with and/or  precedence constraints,” SIAM J. Comput., vol. 33, no. 2, pp. 393–415,  2004.  [4] M. Broxvall and P. Jonsson, “Point algebras for temporal reasoning:  Algorithms and complexity,” Artif. Intell., vol. 149, no. 2, pp. 179–220,  2003.  [5] B. Aspvall, M. F. Plass, and R. E. Tarjan, “A linear-time algorithm for  testing the truth of certain quantiﬁed boolean formulas,” Inf. Process.  Lett., vol. 8, no. 3, pp. 121–123, 1979.  [6] M. Karpinski, H. K. Büning, and P. H. Schmitt, “On the computational  complexity of quantiﬁed horn clauses,” in CSL, 1987, pp. 129–137.  [7] D. Kozen, “Positive ﬁrst-order logic is NP-complete,” IBM Journal of  Research and Development, vol. 25, no. 4, pp. 327–332, 1981.  [8] P. van Beek, “Reasoning about qualitative temporal information,” Artiﬁcial Intelligence, vol. 58, pp. 297–326, 1992.  [9] M. Fisher, D. Gabbay, and L. Vila, Eds., Handbook of Temporal  Reasoning in Artiﬁcial Intelligence. Elsevier, 2005.  [10] M. Bodirsky and H. Chen, “Qualitative temporal and spatial reasoning  revisited,” in CSL’07, 2007, pp. 194–207.  [11] B. Nebel and H.-J. Bürckert, “Reasoning about temporal relations: A  maximal tractable subclass of Allen’s interval algebra,” JACM, vol. 42,  no. 1, pp. 43–66, 1995.  [12] P. Balbiani, J.-F. Condotta, and L. F. del Cerro, “Tractability results in  the block algebra,” J. Log. Comput., vol. 12, no. 5, pp. 885–909, 2002.  [13] M. Bodirsky and J. Kára, “The complexity of temporal constraint satisfaction problems,” Accepted for publication in the Journal of the ACM,  2009, an extended abstract appeared in the proceedings of STOC’08.  [14] M. Bodirsky and H. Chen, “Quantiﬁed equality constraints,” SIAM  Journal on Computing, vol. 39, no. 8, pp. 3682–3699, 2010.  [15] M. Wrona, “Syntactically characterizing local-to-global consistency in  ord-horn,” in the proceedings of 18th International Conference on  Principles and Practice of Constraint Programming.  [16] L. Barto and M. Kozik, “Constraint satisfaction problems of bounded  width,” in Proceedings of FOCS’09, 2009.  [17] K. Subramani, “On a decision procedure for quantiﬁed linear programs,”  Ann. Math. Artif. Intell., vol. 51, no. 1, pp. 55–77, 2007.  [18] W. Charatonik and M. Wrona, “Tractable quantiﬁed constraint satisfaction problems over positive temporal templates,” in LPAR, 2008, pp.  543–557.  [19] ——, “Quantiﬁed positive temporal constraints,” in CSL, 2008, pp. 94–  108.  [20] W. Hodges, A shorter model theory. Cambridge: Cambridge University  Press, 1997.  [21] A. Bulatov, A. Krokhin, and P. G. Jeavons, “Classifying the complexity  of constraints using ﬁnite algebras,” SIAM Journal on Computing,  vol. 34, pp. 720–742, 2005.  [22] M. Bodirsky and H. Chen, “Oligomorphic clones,” Algebra Universalis,  vol. 57, no. 1, pp. 109–125, 2007.  [23] V. Dalmau, P. G. Kolaitis, and M. Y. Vardi, “Constraint satisfaction,  bounded treewidth, and ﬁnite-variable logics,” in Proceedings of CP’02,  2002, pp. 310–326.  [24] H. Chen and V. Dalmau, “From pebble games to tractability: An ambidextrous consistency algorithm for quantiﬁed constraint satisfaction,”  in CSL, 2005, pp. 232–247.  (x1 ≤ y1 ) ∧ . . . ∧ (xm ≤ ym ) ∧ (x1 = y1 ∨ . . . ∨ xm = ym ∨ ψ)  of type 3. It sufﬁces to show that each inequality xi ≤ yi is  satisﬁed in a way that x and y are set to different values. Let  u, v ∈ VΦ be such that {u, v} = {xi , yi } and u <Φ v. Note  that xi , yi are distinct variables, since φ(t) is a normal GOH  formula. We claim that Qv = ∃, which sufﬁces, as the strategy  S is exinjective.  Suppose for a contradiction that Qv = ∀. Then the restriction of f to {u} can be extended to a function g ∈ S  with dom(g) = {u, v} such that g does not satisfy xi ≤ yi ,  contradicting that S is a winning strategy for Φ.   We can now conclude our main polynomial-time decidability result.  Theorem 3.19: Let B be a GOH structure. The problem  QCSP(B) is polynomial-time decidable.  106 