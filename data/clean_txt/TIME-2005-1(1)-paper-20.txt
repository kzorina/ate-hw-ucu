A Local Method for Prioritized Fusion of Temporal Information  Mahat Khelfallah and BelaÃ„Ä…ÄšÂˆd Benhamou  Laboratoire des Sciences de lÃ¢Â€Â™Information et des SysteÄšÂ€mes LSIS - UMR CNRS 6168  Provence University  CMI, TechnopoÄšÂ‚le de ChaÄšÂ‚teau Gombert  39, rue Joliot-Curie - 13453 Marseille - France.  {mahat,benhamou}@cmi.univ-mrs.fr  Abstract  Information often comes from different sources and  merging these sources usually leads to the apparition of  inconsistencies. Fusion is the operation which consists  in restoring the consistency of the merged information by  changing a minimum of the initial information. In this paper, we are interested in linear constraints prioritized fusion in the framework of simple temporal problems (STPs).  Priority expresses a preference relation between linear constraints and can represent either conÄÅ¹Âdence or quality degrees of the constraints, or the reliability of their sources.  We propose a local fusion method which we experiment on  random prioritized STP instances.  1. Introduction  Information often comes from different sources and  merging these sources usually leads to apparition of inconsistencies. Fusion consists in restoring the consistency of  the merged information by keeping a maximum of the initial information unchanged.  Information fusion is an important area in the artiÄÅ¹Âcial  intelligence ÄÅ¹Âeld. Several fusion methods have been proposed in the literature [12, 1, 8]. Most of them was done in  the framework of propositional logic or other logic-based  formalisms.  There are many ÄÅ¹Âelds or applications where the information can be represented by simple linear constraints. For instance scheduling problems [7], some geographic information can be also expressed by linear constraints [9, 13, 5, 6].  In this paper, we are interested in the prioritized fusion  of linear constraints in the framework of simple temporal  problems (STPs). Each STP is issued from a source of information. We extend the formalism of STP to handle prioritized constraints. Priority expresses a preference relation  between constraints. It stems from two situations: (i) All  the sources of information are equally reliable, thus all the  STPs have the same priority. But the constraints of each  STP are ordered according to their quality or importance  levels. The consideration of all the STPs generates a total  preordering on all the constraints. (ii) Conversely, there is  a total preordering between the sources of information according to their reliability or quality degrees. This deÄÅ¹Ânes a  total preordering on the STPs. However, the constraints of  each STP have the same priority. In both situations, merging all the STPs generates a prioritized STP which is probably inconsistent. The restoration of its consistency has two  main steps: the detection of its conÄÅ¹Â‚icts, and the elimination  of these conÄÅ¹Â‚icts.  In [5, 6] revision methods of linear constraints have been  proposed in the framework of a real-world geographic application (a ÄÅ¹Â‚ooding application). We extend in this paper  what was proposed in [5, 6] by: (1) considering more general linear constraints since the ÄÅ¹Â‚ooding problem was represented by a particular STP. (2) All the STP constraints are  subject to correction in this work whereas only constraints  involving the origin variable were corrected when revising  the ÄÅ¹Â‚ooding problem. (3) handling prioritized constraints.  In [2], a local handling of conÄÅ¹Â‚icts in inconsistent belief bases was investigated. However, the local aspect concerned only the resolution of conÄÅ¹Â‚icts since an exhaustive  identiÄÅ¹Âcation of the conÄÅ¹Â‚icts was performed, before ordering them according to inÄÅ¹Â‚uence relations deÄÅ¹Âned on these  conÄÅ¹Â‚icts and correcting them. We shall see that the local  handling in this paper concerns the identiÄÅ¹Âcation of conÄÅ¹Â‚icts as well as their elimination.  The rest of this paper is organized as follows. In section  2, we recall some background on simple temporal problems  STPs. We present, in section 3, the fusion principle and we  propose a fusion method in section 4. This method is experimented on random instances of prioritized STPs, and the  obtained results are given in section 5, before concluding in  section 6.  Proceedings of the 12th International Symposium on Temporal Representation and Reasoning (TIMEÃ¢Â€Â™05)  1530-1311/05 $20.00 Ã‚Å  2005 IEEE  2. Background  by S = (X , C) where X =    Xi and C is ob-  1Ã¢Â‰Â¤iÃ¢Â‰Â¤p  A Simple Temporal Problem (STP) S is deÄÅ¹Âned by S =  (X , C) where X is a ÄÅ¹Ânite set of variables X0 , ..., Xn , having continuous domains. These variables represent temporal events (time points) and X0 usually represents the origin  of time. C is the set of constraints of the form Xj Ã¢ÂˆÂ’Xi Ã¢Â‰Â¤ aij  deÄÅ¹Âned on these variables, where aij is a scalar. Each constraint expresses a distance between two temporal events.  Constraints of the form Xj Ã¢ÂˆÂ’ Xi Ã¢Â‰Ä½ aij can be also represented since Xj Ã¢ÂˆÂ’ Xi Ã¢Â‰Ä½ aij is equivalent to the constraint  Xi Ã¢ÂˆÂ’ Xj Ã¢Â‰Â¤ Ã¢ÂˆÂ’aij .  A tuple x = (x1 , ..., xn ) of real values is a solution of the  STP S if the instantiation {X1 =x1 , ..., Xn =xn } satisÄÅ¹Âes all  its constraints. The STP S is consistent if and only if it has  a solution.  The STP S = (X , C) is associated with a directed edgeweighted graph, Gd = (X , Ed ), called its distance graph  where X , the set of vertices, is the set of variables of the  STP S, and Ed is the set of weighted arcs representing the  set of constraints C. Each constraint Xj Ã¢ÂˆÂ’ Xi Ã¢Â‰Â¤ aij of C  is represented by the arc i Ã¢Â†Â’ j 1 , which is weighted by aij .  For more details see [4].  3. Prioritized fusion of constraints  Before addressing the prioritized fusion of the constraints of STPs, we extend the deÄÅ¹Ânition of an STP by considering priorities. First, we deÄÅ¹Âne the notion of a prioritized set of constraints.  DeÄÅ¹Ânition 1 A prioritized set of constraints is a set C of  constraints which is partitioned into r strata C 1 , . . . , C r  (i.e., C = C 1 Ã¢ÂˆÅ . . . Ã¢ÂˆÅ C r , and Ã¢ÂˆÂ€i, j, i = j: C i Ã¢ÂˆÅ  C j = Ã¢ÂˆÂ…),  where all the constraints of each strata C i have the same  priority and have a higher priority than the constraints of  C j for each j such that i < j Ã¢Â‰Â¤ r.  A prioritized STP S is deÄÅ¹Âned by S = (X , C) where X is a  set of variables and C a set of prioritized constraints.  When different (prioritized) STPs are merged conÄÅ¹Â‚icts  could appear even if each of the considered (prioritized)  STPs is consistent separately. Let S1 = (X1 , C1 ),. . .,  Sp = (Xp , Cp ) be p (prioritized) STPs obtained from different sources. We can distinguish two situations:  Ã¢Â€Ë˜ In the ÄÅ¹Ârst one, we merge p prioritized STPs which  have the same priority (reliability degree) such that for  each prioritized STP Si = (Xi , Ci ), the set of constraints Ci is stratiÄÅ¹Âed into r strata Ci1 , . . . , Cir . Let  S be the prioritized STP obtained from the aggregation of the p prioritized STPs S1 , . . . , Sp and deÄÅ¹Âned  1 For  simplicity a vertex Xi of the graph Gd is denoted by its index i.  tained by aggregating the prioritized set of constraints  C1 , . . . , Cp . C is partitioned into r   strata C 1 , . . . , C r  where each set of constraints C i =  Cji .  1Ã¢Â‰Â¤jÃ¢Â‰Â¤p  Ã¢Â€Ë˜ In the second situation, there is a total preordering between the p STPs but the constraints of each STP Si  have the same priority. Let S be the prioritized STP  obtained from the union of the p STPs Si with respect to the preordering deÄÅ¹Âned on   them. S is deÄÅ¹Âned by S = (X , C) where X =  Xi and C is  1Ã¢Â‰Â¤iÃ¢Â‰Â¤p  stratiÄÅ¹Âed into   r (r Ã¢Â‰Â¤ p) strata C 1 , . . . , C r where each  Ci =  Cj .  Sj has the priority i  In both situations, the aggregation of the p (prioritized)  STPs generates the prioritized STP S. With no lost of generality, we suppose in the sequel that S contains at most  one constraint between each ordered pair of variables2 . If  the prioritized STP S is consistent, the fusion is done. Otherwise, its consistency has to be restored.  Example 1 (Inspired from [4]Ã¢Â€Â™s example) We have two persons Nana and Sissi which go to work every morning,  and we have two scenarii. The ÄÅ¹Ârst one informs us that:  Nana leaves home before 7:05, and arrives at work between 7:20 and 7:30. Sissi leaves home at most 5 mn after Nana does so and arrives at work at least 10 mn before  Nana. The second scenario states that: It takes to Nana  at most 10 mn to get at work, whereas it takes to Sissi between 10 and 20 mn to get at work, and Nana arrives at  work at most 5 mn after Sissi leaves home. Information  of each scenario can be represented by an STP. Let S1 be  the STP representing the ÄÅ¹Ârst scenario, and S2 be the STP  representing the second one. Let X1 , X2 , X3 , X4 be the  variables representing the temporal events Ã¢Â€ÂNana leaves  homeÃ¢Â€Â, Ã¢Â€ÂNana arrives at workÃ¢Â€Â, Ã¢Â€ÂSissi leaves homeÃ¢Â€Â and  Ã¢Â€ÂSissi arrives at workÃ¢Â€Â respectively. Let X0 be the variable  representing the time 7:00 a.m. The information Ã¢Â€ÂNana  leaves home before 7:05Ã¢Â€Â can be represented by the constraint X1 Ã¢ÂˆÂ’ X0 Ã¢Â‰Â¤ 5. Ã¢Â€ÂNana arrived at work between  7:20 and 7:30Ã¢Â€Â is represented by 20 Ã¢Â‰Â¤ X2 Ã¢ÂˆÂ’ X0 Ã¢Â‰Â¤ 30,  and so on. We obtain the STPs S1 and S2 such that:  S1 = (X1 , C1 ) where X1 = {X0 , X1 , X2 , X3 , X4 } and  C1 = {X1 Ã¢ÂˆÂ’ X0 Ã¢Â‰Â¤ 5 , X2 Ã¢ÂˆÂ’ X0 Ã¢Â‰Â¤ 30 , X0 Ã¢ÂˆÂ’ X2 Ã¢Â‰Â¤ Ã¢ÂˆÂ’20 ,  X3 Ã¢ÂˆÂ’ X1 Ã¢Â‰Â¤ 5 , X4 Ã¢ÂˆÂ’ X2 Ã¢Â‰Â¤ Ã¢ÂˆÂ’10}, and S2 = (X2 , C2 )  where X2 = {X1 , X2 , X3 , X4 } and C2 = {X2 Ã¢ÂˆÂ’ X1 Ã¢Â‰Â¤  10 , X4 Ã¢ÂˆÂ’ X3 Ã¢Â‰Â¤ 20 , X3 Ã¢ÂˆÂ’ X4 Ã¢Â‰Â¤ Ã¢ÂˆÂ’10 , X2 Ã¢ÂˆÂ’ X3 Ã¢Â‰Â¤ 5}. The  2 If there are two constraints X Ã¢ÂˆÂ’ X Ã¢Â‰Â¤ a  i  j  ij and Xi Ã¢ÂˆÂ’ Xj Ã¢Â‰Â¤ bij  in the prioritized STP S such that aij < bij , then only the constraint  Xi Ã¢ÂˆÂ’ Xj Ã¢Â‰Â¤ aij is considered in S.  Proceedings of the 12th International Symposium on Temporal Representation and Reasoning (TIMEÃ¢Â€Â™05)  1530-1311/05 $20.00 Ã‚Å  2005 IEEE  STPs S1 and S2 are consistent separately. We suppose that  the ÄÅ¹Ârst scenario is more reliable than the second one, thus  the constraints of S1 have higher priority than the ones of  S2 . The aggregation of S1 and S2 gives the prioritized STP  S = (X , C) where X = X1 Ã¢ÂˆÅ X2 = {X0 , X1 , X2 , X3 , X4 }  and C = C1 Ã¢ÂˆÅ C2 = {X1 Ã¢ÂˆÂ’ X0 Ã¢Â‰Â¤ 5 , X2 Ã¢ÂˆÂ’ X0 Ã¢Â‰Â¤  30 , X0 Ã¢ÂˆÂ’ X2 Ã¢Â‰Â¤ Ã¢ÂˆÂ’20 , X3 Ã¢ÂˆÂ’ X1 Ã¢Â‰Â¤ 5 , X4 Ã¢ÂˆÂ’ X2 Ã¢Â‰Â¤ Ã¢ÂˆÂ’10 ,  X2 Ã¢ÂˆÂ’X1 Ã¢Â‰Â¤ 10, X4 Ã¢ÂˆÂ’X3 Ã¢Â‰Â¤ 20, X3 Ã¢ÂˆÂ’X4 Ã¢Â‰Â¤ Ã¢ÂˆÂ’10, X2 Ã¢ÂˆÂ’X3 Ã¢Â‰Â¤  5} such that the constraints of C1 have the priority 1which  is the highest and the constraints of C2 have the priority 2.  The priority notion is not involved in the distance graph.  The distance graph deÄÅ¹Ânition of a prioritized STP remains  the same as the one of classical STPs.  Throughout this paper, we will manipulate the prioritized  STP S instead of the (prioritized) STPs S1 , . . ., Sp . Let  n , m and r be respectively the number of variables, the  number of constraints and the number of priorities of the  prioritized STP S. The prioritized STP S is deÄÅ¹Âned by S =  (X , C) such that C = C 1 Ã¢ÂˆÅ . . . Ã¢ÂˆÅ C r , where C i , 1 Ã¢Â‰Â¤ i Ã¢Â‰Â¤ r,  is the set of constraints of priority i. We suppose that 1  is the highest priority and r is the lowest. Let Gd be the  distance graph associated with the prioritized STP S. Thus,  n and m are also the number of vertices and the number of  arcs of the distance graph Gd respectively. Restoring the  consistency of the prioritized STP S consists in detecting  its conÄÅ¹Â‚icts, representing them and identifying a subset of  constraints whose correction is sufÄÅ¹Âcient to eliminate them.  We present in the following each of these steps.  3.1. Detection of ConÄÅ¹Â‚icts  The ÄÅ¹Ârst step of the fusion operation is the detection of  conÄÅ¹Â‚icts of the prioritized STP S. The method which we  propose is based on a variant of the following well known  result.  Theorem 1 ([14, 11, 10]) An STP is consistent if and only  if its corresponding distance graph does not contain negative circuits.  We can deduce from Theorem 1 that for restoring the  consistency of an STP, we need to remove all the negative  circuits of its distance graph. Actually, it is sufÄÅ¹Âcient to  remove all the elementary negative circuits in the distance  graph to restore the consistency of an STP. This weakened  the conditions of Theorem 1. We extend this result to handle prioritized STPs. We obtain the following theorem on  which is based our fusion method.  Theorem 2 A prioritized STP is consistent if and only if its  corresponding distance graph does not contain elementary  negative circuits.  Proof 1 Let S be a prioritized STP, and let S  be an STP  obtained from the prioritized S by ignoring the priorities  of S. S and S  have the same distance graph, let Gd be  this distance graph. The STP S  is consistent if and only if  it has a solution x which satisÄÅ¹Âes all its constraints. It is  clear that a solution x of the STP S  is also a solution of  the prioritized STP S, since S and S  have the same set of  constraints. This implies that S is consistent if and only if  S  is consistent. On the other hand, the STP S  is consistent  if and only if Gd does not contain negative circuits (Theorem 1). Thus, we can conclude that the prioritized STP S  is consistent if and only if its distance graph Gd does not  contain negative circuits. If S is consistent then Gd does  not contain any negative circuit, and in particular, it does  not contain any elementary negative circuit. Conversely, if  Gd does not contain any elementary negative circuit, then  Gd does not contain any negative circuit. hence, the STP  S  is consistent (Theorem 1), and the prioritized STP S is  consistent.  The presence of elementary negative circuits in Gd  means that the prioritized STP S contains conÄÅ¹Â‚icts. A conÄÅ¹Â‚ict is deÄÅ¹Âned as follows.  DeÄÅ¹Ânition 2 Let S be a prioritized STP and Gd be its distance graph. A conÄÅ¹Â‚ict of S is a pair (ÄÂƒ, d) where ÄÂƒ is an  elementary negative circuit of the distance graph Gd and d  is the distance3 of the circuit ÄÂƒ.  Now, we deÄÅ¹Âne the ConÄÅ¹Â‚ict-Detection function which  detects conÄÅ¹Â‚icts of the distance graph. The ConÄÅ¹Â‚ictDetection function is an extension of the Bellman-Ford algorithm which computes the shortest paths of a graph [3].  The main idea is to compute for each pair (i, j) of vertices  the shortest path from i to j in the distance graph Gd . In  particular, when i = j, the function computes the shortest  circuit visiting the vertex i. In fact, the ConÄÅ¹Â‚ict-Detection  function computes the conÄÅ¹Â‚icts, of the distance graph, having the minimum circuit length.  The ConÄÅ¹Â‚ict-Detection function is given in Algorithm 1.  It consists in two steps. First, it constructs a matrix mat(0)  (0)  whose elements are pairs deÄÅ¹Âned by: matij = (pij , dij )  where pij represents a path of length 1 from i to j in Gd ,  and dij is the distance of the path pij . The initialization step  terminates by copying the matrix mat(0) in the matrix mat.  The second step is a loop which computes the shortest paths  between each pair (i, j) of vertices. At each iteration l of the  Ã¢Â€ÂwhileÃ¢Â€Â loop, a call to the Shortest-Path-Extension function  given in Algorithm 2 is made to compute the shortest paths  of length l between each pair of vertices. The loop stops  either when a conÄÅ¹Â‚ict is detected or when the length of the  computed paths reaches n.  3 The  distance of a path is the sum of its arc weights.  Proceedings of the 12th International Symposium on Temporal Representation and Reasoning (TIMEÃ¢Â€Â™05)  1530-1311/05 $20.00 Ã‚Å  2005 IEEE  Algorithm 1 ConÄÅ¹Â‚ict Detection  Function ConÄÅ¹Â‚ict-Detection(Gd): a set of conÄÅ¹Â‚icts  Var mat(0) , mat: matrices of pairs (path,distance)  Conf : a set of conÄÅ¹Â‚icts  Begin  { Initialization }  Conf := Ã¢Âˆ  l := 2  for i, j := 1 to n do  if there is an arc i Ã¢Â†Â’ j in Gd weighted by aij  (0)  then matij := ((i, j), aij )  (0)  else if i = j then matij := (Ã¢ÂˆÂ…, Ã¢ÂˆÂ)  (0)  else matij := (Ã¢ÂˆÂ…, 0)  (0)  mat := mat  { Path extension and conÄÅ¹Â‚ict detection }  while l Ã¢Â‰Â¤ n and Conf = Ã¢ÂˆÂ… do  begin  mat := Shortest-Path-Extension(mat(0), mat, Conf )  l := l + 1  end  ConÄÅ¹Â‚ict-Detection := Conf  End  The Shortest-Path-Extension function is based on the  following: a shortest path pij of length l from i to j is composed by a shortest path pik of length l Ã¢ÂˆÂ’ 1 from i to k  and an arc from k to j. When the Shortest-Path-Extension  function is called at the iteration l in the loop of the ConÄÅ¹Â‚ictDetection function, it takes as arguments: mat(0) the initial  matrix of pairs (path,distance) corresponding to the distance  graph Gd , mat the matrix of pairs (path,distance) corresponding to the shortest paths of length l Ã¢ÂˆÂ’ 1 in Gd . It  returns the matrix mat corresponding to the shortest paths  of Gd of length l. In particular, matii will contain a negative circuit of length l including the vertex i, if it exists.  Furthermore, the detected negative circuits are elementary  and are added to Conf . The Shortest-Path-Extension function returns in Conf the set of conÄÅ¹Â‚icts whose negative circuits are of length l. If Conf = Ã¢ÂˆÂ…, then there is no negative  circuit of length l in Gd .  Now, We evaluate the complexity of the Shortest-PathExtension function. The initialization phase is performed in  O(n2 ). The second phase consists in three loops. Each iteration of the internal loop can be done in O(n) since both  the path and the distance tests are done in a constant time  and path concatenation is done in O(n). Thus, the second  phase can be performed in O(n4 ). Therefore, the time complexity of the Shortest-Path-Extension function is O(n4 ) in  the worst case.  Algorithm 2 Shortest Path Extension  Function Shortest-Path-Extension(mat(0), mat, Var  Conf ): the extended matrix of (path,distance)  Var mat the extended matrix of (path,distance)  Begin  { Initialization }  for i, j := 1 to n, i = j do matij := (Ã¢ÂˆÂ…, Ã¢ÂˆÂ)  for i := 1 to n do matii := (Ã¢ÂˆÂ…, 0)  { Extension of the paths of mat }  for i, j := 1 to n do  for k := 1 to n do  (0)  if (matik .path = Ã¢ÂˆÂ… and matkj .path = Ã¢ÂˆÂ… and  (0)  matik .distance + matkj .distance < matij .distance)  then begin  (0)  p := matik .path Ã¢Â€Ë˜ matkj .path  (0)  d := matik .distance + matkj .distance    matij := (p, d)  if (i = j) then Conf := Conf Ã¢ÂˆÅ matii  end  Shortest-Path-Extension := mat  End  Now, we evaluate the complexity of the ConÄÅ¹Â‚ictDetection function. The initialization phase can be performed in O(n2 ). In the second phase, the function performs at most n Ã¢ÂˆÂ’ 1 iterations, and the complexity of each  of them is identical to the complexity of the Shortest-PathExtension function which is O(n4 ). Therefore, the complexity of the ConÄÅ¹Â‚ict-Detection function is O(n5 ) in the  worst case.  Now, we can prove some properties of the Shortest-PathExtension and ConÄÅ¹Â‚ict-Detection functions.  Proposition 1 The Shortest-Path-Extension function applied to the matrix mat corresponding to the shortest paths  of length l in Gd detects at least one elementary negative  circuit if and only if it exists one of length l + 1 in Gd .  Proof 2 Let mat(0) be the matrix of pairs (path,distance)  corresponding to the distance graph Gd , and mat be  the matrix of pairs (path,distance) representing the shortest paths of Gd of length l. Let mat = Shortest-PathExtension(mat(0),mat,Conf ) where Conf is the set of detected conÄÅ¹Â‚icts. The shortest path pij from i to j of length  l + 1 of Gd is deÄÅ¹Âned by pij = M in1Ã¢Â‰Â¤kÃ¢Â‰Â¤n (pik Ã¢Â€Ë˜ (k Ã¢Â†Â’ j)),  where M in is a function which selects the path having the  minimal distance, pik is the shortest path of length l from i  to k of Gd , and (k Ã¢Â†Â’ j) is an arc of Gd . This implies that  the elements of mat represent really the shortest paths of  length l + 1 of Gd . We can prove now the ÄÅ¹Ârst statement of  the proposition.  Proceedings of the 12th International Symposium on Temporal Representation and Reasoning (TIMEÃ¢Â€Â™05)  1530-1311/05 $20.00 Ã‚Å  2005 IEEE  (Ã¢Â‡Â’) If the Shortest-Path-Extension function applied to the  matrix mat corresponding to the shortest paths of length l  in Gd detects at least one elementary negative circuit, then  there exists at least one vertex i included in a negative circuit of length l + 1.  (Ã¢Â‡Â) Suppose that there is an elementary negative circuit ÄÂƒi  of length l + 1 including a vertex i of Gd . Let d (d < 0) be  the distance of ÄÂƒi . Since matii = (pii , dii ) represents the  shortest path pii of length l + 1 from i to i and its distance  dii , then the circuit pii is shorter than the circuit ÄÂƒi , and  consequently dii < d < 0. This means that the circuit pii  is negative also. Thus, the Shortest-Path-Extension function  detects at least one negative circuit, if it exists.  Furthermore, the negative circuits detected by the  Shortest-Path-Extension function are elementary. This can  be trivially proved since the function is applied the extend  the shortest paths of length l only if there are no negative  circuits of length l such that l Ã¢Â‰Â¤ l. Proposition 2 states  that when the ConÄÅ¹Â‚ict-Detection function does not detect  any negative elementary circuits in the distance graph Gd  the prioritized STP S is consistent.  Proposition 2 The prioritized STP S is consistent if and  only if the ConÄÅ¹Â‚ict-Detection function, applied to its distance graph Gd , does not detect any conÄÅ¹Â‚ict.  Proof 3 (Ã¢Â‡Â’) If the prioritized STP S is consistent then its  distance graph Gd does not contain any elementary negative circuit (by Theorem 2). In particular, Gd does not  contain any elementary negative circuit of length l, 2 Ã¢Â‰Â¤  l Ã¢Â‰Â¤ n. Thus, the repeated application of the Shortest-PathExtension function does not detect any negative circuit, and  the ConÄÅ¹Â‚ict-Detection function does not detect any conÄÅ¹Â‚ict.  (Ã¢Â‡Â) If the ConÄÅ¹Â‚ict-Detection function does not detect any  conÄÅ¹Â‚ict, then the Shortest-Path-Extension function has been  applied until l = n and for each length, no conÄÅ¹Â‚ict was detected (i.e., Conf = Ã¢ÂˆÂ…). This means that there is no negative circuit of length l, 2 Ã¢Â‰Â¤ l Ã¢Â‰Â¤ n in Gd (by Proposition  1). Therefore, there is no elementary negative circuit in Gd ,  hence the prioritized STP S is consistent.  3.2. Representation of conÄÅ¹Â‚icts  Each conÄÅ¹Â‚ict of the prioritized STP S is identiÄÅ¹Âed by  a tuple (ÄÂƒ, d) where ÄÂƒ is an elementary negative circuit of  the distance graph Gd and d is the distance of ÄÂƒ. We recall  that each arc i Ã¢Â†Â’ j in Gd , weighted by aij , represents the  constraint cij : Xj Ã¢ÂˆÂ’ Xi Ã¢Â‰Â¤ aij of the prioritized STP S. We  deÄÅ¹Âne now the notion of conÄÅ¹Â‚icting constraint.  DeÄÅ¹Ânition 3 Let S = (X , C) be a prioritized STP, Gd its  distance graph, and Conf the set of conÄÅ¹Â‚icts of S. A constraint cij Ã¢ÂˆÂˆ C is a conÄÅ¹Â‚icting constraint if and only if there  5  0  1  (c1,2 , 2)  Ã¢ÂˆÂ’20 10  30  5  5  2  20  Ã¢ÂˆÂ’10  (c0,1 , 1)  (c2,0 , 1)  (c1,3 , 1)  (c3,2 , 2)  3  Ã¢ÂˆÂ’10  (c4,3 , 2)  4  a. The distance graph  (c2,4 , 1)  b. The hypergraph of conflicts  Figure 1. The distance graph and the hypergraph of conÄÅ¹Â‚icts of the prioritized STP S deÄÅ¹Âned in Example 1  is a conÄÅ¹Â‚ict c = (ÄÂƒ, d) in Conf such that the arc i Ã¢Â†Â’ j belongs to the elementary negative circuit ÄÂƒ of Gd .  Let Conf Const be the function which associates to  each conÄÅ¹Â‚ict c = (ÄÂƒ, d) the set of its conÄÅ¹Â‚icting constraints.  That is, Conf Const(c) = {cij Ã¢ÂˆÂˆ C : i Ã¢Â†Â’ j is an arc of  ÄÂƒ}.  The set of the detected conÄÅ¹Â‚icts Conf is represented by  a vertex-weighted hypergraph Hc = (V, Ec ) where V is  the set of vertices corresponding to the   set of all conÄÅ¹Â‚ictConf Const(c),  ing constraints deÄÅ¹Âned by: V =  cÃ¢ÂˆÂˆConf  and Ec is the set of hyperedges deÄÅ¹Âned as follows: each  hyperedge e represents a conÄÅ¹Â‚ict c of Conf such that e represents the conÄÅ¹Â‚icting constraints of the conÄÅ¹Â‚ict c, i.e., e =  Conf Const(c). Thus Ec = {Conf Const(c) : c Ã¢ÂˆÂˆ Conf }.  Each vertex cij of Hc is weighted by k, where k is the  priority of the constraint cij , i.e., cij Ã¢ÂˆÂˆ C k . Hc is called  the hypergraph of conÄÅ¹Â‚icts of the prioritized STP S. Let  V 1 , . . . , V r be a partition of the set of vertices V such that:  v Ã¢ÂˆÂˆ V i if the weight of the vertex v in the hypergraph Hc  equals i.  Example 2 The distance graph of the prioritized STP S deÄÅ¹Âned in Example 1 is represented in Figure 1.a. The elementary negative circuit {(0,1),(1,2),(2,0)} shows a conÄÅ¹Â‚ict  between the constraints c0,1 , c1,2 and c2,0 . This adds the  hyperedge {(c0,1 , 1), (c1,2 , 2), (c2,0 , 1)} in the hypergraph  of conÄÅ¹Â‚icts. By considering all the elementary negative circuits of the distance graph of Figure 1.a, we obtain the hypergraph of conÄÅ¹Â‚icts of Figure 1.b. Each vertex of the hypergraph is a constraint which is weighted by its priority.  3.3. IdentiÄÅ¹Âcation of a subset of constraints to correct  Removing all the detected conÄÅ¹Â‚icts needs correcting  some constraints involved in them. At least one conÄÅ¹Â‚icting  Proceedings of the 12th International Symposium on Temporal Representation and Reasoning (TIMEÃ¢Â€Â™05)  1530-1311/05 $20.00 Ã‚Å  2005 IEEE  constraint of each detected conÄÅ¹Â‚ict has to be corrected. In  other words, the intersection of the set of the corrected constraints and the set of conÄÅ¹Â‚icting constraints of each conÄÅ¹Â‚ict  is not empty. Therefore, the subset of corrected constraints  is a transversal of the hypergraph of conÄÅ¹Â‚icts Hc of the prioritized STP S. Minimizing change when restoring the consistency of a prioritized STP S amounts to minimizing the  number of corrected constraints of C 1 (having the highest  priority), then the number of corrected constraints of C 2 ,  and so on. We recall the deÄÅ¹Ânition of a transversal before  deÄÅ¹Âning the notion of prioritized transversal.  DeÄÅ¹Ânition 4 Let H = (V, E) be a hypergraph. T is a  transversal of the hypergraph H if T Ã¢ÂŠÂ† V and for each  hyperedge e of E, T Ã¢ÂˆÅ  e = Ã¢ÂˆÂ….  Now, we deÄÅ¹Âne a preference relation on the transversals  of a vertex-weighted hypergraph.  DeÄÅ¹Ânition 5 Let H = (V, E) be a vertex-weighted hypergraph where V = V 1 Ã¢ÂˆÅ. . .Ã¢ÂˆÅV r such that the vertex v Ã¢ÂˆÂˆ V i  if v is weighted by i in H. Let T1 and T2 be two transversals of the hypergraph H. T1 is preferred to T2 if (i) Ã¢ÂˆÂƒi,  1 Ã¢Â‰Â¤ i Ã¢Â‰Â¤ r such that |T1 Ã¢ÂˆÅ  V i | < |T2 Ã¢ÂˆÅ  V i |, and (ii) Ã¢ÂˆÂ€j,  1 Ã¢Â‰Â¤ j < i, |T1 Ã¢ÂˆÅ  V j | = |T2 Ã¢ÂˆÅ  V j |.  DeÄÅ¹Ânition 6 Let H = (V, E) be a vertex-weighted hypergraph. Tp is a prioritized transversal of the hypergraph H  if (i) Tp is a transversal of H, and (ii) for each transversal  T of H, T is not preferred to Tp .  Example 3 The hypergraph of conÄÅ¹Â‚icts shown in  Figure 1.b has many transversals.  For instance  T ={(c2,0, 1), (c4,3 , 1)}. It has one prioritized transversal  Tp ={(c1,2 , 2), (c3,2 , 2)}.  Algorithm 3 Prioritized Transversal procedure  Procedure Prioritized-Transversal(Hc = (V, Ec ),T , W ,  Var Tp )  Begin  if Ec = Ã¢ÂˆÂ… then Tp := T  else if V = W then  begin  select a vertex v from V Ã¢ÂˆÂ’ W  Prioritized-Transversal (Hc , T, W Ã¢ÂˆÅ {v}, Tp )  V := V Ã¢ÂˆÂ’ {v}  Ec := Ec Ã¢ÂˆÂ’ {e : e Ã¢ÂˆÂˆ Ec and e  v}  if (Tp = Ã¢ÂˆÂ… or T Ã¢ÂˆÅ {v} is preferred to Tp )  then Prioritized-Transversal (Hc , T Ã¢ÂˆÅ {v}, W, Tp )  end  End  We deÄÅ¹Âne the Prioritized-Transversal procedure (Algorithm 3) to compute a prioritized transversal of the hypergraph of conÄÅ¹Â‚icts Hc . The search space of this procedure  is a binary tree. At each node of this tree, a vertex is either considered in the current partial transversal T , or not  considered then it is put in the set W . This procedure does  not enumerate systematically all the possible transversals of  the hypergraph of conÄÅ¹Â‚icts to ÄÅ¹Ând a prioritized one. Indeed,  it prunes the branches of the search tree leading to partial  transversals T which are not preferred to the current prioritized transversal Tp . The Prioritized-Transversal procedure  is called with the parameters Hc = (V, EC ) which is the  hypergraph of conÄÅ¹Â‚icts, T the current partial transversal, W  the set of non considered vertices and Tp the current prioritized transversal of the hypergraph Hc which the procedure  returns. Initially, T = W = Tp = Ã¢ÂˆÂ….  To evaluate roughly the complexity of the PrioritizedTransversal procedure, let nc and mc be respectively the  number of vertices and the number of hyperedges of the  hypergraph of conÄÅ¹Â‚icts Hc . The search space is bounded  by 2nc which is the number of all the possible transversals.  The selection of a vertex v Ã¢ÂˆÂˆ V Ã¢ÂˆÂ’ W can be performed  in O(nc ), and the removal of the hyperedges incident to  v is performed in O(mc ). Testing if the current partial  transversal T Ã¢ÂˆÅ {v} is preferred to the current prioritized  transversal Tp can be done in O(r). Since r < nc , then  the complexity of the Prioritized-Transversal algorithm is  O((mc + nc )2nc ) in the worst case.  Example 4 The application of the Prioritized-Transversal  procedure to the hypergraph of conÄÅ¹Â‚icts shown in  Figure 1.b returns the prioritized transversal Tp =  {(c1,2 , 2), (c3,2 , 2)}.  3.4. Correction of the conÄÅ¹Â‚icting constraints  Now, we shall see how to perform the corrections. Let  c = (ÄÂƒ, d) be a conÄÅ¹Â‚ict of the prioritized STP S. The elimination of the conÄÅ¹Â‚ict c needs the elimination of its associated elementary negative circuit ÄÂƒ. This implies the correction of at least one of the constraints involved in ÄÂƒ, i.e.,  at least one of the constraints of Conf Const(c) is corrected. The following proposition shows how this correction is done.  Proposition 3 Let S be a prioritized STP and c = (ÄÂƒ, d)  be a conÄÅ¹Â‚ict of S. Let cij : Xj Ã¢ÂˆÂ’ Xi Ã¢Â‰Â¤ aij be a conÄÅ¹Â‚icting constraint of c (cij Ã¢ÂˆÂˆ Conf Const(c)). Replacing the constraint cij : Xj Ã¢ÂˆÂ’ Xi Ã¢Â‰Â¤ aij by the constraint  Xj Ã¢ÂˆÂ’ Xi Ã¢Â‰Â¤ aij Ã¢ÂˆÂ’ d eliminates the conÄÅ¹Â‚ict c.  Proof 4 Let c = (ÄÂƒ, d) be a conÄÅ¹Â‚ict, and let cij : Xj Ã¢ÂˆÂ’Xi Ã¢Â‰Â¤  aij be a conÄÅ¹Â‚icting constraint of c, cij Ã¢ÂˆÂˆ Conf Const(c).  Proceedings of the 12th International Symposium on Temporal Representation and Reasoning (TIMEÃ¢Â€Â™05)  1530-1311/05 $20.00 Ã‚Å  2005 IEEE  The circuit ÄÂƒ has a negative distance d, and replacing the  constraint Xj Ã¢ÂˆÂ’Xi Ã¢Â‰Â¤ aij by the constraint Xj Ã¢ÂˆÂ’Xi Ã¢Â‰Â¤ aij Ã¢ÂˆÂ’  d, will make this distance equal to zero. Hence the negative  circuit ÄÂƒ is eliminated and the conÄÅ¹Â‚ict c is corrected.  Example 5 In Figure 1, the elementary negative circuit  {(0,1),(1,2),(2,0)} whose distance is -5 identiÄÅ¹Âes the conÄÅ¹Â‚ict  ({(0,1),(1,2),(2,0)},-5) between the constraints X1 Ã¢ÂˆÂ’ X0 Ã¢Â‰Â¤  5 (representing the fact that Nana leaves home before 7:05),  X2 Ã¢ÂˆÂ’ X1 Ã¢Â‰Â¤ 10 (representing the fact that it takes less than  10 mn to Nana to get at work) and X0 Ã¢ÂˆÂ’ X2 Ã¢Â‰Â¤ Ã¢ÂˆÂ’20 (representing the fact that Nana arrives at work after 7:20).  This conÄÅ¹Â‚ict can be removed by replacing the constraint  X2 Ã¢ÂˆÂ’ X1 Ã¢Â‰Â¤ 10 by the constraint X2 Ã¢ÂˆÂ’ X1 Ã¢Â‰Â¤ 15 (it takes to  Nana less than 15 mn to get work instead of 10 mn).  The following proposition states that a conÄÅ¹Â‚ict is eliminated if and only if one of its conÄÅ¹Â‚icting constraints is corrected.  Proposition 4 Let S be an inconsistent prioritized STP and  c = (ÄÂƒ, d) be a conÄÅ¹Â‚ict of S. The conÄÅ¹Â‚ict c is eliminated if  and only if at least one of its conÄÅ¹Â‚icting constraints cij Ã¢ÂˆÂˆ  Conf Const(c) is corrected with respect to Proposition 3.  Proof 5 Let S be an inconsistent prioritized STP and c =  (ÄÂƒ, d) be a conÄÅ¹Â‚ict of S. (Ã¢Â‡Â’) Suppose that the conÄÅ¹Â‚ict c =  (ÄÂƒ, d) is eliminated. This implies that the negative circuit  ÄÂƒ is eliminated, i.e., its distance is changed from negative  to positive. This is done by changing at least the weight of  one of its arcs. In other words, by correcting, at least, one  constraint cij of Conf Const(c). (Ã¢Â‡Â) The correction of a  constraint cij Ã¢ÂˆÂˆ Conf Const(c) makes the conÄÅ¹Â‚ict circuit  ÄÂƒ positive. Hence, the conÄÅ¹Â‚ict c = (ÄÂƒ, d) is eliminated.  When correcting a constraint no new conÄÅ¹Â‚icts are generated and the following theorem states that the correction of  the constraints corresponding to a transversal of the hypergraph of conÄÅ¹Â‚icts representing the detected conÄÅ¹Â‚icts, eliminates these conÄÅ¹Â‚icts.  Theorem 3 Let S be an inconsistent prioritized STP and  let Conf be a set of detected conÄÅ¹Â‚icts of S. Let Hc be  the hypergraph of conÄÅ¹Â‚icts representing the set Conf . The  conÄÅ¹Â‚icts of Conf are removed from the prioritized STP S  if and only if the constraints corresponding to a transversal  of the hypergraph of conÄÅ¹Â‚icts Hc are corrected.  Proof 6 Let S be an inconsistent STP and let Conf be the  set of detected conÄÅ¹Â‚icts of S. Let Hc be the hypergraph of  conÄÅ¹Â‚icts representing Conf .  (Ã¢Â‡Â’) Suppose that all the conÄÅ¹Â‚icts of Conf are removed.  Let Cr be the subset of constraints corrected when removing the conÄÅ¹Â‚icts of Conf . Each conÄÅ¹Â‚ict c of Conf is removed by the correction of, at least, one of its conÄÅ¹Â‚icting  constraints, that is a constraint of Conf Const(c) (Proposition 4). This means that Cr Ã¢ÂˆÅ  Conf Const(c) = Ã¢ÂˆÂ… for  each conÄÅ¹Â‚ict c Ã¢ÂˆÂˆ Conf . However, Conf Const(c) = e  where e is the hyperedge representing the conÄÅ¹Â‚ict c in Hc .  Then, Cr Ã¢ÂˆÅ  e = Ã¢ÂˆÂ… for each hyperedge e of the hypergraph  of conÄÅ¹Â‚icts Hc . Thus Cr is a transversal of the hypergraph  of conÄÅ¹Â‚icts Hc .  (Ã¢Â‡Â) Suppose that Cr is a transversal of the hypergraph  of conÄÅ¹Â‚icts Hc and all its corresponding constraints are  corrected. This means that for each hyperedge e of Hc ,  e Ã¢ÂˆÅ  Cr = Ã¢ÂˆÂ…. However, each hyperedge e of Hc represents  the set of conÄÅ¹Â‚icting constraints of a conÄÅ¹Â‚ict c of Conf , i.e.,  e = Conf Const(c). This implies that for each conÄÅ¹Â‚ict c of  Conf , at least one conÄÅ¹Â‚icting constraint of c is corrected  (because Cr Ã¢ÂˆÅ  Conf Const(c) = Ã¢ÂˆÂ…). Hence, each conÄÅ¹Â‚ict c  is eliminated (by Proposition 4). We conclude that the correction of all the constraints corresponding to Cr eliminates  all the conÄÅ¹Â‚icts of Conf .  4. Local prioritized fusion algorithm  Since the number of elementary negative circuits of the  distance graph of a prioritized STP is potentially high, the  exhaustive detection of conÄÅ¹Â‚icts can be impossible. A local handling of the problem seems to be a good alternative  to this problem. That is, if the conÄÅ¹Â‚icts are detected and  corrected bundle by bundle, the complexity of the fusion  operation decreases. On other hand, if a detected conÄÅ¹Â‚ict c,  of the prioritized STP S, involves for instance a constraint  cij , and if this constraint participates in another not yet detected conÄÅ¹Â‚ict c , then the correction of the constraint cij  could eliminate the conÄÅ¹Â‚ict c .  The Local Prioritized Fusion function, sketched in Algorithm 4, consists in detecting a bundle of conÄÅ¹Â‚icts, then  in eliminating them by correcting the conÄÅ¹Â‚icting constraints  corresponding to a prioritized transversal of the hypergraph  of conÄÅ¹Â‚icts. It repeats these operations until the restoration  of the consistency.  Theorem 4 The Local Prioritized Fusion algorithm, applied to the prioritized STP S, terminates and restores the  consistency of S.  Proof 7 Let S be a prioritized STP. The number of conÄÅ¹Â‚icts  of S is ÄÅ¹Ânite and the correction of constraints cannot generate new ones. At each iteration of the Local-PrioritizedFusion algorithm, the ConÄÅ¹Â‚ict-Detection function detects  a subset of conÄÅ¹Â‚icts. The elimination of these conÄÅ¹Â‚icts is  guaranteed by the correction of the constraints of a prioritized transversal Tp of the hypergraph of conÄÅ¹Â‚icts Hc  representing the detected conÄÅ¹Â‚icts (see Theorem 3). This  implies that at each iteration, the total number of conÄÅ¹Â‚icts  Proceedings of the 12th International Symposium on Temporal Representation and Reasoning (TIMEÃ¢Â€Â™05)  1530-1311/05 $20.00 Ã‚Å  2005 IEEE  Algorithm 4 Local Prioritized Fusion  Function Local-Prioritized-Fusion(S prioritized STP): a  consistent prioritized STP  Begin  Construct Gd the distance graph of S  Conf := Detection-ConÄÅ¹Â‚ict(Gd)  repeat  Construct Hc the hypergraph of conÄÅ¹Â‚icts corresponding  to Conf  Tp := Ã¢Âˆ  Prioritized-Transversal(Hc , Ã¢ÂˆÂ…, Ã¢ÂˆÂ…, Tp )  Correct the constraints corresponding to the prioritized  transversal Tp  Conf := Detection-ConÄÅ¹Â‚ict(Gd)  until Conf = Ã¢Âˆ  Local-Prioritized-Fusion := S  End  decreases, until the elimination of all conÄÅ¹Â‚icts. The algorithm stops when no conÄÅ¹Â‚icts are detected by the ConÄÅ¹Â‚ictDetection function. This implies that there is no conÄÅ¹Â‚ict in  the prioritized STP S (Proposition 2). Therefore, the LocalPrioritized Fusion function terminates and restores the consistency of the prioritized STP S.  To evaluate the complexity of the Local-PrioritizedFusion algorithm, we proceed step by step. Let mc be  the number of conÄÅ¹Â‚icts of the prioritized STP S. This  number is bounded by the number of possible elementary  circuits of the distance graph Gd which is itself bounded  n    n!  Akn where Akn = (nÃ¢ÂˆÂ’k)!  . The complexity of the  by  k=2  ConÄÅ¹Â‚ict-Detection function is O(n5 ), and the construction  of the distance graph is in O(nm). Now, we evaluate the  complexity of each iteration. Since the number of detected  conÄÅ¹Â‚icts at each iteration is at most n and each conÄÅ¹Â‚ict can  involve at most n conÄÅ¹Â‚icting constraints, the construction  of the hypergraph of conÄÅ¹Â‚icts Hc corresponding to Conf is  in O(n2 ). The prioritized transversal Tp of the hypergraph    of conÄÅ¹Â‚icts Hc is computed in O((mc + nc )2nc ) where mc  is the number of handled conÄÅ¹Â‚icts and nc is the number  of conÄÅ¹Â‚icting constraints. The number mc is bounded by  n because at most n conÄÅ¹Â‚icts are handled in each iteration  and nc is bounded by n2 . Thus, the Prioritized transversal  2  search is performed in O(n2 2n ) in the worst case. The correction of the constraints of Tp is performed in O(n) since  at most n constraints can be corrected. Therefore, each it2  eration is performed in O(n2 2n ) in the worst case. The  Local Prioritized Fusion algorithm performs at most mnc it2  erations. Therefore, its complexity is O(mc n2n ) in the  worst case.  5. Experimental results  The local prioritized fusion algorithm presented in this  paper is implemented in C and tested on randomly generated prioritized STPs. The program runs on a P4 with 2.2  MHz and 512 MB of RAM.  Generation of random prioritized STPs is based on three  parameters: the number of variables n, the number of priorities (strata) r, and the constraint density d which is the  ratio of the number of constraints to the number of possiof constraints  . The tightness of  ble constraints, d = number n(nÃ¢ÂˆÂ’1)  the constraints is represented by the interval [-50,50] where  the constraint weights are generated. A sample of 50 problems is generated for each tuple (n, r, d) and the measures  are taken in average. The experimental results obtained by  the application of the Local Prioritized Fusion algorithm on  random prioritized STP instances are shown in Table 1. A  dash (-) means that the algorithm did not answer after running 2 hours.  We can see in Table 1 that when the density grows, the  number of conÄÅ¹Â‚icts grows. This increases the number of  corrected constraints, the number of iterations and the CPU  time. The fusion algorithm becomes faster as the number of  considered priorities increases even though the number of  detected conÄÅ¹Â‚icts, the number of corrected constraints and  the number of iterations increase. This can be explained by  the speed up of the prioritized transversal search when there  are many strata. As expected, the number of corrected constraints when only one stratum is considered is the smallest. This is due to minimal change policy. In the same  spirit, when the number of considered priorities increases,  the number of corrected constraints having the highest priority decreases. We can see that the method fuses in reasonable time problems having 30 variables with a small density  (d = 0.2), but reaches its limit on higher densities.  6. Conclusion  In this paper, we investigated the prioritized fusion of  Simple Temporal Problems STPs. That is, giving a set of  prioritized STPs to fuse, we considered the prioritized STP  S resulting from their union. If S is consistent, then the  fusion is done. Otherwise, the consistency of S has to be  restored. We presented a principle of a prioritized fusion on  which is based the local prioritized fusion method which  we proposed. Two justiÄÅ¹Âcations motivate the local strategy.  The ÄÅ¹Ârst one is the high complexity of the exhaustive detection of the conÄÅ¹Â‚icts. The second justiÄÅ¹Âcation is related to the  conÄÅ¹Â‚ict nature. If a bundle of conÄÅ¹Â‚icts is detected and corrected, this could eliminate not yet detected conÄÅ¹Â‚icts. This  speeds up the fusion operation.  In future, we can improve the local prioritized fusion  algorithm efÄÅ¹Âciency by considering a Ã¢Â€ÂgoodÃ¢Â€Â transversal  Proceedings of the 12th International Symposium on Temporal Representation and Reasoning (TIMEÃ¢Â€Â™05)  1530-1311/05 $20.00 Ã‚Å  2005 IEEE  # priorities  r=1  r=5  r = 10  # conÄÅ¹Â‚icts  # corrected const  # corrected const.  # corrected const.  # iterations  CPU time (s)  # conÄÅ¹Â‚icts  # corrected const  # corrected const.  # corrected const.  # iterations  CPU time (s)  # conÄÅ¹Â‚icts  # corrected const  # corrected const.  # corrected const.  # iterations  CPU time (s)  highest prior.  lowest prior.  highest prior.  lowest prior.  highest prior.  lowest prior.  n = 10  Density  0.2 0.5 0.8  1  23 43  1  14 25  1  14 25  1  14 25  2  8  11  0  0  0  1  25 47  1  15 32  0  0  0  1  6  11  2  8  12  0  0  0  1  22 48  1  13 13  0  0  0  1  4  5  2  8  13  0  0  0  0.2  42  23  23  23  11  0  44  29  0  13  12  0  47  28  0  7  12  0  n = 20  Density  0.5 0.8  160 232  92 144  92 144  92 144  21  26  33 120  197 292  141 219  2  9  42  57  27  35  1  7  204 325  150 251  0  1  23  34  28  38  3  7  n = 30  Density  0.2 0.5  142  68  68  68  19  416  187  123  0  47  24  135  192  130  0  22  24  127  -  0.8  -  Table 1. Experimental results obtained by the application of the Local-Prioritized-Fusion algorithm  on random prioritized STP instances  rather than a prioritized one. We also hope to extend this  work to handle disjunctive temporal problems.  References  [1] S. Benferhat, D. Dubois, and H. Prade. Some syntactic approaches to the handling of inconsistent knowledge bases:  A comparative study part 1: The ÄÅ¹Â‚at case. Studia Logica,  58:17Ã¢Â€Â“45, 1997.  [2] S. Benferhat and L. Garcia. Handling locally stratiÄÅ¹Âed inconsistent knowledge bases. Studia Logica, 70:77Ã¢Â€Â“104,  2002.  [3] T. Cormen, C. Leiserson, and R. Rivest. Introduction to Algorithms. MIT Press, Cambridge, Massachusetts, 1990.  [4] R. Dechter, I. Meiri, and J. Pearl. Temporal constraint networks. ArtiÄÅ¹Âcial Intelligence, 49:61Ã¢Â€Â“95, 1991.  [5] M. Khelfallah and B. Benhamou. Geographic information  revision based on constraints. In Proc. of the 14th European  Conference on ArtiÄÅ¹Âcial Intelligence, ECAIÃ¢Â€Â™04, pages 828Ã¢Â€Â“  832, 2004.  [6] M. Khelfallah and B. Benhamou. Two revision methods  based on constraints: Application to a ÄÅ¹Â‚ooding problem. In  Proc. of the 7th Int. Conf. of ArtiÄÅ¹Âcial Intelligence and Symbolic Computation AISCÃ¢Â€Â™04, volume 3249 of LNAI, pages  265Ã¢Â€Â“270, 2004.  [7] R. Kolisch and R. Padman. An integrated survey of deterministic project scheduling. Omega, 29:249Ã¢Â€Â“272, 2001.  [8] S. Konieczny, J. Lang, and P. Marquis. Distance based merging: A general framework and some complexity results. In  Proc. of the 8th Int. Conf. on Principles of Knowledge Representation and Reasoning (KRÃ¢Â€Â™02), pages 97Ã¢Â€Â“108, 2002.  [9] G. Kuper, G. L. Libkin, and J. Paradaens, editors. Constraint  Databases. Springer-Verlag, 2000.  [10] C. Leiserson and J. Saxe. A mixed-integer linear programming problem which is efÄÅ¹Âciently solvable. In Proc. of the  21st annual Allerton conference on Communications, Control, and Computing, pages 204Ã¢Â€Â“213, 1983.  [11] Y. Lia and C. Wong. An algorithm to compact a vlsi  symbolic layout with mixed constraints. In IEEE Trans.  Computer-Aided Design of Integrated Circuits and Systems,  volume 2, pages 62Ã¢Â€Â“69, 1983.  [12] J. Lin and A. Mendelzon. Dynamic Worlds: From the Frame  Problem to Knowledge Management, volume 12 of Applied  Logic Series, chapter Knowledge Base Merging by Majority.  Kluwer, 1999.  [13] P. Rigaux, M. Scholl, and A. Voisard. Spatial Databases  with Application to GIS. Morgan Kaufmann, 2002.  [14] R. Shostak. Deciding linear inequalities by computing loop  residues,. Journal of ACM, 28(4):769Ã¢Â€Â“779, 1981.  Proceedings of the 12th International Symposium on Temporal Representation and Reasoning (TIMEÃ¢Â€Â™05)  1530-1311/05 $20.00 Ã‚Å  2005 IEEE 