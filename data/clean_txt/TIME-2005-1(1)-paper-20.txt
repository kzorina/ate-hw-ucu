A Local Method for Prioritized Fusion of Temporal Information  Mahat Khelfallah and BelaÄąĚd Benhamou  Laboratoire des Sciences de lâInformation et des SysteĚmes LSIS - UMR CNRS 6168  Provence University  CMI, TechnopoĚle de ChaĚteau Gombert  39, rue Joliot-Curie - 13453 Marseille - France.  {mahat,benhamou}@cmi.univ-mrs.fr  Abstract  Information often comes from different sources and  merging these sources usually leads to the apparition of  inconsistencies. Fusion is the operation which consists  in restoring the consistency of the merged information by  changing a minimum of the initial information. In this paper, we are interested in linear constraints prioritized fusion in the framework of simple temporal problems (STPs).  Priority expresses a preference relation between linear constraints and can represent either conďŹdence or quality degrees of the constraints, or the reliability of their sources.  We propose a local fusion method which we experiment on  random prioritized STP instances.  1. Introduction  Information often comes from different sources and  merging these sources usually leads to apparition of inconsistencies. Fusion consists in restoring the consistency of  the merged information by keeping a maximum of the initial information unchanged.  Information fusion is an important area in the artiďŹcial  intelligence ďŹeld. Several fusion methods have been proposed in the literature [12, 1, 8]. Most of them was done in  the framework of propositional logic or other logic-based  formalisms.  There are many ďŹelds or applications where the information can be represented by simple linear constraints. For instance scheduling problems [7], some geographic information can be also expressed by linear constraints [9, 13, 5, 6].  In this paper, we are interested in the prioritized fusion  of linear constraints in the framework of simple temporal  problems (STPs). Each STP is issued from a source of information. We extend the formalism of STP to handle prioritized constraints. Priority expresses a preference relation  between constraints. It stems from two situations: (i) All  the sources of information are equally reliable, thus all the  STPs have the same priority. But the constraints of each  STP are ordered according to their quality or importance  levels. The consideration of all the STPs generates a total  preordering on all the constraints. (ii) Conversely, there is  a total preordering between the sources of information according to their reliability or quality degrees. This deďŹnes a  total preordering on the STPs. However, the constraints of  each STP have the same priority. In both situations, merging all the STPs generates a prioritized STP which is probably inconsistent. The restoration of its consistency has two  main steps: the detection of its conďŹicts, and the elimination  of these conďŹicts.  In [5, 6] revision methods of linear constraints have been  proposed in the framework of a real-world geographic application (a ďŹooding application). We extend in this paper  what was proposed in [5, 6] by: (1) considering more general linear constraints since the ďŹooding problem was represented by a particular STP. (2) All the STP constraints are  subject to correction in this work whereas only constraints  involving the origin variable were corrected when revising  the ďŹooding problem. (3) handling prioritized constraints.  In [2], a local handling of conďŹicts in inconsistent belief bases was investigated. However, the local aspect concerned only the resolution of conďŹicts since an exhaustive  identiďŹcation of the conďŹicts was performed, before ordering them according to inďŹuence relations deďŹned on these  conďŹicts and correcting them. We shall see that the local  handling in this paper concerns the identiďŹcation of conďŹicts as well as their elimination.  The rest of this paper is organized as follows. In section  2, we recall some background on simple temporal problems  STPs. We present, in section 3, the fusion principle and we  propose a fusion method in section 4. This method is experimented on random instances of prioritized STPs, and the  obtained results are given in section 5, before concluding in  section 6.  Proceedings of the 12th International Symposium on Temporal Representation and Reasoning (TIMEâ05)  1530-1311/05 $20.00 ÂŠ 2005 IEEE  2. Background  by S = (X , C) where X =    Xi and C is ob-  1â¤iâ¤p  A Simple Temporal Problem (STP) S is deďŹned by S =  (X , C) where X is a ďŹnite set of variables X0 , ..., Xn , having continuous domains. These variables represent temporal events (time points) and X0 usually represents the origin  of time. C is the set of constraints of the form Xj âXi â¤ aij  deďŹned on these variables, where aij is a scalar. Each constraint expresses a distance between two temporal events.  Constraints of the form Xj â Xi âĽ aij can be also represented since Xj â Xi âĽ aij is equivalent to the constraint  Xi â Xj â¤ âaij .  A tuple x = (x1 , ..., xn ) of real values is a solution of the  STP S if the instantiation {X1 =x1 , ..., Xn =xn } satisďŹes all  its constraints. The STP S is consistent if and only if it has  a solution.  The STP S = (X , C) is associated with a directed edgeweighted graph, Gd = (X , Ed ), called its distance graph  where X , the set of vertices, is the set of variables of the  STP S, and Ed is the set of weighted arcs representing the  set of constraints C. Each constraint Xj â Xi â¤ aij of C  is represented by the arc i â j 1 , which is weighted by aij .  For more details see [4].  3. Prioritized fusion of constraints  Before addressing the prioritized fusion of the constraints of STPs, we extend the deďŹnition of an STP by considering priorities. First, we deďŹne the notion of a prioritized set of constraints.  DeďŹnition 1 A prioritized set of constraints is a set C of  constraints which is partitioned into r strata C 1 , . . . , C r  (i.e., C = C 1 âŞ . . . âŞ C r , and âi, j, i = j: C i âŠ C j = â),  where all the constraints of each strata C i have the same  priority and have a higher priority than the constraints of  C j for each j such that i < j â¤ r.  A prioritized STP S is deďŹned by S = (X , C) where X is a  set of variables and C a set of prioritized constraints.  When different (prioritized) STPs are merged conďŹicts  could appear even if each of the considered (prioritized)  STPs is consistent separately. Let S1 = (X1 , C1 ),. . .,  Sp = (Xp , Cp ) be p (prioritized) STPs obtained from different sources. We can distinguish two situations:  â˘ In the ďŹrst one, we merge p prioritized STPs which  have the same priority (reliability degree) such that for  each prioritized STP Si = (Xi , Ci ), the set of constraints Ci is stratiďŹed into r strata Ci1 , . . . , Cir . Let  S be the prioritized STP obtained from the aggregation of the p prioritized STPs S1 , . . . , Sp and deďŹned  1 For  simplicity a vertex Xi of the graph Gd is denoted by its index i.  tained by aggregating the prioritized set of constraints  C1 , . . . , Cp . C is partitioned into r   strata C 1 , . . . , C r  where each set of constraints C i =  Cji .  1â¤jâ¤p  â˘ In the second situation, there is a total preordering between the p STPs but the constraints of each STP Si  have the same priority. Let S be the prioritized STP  obtained from the union of the p STPs Si with respect to the preordering deďŹned on   them. S is deďŹned by S = (X , C) where X =  Xi and C is  1â¤iâ¤p  stratiďŹed into   r (r â¤ p) strata C 1 , . . . , C r where each  Ci =  Cj .  Sj has the priority i  In both situations, the aggregation of the p (prioritized)  STPs generates the prioritized STP S. With no lost of generality, we suppose in the sequel that S contains at most  one constraint between each ordered pair of variables2 . If  the prioritized STP S is consistent, the fusion is done. Otherwise, its consistency has to be restored.  Example 1 (Inspired from [4]âs example) We have two persons Nana and Sissi which go to work every morning,  and we have two scenarii. The ďŹrst one informs us that:  Nana leaves home before 7:05, and arrives at work between 7:20 and 7:30. Sissi leaves home at most 5 mn after Nana does so and arrives at work at least 10 mn before  Nana. The second scenario states that: It takes to Nana  at most 10 mn to get at work, whereas it takes to Sissi between 10 and 20 mn to get at work, and Nana arrives at  work at most 5 mn after Sissi leaves home. Information  of each scenario can be represented by an STP. Let S1 be  the STP representing the ďŹrst scenario, and S2 be the STP  representing the second one. Let X1 , X2 , X3 , X4 be the  variables representing the temporal events âNana leaves  homeâ, âNana arrives at workâ, âSissi leaves homeâ and  âSissi arrives at workâ respectively. Let X0 be the variable  representing the time 7:00 a.m. The information âNana  leaves home before 7:05â can be represented by the constraint X1 â X0 â¤ 5. âNana arrived at work between  7:20 and 7:30â is represented by 20 â¤ X2 â X0 â¤ 30,  and so on. We obtain the STPs S1 and S2 such that:  S1 = (X1 , C1 ) where X1 = {X0 , X1 , X2 , X3 , X4 } and  C1 = {X1 â X0 â¤ 5 , X2 â X0 â¤ 30 , X0 â X2 â¤ â20 ,  X3 â X1 â¤ 5 , X4 â X2 â¤ â10}, and S2 = (X2 , C2 )  where X2 = {X1 , X2 , X3 , X4 } and C2 = {X2 â X1 â¤  10 , X4 â X3 â¤ 20 , X3 â X4 â¤ â10 , X2 â X3 â¤ 5}. The  2 If there are two constraints X â X â¤ a  i  j  ij and Xi â Xj â¤ bij  in the prioritized STP S such that aij < bij , then only the constraint  Xi â Xj â¤ aij is considered in S.  Proceedings of the 12th International Symposium on Temporal Representation and Reasoning (TIMEâ05)  1530-1311/05 $20.00 ÂŠ 2005 IEEE  STPs S1 and S2 are consistent separately. We suppose that  the ďŹrst scenario is more reliable than the second one, thus  the constraints of S1 have higher priority than the ones of  S2 . The aggregation of S1 and S2 gives the prioritized STP  S = (X , C) where X = X1 âŞ X2 = {X0 , X1 , X2 , X3 , X4 }  and C = C1 âŞ C2 = {X1 â X0 â¤ 5 , X2 â X0 â¤  30 , X0 â X2 â¤ â20 , X3 â X1 â¤ 5 , X4 â X2 â¤ â10 ,  X2 âX1 â¤ 10, X4 âX3 â¤ 20, X3 âX4 â¤ â10, X2 âX3 â¤  5} such that the constraints of C1 have the priority 1which  is the highest and the constraints of C2 have the priority 2.  The priority notion is not involved in the distance graph.  The distance graph deďŹnition of a prioritized STP remains  the same as the one of classical STPs.  Throughout this paper, we will manipulate the prioritized  STP S instead of the (prioritized) STPs S1 , . . ., Sp . Let  n , m and r be respectively the number of variables, the  number of constraints and the number of priorities of the  prioritized STP S. The prioritized STP S is deďŹned by S =  (X , C) such that C = C 1 âŞ . . . âŞ C r , where C i , 1 â¤ i â¤ r,  is the set of constraints of priority i. We suppose that 1  is the highest priority and r is the lowest. Let Gd be the  distance graph associated with the prioritized STP S. Thus,  n and m are also the number of vertices and the number of  arcs of the distance graph Gd respectively. Restoring the  consistency of the prioritized STP S consists in detecting  its conďŹicts, representing them and identifying a subset of  constraints whose correction is sufďŹcient to eliminate them.  We present in the following each of these steps.  3.1. Detection of ConďŹicts  The ďŹrst step of the fusion operation is the detection of  conďŹicts of the prioritized STP S. The method which we  propose is based on a variant of the following well known  result.  Theorem 1 ([14, 11, 10]) An STP is consistent if and only  if its corresponding distance graph does not contain negative circuits.  We can deduce from Theorem 1 that for restoring the  consistency of an STP, we need to remove all the negative  circuits of its distance graph. Actually, it is sufďŹcient to  remove all the elementary negative circuits in the distance  graph to restore the consistency of an STP. This weakened  the conditions of Theorem 1. We extend this result to handle prioritized STPs. We obtain the following theorem on  which is based our fusion method.  Theorem 2 A prioritized STP is consistent if and only if its  corresponding distance graph does not contain elementary  negative circuits.  Proof 1 Let S be a prioritized STP, and let S  be an STP  obtained from the prioritized S by ignoring the priorities  of S. S and S  have the same distance graph, let Gd be  this distance graph. The STP S  is consistent if and only if  it has a solution x which satisďŹes all its constraints. It is  clear that a solution x of the STP S  is also a solution of  the prioritized STP S, since S and S  have the same set of  constraints. This implies that S is consistent if and only if  S  is consistent. On the other hand, the STP S  is consistent  if and only if Gd does not contain negative circuits (Theorem 1). Thus, we can conclude that the prioritized STP S  is consistent if and only if its distance graph Gd does not  contain negative circuits. If S is consistent then Gd does  not contain any negative circuit, and in particular, it does  not contain any elementary negative circuit. Conversely, if  Gd does not contain any elementary negative circuit, then  Gd does not contain any negative circuit. hence, the STP  S  is consistent (Theorem 1), and the prioritized STP S is  consistent.  The presence of elementary negative circuits in Gd  means that the prioritized STP S contains conďŹicts. A conďŹict is deďŹned as follows.  DeďŹnition 2 Let S be a prioritized STP and Gd be its distance graph. A conďŹict of S is a pair (Ď, d) where Ď is an  elementary negative circuit of the distance graph Gd and d  is the distance3 of the circuit Ď.  Now, we deďŹne the ConďŹict-Detection function which  detects conďŹicts of the distance graph. The ConďŹictDetection function is an extension of the Bellman-Ford algorithm which computes the shortest paths of a graph [3].  The main idea is to compute for each pair (i, j) of vertices  the shortest path from i to j in the distance graph Gd . In  particular, when i = j, the function computes the shortest  circuit visiting the vertex i. In fact, the ConďŹict-Detection  function computes the conďŹicts, of the distance graph, having the minimum circuit length.  The ConďŹict-Detection function is given in Algorithm 1.  It consists in two steps. First, it constructs a matrix mat(0)  (0)  whose elements are pairs deďŹned by: matij = (pij , dij )  where pij represents a path of length 1 from i to j in Gd ,  and dij is the distance of the path pij . The initialization step  terminates by copying the matrix mat(0) in the matrix mat.  The second step is a loop which computes the shortest paths  between each pair (i, j) of vertices. At each iteration l of the  âwhileâ loop, a call to the Shortest-Path-Extension function  given in Algorithm 2 is made to compute the shortest paths  of length l between each pair of vertices. The loop stops  either when a conďŹict is detected or when the length of the  computed paths reaches n.  3 The  distance of a path is the sum of its arc weights.  Proceedings of the 12th International Symposium on Temporal Representation and Reasoning (TIMEâ05)  1530-1311/05 $20.00 ÂŠ 2005 IEEE  Algorithm 1 ConďŹict Detection  Function ConďŹict-Detection(Gd): a set of conďŹicts  Var mat(0) , mat: matrices of pairs (path,distance)  Conf : a set of conďŹicts  Begin  { Initialization }  Conf := â  l := 2  for i, j := 1 to n do  if there is an arc i â j in Gd weighted by aij  (0)  then matij := ((i, j), aij )  (0)  else if i = j then matij := (â, â)  (0)  else matij := (â, 0)  (0)  mat := mat  { Path extension and conďŹict detection }  while l â¤ n and Conf = â do  begin  mat := Shortest-Path-Extension(mat(0), mat, Conf )  l := l + 1  end  ConďŹict-Detection := Conf  End  The Shortest-Path-Extension function is based on the  following: a shortest path pij of length l from i to j is composed by a shortest path pik of length l â 1 from i to k  and an arc from k to j. When the Shortest-Path-Extension  function is called at the iteration l in the loop of the ConďŹictDetection function, it takes as arguments: mat(0) the initial  matrix of pairs (path,distance) corresponding to the distance  graph Gd , mat the matrix of pairs (path,distance) corresponding to the shortest paths of length l â 1 in Gd . It  returns the matrix mat corresponding to the shortest paths  of Gd of length l. In particular, matii will contain a negative circuit of length l including the vertex i, if it exists.  Furthermore, the detected negative circuits are elementary  and are added to Conf . The Shortest-Path-Extension function returns in Conf the set of conďŹicts whose negative circuits are of length l. If Conf = â, then there is no negative  circuit of length l in Gd .  Now, We evaluate the complexity of the Shortest-PathExtension function. The initialization phase is performed in  O(n2 ). The second phase consists in three loops. Each iteration of the internal loop can be done in O(n) since both  the path and the distance tests are done in a constant time  and path concatenation is done in O(n). Thus, the second  phase can be performed in O(n4 ). Therefore, the time complexity of the Shortest-Path-Extension function is O(n4 ) in  the worst case.  Algorithm 2 Shortest Path Extension  Function Shortest-Path-Extension(mat(0), mat, Var  Conf ): the extended matrix of (path,distance)  Var mat the extended matrix of (path,distance)  Begin  { Initialization }  for i, j := 1 to n, i = j do matij := (â, â)  for i := 1 to n do matii := (â, 0)  { Extension of the paths of mat }  for i, j := 1 to n do  for k := 1 to n do  (0)  if (matik .path = â and matkj .path = â and  (0)  matik .distance + matkj .distance < matij .distance)  then begin  (0)  p := matik .path â˘ matkj .path  (0)  d := matik .distance + matkj .distance    matij := (p, d)  if (i = j) then Conf := Conf âŞ matii  end  Shortest-Path-Extension := mat  End  Now, we evaluate the complexity of the ConďŹictDetection function. The initialization phase can be performed in O(n2 ). In the second phase, the function performs at most n â 1 iterations, and the complexity of each  of them is identical to the complexity of the Shortest-PathExtension function which is O(n4 ). Therefore, the complexity of the ConďŹict-Detection function is O(n5 ) in the  worst case.  Now, we can prove some properties of the Shortest-PathExtension and ConďŹict-Detection functions.  Proposition 1 The Shortest-Path-Extension function applied to the matrix mat corresponding to the shortest paths  of length l in Gd detects at least one elementary negative  circuit if and only if it exists one of length l + 1 in Gd .  Proof 2 Let mat(0) be the matrix of pairs (path,distance)  corresponding to the distance graph Gd , and mat be  the matrix of pairs (path,distance) representing the shortest paths of Gd of length l. Let mat = Shortest-PathExtension(mat(0),mat,Conf ) where Conf is the set of detected conďŹicts. The shortest path pij from i to j of length  l + 1 of Gd is deďŹned by pij = M in1â¤kâ¤n (pik â˘ (k â j)),  where M in is a function which selects the path having the  minimal distance, pik is the shortest path of length l from i  to k of Gd , and (k â j) is an arc of Gd . This implies that  the elements of mat represent really the shortest paths of  length l + 1 of Gd . We can prove now the ďŹrst statement of  the proposition.  Proceedings of the 12th International Symposium on Temporal Representation and Reasoning (TIMEâ05)  1530-1311/05 $20.00 ÂŠ 2005 IEEE  (â) If the Shortest-Path-Extension function applied to the  matrix mat corresponding to the shortest paths of length l  in Gd detects at least one elementary negative circuit, then  there exists at least one vertex i included in a negative circuit of length l + 1.  (â) Suppose that there is an elementary negative circuit Ďi  of length l + 1 including a vertex i of Gd . Let d (d < 0) be  the distance of Ďi . Since matii = (pii , dii ) represents the  shortest path pii of length l + 1 from i to i and its distance  dii , then the circuit pii is shorter than the circuit Ďi , and  consequently dii < d < 0. This means that the circuit pii  is negative also. Thus, the Shortest-Path-Extension function  detects at least one negative circuit, if it exists.  Furthermore, the negative circuits detected by the  Shortest-Path-Extension function are elementary. This can  be trivially proved since the function is applied the extend  the shortest paths of length l only if there are no negative  circuits of length l such that l â¤ l. Proposition 2 states  that when the ConďŹict-Detection function does not detect  any negative elementary circuits in the distance graph Gd  the prioritized STP S is consistent.  Proposition 2 The prioritized STP S is consistent if and  only if the ConďŹict-Detection function, applied to its distance graph Gd , does not detect any conďŹict.  Proof 3 (â) If the prioritized STP S is consistent then its  distance graph Gd does not contain any elementary negative circuit (by Theorem 2). In particular, Gd does not  contain any elementary negative circuit of length l, 2 â¤  l â¤ n. Thus, the repeated application of the Shortest-PathExtension function does not detect any negative circuit, and  the ConďŹict-Detection function does not detect any conďŹict.  (â) If the ConďŹict-Detection function does not detect any  conďŹict, then the Shortest-Path-Extension function has been  applied until l = n and for each length, no conďŹict was detected (i.e., Conf = â). This means that there is no negative circuit of length l, 2 â¤ l â¤ n in Gd (by Proposition  1). Therefore, there is no elementary negative circuit in Gd ,  hence the prioritized STP S is consistent.  3.2. Representation of conďŹicts  Each conďŹict of the prioritized STP S is identiďŹed by  a tuple (Ď, d) where Ď is an elementary negative circuit of  the distance graph Gd and d is the distance of Ď. We recall  that each arc i â j in Gd , weighted by aij , represents the  constraint cij : Xj â Xi â¤ aij of the prioritized STP S. We  deďŹne now the notion of conďŹicting constraint.  DeďŹnition 3 Let S = (X , C) be a prioritized STP, Gd its  distance graph, and Conf the set of conďŹicts of S. A constraint cij â C is a conďŹicting constraint if and only if there  5  0  1  (c1,2 , 2)  â20 10  30  5  5  2  20  â10  (c0,1 , 1)  (c2,0 , 1)  (c1,3 , 1)  (c3,2 , 2)  3  â10  (c4,3 , 2)  4  a. The distance graph  (c2,4 , 1)  b. The hypergraph of conflicts  Figure 1. The distance graph and the hypergraph of conďŹicts of the prioritized STP S deďŹned in Example 1  is a conďŹict c = (Ď, d) in Conf such that the arc i â j belongs to the elementary negative circuit Ď of Gd .  Let Conf Const be the function which associates to  each conďŹict c = (Ď, d) the set of its conďŹicting constraints.  That is, Conf Const(c) = {cij â C : i â j is an arc of  Ď}.  The set of the detected conďŹicts Conf is represented by  a vertex-weighted hypergraph Hc = (V, Ec ) where V is  the set of vertices corresponding to the   set of all conďŹictConf Const(c),  ing constraints deďŹned by: V =  câConf  and Ec is the set of hyperedges deďŹned as follows: each  hyperedge e represents a conďŹict c of Conf such that e represents the conďŹicting constraints of the conďŹict c, i.e., e =  Conf Const(c). Thus Ec = {Conf Const(c) : c â Conf }.  Each vertex cij of Hc is weighted by k, where k is the  priority of the constraint cij , i.e., cij â C k . Hc is called  the hypergraph of conďŹicts of the prioritized STP S. Let  V 1 , . . . , V r be a partition of the set of vertices V such that:  v â V i if the weight of the vertex v in the hypergraph Hc  equals i.  Example 2 The distance graph of the prioritized STP S deďŹned in Example 1 is represented in Figure 1.a. The elementary negative circuit {(0,1),(1,2),(2,0)} shows a conďŹict  between the constraints c0,1 , c1,2 and c2,0 . This adds the  hyperedge {(c0,1 , 1), (c1,2 , 2), (c2,0 , 1)} in the hypergraph  of conďŹicts. By considering all the elementary negative circuits of the distance graph of Figure 1.a, we obtain the hypergraph of conďŹicts of Figure 1.b. Each vertex of the hypergraph is a constraint which is weighted by its priority.  3.3. IdentiďŹcation of a subset of constraints to correct  Removing all the detected conďŹicts needs correcting  some constraints involved in them. At least one conďŹicting  Proceedings of the 12th International Symposium on Temporal Representation and Reasoning (TIMEâ05)  1530-1311/05 $20.00 ÂŠ 2005 IEEE  constraint of each detected conďŹict has to be corrected. In  other words, the intersection of the set of the corrected constraints and the set of conďŹicting constraints of each conďŹict  is not empty. Therefore, the subset of corrected constraints  is a transversal of the hypergraph of conďŹicts Hc of the prioritized STP S. Minimizing change when restoring the consistency of a prioritized STP S amounts to minimizing the  number of corrected constraints of C 1 (having the highest  priority), then the number of corrected constraints of C 2 ,  and so on. We recall the deďŹnition of a transversal before  deďŹning the notion of prioritized transversal.  DeďŹnition 4 Let H = (V, E) be a hypergraph. T is a  transversal of the hypergraph H if T â V and for each  hyperedge e of E, T âŠ e = â.  Now, we deďŹne a preference relation on the transversals  of a vertex-weighted hypergraph.  DeďŹnition 5 Let H = (V, E) be a vertex-weighted hypergraph where V = V 1 âŞ. . .âŞV r such that the vertex v â V i  if v is weighted by i in H. Let T1 and T2 be two transversals of the hypergraph H. T1 is preferred to T2 if (i) âi,  1 â¤ i â¤ r such that |T1 âŠ V i | < |T2 âŠ V i |, and (ii) âj,  1 â¤ j < i, |T1 âŠ V j | = |T2 âŠ V j |.  DeďŹnition 6 Let H = (V, E) be a vertex-weighted hypergraph. Tp is a prioritized transversal of the hypergraph H  if (i) Tp is a transversal of H, and (ii) for each transversal  T of H, T is not preferred to Tp .  Example 3 The hypergraph of conďŹicts shown in  Figure 1.b has many transversals.  For instance  T ={(c2,0, 1), (c4,3 , 1)}. It has one prioritized transversal  Tp ={(c1,2 , 2), (c3,2 , 2)}.  Algorithm 3 Prioritized Transversal procedure  Procedure Prioritized-Transversal(Hc = (V, Ec ),T , W ,  Var Tp )  Begin  if Ec = â then Tp := T  else if V = W then  begin  select a vertex v from V â W  Prioritized-Transversal (Hc , T, W âŞ {v}, Tp )  V := V â {v}  Ec := Ec â {e : e â Ec and e  v}  if (Tp = â or T âŞ {v} is preferred to Tp )  then Prioritized-Transversal (Hc , T âŞ {v}, W, Tp )  end  End  We deďŹne the Prioritized-Transversal procedure (Algorithm 3) to compute a prioritized transversal of the hypergraph of conďŹicts Hc . The search space of this procedure  is a binary tree. At each node of this tree, a vertex is either considered in the current partial transversal T , or not  considered then it is put in the set W . This procedure does  not enumerate systematically all the possible transversals of  the hypergraph of conďŹicts to ďŹnd a prioritized one. Indeed,  it prunes the branches of the search tree leading to partial  transversals T which are not preferred to the current prioritized transversal Tp . The Prioritized-Transversal procedure  is called with the parameters Hc = (V, EC ) which is the  hypergraph of conďŹicts, T the current partial transversal, W  the set of non considered vertices and Tp the current prioritized transversal of the hypergraph Hc which the procedure  returns. Initially, T = W = Tp = â.  To evaluate roughly the complexity of the PrioritizedTransversal procedure, let nc and mc be respectively the  number of vertices and the number of hyperedges of the  hypergraph of conďŹicts Hc . The search space is bounded  by 2nc which is the number of all the possible transversals.  The selection of a vertex v â V â W can be performed  in O(nc ), and the removal of the hyperedges incident to  v is performed in O(mc ). Testing if the current partial  transversal T âŞ {v} is preferred to the current prioritized  transversal Tp can be done in O(r). Since r < nc , then  the complexity of the Prioritized-Transversal algorithm is  O((mc + nc )2nc ) in the worst case.  Example 4 The application of the Prioritized-Transversal  procedure to the hypergraph of conďŹicts shown in  Figure 1.b returns the prioritized transversal Tp =  {(c1,2 , 2), (c3,2 , 2)}.  3.4. Correction of the conďŹicting constraints  Now, we shall see how to perform the corrections. Let  c = (Ď, d) be a conďŹict of the prioritized STP S. The elimination of the conďŹict c needs the elimination of its associated elementary negative circuit Ď. This implies the correction of at least one of the constraints involved in Ď, i.e.,  at least one of the constraints of Conf Const(c) is corrected. The following proposition shows how this correction is done.  Proposition 3 Let S be a prioritized STP and c = (Ď, d)  be a conďŹict of S. Let cij : Xj â Xi â¤ aij be a conďŹicting constraint of c (cij â Conf Const(c)). Replacing the constraint cij : Xj â Xi â¤ aij by the constraint  Xj â Xi â¤ aij â d eliminates the conďŹict c.  Proof 4 Let c = (Ď, d) be a conďŹict, and let cij : Xj âXi â¤  aij be a conďŹicting constraint of c, cij â Conf Const(c).  Proceedings of the 12th International Symposium on Temporal Representation and Reasoning (TIMEâ05)  1530-1311/05 $20.00 ÂŠ 2005 IEEE  The circuit Ď has a negative distance d, and replacing the  constraint Xj âXi â¤ aij by the constraint Xj âXi â¤ aij â  d, will make this distance equal to zero. Hence the negative  circuit Ď is eliminated and the conďŹict c is corrected.  Example 5 In Figure 1, the elementary negative circuit  {(0,1),(1,2),(2,0)} whose distance is -5 identiďŹes the conďŹict  ({(0,1),(1,2),(2,0)},-5) between the constraints X1 â X0 â¤  5 (representing the fact that Nana leaves home before 7:05),  X2 â X1 â¤ 10 (representing the fact that it takes less than  10 mn to Nana to get at work) and X0 â X2 â¤ â20 (representing the fact that Nana arrives at work after 7:20).  This conďŹict can be removed by replacing the constraint  X2 â X1 â¤ 10 by the constraint X2 â X1 â¤ 15 (it takes to  Nana less than 15 mn to get work instead of 10 mn).  The following proposition states that a conďŹict is eliminated if and only if one of its conďŹicting constraints is corrected.  Proposition 4 Let S be an inconsistent prioritized STP and  c = (Ď, d) be a conďŹict of S. The conďŹict c is eliminated if  and only if at least one of its conďŹicting constraints cij â  Conf Const(c) is corrected with respect to Proposition 3.  Proof 5 Let S be an inconsistent prioritized STP and c =  (Ď, d) be a conďŹict of S. (â) Suppose that the conďŹict c =  (Ď, d) is eliminated. This implies that the negative circuit  Ď is eliminated, i.e., its distance is changed from negative  to positive. This is done by changing at least the weight of  one of its arcs. In other words, by correcting, at least, one  constraint cij of Conf Const(c). (â) The correction of a  constraint cij â Conf Const(c) makes the conďŹict circuit  Ď positive. Hence, the conďŹict c = (Ď, d) is eliminated.  When correcting a constraint no new conďŹicts are generated and the following theorem states that the correction of  the constraints corresponding to a transversal of the hypergraph of conďŹicts representing the detected conďŹicts, eliminates these conďŹicts.  Theorem 3 Let S be an inconsistent prioritized STP and  let Conf be a set of detected conďŹicts of S. Let Hc be  the hypergraph of conďŹicts representing the set Conf . The  conďŹicts of Conf are removed from the prioritized STP S  if and only if the constraints corresponding to a transversal  of the hypergraph of conďŹicts Hc are corrected.  Proof 6 Let S be an inconsistent STP and let Conf be the  set of detected conďŹicts of S. Let Hc be the hypergraph of  conďŹicts representing Conf .  (â) Suppose that all the conďŹicts of Conf are removed.  Let Cr be the subset of constraints corrected when removing the conďŹicts of Conf . Each conďŹict c of Conf is removed by the correction of, at least, one of its conďŹicting  constraints, that is a constraint of Conf Const(c) (Proposition 4). This means that Cr âŠ Conf Const(c) = â for  each conďŹict c â Conf . However, Conf Const(c) = e  where e is the hyperedge representing the conďŹict c in Hc .  Then, Cr âŠ e = â for each hyperedge e of the hypergraph  of conďŹicts Hc . Thus Cr is a transversal of the hypergraph  of conďŹicts Hc .  (â) Suppose that Cr is a transversal of the hypergraph  of conďŹicts Hc and all its corresponding constraints are  corrected. This means that for each hyperedge e of Hc ,  e âŠ Cr = â. However, each hyperedge e of Hc represents  the set of conďŹicting constraints of a conďŹict c of Conf , i.e.,  e = Conf Const(c). This implies that for each conďŹict c of  Conf , at least one conďŹicting constraint of c is corrected  (because Cr âŠ Conf Const(c) = â). Hence, each conďŹict c  is eliminated (by Proposition 4). We conclude that the correction of all the constraints corresponding to Cr eliminates  all the conďŹicts of Conf .  4. Local prioritized fusion algorithm  Since the number of elementary negative circuits of the  distance graph of a prioritized STP is potentially high, the  exhaustive detection of conďŹicts can be impossible. A local handling of the problem seems to be a good alternative  to this problem. That is, if the conďŹicts are detected and  corrected bundle by bundle, the complexity of the fusion  operation decreases. On other hand, if a detected conďŹict c,  of the prioritized STP S, involves for instance a constraint  cij , and if this constraint participates in another not yet detected conďŹict c , then the correction of the constraint cij  could eliminate the conďŹict c .  The Local Prioritized Fusion function, sketched in Algorithm 4, consists in detecting a bundle of conďŹicts, then  in eliminating them by correcting the conďŹicting constraints  corresponding to a prioritized transversal of the hypergraph  of conďŹicts. It repeats these operations until the restoration  of the consistency.  Theorem 4 The Local Prioritized Fusion algorithm, applied to the prioritized STP S, terminates and restores the  consistency of S.  Proof 7 Let S be a prioritized STP. The number of conďŹicts  of S is ďŹnite and the correction of constraints cannot generate new ones. At each iteration of the Local-PrioritizedFusion algorithm, the ConďŹict-Detection function detects  a subset of conďŹicts. The elimination of these conďŹicts is  guaranteed by the correction of the constraints of a prioritized transversal Tp of the hypergraph of conďŹicts Hc  representing the detected conďŹicts (see Theorem 3). This  implies that at each iteration, the total number of conďŹicts  Proceedings of the 12th International Symposium on Temporal Representation and Reasoning (TIMEâ05)  1530-1311/05 $20.00 ÂŠ 2005 IEEE  Algorithm 4 Local Prioritized Fusion  Function Local-Prioritized-Fusion(S prioritized STP): a  consistent prioritized STP  Begin  Construct Gd the distance graph of S  Conf := Detection-ConďŹict(Gd)  repeat  Construct Hc the hypergraph of conďŹicts corresponding  to Conf  Tp := â  Prioritized-Transversal(Hc , â, â, Tp )  Correct the constraints corresponding to the prioritized  transversal Tp  Conf := Detection-ConďŹict(Gd)  until Conf = â  Local-Prioritized-Fusion := S  End  decreases, until the elimination of all conďŹicts. The algorithm stops when no conďŹicts are detected by the ConďŹictDetection function. This implies that there is no conďŹict in  the prioritized STP S (Proposition 2). Therefore, the LocalPrioritized Fusion function terminates and restores the consistency of the prioritized STP S.  To evaluate the complexity of the Local-PrioritizedFusion algorithm, we proceed step by step. Let mc be  the number of conďŹicts of the prioritized STP S. This  number is bounded by the number of possible elementary  circuits of the distance graph Gd which is itself bounded  n    n!  Akn where Akn = (nâk)!  . The complexity of the  by  k=2  ConďŹict-Detection function is O(n5 ), and the construction  of the distance graph is in O(nm). Now, we evaluate the  complexity of each iteration. Since the number of detected  conďŹicts at each iteration is at most n and each conďŹict can  involve at most n conďŹicting constraints, the construction  of the hypergraph of conďŹicts Hc corresponding to Conf is  in O(n2 ). The prioritized transversal Tp of the hypergraph    of conďŹicts Hc is computed in O((mc + nc )2nc ) where mc  is the number of handled conďŹicts and nc is the number  of conďŹicting constraints. The number mc is bounded by  n because at most n conďŹicts are handled in each iteration  and nc is bounded by n2 . Thus, the Prioritized transversal  2  search is performed in O(n2 2n ) in the worst case. The correction of the constraints of Tp is performed in O(n) since  at most n constraints can be corrected. Therefore, each it2  eration is performed in O(n2 2n ) in the worst case. The  Local Prioritized Fusion algorithm performs at most mnc it2  erations. Therefore, its complexity is O(mc n2n ) in the  worst case.  5. Experimental results  The local prioritized fusion algorithm presented in this  paper is implemented in C and tested on randomly generated prioritized STPs. The program runs on a P4 with 2.2  MHz and 512 MB of RAM.  Generation of random prioritized STPs is based on three  parameters: the number of variables n, the number of priorities (strata) r, and the constraint density d which is the  ratio of the number of constraints to the number of possiof constraints  . The tightness of  ble constraints, d = number n(nâ1)  the constraints is represented by the interval [-50,50] where  the constraint weights are generated. A sample of 50 problems is generated for each tuple (n, r, d) and the measures  are taken in average. The experimental results obtained by  the application of the Local Prioritized Fusion algorithm on  random prioritized STP instances are shown in Table 1. A  dash (-) means that the algorithm did not answer after running 2 hours.  We can see in Table 1 that when the density grows, the  number of conďŹicts grows. This increases the number of  corrected constraints, the number of iterations and the CPU  time. The fusion algorithm becomes faster as the number of  considered priorities increases even though the number of  detected conďŹicts, the number of corrected constraints and  the number of iterations increase. This can be explained by  the speed up of the prioritized transversal search when there  are many strata. As expected, the number of corrected constraints when only one stratum is considered is the smallest. This is due to minimal change policy. In the same  spirit, when the number of considered priorities increases,  the number of corrected constraints having the highest priority decreases. We can see that the method fuses in reasonable time problems having 30 variables with a small density  (d = 0.2), but reaches its limit on higher densities.  6. Conclusion  In this paper, we investigated the prioritized fusion of  Simple Temporal Problems STPs. That is, giving a set of  prioritized STPs to fuse, we considered the prioritized STP  S resulting from their union. If S is consistent, then the  fusion is done. Otherwise, the consistency of S has to be  restored. We presented a principle of a prioritized fusion on  which is based the local prioritized fusion method which  we proposed. Two justiďŹcations motivate the local strategy.  The ďŹrst one is the high complexity of the exhaustive detection of the conďŹicts. The second justiďŹcation is related to the  conďŹict nature. If a bundle of conďŹicts is detected and corrected, this could eliminate not yet detected conďŹicts. This  speeds up the fusion operation.  In future, we can improve the local prioritized fusion  algorithm efďŹciency by considering a âgoodâ transversal  Proceedings of the 12th International Symposium on Temporal Representation and Reasoning (TIMEâ05)  1530-1311/05 $20.00 ÂŠ 2005 IEEE  # priorities  r=1  r=5  r = 10  # conďŹicts  # corrected const  # corrected const.  # corrected const.  # iterations  CPU time (s)  # conďŹicts  # corrected const  # corrected const.  # corrected const.  # iterations  CPU time (s)  # conďŹicts  # corrected const  # corrected const.  # corrected const.  # iterations  CPU time (s)  highest prior.  lowest prior.  highest prior.  lowest prior.  highest prior.  lowest prior.  n = 10  Density  0.2 0.5 0.8  1  23 43  1  14 25  1  14 25  1  14 25  2  8  11  0  0  0  1  25 47  1  15 32  0  0  0  1  6  11  2  8  12  0  0  0  1  22 48  1  13 13  0  0  0  1  4  5  2  8  13  0  0  0  0.2  42  23  23  23  11  0  44  29  0  13  12  0  47  28  0  7  12  0  n = 20  Density  0.5 0.8  160 232  92 144  92 144  92 144  21  26  33 120  197 292  141 219  2  9  42  57  27  35  1  7  204 325  150 251  0  1  23  34  28  38  3  7  n = 30  Density  0.2 0.5  142  68  68  68  19  416  187  123  0  47  24  135  192  130  0  22  24  127  -  0.8  -  Table 1. Experimental results obtained by the application of the Local-Prioritized-Fusion algorithm  on random prioritized STP instances  rather than a prioritized one. We also hope to extend this  work to handle disjunctive temporal problems.  References  [1] S. Benferhat, D. Dubois, and H. Prade. Some syntactic approaches to the handling of inconsistent knowledge bases:  A comparative study part 1: The ďŹat case. Studia Logica,  58:17â45, 1997.  [2] S. Benferhat and L. Garcia. Handling locally stratiďŹed inconsistent knowledge bases. Studia Logica, 70:77â104,  2002.  [3] T. Cormen, C. Leiserson, and R. Rivest. Introduction to Algorithms. MIT Press, Cambridge, Massachusetts, 1990.  [4] R. Dechter, I. Meiri, and J. Pearl. Temporal constraint networks. ArtiďŹcial Intelligence, 49:61â95, 1991.  [5] M. Khelfallah and B. Benhamou. Geographic information  revision based on constraints. In Proc. of the 14th European  Conference on ArtiďŹcial Intelligence, ECAIâ04, pages 828â  832, 2004.  [6] M. Khelfallah and B. Benhamou. Two revision methods  based on constraints: Application to a ďŹooding problem. In  Proc. of the 7th Int. Conf. of ArtiďŹcial Intelligence and Symbolic Computation AISCâ04, volume 3249 of LNAI, pages  265â270, 2004.  [7] R. Kolisch and R. Padman. An integrated survey of deterministic project scheduling. Omega, 29:249â272, 2001.  [8] S. Konieczny, J. Lang, and P. Marquis. Distance based merging: A general framework and some complexity results. In  Proc. of the 8th Int. Conf. on Principles of Knowledge Representation and Reasoning (KRâ02), pages 97â108, 2002.  [9] G. Kuper, G. L. Libkin, and J. Paradaens, editors. Constraint  Databases. Springer-Verlag, 2000.  [10] C. Leiserson and J. Saxe. A mixed-integer linear programming problem which is efďŹciently solvable. In Proc. of the  21st annual Allerton conference on Communications, Control, and Computing, pages 204â213, 1983.  [11] Y. Lia and C. Wong. An algorithm to compact a vlsi  symbolic layout with mixed constraints. In IEEE Trans.  Computer-Aided Design of Integrated Circuits and Systems,  volume 2, pages 62â69, 1983.  [12] J. Lin and A. Mendelzon. Dynamic Worlds: From the Frame  Problem to Knowledge Management, volume 12 of Applied  Logic Series, chapter Knowledge Base Merging by Majority.  Kluwer, 1999.  [13] P. Rigaux, M. Scholl, and A. Voisard. Spatial Databases  with Application to GIS. Morgan Kaufmann, 2002.  [14] R. Shostak. Deciding linear inequalities by computing loop  residues,. Journal of ACM, 28(4):769â779, 1981.  Proceedings of the 12th International Symposium on Temporal Representation and Reasoning (TIMEâ05)  1530-1311/05 $20.00 ÂŠ 2005 IEEE 