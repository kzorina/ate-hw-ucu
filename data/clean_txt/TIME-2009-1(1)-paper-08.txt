Resolution-Based Model Construction for PLTL  Michel Ludwig and Ullrich Hustadt  Department of Computer Science  University of Liverpool, United Kingdom  {Michel.Ludwig, U.Hustadt}@liverpool.ac.uk  AbstractÃ¢Â€Â”With tableaux-based reasoning approaches or  model checking techniques for propositional linear-time temporal logics, PLTL, it is easily possible to construct counter  examples for formulae that are not valid. In contrast, only  the information that a formula is satisfiable is usually available in resolution-based inference systems. In this paper we  present a resolution-based approach for constructing models  for satisfiable PLTL formulae. Our approach is based on  using the standard model construction for sets of propositional  clauses saturated under ordered resolution in the different time  points of a temporal model. The temporal model construction  procedure is also designed in such a way that it can be easily  implemented in existing theorem provers for PLTL.  Keywords-Propositional Linear-Time Temporal Logic; Resolution; Automated Model Construction  I. I NTRODUCTION  Temporal Logics are a powerful notational framework for  specifying computational systems and associated properties  in the area of formal verification. The field of formal  verification is concerned with verifying that a specified  system behaves correctly in all situations. In particular,  propositional temporal logics have been successfully applied  to the verification of reactive or concurrent systems [1] and  to verification via model-checking [2].  In this paper we focus on temporal reasoning through  clausal resolution-based methods. More specifically, we consider propositional linear-time temporal logic (PLTL) with  finite past and infinite future. A clausal resolution calculus  for this logic has been introduced in [3] and implemented,  for example, in the theorem prover TSPASS [4]. Another  type of proof methods for PLTL are, for instance, tableauxbased approaches [5] and an implementation of a one-pass  tableau calculus [6] exists in the Logics Workbench [7].  In order to prove the validity of a formula ÄÂ• both proof  methods operate on the negated formula Ã‚Å¹ÄÂ•. In the case of  tableaux reasoning one essentially tries to construct a model  for the formula Ã‚Å¹ÄÂ•. If no model can be found, then one  can conclude that the formula Ã‚Å¹ÄÂ• is unsatisfiable, which  is equivalent to ÄÂ• being valid. For resolution-based proof  methods on the other hand the proof goal consists in deriving  a contradiction from the formula Ã‚Å¹ÄÂ•, from which one can  conclude again that ÄÂ• is valid.  It is therefore easy to see that formal verification by using  tableaux-based systems bears the advantage that in case of a  failure to prove the validity of a specific property a counter  example demonstrating the erroneous behaviour has already  been constructed. For clausal resolution-based reasoning a  set of clauses on which every application of an inference rule  will only derive redundant clauses, a so-called saturated set,  will have typically been constructed in that case. If the empty  clause is not contained in this saturated set, one can conclude  that the formula Ã‚Å¹ÄÂ• is satisfiable, which implies that ÄÂ• is  not valid. Thus, only the knowledge that the specification  does not satisfy the required property is generally available  for clausal resolution-based verification.  A way of constructing a model satisfying a saturated  set (under ordered resolution) both for propositional and  first-order logic has been devised in [8]. The model construction algorithm involves ordering the clauses by using  an extension of the ordering on propositional symbols that  has been used in the saturation of the clause set. One  positive (maximal) literal is then satisfied per clause, whenever necessary, starting from the smallest clause w.r.t. the  considered ordering. A term model, or so-called Herbrand  model, representing the satisfied literals will be constructed  in this way.  In this paper we present a method that allows to construct  a model for a satisfiable PLTL formula. Our approach  is based on analysing the saturated clause set that has  been computed under ordered fine-grained resolution with  selection, which is in fact a sound and complete calculus  for monodic first-order temporal logic. A temporal model  is then obtained by constructing models for sets of (nontemporal) propositional clauses at the different time points.  The sets of clauses considered for the individual points in the  time line will be constructed dynamically during the model  construction process by taking those clauses into account  that allow to express constraints among different time points.  The whole model construction procedure is designed in  such a way that it can be easily incorporated into existing  resolution-based theorem provers for PLTL.  The paper is organised as follows. In Section II we  briefly define the variant of propositional temporal logic we  are considering, whereas Section III recalls the calculus of  ordered fine-grained resolution. We then describe the propositional model construction procedure in Section IV, and in  Section V we introduce the resolution-based temporal model  construction algorithm for PLTL and prove its correctness.  In Section VI we consider practical aspects of the algorithm  and its complexity. We conclude with a brief overview of its  implementation in the theorem prover TSPASS and present  some experimental results in Section VII.  II. P ROPOSITIONAL L INEAR T IME T EMPORAL L OGIC  The language of Propositional Linear Time Temporal  Logic, PLTL, is an extension of classical propositional logic  by temporal operators for a discrete linear model of time  (i.e. isomorphic to N). The signature of PLTL is composed  of a countably infinite set of propositional symbols p, q, p0 ,  p1 , . . . , the propositional operators >, Ã‚Å¹, Ã¢ÂˆÂ¨, and the tempo(Ã¢Â€Â˜always in the futureÃ¢Â€Â™), Ã¢Â™Åš (Ã¢Â€Â˜eventually in  ral operators  the futureÃ¢Â€Â™),  (Ã¢Â€Â˜at the next momentÃ¢Â€Â™), U (Ã¢Â€Â˜untilÃ¢Â€Â™) and W  (Ã¢Â€Â˜weak untilÃ¢Â€Â™) (see e.g. [9]). We also use Ã¢ÂŠÄ½ (false), Ã¢ÂˆÂ§, and  Ã¢Â‡Â’ as additional operators, defined using > (true), Ã‚Å¹, and  Ã¢ÂˆÂ¨ in the usual way. The set of PLTL formulae is defined as  follows: > is a PLTL formula; any propositional symbol P  is an atomic PLTL formula or atom; if ÄÂ• and ÄÂˆ are PLTL  formulae, then so are Ã‚Å¹ÄÂ•, ÄÂ• Ã¢ÂˆÂ¨ ÄÂˆ, ÄÂ•, Ã¢Â™ÅšÄÂ•, ÄÂ•, ÄÂ• U ÄÂˆ, and  ÄÂ• W ÄÂˆ. As usual, a literal is either an atomic formula or its  negation. A propositional clause is a set of literals.  Formulae of this logic are interpreted over temporal  structures M = (Dn )nÃ¢ÂˆÂˆN that associate with each element n  of N, representing a moment in time, a propositional model  (or valuation) Dn given by a set of propositional symbols.  The definition of the truth relation Mn |= ÄÂ• is as follows:  Mn |= >  Mn |= p  iff p Ã¢ÂˆÂˆ Dn  Mn |= Ã‚Å¹ÄÂ•  iff not Mn |= ÄÂ•  Mn |= ÄÂ• Ã¢ÂˆÂ¨ ÄÂˆ iff Mn |= ÄÂ• or Mn |= ÄÂˆ  Mn |= ÄÂ• iff Mn+1 |= ÄÂ•  Mn |= Ã¢Â™ÅšÄÂ•  iff there exists m Ã¢Â‰Ä½ n such that Mm |= ÄÂ•  Mn |= ÄÂ• iff for all m Ã¢Â‰Ä½ n, Mm |= ÄÂ•  Mn |= ÄÂ• U ÄÂˆ iff there exists a m Ã¢Â‰Ä½ n such that Mm |= ÄÂˆ  and Mi |= ÄÂ• for every i, n Ã¢Â‰Â¤ i < m  Mn |= ÄÂ• W ÄÂˆ iff Mn |= ÄÂ• U ÄÂˆ or Mn |= ÄÂ•  A temporal structure M = (Dn )nÃ¢ÂˆÂˆN is said to be a model  for a formula ÄÂ• if and only if it holds that M0 |= ÄÂ•. A  formula is satisfiable if and only there exists a model for ÄÂ•.  A formula ÄÂ• is valid if and only if every temporal structure  M = (Dn )nÃ¢ÂˆÂˆN is a model for ÄÂ•.  We say that a set of formulae F entails a formula ÄÂˆ,  written F  ÄÂˆ, if and only if every temporal structure M  that is a model for every formula ÄÂ• Ã¢ÂˆÂˆ F is a model for ÄÂˆ  (analogously for sets of propositional clauses).  Every PLTL formula can be transformed into an equisatisfiable normal form, called divided separated clausal  normal form (DSCNF).  Definition 1. A propositional temporal problem P in divided  separated clausal normal form (DSCNF) is a quadruple  hU, I, S, Ei, where  (i) the universal part U and the initial part I are finite  sets of propositional clauses;  (ii) the step part S is a finite set of clauses of the form  p Ã¢Â‡Â’ q, where p is a propositional symbol and q is  a propositional literal; and  (iii) the eventuality part E is a finite set of formulae of  the form Ã¢Â™Åšl (an eventuality clause), where l is a  propositional literal.  We associate with each propositional temporal problem  P = hU, I, S, Ei the PLTL formula I Ã¢ÂˆÂ§ U Ã¢ÂˆÂ§ S Ã¢ÂˆÂ§ E.  When we talk about particular properties of a temporal  problem (e.g., satisfiability, validity, logical consequences,  etc.) we refer to properties of this associated formula.  The transformation to DSCNF is based on a renaming  and unwinding technique which substitutes non-atomic subformulae by new propositional symbols and their definitions,  and replaces temporal operators by their fixed point definitions as described, for example, in [3].  Theorem 1. Any formula in propositional linear-time temporal logic can be transformed into an equi-satisfiable  propositional temporal problem in DSCNF with at most a  linear increase in the size of the problem.  Proof: Follows from [10], Theorem 3.4.  The main purpose of the divided separated clausal normal  form is to cleanly separate different temporal aspects of a  PLTL formula from each other. One has to note that step  clauses of the form C Ã¢Â‡Â’ D, where C is a conjunction  of propositional symbols and D a disjunction of propositional literals, can be derived by the calculus introduced in  Section III.  In this paper we assume that propositional temporal  problems in DSCNF contain at most one single eventuality.  This is not a restrictive assumption as every propositional  problem can be transformed in such a way that it contains  at most one eventuality up to a linear increase in the size of  the problem (see [11], Lemma 7).  Let {p1 Ã¢Â‡Â’V q1 , . . . , pn Ã¢Â‡Â’  Vn qn } be a set of step clauses  n  in P. Then ( i=1 pi ) Ã¢Â‡Â’ ( i=1 qi ) is called a merged step  clause built from P.  In what follows, A Ã¢Â‡Â’  B and Ai Ã¢Â‡Â’  Bi denote  merged step clauses, and U denotes the (current) universal  part of a propositional temporal problem P.  In the next section we recall the propositional version of  the ordered fine-grained resolution with selection calculus  first presented in [12]. As the clauses we are considering  are actually sets of literals instead of multisets, we do not  have to introduce factoring rules.  III. O RDERED F INE -G RAINED R ESOLUTION WITH  S ELECTION  We assume that we are given an admissible ordering ,  that is, a strict partial ordering on propositional symbols  that is well-founded and total, and a selection function S  which maps any propositional clause C to a (possibly empty)  subset of its negative literals. The ordering  is extended  to literals by Ã‚Å¹A  A and (Ã‚Å¹)A  (Ã‚Å¹)B if and only if  A  B. A literal L is called (strictly) maximal w.r.t. a clause  C if and only if there is no literal L0 Ã¢ÂˆÂˆ C with L0  L  (L0  L). A literal L is eligible in a clause L Ã¢ÂˆÂ¨ C if either it  is selected in L Ã¢ÂˆÂ¨ C, or otherwise no literal is selected in C  and L is maximal w.r.t. C. The admissible ordering  and  the selection function S are used to restrict the applicability  of the deduction rules of fine-grained resolution as follows.  (i) Ordered resolution with selection between two universal clauses  C1 Ã¢ÂˆÂ¨ A Ã‚Å¹A Ã¢ÂˆÂ¨ C2  C1 Ã¢ÂˆÂ¨ C2  if A is eligible in (C1 Ã¢ÂˆÂ¨ A), and Ã‚Å¹A is eligible in  (Ã‚Å¹A Ã¢ÂˆÂ¨ C2 ). The result is a universal clause.  (ii) Ordered resolution with selection between an initial  and a universal clause and between two initial clauses.  These are defined in analogy to the two deduction rules  above with the only difference that the result is an  initial clause.  (iii) Ordered fine-grained step resolution with selection.  C1 Ã¢Â‡Â’  (D1 Ã¢ÂˆÂ¨ A) C2 Ã¢Â‡Â’ (D2 Ã¢ÂˆÂ¨ Ã‚Å¹A)  (C1 Ã¢ÂˆÂ§ C2 ) Ã¢Â‡Â’ (D1 Ã¢ÂˆÂ¨ D2 )  where C1 Ã¢Â‡Â’ (D1 Ã¢ÂˆÂ¨ A) and C2 Ã¢Â‡Â’ (D2 Ã¢ÂˆÂ¨ Ã‚Å¹A)  are step clauses, A is eligible in (D1 Ã¢ÂˆÂ¨ A), and Ã‚Å¹A is  eligible in (D2 Ã¢ÂˆÂ¨ Ã‚Å¹A).  C1 Ã¢Â‡Â’ (D1 Ã¢ÂˆÂ¨ A) D2 Ã¢ÂˆÂ¨ Ã‚Å¹A  C1 Ã¢Â‡Â’ (D1 Ã¢ÂˆÂ¨ D2 )  where C1 Ã¢Â‡Â’ (D1 Ã¢ÂˆÂ¨ A) is a step clause, D2 Ã¢ÂˆÂ¨ Ã‚Å¹A is  a universal clause, A is eligible in (D1 Ã¢ÂˆÂ¨ A), and Ã‚Å¹A  is eligible in (D2 Ã¢ÂˆÂ¨ Ã‚Å¹A).  D1 Ã¢ÂˆÂ¨ A C2 Ã¢Â‡Â’ (D2 Ã¢ÂˆÂ¨ Ã‚Å¹A)  C2 Ã¢Â‡Â’ (D1 Ã¢ÂˆÂ¨ D2 )  where D1 Ã¢ÂˆÂ¨A is a universal clause, C2 Ã¢Â‡Â’ (D2 Ã¢ÂˆÂ¨Ã‚Å¹A)  is a step clause, A is eligible in (D1 Ã¢ÂˆÂ¨ A), and Ã‚Å¹A is  eligible in (D2 Ã¢ÂˆÂ¨ Ã‚Å¹A).  (iv) Clause conversion. A step clause of the form C Ã¢Â‡Â’ Ã¢ÂŠÄ½  is rewritten to the universal clause Ã‚Å¹C.  (v) Eventuality resolution rule w.r.t. U .  A1 Ã¢Â‡Â’  B1  Ã‚Ë‡ Ã‚Ë‡ Ã‚Ë‡ An Ã¢Â‡Â’  Vn  i=1 Ã‚Å¹Ai  Bn  Ã¢Â™Åšl  (Ã¢Â™ÅšU  res )  where Ai Ã¢Â‡Â’ Bi are merged step clauses such that for  every i, 1 Ã¢Â‰Â¤ i Ã¢Â‰Â¤ n, the  Wnloop side conditions U Ã¢ÂˆÂ§ Bi |=  Ã‚Å¹l and U Ã¢ÂˆÂ§ Bi |= j=1 Aj are valid. (In the case  U |= Ã‚Å¹l, the degenerate clause, > Ã¢Â‡Â’ >, can be  considered as a premise of this rule, and the conclusion  of the rule is then Ã‚Å¹>.)  The set of full merged step clauses, satisfying the loop  side  Wn conditions, is called a loop in Ã¢Â™Åšl and the formula  j=1 Aj is called a loop formula.  Rules i to iii, also called rules of fine-grained step resolution, are either identical or closely related to the deduction  rules of ordered propositional resolution with selection.  In contrast, rule v is much more complex, as it requires  not just one or two premises, but an indeterminate (though  finite) number of complex combinations of step clauses,  which have to satisfy certain conditions. To find premises  suitable for an application of the eventuality resolution rule  we use a particular algorithm, called FG-BFS (for finegrained breadth-first search), which conducts a so-called  loop search (see e.g. [10] for more details). The algorithm  internally uses W  the deduction rules i to iii and returns a loop  n  formula H = j=1 Aj , which allows to directly add Ã‚Å¹H  to the universal part of a temporal problem as the result of  applying the eventuality resolution rule.  Let ordered fine-grained resolution with selection be the  calculus consisting of the rules i to iv above, together with  the eventuality resolution rule v. We denote this calculus  by IS,  FG . The calculus can be extended by redundancy  elimination rules, like for example, the deletion of subsumed  clauses.  Definition 2 (Derivation). A (linear) derivation D (in IS,  FG )  from a temporal problem P in DSCNF is a sequence of  tuples  D = hU1 , I1 , S1 , Ei, hU2 , I2 , S2 , Ei, . . .  such that each tuple hUi+1 , Ii+1 , Si+1 , Ei is obtained from  hUi , Ii , Si , Ei by adding the conclusion of an application of  one of the inference rules of IS,  to premises from one of  FG  the sets Ui , Ii , Si to that set, with the other sets as well as  E remaining unchanged1 .  A derivation D such that the empty clause is an element  of a Ui Ã¢ÂˆÅ Ii is called a (IS,  FG -)refutation of hU1 , I1 , S1 , Ei.  A derivation D is fair if and only if for each clause C  which can be derived from premises in  S  S  S  h iÃ¢Â‰Ä½1 Ui , iÃ¢Â‰Ä½1 Ii , iÃ¢Â‰Ä½1 Si , Ei  there exists an index j such that C occurs in hUj , Ij , Sj , Ei.  Ordered fine-grained resolution with selection is sound  and complete for propositional temporal problems as stated  in the following theorem.  Theorem 2 (see [12], Theorem 5). Let P be propositional  temporal problem in DSCNF. Let  be an admissible ordering and S a selection function. Then P is unsatisfiable  iff there exists a IS,  FG -refutation of P. Moreover, P is  unsatisfiable iff any fair IS,  FG -derivation is a refutation of P.  IV. P ROPOSITIONAL M ODEL C ONSTRUCTION  In this section we briefly recall the model construction  procedure for satisfiable sets of (non-temporal) propositional  1 In an application of the eventuality resolution rule, the set U in the  definition of the rule refers to Ui .  clauses as it was introduced in [8]. This model construction  procedure uses an admissible ordering on propositional  symbols again, which is then extended on propositional  clauses as its (multi)set extension. The model is constructed  by considering which literals have to be satisfied in a given  clause, starting from the smallest clause w.r.t. the clause  ordering.  Definition 3 (Propositional Model Construction). Let  be an admissible ordering and S be a selection function.  Additionally, let N be a set of propositional clauses.  For a propositional clause C Ã¢ÂˆÂˆ N we inductively define  a propositional model I,S (C) and a set ÃÄ¾C as follows.  Let C Ã¢ÂˆÂˆ S  N be a propositional clause. Then, we define  I,S (C) = CD ÃÄ¾D , and if the clause C  (i) is of the form C 0 Ã¢ÂˆÂ¨ A, where A is the maximal literal  in C,  (ii) is false in I,S (C), and  (iii) if no negative literal is selected in C,  we define ÃÄ¾C = {A};  S otherwise we set ÃÄ¾C = Ã¢ÂˆÂ…. Finally, we  define I,S (N ) = CÃ¢ÂˆÂˆN ÃÄ¾C .  In line with the definition of the semantics for PLTL  given in Section II propositional symbols not listed in a  propositional model I,S (N ) will be set to Ã¢Â€Â˜falseÃ¢Â€Â™2 in the  model.  It can be shown that for an arbitrary admissible ordering,  an arbitrary selection function and for an arbitrary saturated  set of propositional clauses (w.r.t. to the given ordering)  which does not contain the empty clause, the propositional  model construction indeed constructs a model.  Theorem 3 (see [8], Theorem 3.16). Let  be an admissible  ordering and S be a selection function. Moreover, let N  be a set of propositional clauses that is saturated under  inferences by the rules of ordered (propositional) resolution  with selection and let N not contain the empty clause. Then  it holds that I,S (N ) |= N .  V. T EMPORAL M ODEL C ONSTRUCTION  For a temporal problem P = hU, I, S, Ei the temporal  model construction is based on using the regular propositional model construction for the different time points of  a temporal model. For the initial time point 0 the regular  propositional model construction will be performed over  the set of universal clauses together with the set of initial  clauses. For time points different from the initial point in  time, the (merged) step clauses C Ã¢Â‡Â’ D whose left-hand  sides C were fulfilled at the previous moment in time have  to be considered in addition to the set of universal clauses.  If the temporal problem P contains a single eventuality,  i.e. E = {Ã¢Â™Åšl}, special care has to be taken for allowing it to  be satisfied infinitely often. We add the eventuality to the set  2 More  specifically, the terminology of Ã¢Â€ÂœdonÃ¢Â€Â™t careÃ¢Â€Â literals from SAT  solvers does not apply here.  of clauses used for the model construction in a specific time  point if the newly-added eventuality unit clause does not lead  to a contradiction. As a result, the constructed model will  satisfy the eventuality in every time point in which the set of  universal clauses and the right-hand sides of the step clauses  whose left-hand sides were fulfilled at the previous time  point do not imply the negated eventuality. Consequently,  the only Ã¢Â€Â˜criticalÃ¢Â€Â™ merged step clauses A Ã¢Â‡Â’ B are those  with U Ã¢ÂˆÅ {B}  Ã‚Å¹l and U 6 Ã‚Å¹A. In particular one has to  avoid that the left-hand side of one of these Ã¢Â€Â˜criticalÃ¢Â€Â™ merged  step clauses is constantly fulfilled from any given time point  onwards. One way of ensuring this requirement consists in  varying the ordering on propositional symbols that is used  to construct the models for the different time points, which  is also the approach that is taken in this paper.  For example, if we were to construct a temporal model  as described above for the temporal problem P0 = h{p Ã¢ÂˆÂ¨  q}, Ã¢ÂˆÂ…, {p Ã¢Â‡Â’  Ã‚Å¹l}, {Ã¢Â™Åšl}i, we have to ensure that the  propositional symbol p is not satisfied at every time point  as otherwise we would obtain the sequence of propositional models {p, l}, {p}, {p}, . . . . The constructed sequence  would obviously not satisfy the formula Ã¢Â™Åšl.  In the next subsection we describe the model construction  procedure in a formal way and give an example for the  construction of a model, while we prove the correctness of  the procedure in the subsequent subsection.  A. Construction Principle  Before we can introduce the model construction procedure, we still need to give a couple of auxiliary definitions.  First of all, for a temporal problem P we associate with  every set of merged step clauses C (and with the power set  P(C)) a set OC of strict total orderings on Symbols(P).  Definition 4. Let P be a propositional temporal problem in  DSCNF and let C = {A1 Ã¢Â‡Â’ B1 , . . . , An Ã¢Â‡Â’ Bn } be a  set of merged step  built from the temporal problem P,  Vmiclauses  where Ai = j=1  aij for 1 Ã¢Â‰Â¤ i Ã¢Â‰Â¤ n and ai1 , . . . , aimi are  propositional symbols for 1 Ã¢Â‰Â¤ i Ã¢Â‰Â¤ n.  We define OC to be the smallest set of admissible orderings on Symbols(P) which contains for every tuple  (i1 , . . . , in ) Ã¢ÂˆÂˆ {1, . . . , m1 } Ä‚Â— . . . Ä‚Â— {1, . . . , mn } exactly  one ordering  Ã¢ÂˆÂˆ OC with Symbols(P) \ {a1i1 , . . . , anin }  a1i1 , . . . , anin .  S For the power set P(C) of C we define that OP(C) =  SÃ¢ÂˆÂˆP(C) OS , where OÃ¢ÂˆÂ… = Ã¢ÂˆÂ….  The next definition introduces the set RS (M) which  contains the right-hand sides of step clauses whose left-hand  sides are triggered by a propositional model M.  Definition 5. Let P = hU, I, S, Ei be a propositional temporal problem such that E = Ã¢ÂˆÂ… or E = {Ã¢Â™Åšl}. Additionally,  let S be a set of step clauses built from P and M be a  propositional model over Symbols(P). Then we define:  RS (M) = { l1 Ã¢ÂˆÂ¨ . . . Ã¢ÂˆÂ¨ lm | (p1 Ã¢ÂˆÂ§ . . . Ã¢ÂˆÂ§ pm ) Ã¢Â‡Â’  (l1 Ã¢ÂˆÂ¨ . . . Ã¢ÂˆÂ¨ lm ) Ã¢ÂˆÂˆ S and M |= p1 Ã¢ÂˆÂ§ . . . Ã¢ÂˆÂ§ pm }  Next we define the set LE (N ), which adds to the set N  the unit clause l if E = {Ã¢Â™Åšl} and N 6 Ã‚Å¹l.  Definition 6. Let P = hU, I, S, Ei be a propositional temporal problem such that E = Ã¢ÂˆÂ… or E = {Ã¢Â™Åšl}. Furthermore,  let N be a set of propositional clauses over Symbols(P).  Then we define:  N Ã¢ÂˆÅ {l} if E = {Ã¢Â™Åšl} and N 6 Ã‚Å¹l  LE (N ) =  N  otherwise  Finally, for a set of propositional clauses N we denote  by Res,S (N ) the set of all the clauses obtained by an  application of the ordered resolution rule using the ordering  to premises in N and the selection  function S. We  S  i  also define that ResÃ¢ÂˆÂ  (N  )  =  Res  ,S  ,S (N ), where  iÃ¢ÂˆÂˆN  0  Res,S (N ) = N .  We can now give the definition of the temporal model  construction procedure.  Definition 7 (Temporal Model Construction). Let P =  hU, I, S, Ei be a propositional temporal problem in DSCNF  such that Ã¢ÂŠÄ½ 6Ã¢ÂˆÂˆ U Ã¢ÂˆÅ I, and E = Ã¢ÂˆÂ… or E = {Ã¢Â™Åšl}.  Additionally, let S be a selection function, and if E = {Ã¢Â™Åšl},  let C = {A1 Ã¢Â‡Â’ B1 , . . . , An Ã¢Â‡Â’ Bn } be the set of all  the merged step clauses built from the temporal problem P  such that for every i, 1 Ã¢Â‰Â¤ i Ã¢Â‰Â¤ n:  (i) U Ã¢ÂˆÅ {Bi }  Ã‚Å¹l, and  (ii) U 6 Ã‚Å¹Ai , and  (iii) for every A Ã¢Â‡Â’ B with A ( Ai (and B ( Bi ) it  holds that U Ã¢ÂˆÅ {B} 6 Ã‚Å¹l.  The merged step clauses from the set C will also be called  critical merged step clauses for the temporal problem P.  We then define a sequence of propositional models  H0 , H1 , . . . as follows:  E  H0 = I0 ,S (ResÃ¢ÂˆÂ  0 ,S (L (U Ã¢ÂˆÅ I))))  and for i Ã¢Â‰Ä½ 1:  E  S  Hi = Ii ,S (ResÃ¢ÂˆÂ  i ,S (L (U Ã¢ÂˆÅ R (HiÃ¢ÂˆÂ’1 ))))  where i (i Ã¢ÂˆÂˆ N) are admissible orderingsWon Symbols(P)  n  such that for every Hj , j Ã¢Â‰Ä½ 1 with Hj |= k=1 Ak , which  occurs infinitely often,  OP(C) Ã¢ÂŠÂ† { t+1 | t Ã¢Â‰Ä½ j and Ht = HjW}.  n  Additionally, for every Hj , j Ã¢Â‰Ä½ 1 with Hj 6|= k=1 Ak we  have j+1 = 0 .  Let H = (H0 , H1 , . . . ) denote the temporal model obtained in this way.  First of all, one can observe that the process of ensuring  that every ordering is used infinitely often corresponds to the  notion of fairness, which is employed in the field of model  checking [13].  Then, as explained above, the sets of initial and universal  clauses are considered for the model construction in the time  point 0. Additionally, the eventuality is added to the clause  set used for model construction if its presence does not lead  to a contradiction. The regular model construction is then  performed through an initial ordering 0 on Symbols(P)  after the model construction clause set has been saturated  under regular ordered resolution with selection using the  ordering 0 . This saturation process is necessary in order to  ensure the correctness of the propositional model construction.  For any time point other than the initial point of the  time line, the universal clauses together with the righthand side of any step clause whose left-hand was satisfied  at the previous time point are used for the propositional  model construction. Again, the eventuality is added to the  considered set if does not lead to a contradiction. It is  now important to note that the ordering on propositional  symbols under which the propositional resolution and model  construction is performed has to be varied for the temporal  model construction to succeed. The variation of the orderings on propositional symbols ensures that a propositional  model is found for a time point which does not trigger the  left-hand side of any critical step clause,  For example, for the temporal problem P0 = h{p Ã¢ÂˆÂ¨  q}, Ã¢ÂˆÂ…, {p Ã¢Â‡Â’ Ã‚Å¹l}, {Ã¢Â™Åšl}i again, we cannot use the ordering  l  p  q at every time point as it would not lead to a correct  temporal model. We have to use an ordering 0 with q 0 p  at some time points instead.  It is important to note that in general different choices of  orderings can lead to different models, which can greatly  vary in size. However, it is not possible to construct every  model of a temporal problem P though the model construction method introduced in this paper. For example, the model  {p}, {p}, . . . cannot be obtained for the temporal problem  h{Ã‚Å¹p Ã¢ÂˆÂ¨ Ã‚Å¹q}, Ã¢ÂˆÂ…, Ã¢ÂˆÂ…, Ã¢ÂˆÂ…i.  We conclude this section by applying the temporal model  construction procedure on a concrete example. We consider  the temporal problem P00 = h{p Ã¢ÂˆÂ¨ q}, {p}, {p Ã¢Â‡Â’ q, q Ã¢Â‡Â’  p}, {Ã¢Â™ÅšÃ‚Å¹p}i. Saturating the problem P00 under ordered  fine-grained resolution (with an empty selection function)  using the ordering p  q derives the universal clause  Ã‚Å¹p Ã¢ÂˆÂ¨ Ã‚Å¹q (through loop search), the initial clause Ã‚Å¹q, and  the step clause q Ã¢Â‡Â’  Ã‚Å¹q. The step clause q Ã¢Â‡Â’  p is  a critical step clause for the set of universal clauses as  {p Ã¢ÂˆÂ¨ q, Ã‚Å¹p Ã¢ÂˆÂ¨ Ã‚Å¹q, p}  Ã‚Å¹Ã‚Å¹p.  For the initial time point we hence consider the set of  propositional clauses {Ã‚Å¹q, p, p Ã¢ÂˆÂ¨ q, Ã‚Å¹p Ã¢ÂˆÂ¨ Ã‚Å¹q} for the propositional model construction procedure. With the symbol  ordering p  q, we obtain the model H0 = {p}.  Then, as the step clause p Ã¢Â‡Â’ q has been triggered at  the initial time point, we have to add the unit clause q to the  considered clause set. As {q, p Ã¢ÂˆÂ¨ q, Ã‚Å¹p Ã¢ÂˆÂ¨ Ã‚Å¹q}   6 Ã‚Å¹Ã‚Å¹p, we add  the unit clause Ã‚Å¹p and obtain the set {q, p Ã¢ÂˆÂ¨ q, Ã‚Å¹p, Ã‚Å¹p Ã¢ÂˆÂ¨ Ã‚Å¹q},  which is to be used for the propositional model construction.  After saturation with the ordering p  q, the standard  propositional model construction yields the propositional  model H1 = {q} in the time point 1.  Finally, as the step clauses q Ã¢Â‡Â’ p, q Ã¢Â‡Â’ Ã‚Å¹q have been  triggered in time point 1, the unit clauses p and Ã‚Å¹q have to be  added to the clause set used for the propositional model construction. Additionally, as the set {Ã‚Å¹q, p, p Ã¢ÂˆÂ¨ q, Ã‚Å¹p, Ã‚Å¹p Ã¢ÂˆÂ¨ Ã‚Å¹q}  is unsatisfiable, the set {Ã‚Å¹q, p, p Ã¢ÂˆÂ¨ q, Ã‚Å¹p Ã¢ÂˆÂ¨ Ã‚Å¹q} has be to be  considered for the propositional model construction, which  results in the model H2 = {p} with the ordering p  q.  As H0 = H2 the temporal model construction procedure  will now construct models for the remaining time points  analogously to ones shown above.  B. Correctness  In this section we prove the correctness of the construction  procedure introduced in Definition 7, i.e. we show that the  constructed sequence of propositional models is indeed a  model for the considered temporal problem. We only state  the required lemmata and theorems; the full proofs can be  found in [14]. First of all, we introduce three lemmata that  will be required for the subsequent correctness theorem.  Lemma 4. Let N be a set of propositional clauses over a set  of propositional symbols P such that every clause contains  at least one negative literal. Let  be an admissible ordering  on the propositional symbols P and S be a selection  function.  Then it holds that I,S (N ) = Ã¢ÂˆÂ….  Lemma 5. Let N be a satisfiable set of propositional  clauses. Moreover, let a1 , . . . , an be propositional symbols  and let  be an admissible ordering on propositional  symbols such that Symbols(N)\{a1 , . . . , an }  a1 , . . . , an .  Finally, let S be a selection function. Then it holds that:  I,S (ResÃ¢ÂˆÂ  ,S (N ))  a1 Ã¢ÂˆÂ¨ . . . Ã¢ÂˆÂ¨ an iff N  a1 Ã¢ÂˆÂ¨ . . . Ã¢ÂˆÂ¨ an  Lemma 6. Let P be a propositional temporal problem and  let N be a satisfiable set of propositional clauses which  only uses propositional symbols from P. Additionally, let  C = {A1 Ã¢Â‡Â’ B1 , . . . , An Ã¢Â‡Â’ Bn } be a set of merged  step clause built from the temporal problem P, and let S be  a selection function. Then it holds that:  Wn  Wn  N  i=1 Ai iff Ã¢ÂˆÂ€  Ã¢ÂˆÂˆ OC : I,S (ResÃ¢ÂˆÂ  ,S (N )) |=  i=1 Ai  We can now state the correctness theorem for the model  construction procedure.  Theorem 7. Let P = hU, I, S, Ei be a propositional temporal problem with E = Ã¢ÂˆÂ… or E = {Ã¢Â™Åšl} which is saturated  under ordered fine-grained resolution with selection and  does not contain the empty clause. Additionally, let H be the  corresponding sequence of propositional models obtained  through temporal model construction. Then it holds that:  H0 |= I Ã¢ÂˆÂ§  UÃ¢ÂˆÂ§  SÃ¢ÂˆÂ§  E  VI. P RACTICAL C ONSIDERATIONS AND C OMPLEXITY  The temporal model construction as described in the previous section constructs an infinite sequence of propositional  models, as suggested by the definition of the semantics for  PLTL given in Section II. However, for practical applications, a finite representation of a temporal structure, as given  by an ultimately periodic model is more useful.  Definition 8 (Ultimately Periodic Model). Let P =  hU, I, S, Ei be a propositional temporal problem such that  either E = Ã¢ÂˆÂ… or E = {Ã¢Â™Åšl}, and let H = (H0 , H1 , H2 , . . . )  be the an infinite sequence of propositional models over  Symbols(P). Furthermore, let I, J, L Ã¢ÂˆÂˆ N be indices such  that I Ã¢Â‰Â¤ L < J, HI = HJ and HL |= l if E = {Ã¢Â™Åšl}, I = L  otherwise.  We then define a sequence of propositional models H0 =  (H00 , H10 , . . . ) as follows:  (i) Hi0 = Hi for every 0 Ã¢Â‰Â¤ i Ã¢Â‰Â¤ J  (ii) Hi0 = HI+(iÃ¢ÂˆÂ’I) mod (JÃ¢ÂˆÂ’I) for every i Ã¢Â‰Ä½ J + 1  It can be shown that if the sequence H is a model for P,  then the sequence H0 is also a model for P [15].  More concretely, in an implementation of the temporal  model construction procedure one has to keep track of the  ordering that has been used for the saturations used in the  different time points. Whenever a previously considered set  of clauses is encountered again, the symbol ordering used for  the model construction in the considered time point has to be  changed cyclically. Finally, the construction procedure can  terminate whenever a previously encountered valuation has  been computed again and the possibly present eventuality  has been satisfied in between those two time points.  Moreover, it easy to see that for a set C = {A1 Ã¢Â‡Â’  B1 , . . . , An Ã¢Â‡Â’ Bn } of critical merged step clauses for a  temporal problem P the set OP(C) can be constructed from  P(Ã¢ÂˆÅni=1 Symbols(Ai )), the power set of all the propositional  symbols occurring in left-hand sides of critical step clauses.  Every ordering  Ã¢ÂˆÂˆ OP(C) is characterised by the subset  P Ã¢ÂŠÂ† Ã¢ÂˆÅni=1 Symbols(Ai ) such that Symbols(P) \ P  p for  every p Ã¢ÂˆÂˆ P. Thus, in an implementation it is sufficient  to consider all the subsets of Ã¢ÂˆÅni=1 Symbols(Ai ) in order to  construct the required orderings.  Furthermore, it is also possible to eliminate redundant  cycles in constructed temporal models. For example, if  one has built a model for a temporal problem P with a  single eventuality Ã¢Â™Åšl and the constructed model contains a  sequence of valuations Hi , Hi+1 , . . . , Hj such that Hi = Hj  and Hk 6|= l for every i Ã¢Â‰Â¤ k Ã¢Â‰Â¤ j, then the sequence  Hi , . . . , HjÃ¢ÂˆÂ’1 can be removed from the final model as it  does not contribute to satisfying the eventuality.  It is important to note that the model construction procedure is completely deterministic, that is, neither the basic  building blocks given by I,S and ResÃ¢ÂˆÂ  ,S , nor the construction of the sequence of propositional models that form  Time  LWB Ã¢Â€Â˜ModelÃ¢Â€Â™  1  Cran  2  Cran  1  Cran  2  Cran  (n=5)  (n=5)  (n=12)  (n=12)  0.06s  0.06s  1.5s  0.06s  TSPASS  0.03s  0.06s  0.04s  1.13s  TSPASS  Model Construction  0.07s  (0.01s)  0.63s  (0.03s)  0.89s  (0.57s)  53.14s  (0.47s)  LWB Ã¢Â€Â˜ModelÃ¢Â€Â™  Length  7  2  39  2  TSPASS Model Properties  Constructed Critical Merged  Model Length Time  Points Step Clauses  2 (1)  2  0  2 (1)  2  0  14 (7)  16  17  2 (1)  2  0  Table I  M EDIAN R ESULTS ( PER CLASS ) FOR THE TSPASS AND LWB MODEL CONSTRUCTION PROCEDURES APPLIED ON THE BENCHMARK CLASSES  the ultimately periodic model involves any non-deterministic  operation that in an implementation would force us to use  a form of backtracking-search to find a model. On the  other hand, just as standard tableaux-based model generation  procedures for PLTL, there is no guarantee that we will  produce a minimal, that is, shortest possible, ultimately  periodic model for a temporal problem or PLTL formula.  The computational complexity of the temporal model  construction procedure is determined mainly by the time  required to compute the saturation ResÃ¢ÂˆÂ  ,S (N ) of a set N of  clauses under ordered resolution, which is exponential in the  size of N , the size of the ResÃ¢ÂˆÂ  ,S (N ), which is also exponential in the size of N , and the maximal length of the sequence  of propositional models in an ultimately periodic model H0  for a satisfiable temporal problem P = hU, I, S, Ei, which  is again exponential in the size of P. Overall, we obtain the  following result.  Theorem 8. Let P = hU, I, S, Ei be a satisfiable propositional temporal problem with E = Ã¢ÂˆÂ… or E = {Ã¢Â™Åšl}. Then an  ultimately periodic model H for P can be constructed by the  temporal model construction procedure in time exponential  in the size of P.  Since for a given PLTL formula ÄÂ• an equi-satisfiable  propositional problem P in DSCNF can be computed in  polynomial time and space, this result also implies the we  can construct an ultimately periodic model for ÄÂ• in time  exponential in the size of ÄÂ•.  It is important to remember that while the satisfiability problem of PLTL is PSPACE-complete, given that  ultimately periodic models can be of exponential size in  the worst case, we cannot hope for a model construction  procedure of better complexity.  VII. I MPLEMENTATION  The temporal model construction has been implemented  as an extension of the theorem prover TSPASS3 [4], which  is a fair theorem prover for monodic first-order temporal  logic based on ordered fine-grained resolution with selection.  It is important to note that while the temporal problem is  saturated by TSPASS, the critical merged step clauses for  3 http://www.csc.liv.ac.uk/Ã‹Âœmichel/software/tspass/  the considered temporal problem are also computed as part  of the overall loop search process. Consequently, no further  computation is required to obtain these step clauses.  We have compared the resolution-based model construction implemented in TSPASS 0.92-0.16 with the one-pass  tableau calculus described in [6], which is implemented in  the Logics Workbench (LWB) version 1.1 [7]. We have  applied both systems to all the satisfiable PLTL formulae  in the benchmark classes introduced in [16]. Two of the  1  1  (n = 12),  (n = 5) and Cran  benchmark classes, Cran  where n is the number of propositional symbols over which  the formulae are constructed, are designed in such a way  that they can be theoretically solved easily by resolutionbased decision procedures, whereas the two other benchmark  2  2  (n = 12), are designed so that  (n = 5) and Cran  classes, Cran  the satisfiable formulae in them can be theoretically solved  more easily by tableaux-based systems. In particular, in [16]  the implementation of the one-pass tableau calculus in the  LWB was indeed performing best on these formulae.  The experiments were run on a PC equipped with an  Intel Core 2 E6400 CPU and 3 GB of main memory and  an execution timeout of 5 minutes was imposed on each  problem.  For TSPASS an empty selection function was used. The  scheduling of the orderings on propositional symbols was  done w.r.t. an increasing subset size and in such a way that  a maximal number of different orderings were tried out:  whenever a set of propositional clauses was encountered for  the first time the next possible ordering was used for the  propositional model construction instead of starting again  from the initial ordering w.r.t. the critical symbols. For the  1  Cran  classes TSPASS was instructed to perform matching  replacement resolution and formulae (ÄÂ†) Ã¢ÂˆÂ§ (ÄÂˆ) were  rewritten to (ÄÂ† Ã¢ÂˆÂ§ ÄÂˆ) in order to reduce the number of  required renamings.  The median results for all the satisfiable formulae of each  class are shown in Table I, with time values in the table being  the average CPU time of three identical runs. We can observe  that the number of generated clauses and the execution times  increase for the model construction run of TSPASS, which  is due to the transformation to single-eventuality problems  and, as a result, an increased number of step clauses. Such a  transformation is not performed if no model construction is  required. Additionally, one could observe that the time spent  in the transformation to DSCNF is negligible. The numbers  in brackets in the model construction time column indicate  the amount of time actually spent on model construction  w.r.t. the global execution time, and the numbers in brackets  in the model length column represent the length of the  periodic part. Finally, the median total number of constructed  time points during the model construction in TSPASS is  reproduced in the second last column, some of which are  discarded during the elimination of redundant cycles.  1  The class Cran  (n=5) contains 2400 formulae in total  of which 1217 formulae are satisfiable. On these satisfiable  formulae, the model construction of TSPASS could solve all  the problems, whereas the Ã¢Â€Â˜ModelÃ¢Â€Â™ function of the LWB did  not finish on 26 problems within the given time limit. The  2  (n=5) contains 1400 formulae in total of which  class Cran  955 are satisfiable. All the models constructed by TSPASS  and the LWB for this class were at most of length 2. No  timeouts were incurred either in the TSPASS or the LWB  1  (n=12), then, contains 4000 formulae in  run. The class Cran  total of which 2264 are satisfiable. The model construction  of TSPASS did not finish on 30 satisfiable formulae in this  class, whereas the Ã¢Â€Â˜ModelÃ¢Â€Â™ function of the LWB did not  terminate within the given time limit on 284 of the satisfiable  2  (n=12) contains 1900  formulae. Finally, the class Cran  formulae in total of which 1184 formulae are satisfiable.  Again, no timeouts were incurred in either the TSPASS or  LWB run, and all the models constructed by TSPASS and  the LWB for this class were at most of length 2  As one might expect, the Logics Workbench can maintain  2  2  its execution time advantage on Cran  (n = 5) and Cran  (n =  12). On the other hand, the model construction of TSPASS  1  1  (n = 12),  (n = 5) and Cran  proves quite successful on Cran  computing even a smaller median model length than the  LWB.  VIII. C ONCLUSION  We have presented a procedure for constructing models  for satisfiable PLTL formula. The procedure is based on  computing saturations under ordered fine-grained resolution  with selection while using the standard model construction  for propositional clauses to construct models for the different  time points. It is important to observe that the temporal  model construction procedure is not based on performing a  search with backtracking but the construction is guaranteed  to succeed once the appropriate symbol orderings have been  considered, and that it can always produce finite, ultimately  periodic models. We have proved the correctness of the  model construction algorithm, analysed some of its practical  aspects, and briefly introduced our implementation of the  algorithm.  It is easily possible to extend the model construction  method presented in this paper to CTL formulae, but an  extension to first-order temporal logic will require greater  efforts. In future work we intend to address the problem  of reducing the number of renamings necessary for the  transformation to single-eventuality problems and also try to  construct even shorter, ideally minimal, ultimately periodic  models for PLTL formulae.  R EFERENCES  [1] A. Pnueli, Ã¢Â€ÂœThe temporal logic of programs,Ã¢Â€Â in Proc.  FOCSÃ¢Â€Â™77. IEEE Computer Society, 1977, pp. 46Ã¢Â€Â“57.  [2] E. Clarke, O. Grumberg, and D. A. Peled, Model Checking.  MIT Press, 1999.  [3] M. Fisher, C. Dixon, and M. Peim, Ã¢Â€ÂœClausal temporal resolution,Ã¢Â€Â ACM Transactions on Computational Logic, vol. 2,  no. 1, pp. 12Ã¢Â€Â“56, 2001.  [4] M. Ludwig and U. Hustadt, Ã¢Â€ÂœImplementing a fair monodic  temporal logic prover,Ã¢Â€Â AI Communications, To appear.  [5] P. Wolper, Ã¢Â€ÂœTemporal logic can be more expressive,Ã¢Â€Â Information and Control, vol. 56, no. 1/2, pp. 72Ã¢Â€Â“99, 1983.  [6] S. Schwendimann, Ã¢Â€ÂœA new one-pass tableau calculus for  PLTL,Ã¢Â€Â in Proc. TABLEAUXÃ¢Â€Â™98, ser. LNCS, vol. 1397.  Springer, 1998, pp. 277Ã¢Â€Â“292.  [7] A. Heuerding, G. JaÄšÂˆger, S. Schwendimann, and S. Michael,  Ã¢Â€ÂœThe Logics Workbench LWB: A snapshot,Ã¢Â€Â Euromath Bulletin, vol. 2, no. 1, pp. 177Ã¢Â€Â“186, 1996.  [8] L. Bachmair and H. Ganzinger, Ã¢Â€ÂœResolution theorem proving,Ã¢Â€Â in Handbook of Automated Reasoning. Elsevier, 2001,  vol. 1, ch. 2, pp. 19Ã¢Â€Â“99.  [9] E. A. Emerson, Ã¢Â€ÂœTemporal and modal logic,Ã¢Â€Â in Handbook  of Theoretical Computer Science. Elsevier, 1990, pp. 995Ã¢Â€Â“  1072.  [10] A. Degtyarev, M. Fisher, and B. Konev, Ã¢Â€ÂœMonodic temporal resolution,Ã¢Â€Â ACM Transactions On Computational Logic,  vol. 7, no. 1, pp. 108Ã¢Â€Â“150, 2006.  [11] A. Degtyarev, M. Fisher, and B. Konev, Ã¢Â€ÂœA simplified clausal  resolution procedure for propositional linear-time temporal  logic,Ã¢Â€Â in Proc. TABLEAUXÃ¢Â€Â™2002, ser. LNCS, vol. 2381.  Springer, 2002, pp. 85Ã¢Â€Â“99.  [12] U. Hustadt, B. Konev, and R. A. Schmidt, Ã¢Â€ÂœDeciding monodic  fragments by temporal resolution,Ã¢Â€Â in Proc. CADE-20, ser.  LNAI, vol. 3632. Springer, 2005, pp. 204Ã¢Â€Â“218.  [13] N. Francez, Fairness.  New York, USA: Springer, 1986.  [14] M. Ludwig and U. Hustadt, Ã¢Â€ÂœResolution-based model construction for PLTL (Extended Version),Ã¢Â€Â Dep. of Comp. Sci.,  Univ. of Liverpool, Tech. Rep. ULCS-09-008, 2009.  [15] A. P. Sistla and E. M. Clarke, Ã¢Â€ÂœThe complexity of propositional linear temporal logics,Ã¢Â€Â J. ACM, vol. 32, no. 3, pp.  733Ã¢Â€Â“749, 1985.  [16] U. Hustadt and R. A. Schmidt, Ã¢Â€ÂœScientific benchmarking with  temporal logic decision procedures,Ã¢Â€Â in Proc. KRÃ¢Â€Â™02. Morgan  Kaufmann, 2002, pp. 533Ã¢Â€Â“546. 