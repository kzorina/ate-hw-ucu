Logical Methods in Computer Science  Vol. 7 (2:12) 2011, pp. 1â21  www.lmcs-online.org  Submitted  Published  Jan. 14, 2010  Nov. 16, 2011  MODEL CHECKING CTL IS ALMOST ALWAYS INHERENTLY  SEQUENTIAL â  OLAF BEYERSDORFF a , ARNE MEIER b , MARTIN MUNDHENK c , THOMAS SCHNEIDER d ,  MICHAEL THOMAS e , AND HERIBERT VOLLMER f  a,b,e,f  Theoretical Computer Science, Leibniz University of Hannover, Germany  e-mail address: {beyersdorff, meier, thomas, vollmer}@thi.uni-hannover.de  c  Computer Science, University of Jena, Germany  e-mail address: martin.mundhenk@uni-jena.de  d  Computer Science, Saarland University, Germany  e-mail address: schneider@ps.uni-saarland.de  Revision Note. This is a revised and corrected version of the article originally published  on May 17, 2011.  Abstract. The model checking problem for CTL is known to be P-complete (Clarke,  Emerson, and Sistla (1986), see Schnoebelen (2002)). We consider fragments of CTL  obtained by restricting the use of temporal modalities or the use of negationsârestrictions  already studied for LTL by Sistla and Clarke (1985) and Markey (2004). For all these  fragments, except for the trivial case without any temporal operator, we systematically  prove model checking to be either inherently sequential (P-complete) or very efficiently  parallelizable (LOGCFL-complete). For most fragments, however, model checking for  CTL is already P-complete. Hence our results indicate that, in cases where the combined  complexity is of relevance, approaching CTL model checking by parallelism cannot be  expected to result in any significant speedup.  We also completely determine the complexity of the model checking problem for all  fragments of the extensions ECTL, CTL+ , and ECTL+ .  1998 ACM Subject Classification: D.2.4, F.3.1, I.2.2, I.2.4.  Key words and phrases: Model checking, temporal logic, complexity.  â  A preliminary version of this paper appeared in the proceedings of the conference TIMEâ09 [BMM+ 09].  Supported in part by grants DFG VO 630/6-1, VO 630/6-2, DAAD-ARC D/08/08881, and BC-ARC  1323.  l  LOGICAL METHODS  IN COMPUTER SCIENCE  c  DOI:10.2168/LMCS-7 (2:12) 2011  CC  O. Beyersdorff, A. Meier, M. Mundhenk, T. Schneider, M. Thomas, and H. Vollmer  Creative Commons  2  O. BEYERSDORFF, A. MEIER, M. MUNDHENK, T. SCHNEIDER, M. THOMAS, AND H. VOLLMER  1. Introduction  Temporal logic was introduced by Pnueli [Pnu77] as a formalism to specify and verify properties of concurrent programs. Computation Tree Logic (CTL), the logic of branching time,  goes back to Emerson and Clarke [EC82] and contains temporal operators for expressing  that an event occurs at some time in the future (F), always in the future (G), in the next  point of time (X), always in the future until another event holds (U), or as long as it is not  released by the occurrence of another event (R), as well as path quantifiers (E, A) for speaking about computation paths. The full language obtained by these operators and quantifiers  is called CTLâ [EH86]. In CTL, the interaction between the temporal operators and path  quantifiers is restricted. The temporal operators in CTL are obtained by path quantifiers  followed directly by any temporal operator, e.g., AF and AU are CTL-operators. Because  they start with the universal path quantifier, they are called universal CTL-operators. Accordingly, EX and EG are examples for existential CTL-operators.  Since properties are largely verified automatically, the computational complexity of  reasoning tasks is of great interest. Model checking (MC)âthe problem of verifying whether  a given formula holds in a state of a given modelâis one of the most important reasoning  tasks [Sch03]. It is intractable for CTLâ (PSPACE-complete [EL87, Sch03]), but tractable  for CTL (complete for polynomial time [CES86, Sch03]).  Although model checking for CTL is tractable, its P-hardness means that it is presumably not efficiently parallelizable. We therefore search for fragments of CTL with a model  checking problem of lower complexity. We will consider all subsets of CTL-operators, and  examine the complexity of the model checking problems for all resulting fragments of CTL.  Further, we consider three additional restrictions affecting the use of negation and study  the extensions ECTL, CTL+ , and their combination ECTL+ .  The complexity of model checking for fragments of temporal logics has been examined  in the literature: Markey [Mar04] considered satisfiability and model checking for fragments  of Linear Temporal Logic (LTL). Under systematic restrictions to the temporal operators,  the use of negation, and the interaction of future and past operators, Markey classified the  two decision problems into NP-complete, coNP-complete, and PSPACE-complete. Further,  [BMS+ 09] examined model checking for all fragments of LTL obtained by restricting the set  of temporal operators and propositional connectives. The resulting classification separated  cases where model checking is tractable from those where it is intractable. For model  checking paths in LTL an AC1 (LOGDCFL) algorithm is presented in [KF09].  Concerning CTL and its extension ECTL, our results in this paper show that most  restricted versions of the model checking problem exhibit the same hardness as the general  problem. More precisely, we show that apart from the trivial case where CTL-operators are  completely absent, the complexity of CTL model checking is a dichotomy: it is either Pcomplete or LOGCFL-complete. Unfortunately, the latter case only occurs for a few rather  weak fragments and hence there is not much hope that in practice, model checking can be  sped up by using parallelismâit is inherently sequential.  Put as a simple rule, model checking for CTL is P-complete for every fragment that  allows to express a universal and an existential CTL-operator. Only for fragments involving  the operators EX and EF (or alternatively AX and AG) model checking is LOGCFL-complete.  This is visualized in Figure 4 in Section 5. Recall that LOGCFL is defined as the class of  problems logspace-reducible to context-free languages, and NL â LOGCFL â NC2 â P.  MODEL CHECKING CTL IS ALMOST ALWAYS INHERENTLY SEQUENTIAL â  3  Hence, in contrast to inherently sequential P-hard tasks, problems in LOGCFL have very  efficient parallel algorithms.  For the extensions CTL+ and ECTL+ , the situation is more complex. In general, model  checking CTL+ and ECTL+ is âp2 -complete [LMS01]. We show that for T â {A, E, X},  both model checking problems restricted to operators from T remain tractable, while for  T * {A, E, X}, they become âp2 -complete. Yet, for negation restricted fragments with only  existential or only universal path quantifiers, we observe a complexity decrease to NP- resp.  coNP-completeness.  This paper is organized as follows: Section 2 introduces CTL, its model checking problems, and the non-basics of complexity theory we use. Section 3 contains our main results,  separated into upper and lower bounds. We also provide a refined analysis of the reductions  between different model checking problems with restricted use of negation. The results are  then generalized to extensions of CTL in Section 4. Finally, Section 5 concludes with a  graphical overview of the results.  2. Preliminaries  2.1. Temporal Logic. We inductively define CTLâ -formulae as follows. Let ÎŚ be a finite  set of atomic propositions. The symbols used are the atomic propositions in ÎŚ, the constant  symbols â¤, âĽ, the Boolean connectives ÂŹ, â§, and â¨, and the temporal operator symbols A,  E, X, F, G, U, and R.  A and E are called a path quantifiers, temporal operators aside from A and E are pure  temporal operators. The atomic propositions and the constants â¤ and âĽ are atomic formulae.  There are two kinds of formulae, state formulae and path formulae. Each atomic formula  is a state formula, and each state formula is a path formula. If Ď, Ď are state formulae  and Ď, Ď are path formulae, then ÂŹĎ, (Ď â§ Ď), (Ď â¨ Ď), AĎ, EĎ are state formulae, and ÂŹĎ,  (Ď â§ Ď), (Ď â¨ Ď), XĎ, FĎ, GĎ, [ĎUĎ], and [ĎRĎ] are path formulae. The set of CTLâ -formulae  (or formulae) consists of all state formulae.  A Kripke structure is a triple K = (W, R, Îˇ), where W is a finite set of states, R â  W Ă W a total relation (i.e., for each w â W , there exists a wâ˛ such that (w, wâ˛ ) â R), and  Îˇ : W â P(ÎŚ) is a labelling function. A path x is an infinite sequence x = (x1 , x2 , . . .) â W Ď  such that (xi , xi+1 ) â R, for all i âĽ 1. For a path x = (x1 , x2 , . . .) we denote by xi the path  (xi , xi+1 , . . . ).  Let K = (W, R, Îˇ) be a Kripke structure, w â W be a state, and x = (x1 , x2 , . . . ) â W Ď  be a path. Further, let Ď, Ď be state formulae and Ď, Ď be path formulae. The truth of a  CTLâ -formula w.r.t. K is inductively defined as follows:  K, w |= â¤  always,  K, w |= âĽ  never,  K, w |= p  iff p â ÎŚ and p â Îˇ(w),  K, w |= ÂŹĎ  iff K, w 6|= Ď,  K, w |= (Ď â§ Ď) iff K, w |= Ď and K, w |= Ď,  K, w |= (Ď â¨ Ď) iff K, w |= Ď or K, w |= Ď,  K, w |= AĎ  iff K, x |= Ď for all paths x = (x1 , x2 , . . .) with x1 = w,  K, x |= Ď  iff K, x1 |= Ď,  K, x |= ÂŹĎ  iff K, x 6|= Ď,  K, x |= (Ď â§ Ď) iff K, x |= Ď and K, x |= Ď,  4  O. BEYERSDORFF, A. MEIER, M. MUNDHENK, T. SCHNEIDER, M. THOMAS, AND H. VOLLMER  AX, AF, AR  AX, AG, AU  AF, AR  AX, AU  AG, AU  AX, AF, AG  AU  AX, AF  AF, AG  AX, AG  AF  AX  AG  AX, AR  AR  â  Figure 1: The expressive power of CTL(T ).  K, x |= (Ď â¨ Ď) iff K, x |= Ď or K, x |= Ď,  K, x |= XĎ  iff K, x2 |= Ď  K, x |= [ĎUĎ] iff there is a k â N such that K, xk |= Ď and K, xi |= Ď for 1 â¤ i < k.  The semantics of the remaining temporal operators is defined via the equivalences: EĎ âĄ  ÂŹAÂŹĎ, FĎ âĄ [â¤UĎ], GĎ âĄ ÂŹFÂŹĎ, and [ĎRĎ] âĄ ÂŹ[ÂŹĎUÂŹĎ]. A state formula Ď is satisfied by  a Kripke structure K if there exists w â W such that K, w |= Ď. We will also denoted this  by K |= Ď.  We use CTLâ (T ) to denote the set of CTLâ -formulae using the Boolean connectives  {â§, â¨, ÂŹ}, and the temporal operators in T only. If T does not contain any quantifiers, then  including any pure temporal operators in T is meaningless.  A CTL-formula is a CTLâ -formula in which each path quantifier is followed by exactly  one pure temporal operator and each pure temporal operator is preceded by exactly one path  quantifier. The set of CTL-formulae forms a strict subset of the set of all CTLâ -formulae.  For example, AGEFp is a CTL-formula, but A(GFp â§ Fq) is not. CTL is less expressive than  CTLâ [EH85, EH86].  Pairs of path quantifiers and pure temporal operators are called CTL-operators. The  operators AX, AF, AG, AU, and AR are universal CTL-operators, and EX, EF, EG, EU, and  ER are existential CTL-operators. Let ALL denote the set of all universal and existential  CTL-operators. Note that A[ĎUĎ] âĄ AFĎ â§ ÂŹE[ÂŹĎU(ÂŹĎ â§ ÂŹĎ)], and thus E[ĎRĎ] âĄ EGĎ â¨  E[ĎU(Ď â§ Ď)]. Hence {AX, AF, AR} is a minimal set of operators for CTL (in presence of all  Boolean connectives), whereas {AX, AG, AU} is not [Lar95].  By CTL(T ) we denote the set of CTL-formulae using the connectives {â§, â¨, ÂŹ} and  the CTL-operators in T only. Figure 1 shows the structure of sets of CTL-operators with  respect to their expressive power.  MODEL CHECKING CTL IS ALMOST ALWAYS INHERENTLY SEQUENTIAL â  5  Moreover, we define the following fragments of CTL(T ).  â CTLpos (T ) (positive)  CTL-operators may not occur in the scope of a negation.  â CTLa.n. (T ) (atomic negation)  Negation signs appear only directly in front of atomic propositions.  â CTLmon (T ) (monotone)  No negation signs allowed.  This restricted use of negation was introduced and studied in the context of linear temporal  logic, LTL, by Sistla and Clarke [SC85] and Markey [Mar04]. Their original notation was  e ) for CTLa.n. (T ) and L+ (T ) for CTLpos (T ).  L(T  2.2. Model Checking. Now we define the model checking problems for the above mentioned fragments of CTL. Let L be CTL, CTLmon , CTLa.n. , or CTLpos .  Problem: L-MC(T )  Input: A Kripke structure K = (W, R, Îˇ), a state w â W , and an L(T )-formula Ď.  Question: Does K, w |= Ď hold?  2.3. Complexity Theory. We assume familiarity with standard notions of complexity  theory as introduced in, e.g., [Pap94]. Next we will introduce the notions from circuit  complexity that we use for our results. All reductions in this paper are â¤cd -reductions  defined as follows: A language A is constant-depth reducible to B, A â¤cd B, if there is a  logtime-uniform AC0 -circuit family with oracle gates for B that decides membership in A.  That is, there is a circuit family C = (C1 , C2 , C3 , . . . ) such that  â for every n, Cn computes the characteristic function of A for inputs of length n,  â there is a polynomial p and a constant d such that for all input lengths n, the size of Cn  is bounded by p(n) and the depth of Cn is bounded by d,  â each circuit Cn consists of unbounded fan-in AND and OR gates, negation gates, and  gates that compute the characteristic function of B (the oracle gates),  â there is a linear-time Turing machine M that can check the structure of the circuit family,  i.e., given a tuple hn, g, t, hi where n, g, h are binary numbers and t â {AND, OR, NOT, ORACLE},  M accepts if Cn contains a gate g of type t with predecessor h.  Circuit families C with this last property are called logtime-uniform (the name stems from  the fact that the time needed by M is linear in the length of its input tuple, hence logarithmic  in n). For background information we refer to [RV97, Vol99].  We easily obtain the following relations between model checking for fragments of CTL  with restricted negation:  Lemma 2.1. For every set T of CTL-operators, we have  CTLmon -MC(T ) â¤cd CTLa.n. -MC(T ) â¤cd CTLpos -MC(T ).  Further, for model checking, atomic negation can be eluded, that is, CTLa.n. -MC(T ) â¤cd  CTLmon -MC(T ).  6  O. BEYERSDORFF, A. MEIER, M. MUNDHENK, T. SCHNEIDER, M. THOMAS, AND H. VOLLMER  Proof. The first part is straightforward, using the identity function as reduction function.  For the second part, let K = (W, R, Îˇ) be a Kripke structure and let Ď be a CTLa.n. (T )formula over the propositions ÎŚ = {p1 , . . . , pn }. Every negation in Ď appears inside a  negative literal. We obtain Ďâ˛ by replacing every negative literal ÂŹpi with a fresh atomic  proposition qi . Further define K â˛ = (W, R, Îˇ â˛ ), where Îˇ â˛ (w) = Îˇ(w) âŞ {qi | pi â  / Îˇ(w)}.  Obviously, K, w |= Ď iff K â˛ , w |= Ďâ˛ for all w â W . The mapping (K, w, Ď) 7â (K â˛ , w, Ďâ˛ )  can be performed by an AC0 -circuit.  In Section 3.3, we complete the picture by proving CTLpos -MC(T ) â¤cd CTLmon -MC(T ).  The class P consists of all languages that have a polynomial-time decision algorithm. A  problem is P-complete if it is in P and every other problem in P reduces to it. P-complete  problems are sometimes referred to as inherently sequential, because P-complete problems  most likely (formally: if P 6= NC) do not possess NC-algorithms, that is, algorithms running in polylogarithmic time on a parallel computer with a polynomial number of processors. Formally, NC contains all problems solvable by polynomial-size polylogarithmic-depth  logtime-uniform families of circuits with bounded fan-in AND, OR, NOT gates.  There is an NC-algorithm for parsing context-free languages, that is, CFL â NC. Therefore, complexity theorists have studied the class LOGCFL of all problems reducible to  context-free languages (the name âLOGCFLâ refers to the original definition of the class in  terms of logspace-reductions, however it is known that the class does not change if instead,  as everywhere else in this paper, â¤cd -reductions are used). Hence, LOGCFL â NC (even  LOGCFL â NC2 , the second level of the NC-hierarchy, where the depth of the occurring  circuits is restricted to O(log2 n)). The class LOGCFL has a number of different maybe  even somewhat surprising characterizations, e.g., languages in LOGCFL are those that can  be decided by nondeterministic Turing machines operating in polynomial time that have a  worktape of logarithmic size and additionally a stack whose size is not bounded.  More important for this paper is the characterization of LOGCFL as those problems  computable by SAC1 circuit families, that is, families of circuits that  â have polynomial size and logarithmic depth,  â consist of unbounded fan-in OR gates and bounded fan-in AND gates and negation gates,  but the latter are only allowed at the input-level,  â are logtime-uniform (as defined above).  Since the class LOGCFL is known to be closed under complementation, the second  condition can equivalently be replaced to allow unbounded fan-in AND gates and restrict  the fan-in of OR gates to be bounded.  To summarize:  NC1 â L â NL â LOGCFL = SAC1 â NC2 ;  and problems in these classes possess very efficient parallel algorithms: they can be solved  in time O(log2 n) on a parallel machine with a tractable number of processors. For more  background on these and related complexity classes, we refer the reader to [Vol99].  3. Model Checking CTL and CTLpos  This section contains our main results on the complexity of model checking for CTL and  CTLpos . We defer the analysis of the fragments CTLa.n. and CTLmon to Section 3.3, where  MODEL CHECKING CTL IS ALMOST ALWAYS INHERENTLY SEQUENTIAL â  7  we will see that their model-checking problems are computationally equivalent to model  checking for CTLpos .  While model checking for CTL in general is known to be polynomial time solvable and  in fact P-complete [CES86, Sch03], we improve the lower bound by showing that only one  temporal operator is sufficient to obtain hardness for P.  Theorem 3.1. For each nonempty set T of CTL-operators, CTL-MC(T ) is P-complete. If  T = â, then CTL-MC(T ) is NC1 -complete.  If we consider only formulae from CTLpos , where no CTL-operators are allowed inside  the scope of a negation, the situation changes and the complexity of model checking exhibits  a dichotomous behavior. As long as EG or AF are expressible the model checking problem  remains P-complete. Otherwise, its complexity drops to LOGCFL.  Theorem 3.2. Let T be any set of CTL-operators. Then CTLpos -MC(T ) is  â NC1 -complete if T = â,  â LOGCFL-complete if â ( T â {EX, EF} or â ( T â {AX, AG}, and  â P-complete otherwise.  We split the proofs of Theorems 3.1 and 3.2 into the upper and lower bounds in the  following two subsections.  3.1. Upper Bounds. In general, model checking for CTL is known to be solvable in P  [CES86]. While this upper bound also applies to CTLpos -MC(T ) (for every T ), we improve  it for positive CTL-formulae using only EX and EF, or only AX and AG.  Proposition 3.3. Let T be a set of CTL-operators such that T â {EX, EF} or T â  {AX, AG}. Then CTLpos -MC(T ) is in LOGCFL.  Proof. First consider the case T â {EX, EF}. We claim that Algorithm 1 recursively decides  whether the Kripke structure K = (W, R, Îˇ) satisfies the CTLpos (T )-formula Ď in state  w0 â W . There, S is a stack that stores pairs (Ď, w) â CTLpos (T ) Ă W and Râ denotes the  transitive closure of R.  Algorithm 1 always terminates because each subformula of Ď is pushed to the stack  S at most once. For correctness, an induction on the structure of formulae shows that  Algorithm 1 returns false if and only if for the most recently popped pair (Ď, w) from S,  we have K, w 6|= Ď. Thence, in particular, Algorithm 1 returns true iff K, w |= Ď.  Algorithm 1 can be implemented on a nondeterministic polynomial-time Turing machine  that besides its (unbounded) stack uses only logarithmic memory for the local variables.  Thus CTLpos -MC(T ) is in LOGCFL.  The case T â {AX, AG} is analogous and follows from closure of LOGCFL under complementation.  Finally, for the trivial case where no CTL-operators are present, model checking CTL(â)formulae is equivalent to the problem of evaluating a propositional formula. This problem  is known to be solvable in NC1 [Bus87].  8  O. BEYERSDORFF, A. MEIER, M. MUNDHENK, T. SCHNEIDER, M. THOMAS, AND H. VOLLMER  Algorithm 1 Determine whether K, w0 |= Ď.  Require: a Kripke structure K = (W, R, Îˇ), w0 â W , Ď â CTLpos (T )  1: push(S, (Ď, w0 ))  2: while S is not empty do  3:  (Ď, w) â pop(S)  4:  if Ď is a propositional formula then  5:  if Ď evaluates to false in w under Îˇ then  6:  return false  7:  end if  8:  else if Ď = Îą â§ Î˛ then  9:  push(S, (Î˛, w))  10:  push(S, (Îą, w))  11:  else if Ď = Îą â¨ Î˛ then  12:  nondet. push(S, (Îą, w)) or push(S, (Î˛, w))  13:  else if Ď = EXÎą then  14:  nondet. choose wâ˛ â {wâ˛ | (w, wâ˛ ) â R}  15:  push(S, (Îą, wâ˛ ))  16:  else if Ď = EFÎą then  17:  nondet. choose wâ˛ â {wâ˛ | (w, wâ˛ ) â Râ }  18:  push(S, (Îą, wâ˛ ))  19:  end if  20: end while  21: return true  3.2. Lower Bounds. The P-hardness of model checking for CTL was first stated in [Sch03].  We improve this lower bound and concentrate on the smallest fragments of monotone CTLâ  w.r.t. CTL-operatorsâwith P-hard model checking.  Proposition 3.4. Let T denote a set of CTL-operators. Then CTLmon -MC(T ) is P-hard  if T contains an existential and a universal CTL-operator.  Proof. First, assume that T = {AX, EX}. We give a generic reduction from the word problem  for alternating Turing machines working in logarithmic space, which follows the same line  as the classical proof idea (see [Sch03, Theorem 3.8]), and which we will modify in order  to be useful for other combinations of CTL-operators. Let M be an alternating logspace  Turing machine, and let x be an input to M . We may assume w.l.o.g. that each transition  of M leads from an existential to a universal configuration and vice versa. Further we may  assume that each computation of M ends after the same number p(n) of steps, where p is a  polynomial and n is the length of M âs input. Furthermore we may assume that there exists  a polynomial q such that q(n) is the number of configurations of M on any input of length  n.  Let c1 , . . . , cq(n) be an enumeration of all possible configurations of M on input x,  starting with the initial configuration c1 . We construct a Kripke structure K := (W, R, Îˇ)  MODEL CHECKING CTL IS ALMOST ALWAYS INHERENTLY SEQUENTIAL â  9  by defining the set W := {cji | 1 â¤ i â¤ q(n), 0 â¤ j â¤ p(n)} and the relation R â W Ă W as    R := (cji , cj+1  k ) M reaches configuration ck from ci in one step, 0 â¤ j < p(n)   j j  âŞ (ci , ci ) cji has no successor, 1 â¤ i â¤ q(n), 0 â¤ j < p(n)   p(n) p(n)  âŞ (ci , ci ) 1 â¤ i â¤ q(n) .  The labelling function Îˇ is defined for all cji â W as    {t}, if ci is an accepting configuration and j = p(n)  j  Îˇ(ci ) :=  â, otherwise  where t is the only atom used by this labelling. It then holds that       M accepts x ââ K, c01 |= Ď1 Ď2 Âˇ Âˇ Âˇ Ďp(n) (t) Âˇ Âˇ Âˇ ,  where Ďi (x) := AX(x) if M âs configurations before the ith step are universal, and Ďi (x) :=  EX(x) otherwise. Notice that the constructed CTL-formula does not contain any Boolean  connective. Since p(n) and q(n) are polynomials, the size of K and Ď is polynomial in the  size of (M, x). Moreover, K and Ď can be constructed from M and x using AC0 -circuits.  Thus, A â¤cd CTLmon -MC({AX, EX}) for all A â ALOGSPACE = P.  For T = {AF, EG} we modify the above reduction by defining the labelling function Îˇ  and the formula Ďi as follows:    {dj , t}, if ci is an accepting configuration and j = p(n)  Îˇ(cji ) :=  {dj }, otherwise    (3.1)  AF(di â§ x), if M âs configurations before step i are universal,  Ďi (x) :=  EG(Di â¨ x), otherwise,  where dj are  W atomic propositions encoding the âtime stampsâ of the respective configurations  and Di = i6=jâ{0,...,p(n)} dj .  For the combinations of T being one of {AF, EF}, {AF, EX}, {AG, EG}, {AG, EX},  {AX, EF}, and {AX, EG}, the P-hardness of CTLmon -MC(T ) is obtained using analogous  modifications to Îˇ and the Ďi âs.  For the remaining combinations involving the until or the release operator, observe that  w.r.t. the Kripke structure K as defined in (3.1), AF(di â§ x) and EG(Di â¨ x) are equivalent  to A[diâ1 Ux] and E[diâ1 Ux], and that R and U are duals.  In the presence of arbitrary negation, universal operators are definable by existential  operators and vice versa. Hence, from Proposition 3.4 we obtain the following corollary.  Corollary 3.5. The model checking problem CTL-MC(T ) is P-hard for each nonempty set  T of CTL-operators.  Returning to monotone CTL, in most cases even one operator suffices to make model  checking P-hard:  Proposition 3.6. Let T denote a set of CTL-operators. Then CTLmon -MC(T ) is P-hard  if T contains at least one of the operators EG, EU, ER, AF, AU, or AR.  Proof. We modify the proof of Proposition 3.4 to work with EG only. The remaining fragments follow from the closure of P under complementation and FĎ âĄ ÂŹGÂŹĎ âĄ [â¤UĎ],  [ĎUĎ] âĄ ÂŹ[ÂŹĎRÂŹĎ].  10  O. BEYERSDORFF, A. MEIER, M. MUNDHENK, T. SCHNEIDER, M. THOMAS, AND H. VOLLMER  0  d 0 c1  0  d 0 c2  0  d 0 c1  ÂˇÂˇÂˇ  1  d 1 c1  d1  c12  1  d 1 c1  d0  d1  ÂˇÂˇÂˇ  c21  d2  2  d 2 c2  c21  d2  d1  ..  .  p(n)  dp(n c1  )  p(n  t,d c2 )  p(n)  c0  ÂˇÂˇÂˇ  d0  q(n)  d2  ..  .  d1  c2  p(n)  dp(n c1  )  ÂˇÂˇÂˇ  d2  ..  .  ..  .  ÂˇÂˇÂˇ  t,d  cp(n)  q  p(n) (n)  layer  1  d2  ..  .  q  p(n) (n)  layer  2  c2  d2  ..  .  ..  .  ..  .  q(n)  ..  .  p(n  t,d c2 )  p(n)  t,d  z  ÂˇÂˇÂˇ  p(n)  dp(n c1  cp(n)  q(n)  2  d 2 c2  )  ÂˇÂˇÂˇ  c1  d1  c21  c2  p(n  t,d c2 )  p(n)  ÂˇÂˇÂˇ  q(n)  q(n)  q(n)  c12  c1  ÂˇÂˇÂˇ  q(n)  c0  d0  1  d 1 c1  d1  ÂˇÂˇÂˇ  q(n)  ..  .  ..  .  ÂˇÂˇÂˇ  q(n)  c12  c1  0  d 0 c2  c0  2  d 2 c2  ÂˇÂˇÂˇ  ..  .  0  d 0 c1  0  d 0 c2  ÂˇÂˇÂˇ  p(n)  t,d cq(n)  p(n)  layer  q(  n) +  1  Figure 2: The Kripke structure K â˛ ; dashed (resp. solid) arrows correspond to transitions  leaving existential (resp. universal) configurations.  Let the machine M , the word x, the polynomials p, q, and K be as above. Further  assume w.l.o.g. that M branches only binary in each step. Denote by Wâ (resp. Wâ ) the  set of states corresponding to existential (resp. universal) configurations. The purpose  of the introduced layers below is to ensure the uniqueness of the successors of universal  configurations which is essential in the construction of Ďi later. We construct a Kripke  structure K â˛ := (W â˛ , R, Îˇ) consisting of q(n) + 1 layers and a âtrapâ as follows: let W â˛ :=  W Ă {1, . . . , q(n) + 1} âŞ {z}. The transition relation R â W â˛ Ă W â˛ is defined as       cj â Wâ , M reaches ck from ci in one step,  j  j+1  i  R := (ci , â), (ck , â)  1 â¤ â â¤ q(n) + 1, 0 â¤ j < p(n)    ďŁą j  ďŁź  j+1  (c  ,  â),  (c  ,  i)  ,  ďŁ˛ i  j  k   c â Wâ , M reaches ck and ckâ˛ from ci inďŁ˝  j+1  âŞ  (cj+1  ,  i),  (c  ,  q(n)  +  1)  , i  â˛  k    one step, ck â¤ ckâ˛ , 0 â¤ j < p(n)  ďŁł kj+1  ďŁž  (ckâ˛ , q(n) + 1), z   p(n)    p(n)  âŞ  (ci , â), (ci , â) | 1 â¤ i â¤ q(n), 1 â¤ â â¤ q(n) + 1  âŞ (z, z) .  That is, the arcs leaving an existential configurations ci lead to the successor configurations  of ci inside each layer; while any universal configuration ci has exactly one outgoing arc  pointing to its (lexicographically) first successor configuration in the layer i, from where  another arc leads to the second successor of ci in layer q(n) + 1, which in turn has an  outgoing arc to the state z (see Figure 2). The labelling function Îˇ is defined as Îˇ(z) := {z},  Îˇ((cji , â)) := {â, dj , t} if ci is an accepting configuration, and otherwise Îˇ((cji , â)) := {â, dj }  for (1 â¤ â â¤ q(n) + 1). Define  (  EG(diâ1 â¨ (di â§ x) â¨ z), if M âs configurations before step i are universal,  Ďi (x) :=  EG(Di â¨ x), if M âs configurations before step i are existential,  MODEL CHECKING CTL IS ALMOST ALWAYS INHERENTLY SEQUENTIAL â  11  W  and Di = i6=jâ{0,...,p(n)} dj . The correctness of the equivalence K, w |= AF(di â§ x) iff    K â˛ , (w, â) |= EG diâ1 â¨ (di â§ x) â¨ z) , for all w â Wâ , 1 â¤ â â¤ q(n) + 1 and 1 â¤ i â¤ p(n)  can be verified through the following observations. â: if di and x hold in all successors  of w in K, then there exists a path from (w, â) to both of the series-connected successors  reaching the trap and looping there. This is the only possibility for the path as neither diâ1  nor di hold below that level. As in each successor configuration the subformula di â§ x must  be satisfied the composition of the Ďi s ensures that in each such state there must start an  EG-path for each universal successor. â: the only path which satisfies at least one of the  three disjuncts ranges through both series-connected successor configurations and ends in  the trap. For each of the two successor states di and x hold. Thus AF(di â§ x) is true in the  state w in the structure K.  From this, it easily follows that for        M accepts x ââ K â˛ , (c01 , 1) |= Ď1 Ď2 Âˇ Âˇ Âˇ Ďp(n) (t) Âˇ Âˇ Âˇ .  As we essentially only duplicated the set of states in K and R can be constructed from all  triples of states in W â˛ , K â˛ remains AC0 constructible. Concluding A â¤cd CTLmon -MC({EG})  for all A â P.  By Lemma 2.1, CTLmon -MC(T ) â¤cd CTLpos -MC(T ) and hence the above results  directly translate to model checking for CTLpos : for any set T of temporal operators,  CTLpos -MC(T ) is P-hard if T * {EX, EF} or if T * {AX, AG}. These results cannot  be improved w.r.t. T , as for T â {EX, EF} and T â {AX, AG} we obtain a LOGCFL upper  bound for model checking from Proposition 3.3. In the following proposition we prove the  matching LOGCFL lower bound.  Proposition 3.7. For every nonempty set T of CTL-operators, the model checking problem  CTLmon -MC(T ) is LOGCFL-hard.  Proof. As explained in Section 2.3, LOGCFL can be characterized as the set of languages  recognizable by logtime-uniform SAC1 circuits, i.e., circuits of logarithmic depth and polynomial size consisting of â¨-gates with unbounded fan-in and â§-gates with fan-in 2. For  every single CTL-operator O, we will show that CTLmon -MC(T ) is LOGCFL-hard for all  T â {O} by giving a generic â¤cd -reduction f from the word problem for SAC1 circuits to  CTLmon -MC(T ).  First, consider EX â T . Let C be a logtime-uniform SAC1 circuit of depth â with  n inputs and let x = x1 . . . xn â {0, 1}n . Assume w.l.o.g. that C is connected, layered  into alternating layers of â§-gates and â¨-gates, and that the output gate of C is an â¨gate. We number the layers bottom-up, that is, the layer containing (only) the output gate  has level 0, whereas the input-gates and negations of the input-gates are situated in layer  â. Denote the graph of C by G = (V, E), where V := Vin â Vâ§ â Vâ¨ is partitioned into  the sets corresponding to the (possibly negated) input-gates, the â§-gates, and the â¨-gates,  respectively. G is acyclic and directed with paths leading from the input to the output  gates. From (V, E) we construct a Kripke structure that allows to distinguish the two  predecessors of an â§-gate from each other. This will be required to model proof trees using  CTLmon ({EX})-formulae.  12  O. BEYERSDORFF, A. MEIER, M. MUNDHENK, T. SCHNEIDER, M. THOMAS, AND H. VOLLMER  i  For i â {1, 2}, let Vini := {v i | v â Vin }, Vâ¨i := {v i | v â Vâ¨ } and define Vin,â¨  := Vini âŞ Vâ¨i .  Further define    i  E â˛ := (v, ui ) â Vâ§ Ă Vin,â¨  | (u, v) â E and u is the ith predecessor of v  [     i  1  2  (v i , u) â Vin,â¨  Ă Vâ§ | (u, v) â E ,  âŞ (v, v) | v â Vin âŞ Vin âŞ  iâ{1,2}  where the ordering of the predecessors is implicitly given in the encoding of C. We now  1 âŞ V 2 âŞ V , transition  define a Kripke structure K := (V â˛ , E â˛ , Îˇ) with states V â˛ := Vin,â¨  â§  in,â¨  relation E â˛ , and labelling function Îˇ : V â˛ â P({1, 2, t}),  ďŁą  i  i  ďŁ´  ďŁ˛{i, t}, if (v = vinj â Vin and xj = 1) or (v = v inj â Vin and xj = 0),  Îˇ(v) := {i},  if (v = vinj â Vini and xj = 0) or (v = v inj â Vini and xj = 1) or v â Vâ¨i ,  ďŁ´  ďŁł  â,  otherwise,  where i = 1, 2, j = 1, . . . , n and vin1 , . . . , vinn , v in1 , . . . , v inn enumerate the input gates  and their negations. The formula Ď that is to be evaluated on K will consist of atomic  propositions 1, 2 and t, Boolean connectives â§ and â¨, and the CTL-operator EX. To  construct Ď we recursively define formulae (Ďi )0â¤iâ¤â by  ďŁą  ďŁ´  if i = â,  ďŁ˛t,  Ďi := EXĎi+1 ,  if i is even (â¨-layers),  ďŁ´  ďŁłV  i=1,2 EX(i â§ Ďi+1 ), if i is odd (â§-layers).  We define the reduction function f as the mapping (C, x) 7â (K, v0 , Ď), where v0 is the  node corresponding to the output gate of C and Ď := Ď0 . We stress that the size of Ď is  polynomial, for the depth of C is logarithmic only. Clearly, each minimal accepting subtree  (cf. [Ruz80] or [Vol99, Definition 4.15]) of C on input x translates into a sub-structure K â˛  of K such that K â˛ , v0 |= Ď, where  (1) K â˛ includes v0 ,  (2) K â˛ includes one successor for every node corresponding to an â¨-gate, and  (3) K â˛ includes the two successors of every node corresponding to an â§-gate.  As C(x) = 1 iff there exists a minimal accepting subtree of C on x, the LOGCFL-hardness  of CTLmon -MC(T ) for EX â T follows.  Second, consider EF â T . We have to extend our Kripke structure to contain information about the depth of the corresponding gate. We may assume w.l.o.g. that C is encoded  such that each gate contains an additional counter holding the distance to the output gate  (which is equal to the number of the layer it is contained in, cf. [Vol99]). We extend Îˇ  to encode this distance i, 1 â¤ i â¤ â, into the âdepth-propositionsâ di as in the proof of  Proposition 3.4. Denote this modified Kripke structure by K â˛ . Further, we define (Ďâ˛i )0â¤iâ¤â  as  ďŁą  ďŁ´  if i = â,  ďŁ˛t,  â˛  â˛  Ďi := EF(di+1 â§ Ďi+1 ),  if i is even,  ďŁ´  ďŁłV  â˛  i=1,2 EF(di+1 â§ i â§ Ďi+1 ), if i is odd.  Redefining the reduction f as (C, x) 7â (K â˛ , v0 , Ďâ˛0 ) hence yields the LOGCFL-hardness of  CTLmon -MC(T ) for EF â T .  Third, consider AX â T . Consider the reduction in case 1 for CTLmon ({EX})-formulae,  and let f (C, x) = (K, v0 , Ď) be the value computed by the reduction function. It holds that  MODEL CHECKING CTL IS ALMOST ALWAYS INHERENTLY SEQUENTIAL â  13  C(x) = 1 iff K, v0 |= Ď, and equivalently C(x) = 0 iff K, v0 |= ÂŹĎ. Let Ďâ˛ be the formula  obtained from ÂŹĎ by multiplying the negation into the formula. Then Ďâ˛ is a CTLa.n. ({AX})formula. Since LOGCFL is closed under complement, it follows that CTLa.n. -MC({AX}) is  LOGCFL-hard. Using Lemma 2.1, we obtain that CTLmon -MC({AX}) is LOGCFL-hard,  too. An analogous argument works for the case AG â T . The remaining fragments are even  P-complete by Proposition 3.6.  Using Lemma 2.1 we obtain LOGCFL-hardness of CTLpos -MC(T ) for all nonempty  sets T of CTL-operators.  In the absence of CTL-operators, the lower bound for the model checking problem again  follows from the lower bound for evaluating monotone propositional formulae. This problem  is known to be hard for NC1 [Bus87, Sch10].  3.3. The Power of Negation. We will now show that model checking for the fragments  CTLa.n. and CTLpos is computationally equivalent to model checking for CTLmon , for any  set T of CTL-operators. Since we consider â¤cd -reductions, this is not immediate.  From Lemma 2.1 it follows that the hardness results for CTLmon -MC(T ) also hold for  CTLa.n. -MC(T ) and CTLpos -MC(T ). Moreover, the algorithms for CTLpos -MC(T ) also  work for CTLmon -MC(T ) and CTLa.n. -MC(T ) without using more computation resources.  Both observations together yield the same completeness results for all CTL-fragments with  restricted negations.  Theorem 3.8. Let T be any set of CTL-operators. Then CTLmon -MC(T ), CTLa.n. -MC(T ),  and CTLpos -MC(T ) are  â NC1 -complete if T is empty,  â LOGCFL-complete if â ( T â {EX, EF} or â ( T â {AX, AG},  â P-complete otherwise.  Moreover, the problems CTLmon -MC(T ), CTLa.n. -MC(T ), and CTLpos -MC(T ) are equivalent w.r.t. â¤cd -reductions.  This equivalence extends Lemma 2.1. We remark that this equivalence is not straightforward. Simply applying de Morganâs laws to transform one problem into another requires  counting the number of negations on top of â§- and â¨-connectives. This counting cannot  be achieved by an AC0 -circuit and does not lead to the aspired reduction. Here we obtain  equivalence of the problems as a consequence of our generic hardness proofs in Section 3.2.  4. Model Checking Extensions of CTL  It has been argued that CTL lacks the ability to express fairness properties. To address  this shortcoming, Emerson and Halpern introduced ECTL in [EH86]. ECTL extends CTL  â  with the F-operator, which states that for every moment in the future, the enclosed formula  will eventually be satisfied again: for a Kripke structure K, a path x = (x1 , x2 , . . . ), and a  path formula Ď  â  K, x |= FĎ iff K, xi |= FĎ for all i â N.  â  The dual operator G is defined analogously. As for CTL, model checking for ECTL is known  to be tractable. Moreover, our next result shows that even for all fragments, model checking  for ECTL is not harder than for CTL.  14  O. BEYERSDORFF, A. MEIER, M. MUNDHENK, T. SCHNEIDER, M. THOMAS, AND H. VOLLMER  â  Algorithm 2 Case distinction for EF  â  1:  2:  3:  4:  else if Ď = EFÎą then  nondet. choose k â¤ |W | and a path (wi )1â¤iâ¤k such that (w, w1 ) â Râ , (wk , w1 ) â R  nondet. choose some 1 â¤ i â¤ k and push(S, (Îą, wi ))  end if  Theorem 4.1. Let T be a set of temporal operators. Then ECTL-MC(T ) âĄcd CTL-MC(T â˛ )  â  and ECTLpos -MC(T ) âĄcd CTLpos -MC(T â˛ ), where T â˛ is obtained from T by substituting F  â  with F and G with G.  â  â  Proof. For the upper bounds, notice that ECTL-MC(ALL âŞ {EF, AF}) â P. It thus remains  â  â  to show that ECTLpos -MC(T ) â LOGCFL for T â {EX, EF, EF} and T â {AX, AG, AG}  â  â  First, consider the case that T â {EX, EF, EF}. We modify Algorithm 1 to handle EF by  extending the case distinction in lines 4â19 with the code fragment given in Algorithm 1.  â  The algorithm for T â {AX, AG, AG} is analogous and membership in LOGCFL follows  from its closure under complementation.  For the lower bounds, we extend the proofs of Propositions 3.4, 3.6 and 3.7 to handle  â  â  â  â  sets T involving also the operators AF, AG, EF, and EG. Therefore, we only need modify  the accessibility relation R of respective Kripke structure K to be reflexive. The hardness  â  â  results follow by replacing F with F and G with G in the respective reductions.  First consider the case that T contains an existential and a universal operator, say  â  â  T = {AF, EG}. Let M , x, and p be defined as in the proof of Proposition 3.4. We map (M, x)  to (KĚ, c01 , Ď1 ), where KĚ = (W, R, Îˇ) is the reflexive closure of the Kripke   structure K defined      0  for the P-hardness of CTL-MC({AF, EG}), c1 â W , and Ď := Ď1 Ď2 Âˇ Âˇ Âˇ Ďp(n) (t) Âˇ Âˇ Âˇ ,  where  ( â  AF(di â§ x), if M âs configurations in step i are universal,  Ďi (x) :=  â  EG(Di â¨ x), otherwise,  In KĚ it now holds that di â Îˇ(w) and (w, wâ˛ ) â R together imply that either w = wâ˛ or  â  di â  / Îˇ(wâ˛ ). Hence, for all w â W and 1 â¤ i â¤ p(|x|), KĚ, w |= AF(di â§x) iff K, w |= AF(di â§x),  â W  W  and KĚ, w |= EG( i6=jâ{0,...,p(n)} dj â¨ x) iff K, w |= EG( i6=jâ{0,...,p(n)} dj â¨ x). From this,  correctness of the reduction follows. The P-hardness of CTL-MC(T ) for the remaining  fragments follows analogously.  â  As for T â {EX, EF, EF}, we will show that ECTLmon -MC(T ) is LOGCFL-hard under  â  â¤cd -reductions for T = {EF}. Let C, x, and â be as in the proof of Proposition 3.7. We  map the pair (C, x) to the triple (KĚ â˛ , v0 , Ď0 ), where KĚ â˛ = (V â˛ , E â˛ , Îˇ) is the reflexive closure  of the Kripke structure K â˛ defined for the LOGCFL-hardness of CTL-MC({EF}), v0 â V â˛ ,  and Ď0 is recursively defined via (Ďâ˛i )0â¤iâ¤â as  ďŁą  ďŁ´  if i = â,  ďŁ˛t,â  Ďi := EF(di+1 â§ Ďi+1 ),  if i is even,  ďŁ´  â  ďŁłV  i=1,2 EF(di+1 â§ i â§ Ďi+1 ), if i is odd.  Again, we have that in KĚ â˛ , di â Îˇ(v) and (v, v â˛ ) â E â˛ together imply that either v = v â˛ or  â  di â  / Îˇ(v â˛ ). It hence follows KĚ â˛ , v |= EF(di â§ Ďi ) iff K â˛ , v |= EF(di â§ Ďi ), for all v â V â˛ and  MODEL CHECKING CTL IS ALMOST ALWAYS INHERENTLY SEQUENTIAL â  â  15  â  1 â¤ i â¤ â. We conclude that ECTLmon -MC({EF}) is LOGCFL-hard. The case T = {AG}  follows analogously.  We will now consider CTL+ , the extension of CTL by Boolean combinations of path  formulae which is defined as follows. A CTL+ -formula is a CTLâ -formula where each pure  temporal operator in a state formula occurs in the scope of a path quantifier. The set of  all CTL-formulae is a strict subset of the set of all CTL+ -formulae, which again forms a  strict subset of the set of all CTLâ -formulae. For example, AGEFp and A(Gp â§ Fq) are  CTL+ -formulae, but AGFp is not. However, CTL is as expressive as CTL+ [EH85].  By CTL+ (T ) we denote the set of CTL+ -formulae using the connectives {â§, â¨, ÂŹ}  and temporal operators in T only. Analogous to the fragments CTLpos (T ), CTLa.n. (T ),  +  +  and CTLmon (T ), we define CTL+  pos (T ), CTLa.n. (T ), and CTLmon (T ) as those fragments  +  of CTL (T ) that disallow temporal operators in the scope of negations, contain negation  signs only directly in front of atomic propositions, and do not contain negation signs at all,  respectively.  In contrast to CTL, model checking for CTL+ is not tractable, but âp2 -complete  [LMS01]. Below we classify the complexity of model checking for both the full and the  positive fragments of CTL+ .  Theorem 4.2. Let T be a set of temporal operators containing at least one path quantifier.  Then CTL+ -MC(T ) is  â NC1 -complete if T â {A, E},  â P-complete if {X} ( T â {A, E, X}, and  â âp2 -complete otherwise.  Proof. If T â {A, E} then deciding CTL+ -MC(T ) is equivalent to the problem of evaluating  a propositional formula, which is known to be NC1 -complete [Bus87, Sch10].  If {X} ( T â {A, E, X}, then CTL+ -MC(T ) can be solved using a labelling algorithm:  Let K = (W, R, Îˇ) be a Kripke structure, and Ď be a CTL+ ({A, E, X})-formula. Assume  w.l.o.g. that Ď starts with an E and that it does not contain any Aâs. Compute K, w |= Ď for  all w â W and all subformulae EĎ of Ď such that Ď is free of path quantifiers, and replace  EĎ in Ď with a new proposition pĎ while extending the labelling function Îˇ such that  pĎ â Îˇ(w) ââ K, w |= Ď. Repeat this step until Ď is free of path quantifiers and denote  the resulting (propositional) formula by Ďâ˛ . To decide whether K, w |= Ď for some w â W , it  now suffices to check whether Ďâ˛ is satisfied by the assignment implied by Îˇ(w). As for all of  the above subformulae EĎ of Ď, Ď â CTL+ ({X}), it follows that K, w |= Ď can be determined  in polynomial time in the size of K and Ď. Considering that the number of labelling steps  is at most O(|Ď| Âˇ |W |) it follows that CTL+ -MC(T ) is in P. The P-hardness follows from  CTL-MC({EX}) â¤cd CTL+ -MC({E, X}) resp. CTL-MC({AX}) â¤cd CTL+ -MC({A, X}).  For all other possible sets T , we have T âŠ{E, A} =  6 â and T âŠ{F, G, U} =  6 â. Consequently,  each of the temporal operators A, E, F, and G can be expressed in CTL+ (T ). The claim  now follows from [LMS01].  For the positive fragments of CTL+ we obtain a more complex picture:  Theorem 4.3. Let T be a set of temporal operators containing at least one path quantifier.  Then CTL+  pos -MC(T ) is  â NC1 -complete if T â {A, E},  â LOGCFL-complete if T = {A, X} or T = {E, X},  16  O. BEYERSDORFF, A. MEIER, M. MUNDHENK, T. SCHNEIDER, M. THOMAS, AND H. VOLLMER  â P-complete if T = {A, E, X},  â NP-complete if E â T , A 6â T and T contains a pure temporal operator aside from X,  â coNP-complete if A â T , E 6â T and T contains a pure temporal operator aside from X,  and  â âp2 -complete otherwise.  Proof. The first and third claim follow from Theorem 4.2 and the monotone formula value  problem being NC1 -complete [Sch10].  For the second claim, consider the case T = {E, X}. It is straightforward to adopt  Algorithm 1 to guess a successor wâ˛ of the current state once for every path quantifier  E that has been read and decompose the formula w.r.t. wâ˛ . For T = {A, X} analogous  arguments hold.  The fourth claim can be solved with a labelling algorithm analogously to the algorithm  for CTL+ -MC({A, E, X}). In this case, however, whole paths need to be guessed in the  Kripke structures. Hence, we obtain a polynomial time algorithm deciding CTL+  pos -MC(T )  using an oracle B â NP (resp. B â coNP) . This algorithm is furthermore a monotone â¤pT reduction from CTL+  pos -MC(T ) to B, in the sense that for any deterministic oracle Turing  machine M that executes the algorithm,  A â B =â L(M, A) â L(M, B),  where L(M, X) is the language recognized by M with oracle X. Both NP and coNP are  closed under monotone â¤pT -reductions [Sel82]. We thus conclude that CTL+  pos -MC(T ) â NP  (resp. CTL+  -MC(T  )  â  coNP).  pos  As for the NP-hardness of CTL+  pos -MC(T ), note that the reduction from 3SAT to  LTL-MC({F}), the model checking problem for linear temporal logic using the F-operator  only, given by Sistla and Clarke in [SC85] is a reduction to CTL+  pos -MC({E, F}) indeed.  The NP-hardness of CTL+  -MC({E,  G})  is  obtained  by  a  similar  reduction: let Ď be a  pos  Vn  propositional formula in 3CNF, i.e., Ď = i=1 Ci with Ci = âi1 â¨ âi2 â¨ âi3 and âij = xk  or âij = W  ÂŹxk for all 1 â¤ i â¤ n, all 1 Wâ¤ j â¤ 3, and some 1 â¤ k â¤ m. Recall that for  a set A, A denotes the disjunction aâA a. We map Ď to the triple (K, y0 , Ď), where  W  V W  K = (W, R, Îˇ) is the Kripke structure given in (4.1) and Ď := E ni=1 3j=1 G (ÎŚ \ {âźâij })  with ÎŚ := {y0 , yi , xi , xi | 1 â¤ i â¤ m} and âźâij denoting the complementary literal of âij .  W := {y0 } âŞ {xi , xi , yi | 1 â¤ i â¤ m},  R := {(yiâ1 , xi ), (xi , yi ), (yiâ1 , xi ), (xi , yi ) | 1 â¤ i â¤ m} âŞ {(ym , ym )},  (4.1)  Îˇ(w) := {w} for all w â W.  Note that the above reductions prove hardness for CTL+  mon -MC(T ) already. The coNP+  hardness of CTL+  pos -MC({A, G}) and CTLpos -MC({A, F}) follows from the same reductions.  As for the the last claim, note that the âp2 -hardness of CTL+ -MC({A, E, F, G}) carries  +  over to CTL+  mon -MC({A, E, F, G}), because any CTL ({A, E, F, G})-formula can be trans+  formed into a CTLa.n. ({A, E, F, G})-formula, in which all negated atoms ÂŹp may be replaced  by fresh propositions p that are mapped into all states of the Kripke structure whose label  does not contain p. It thus remains to prove the âp2 -hardness of CTL+  pos -MC({A, E, F}) and  +  +  CTLpos -MC({A, E, G}). Consider CTLpos -MC({A, E, G}). Laroussinie et al reduce from  SNSAT, that is the problem to decide, given disjoint sets Z1 , . . . , Zn of propositional variables from {z1 , . . . , zp } and a list Ď1 (Z1 ), Ď2 (x1 , Z2 ), . . . , Ďn (x1 , . . . , xn , Zn ) of formulae in  MODEL CHECKING CTL IS ALMOST ALWAYS INHERENTLY SEQUENTIAL â  xn  xnâ1  s00  n  cn  cnâ1  xnâ1  s11  n  x1  ÂˇÂˇÂˇ  z1  z2  ÂˇÂˇÂˇ  zp  s11  1  z1  z2  ÂˇÂˇÂˇ  zp  c1  s10  1  s10  2  s11  nâ1  s00  1  s01  1  ...  s10  nâ1  s10  n  s00  2  s01  2  s01  nâ1  s01  n  xn  ÂˇÂˇÂˇ  s00  nâ1  17  s11  2  x1  Figure 3: Extended version of the Kripke structure constructed in [LMS01, Figure 3].  conjunctive normal form, whether xn holds in the unique valuation Ď defined by  Ď(xi ) = â¤ ââ Ďi (x1 , . . . , xiâ1 , Zi ) is satisfiable.  (4.2)  An instance I of SNSAT is transformed to the Kripke structure K depicted in Figure 3 and  the formula Ď2nâ1 that is recursively defined as   _  n  n  n  _  _    01  10  11  x  â  6  Ď  )  â¨  s  â¨  s  â¨  s  )  â§  F(  xi â E ÂŹF (s00  Ďk := E G  i  kâ1  i  i  i  i  |  i=1  i=1  i=1  {z  (A)  â§ G  |  n  ^  ÂŹci  i=1  {z  (B)    }  â§  n   ^  Fxi â  i=1  ^_  j  {z  |  m  (C)  }  Fâi,j,m    }  ,  V W  for 1 â¤ k â¤ n, Ď0 := â¤, and Ďi = j m âi,j,m, where the âi,j,mâs are literals over  {x1 , . . . , xn }âŞ Zi . Note that the structure K from Figure 3 differs from the Kripke structure  constructed in [LMS01] in that we introduce different labels ci and sji for 1 â¤ i â¤ n and  j â {00, 01, 10, 11}, as we need to distinguish between the states later on. The intuitive  interpretation of (B) is that the existentially quantified path does actually encode an assignment of {x1 , . . . , xn } to {âĽ, â¤}, while (C) states that this assignment coincides with  Ď on all propositions that are set to â¤. Lastly (A) expresses the recursion inherent in the  definition of SNSAT. It holds that I â SNSAT ââ K, xn |= Ď2nâ1 (see [LMS01] for the  correctness of this argument).  We modify the given reduction to not use F. First note that Ďkâ1 occurs negatively in Ďk .  We will therefore consider the formulae Ď2nâ1 , Ď2nâ3 , . . . , Ď1 and ÂŹĎ2nâ2 , ÂŹĎ2nâ4 , . . . , ÂŹĎ2  separately. In Ď2nâ1 , Ď2nâ3 , . . . , Ď1 replace  n  n  n  n  _  _  ^  _    00  01  10  11  ci â¨ ÂŹĎkâ1 ) ,  xi â E G (ÂŹsi â§ ÂŹsi â§ ÂŹsi â§ ÂŹsi ) â§ G( xi â¨  â (A) with G  i=1  i=1  n     ^  ^_ _  GÂŹxi â¨  G (ÎŚ \ {âźâi,j,m}) ;  â (C) with  i=1  j  i=1  m  and in ÂŹĎ2nâ2 , ÂŹĎ2nâ4 , . . . , ÂŹĎ2 replace  _  _ _    (ÎŚ \ {xi }) â¨ A G( ÎŚ \ {ci }) â¨ G(ci â¨ Ďkâ1 ,  G  â (A) with  1â¤iâ¤n  i=1  18  O. BEYERSDORFF, A. MEIER, M. MUNDHENK, T. SCHNEIDER, M. THOMAS, AND H. VOLLMER  â (B) with  â (C) with  n  _  G  i=2  n   _  _  01 01  11  (ÎŚ \ {s00  i , si , siâ1 , siâ1 }), and  G    _  _^  (ÎŚ \ {xi }) â§  GÂŹâi,j,m ,  j m  00  01  10  {xi , xi , ci , si , si , si , s11  i |  i=1  1 â¤ i â¤ n} âŞ {zi , z i | 1 â¤ i â¤ p} is the set of all  where ÎŚ :=  propositions used in K. Denote the resulting formulae by Ďkâ˛ , k âĽ 0. In Ďkâ˛ , all negations  are atomic and only the temporal operators E, A and G are used.  To verify that K, xk |= Ďk ââ K, xk |= Ďkâ˛ for all 0 â¤ k < 2n, consider Ďk with k odd  first. Suppose K, xk |= Ďk . Then, by (A), there exists a path Ď in K such that whenever  some xi is labelled in the current state Ďp , then there exists a path Ď â˛ starting in Ďp that  never visits any state labelled with sji , 1 â¤ i â¤ n, j â {00, 01, 10, 11}, and eventually falsifies  Ďkâ1 because it reaches a state where neither xi nor ci holds for all 1 â¤ i â¤ n. Hence, by  construction of K, Ď â˛ has to visit the states labelled with ci and xi for i such that xi â Îˇ(Ďp ).  This is equivalent to the existence of a path Ď â˛ starting in Ďp which never visits any state  labelled with sji , 1 â¤ i â¤ n, j â {00, 01, 10, 11}, and that falsifies Ďkâ1 if the current state is  not labelled with ci or xi for all 1 â¤ i â¤ n. Hence the substitution performed on (A) does  not alter the set of states in K on which the formula is satisfied.  The formula (C), on the other hand, states that whenever the path Ď quantified by the  outmost E in Ďk visits the state labelled xi , then for every clause j in the ith formula Ďi of  given SNSAT instance at least one literal âi,j,m occurs in the labels on Ď (i.e., Ďi is satisfied  by the assignment induced by Ď). The path Ď is guaranteed to visit either a state labelled  xi or a state labelled xi but not both, by virtue of the subformula (B). Therefore, the  eventual satisfaction of xi is equivalent to globally satisfying ÂŹxi , whereas the satisfaction  of Ďi can be asserted by requiring that for any clause some literal is globally absent from  the labels on Ď. Thus the substitution performed on (C) does not alter the set of states on  which the formula is satisfied either. Concluding, K, xk |= Ďk ââ K, xk |= Ďkâ˛ for all odd  0 â¤ k < 2n.  Now, if k is even, then   _  n  n  n  _  _    00  01  10  11  xi â§ A F (si â¨ si â¨ si â¨ si ) â¨ G( xi â Ďkâ1 )  ÂŹĎk âĄ A F  |  i=1  i=1  i=1  {z  }  (A)  n  n     _    _  _^  â¨ F  ci â¨  Fxi â§  GÂŹâi,j,m .  |  i=1  {z  (B)  }  i=1  |  j  {z  m  (C)  }  Here, (A) asserts that on all paths Ď there is a state Ďp such that xi â Îˇ(Ďp ) for some  1 â¤ i â¤ n and all paths Ď â˛ starting in Ďp eventually visit a state labelled with sji , 1 â¤ i â¤ n,  j â {00, 01, 10, 11}, or satisfy Ďkâ1 whenever xi â Îˇ(Ďp ) for some 1 â¤ i â¤ n. By construction  of K, this is equivalent to stating the all paths Ď â˛ either pass the state labelled ci and globally  satisfy  As for the states   or   in K the formula  Wndo not pass the state labelled  Wn ci . W  Wn ci â¨ Ďkâ1  F i=1 xi â§ Ď âĄ i=1 F xi â§ Ď is satisfied iff i=1 G (ÎŚ \ {xi }) â¨ Ď is satisfied, the set  of  when substituting (A) with  k is satisfied remains unaltered    W states inWK on which the ĎW  .  })  â¨  A  G(  ÎŚ  \  {c  })  â¨  G(c  â¨  Ď  G  (ÎŚ  \  {x  i  i  i  kâ1  1â¤iâ¤n  MODEL CHECKING CTL IS ALMOST ALWAYS INHERENTLY SEQUENTIAL â  19  Similarly, the set ofW statesWin K on which the Ďk is satisfied remains unaltered when  01 01  11  substituting (B) with ni=2 G (ÎŚ \ {s00  i , si , siâ1 , siâ1 }), as any path in K that visits a  01  01  11  state labelled with some ci cannot pass via states labelled with s00  i , si , siâ1 , or siâ1 .  W V  Wn  W  Finally, the equivalence of Ďk with i=1 G (ÎŚ \ {xi }) â§ j m GÂŹâi,j,m follows from  arguments similar to those for the (C) part in the case that k is odd. We conclude that  p  K, xk |= Ďk ââ K, xk |= Ďkâ˛ for all 0 â¤ k < 2n. Hence, CTL+  pos -MC({A, E, G}) is â2 -hard.  p  +  For T = {A, E, F} similar modifications show that CTLpos -MC(T ) is â2 -hard, too. This  concludes to proof of Theorem 4.3.  Finally consider ECTL+ , the combination of ECTL and CTL+ . One can adapt the  â  â  above hardness and membership proofs to hold for F and G instead of F and G: For example,  â  to establish the âp2 -hardness of ECTL+  pos -MC(T ) in case T = {A, E, G} we modify K such  that the states labelled xn and xn are reachable from zp and z p and assert that (a) the  path quantified by the outmost path quantifier in Ďk , 1 â¤ i < 2n, additionally satisfies  â  Vn â  that all but a  i=1 (GÂŹxi â¨ GÂŹxi ) and (b) whenever xi is labelled,â then there exists a path  â  finite number of times satisfies xi . The changes if F is available instead of G follow by the  duality principle of these operators. For its model checking problem we hence obtain:  Corollary 4.4. Let T be a set of temporal operators containing at least one path quantifier  â  â  and let T â˛ by obtained from T by substituting F with F and G with G. Then ECTL+ -MC(T ) âĄcd  +  CTL+ -MC(T â˛ ) and ECTL+  pos -MC(T ) âĄcd CTLpos -MC(T ).  5. Conclusion  We have shown (Theorem 3.2) that model checking for CTLpos (T ) is already P-complete  for most fragments of CTL. Only for some weak fragments, model checking becomes easier:  if T â {EX, EF} or T â {AX, AG}, then CTLpos -MC(T ) is LOGCFL-complete. In the case  that no CTL-operators are used, NC1 -completeness of evaluating propositional formulae  applies. As a direct consequence (Theorem 3.1), model checking for CTL(T ) is P-complete  for every nonempty T . This shows that for the majority of interesting fragments, model  checking CTL(T ) is inherently sequential and cannot be sped up using parallelism.  While all the results above can be transferred to ECTL (Theorem 4.1), CTL+ and  ECTL+ exhibit different properties. For both logics, the general model checking problem  was shown to be complete for âp2 in [LMS01]. Here we proved that model checking fragments  of CTL+ (T ) and ECTL+ (T ) for T â {A, E, X} remains tractable, while the existential and  +  the universal fragments of CTL+  pos (T ) and ECTLpos (T ) containing temporal operators other  than X are complete for NP and coNP, respectively.  Instead of restricting only the use of negation as done in this paper, one might go one  step further and restrict the allowed Boolean connectives in an arbitrary way. One might,  e.g., allow the exclusive-OR as the only propositional connective. This has been done for  the case of linear temporal logic LTL in [BMS+ 09], where the complexity of LTL-MC(T, B)  for an arbitrary set T of temporal operators and B of propositional connectives was studied.  For example, restricting the Boolean connectives to only one of the functions AND or OR  leads to many NL-complete fragments in the presence of certain sets of temporal operators.  However a full classification is still open.  Considering the CTL variants considered in this paper, plus CTLâ , over arbitrary sets  of Boolean operators would be one way to generalise our results. In the case of CTL+ and  20  O. BEYERSDORFF, A. MEIER, M. MUNDHENK, T. SCHNEIDER, M. THOMAS, AND H. VOLLMER  EX, EF  LOGCFL-c.  AX, AG, O  EX, EF  O  NC1 -c.  P-c.  ALL  EX, EF, O  AX, AG  LOGCFL-c.  AX, AG  O = AF, AU, AR, EG, EU, ER  Figure 4: Complexity of CTLpos -MC(T ) for all sets T of CTL-operators (depicted as a  âfinite automatonâ where states indicate completeness results and arrows indicate  an increase of the set of CTL-operators).  CTLâ , where model checking is intractable [EL87, Sch03, LMS01], such a more fine-grained  complexity analysis could help draw a tighter border between fragments with tractable  and intractable model checking problems. As for the corresponding satisfiability problems  CTL-SAT(T, B) and CTLâ -SAT(T, B), their complexity has been determinedâwith respect  to the set of Boolean operators, completelyâin [MMTV09].  Throughout this paper, we have assumed that the formula and the Kripke structure  are part of the input and can vary in size. The case where the complexity is measured  in terms of the size of the formula (or the Kripke structure), and the other component is  assumed to be fixed, is usually referred to as specification complexity (or system complexity).  Our approach measures the joint complexity. In applications, where usually the structure  is significantly bigger than the specification, an analysis of the system complexity becomes  interesting. For system complexity, model checking for CTL and CTLâ is already NLcomplete [BVW94, KVW00]. Still, the hope for a significant drop of system complexity  justifies a systematic analysis of fragments of these logics.  References  +  [BMM 09] O. Beyersdorff, A. Meier, M. Mundhenk, T. Schneider, M. Thomas, and H. Vollmer. Model  checking CTL is almost always inherently sequential. In Proc. 16th International Symposium on  Temporal Representation and Reasoning. IEEE Computer Society Press, 2009.  [BMS+ 09] M. Bauland, M. Mundhenk, T. Schneider, H. Schnoor, I. Schnoor, and H. Vollmer. The tractability of model checking for LTL: the good, the bad, and the ugly fragments. In Proc. 5th Methods  for Modalities, volume 231 of Electronic Notes in Theoretical Computer Science, pages 277â292,  2009.  [Bus87]  S. R. Buss. The Boolean formula value problem is in ALOGTIME. In Proc. 19th Symposium on  Theory of Computing, pages 123â131. ACM Press, 1987.  [BVW94] O. Bernholtz, M. Vardi, and P. Wolper. An automata-theoretic approach to branching-time  model checking (extended abstract). In Proc. 6th International Conference on Computer Aided  Verification, volume 818 of Lecture Notes in Computer Science, pages 142â155. Springer, 1994.  [CES86]  E. Clarke, E. A. Emerson, and A. Sistla. Automatic verification of finite-state concurrent systems  using temporal logic specifications. ACM Transactions on Programming Languages and Systems,  8(2):244â263, 1986.  [EC82]  E. A. Emerson and E. M. Clarke. Using branching time temporal logic to synthesize synchronization skeletons. Science of Computer Programming, 2(3):241â266, 1982.  MODEL CHECKING CTL IS ALMOST ALWAYS INHERENTLY SEQUENTIAL â  21  [EH85]  E. A. Emerson and J. Y. Halpern. Decision procedures and expressiveness in the temporal logic  of branching time. Journal of Computer and System Sciences, 30(1):1â24, 1985.  [EH86]  E. A. Emerson and J. Y. Halpern. âSometimesâ and ânot neverâ revisited: on branching versus  linear time temporal logic. Journal of the ACM, 33(1):151â178, 1986.  [EL87]  E. A. Emerson and C.-L. Lei. Modalities for model checking: Branching time logic strikes back.  Science of Computer Programming, 8(3):275â306, 1987.  [KF09]  L. Kuhtz and B. Finkbeiner. LTL Path Checking is Efficiently Parallelizable. International Colloquium on Automata, Languages and Programming, 2009.  [KVW00] O. Kupferman, M. Y. Vardi, and P. Wolper. An automata-theoretic approach to branching-time  model checking. Journal of the ACM, 47(2):312â360, 2000.  [Lar95]  F. Laroussinie. About the expressive power of CTL combinators. Information Processing Letters,  54(6):343â345, 1995.  [LMS01]  F. Laroussinie, N. Markey, and P. Schnoebelen. Model checking CTL+ and FCTL is hard. In  Proc. 4th Foundations of Software Science and Computation Structure, volume 2030 of Lecture  Notes in Computer Science, pages 318â331. Springer Verlag, 2001.  [Mar04]  N. Markey. Past is for free: on the complexity of verifying linear temporal properties with past.  Acta Informatica, 40(6-7):431â458, 2004.  [MMTV09] A. Meier, M. Mundhenk, M. Thomas, and H. Vollmer. The complexity of satisfiability for fragments of CTL and CTLâ . International Journal of Foundations of Computer Science, 20(5):901â  918, 2009.  [Pap94]  C. H. Papadimitriou. Computational Complexity. Addison-Wesley, Reading, MA, 1994.  [Pnu77]  A. Pnueli. The temporal logic of programs. In Proc. 18th Symposium on Foundations of Computer Science, pages 46â57. IEEE Computer Society Press, 1977.  [Ruz80]  W. L. Ruzzo. Tree-size bounded alternation. Journal of Computer and System Sciences, 21:218â  235, 1980.  [RV97]  K. Regan and H. Vollmer. Gap-languages and log-time complexity classes. Theoretical Computer  Science, 188:101â116, 1997.  [SC85]  A. Sistla and E. Clarke. The complexity of propositional linear temporal logics. Journal of the  ACM, 32(3):733â749, 1985.  [Sch03]  Ph. Schnoebelen. The Complexity of Temporal Logic Model Checking, volume 4 of Advances in  Modal Logic, pages 393â436. Kingâs College Publications, 2003.  [Sch10]  H. Schnoor. The complexity of model checking for Boolean formulas. Int. Journal on Foundations  of Computer Science, 21(3):289â309, 2010.  [Sel82]  A. L. Selman. Reductions on NP and P-selective sets. Theoretical Computer Science, 19:287â304,  1982.  [Vol99]  H. Vollmer. Introduction to Circuit Complexity â A Uniform Approach. Texts in Theoretical  Computer Science. Springer Verlag, Berlin Heidelberg, 1999.  This work is licensed under the Creative Commons Attribution-NoDerivs License. To view  a copy of this license, visit http://creativecommons.org/licenses/by-nd/2.0/ or send a  letter to Creative Commons, 171 Second St, Suite 300, San Francisco, CA 94105, USA, or  Eisenacher Strasse 2, 10777 Berlin, Germany 