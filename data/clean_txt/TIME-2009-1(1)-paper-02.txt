Logical Methods in Computer Science  Vol. 7 (2:12) 2011, pp. 1Ã¢Â€Â“21  www.lmcs-online.org  Submitted  Published  Jan. 14, 2010  Nov. 16, 2011  MODEL CHECKING CTL IS ALMOST ALWAYS INHERENTLY  SEQUENTIAL Ã¢ÂˆÂ—  OLAF BEYERSDORFF a , ARNE MEIER b , MARTIN MUNDHENK c , THOMAS SCHNEIDER d ,  MICHAEL THOMAS e , AND HERIBERT VOLLMER f  a,b,e,f  Theoretical Computer Science, Leibniz University of Hannover, Germany  e-mail address: {beyersdorff, meier, thomas, vollmer}@thi.uni-hannover.de  c  Computer Science, University of Jena, Germany  e-mail address: martin.mundhenk@uni-jena.de  d  Computer Science, Saarland University, Germany  e-mail address: schneider@ps.uni-saarland.de  Revision Note. This is a revised and corrected version of the article originally published  on May 17, 2011.  Abstract. The model checking problem for CTL is known to be P-complete (Clarke,  Emerson, and Sistla (1986), see Schnoebelen (2002)). We consider fragments of CTL  obtained by restricting the use of temporal modalities or the use of negationsÃ¢Â€Â”restrictions  already studied for LTL by Sistla and Clarke (1985) and Markey (2004). For all these  fragments, except for the trivial case without any temporal operator, we systematically  prove model checking to be either inherently sequential (P-complete) or very efficiently  parallelizable (LOGCFL-complete). For most fragments, however, model checking for  CTL is already P-complete. Hence our results indicate that, in cases where the combined  complexity is of relevance, approaching CTL model checking by parallelism cannot be  expected to result in any significant speedup.  We also completely determine the complexity of the model checking problem for all  fragments of the extensions ECTL, CTL+ , and ECTL+ .  1998 ACM Subject Classification: D.2.4, F.3.1, I.2.2, I.2.4.  Key words and phrases: Model checking, temporal logic, complexity.  Ã¢ÂˆÂ—  A preliminary version of this paper appeared in the proceedings of the conference TIMEÃ¢Â€Â™09 [BMM+ 09].  Supported in part by grants DFG VO 630/6-1, VO 630/6-2, DAAD-ARC D/08/08881, and BC-ARC  1323.  l  LOGICAL METHODS  IN COMPUTER SCIENCE  c  DOI:10.2168/LMCS-7 (2:12) 2011  CC  O. Beyersdorff, A. Meier, M. Mundhenk, T. Schneider, M. Thomas, and H. Vollmer  Creative Commons  2  O. BEYERSDORFF, A. MEIER, M. MUNDHENK, T. SCHNEIDER, M. THOMAS, AND H. VOLLMER  1. Introduction  Temporal logic was introduced by Pnueli [Pnu77] as a formalism to specify and verify properties of concurrent programs. Computation Tree Logic (CTL), the logic of branching time,  goes back to Emerson and Clarke [EC82] and contains temporal operators for expressing  that an event occurs at some time in the future (F), always in the future (G), in the next  point of time (X), always in the future until another event holds (U), or as long as it is not  released by the occurrence of another event (R), as well as path quantifiers (E, A) for speaking about computation paths. The full language obtained by these operators and quantifiers  is called CTLÃ¢Â‹Â† [EH86]. In CTL, the interaction between the temporal operators and path  quantifiers is restricted. The temporal operators in CTL are obtained by path quantifiers  followed directly by any temporal operator, e.g., AF and AU are CTL-operators. Because  they start with the universal path quantifier, they are called universal CTL-operators. Accordingly, EX and EG are examples for existential CTL-operators.  Since properties are largely verified automatically, the computational complexity of  reasoning tasks is of great interest. Model checking (MC)Ã¢Â€Â”the problem of verifying whether  a given formula holds in a state of a given modelÃ¢Â€Â”is one of the most important reasoning  tasks [Sch03]. It is intractable for CTLÃ¢Â‹Â† (PSPACE-complete [EL87, Sch03]), but tractable  for CTL (complete for polynomial time [CES86, Sch03]).  Although model checking for CTL is tractable, its P-hardness means that it is presumably not efficiently parallelizable. We therefore search for fragments of CTL with a model  checking problem of lower complexity. We will consider all subsets of CTL-operators, and  examine the complexity of the model checking problems for all resulting fragments of CTL.  Further, we consider three additional restrictions affecting the use of negation and study  the extensions ECTL, CTL+ , and their combination ECTL+ .  The complexity of model checking for fragments of temporal logics has been examined  in the literature: Markey [Mar04] considered satisfiability and model checking for fragments  of Linear Temporal Logic (LTL). Under systematic restrictions to the temporal operators,  the use of negation, and the interaction of future and past operators, Markey classified the  two decision problems into NP-complete, coNP-complete, and PSPACE-complete. Further,  [BMS+ 09] examined model checking for all fragments of LTL obtained by restricting the set  of temporal operators and propositional connectives. The resulting classification separated  cases where model checking is tractable from those where it is intractable. For model  checking paths in LTL an AC1 (LOGDCFL) algorithm is presented in [KF09].  Concerning CTL and its extension ECTL, our results in this paper show that most  restricted versions of the model checking problem exhibit the same hardness as the general  problem. More precisely, we show that apart from the trivial case where CTL-operators are  completely absent, the complexity of CTL model checking is a dichotomy: it is either Pcomplete or LOGCFL-complete. Unfortunately, the latter case only occurs for a few rather  weak fragments and hence there is not much hope that in practice, model checking can be  sped up by using parallelismÃ¢Â€Â”it is inherently sequential.  Put as a simple rule, model checking for CTL is P-complete for every fragment that  allows to express a universal and an existential CTL-operator. Only for fragments involving  the operators EX and EF (or alternatively AX and AG) model checking is LOGCFL-complete.  This is visualized in Figure 4 in Section 5. Recall that LOGCFL is defined as the class of  problems logspace-reducible to context-free languages, and NL Ã¢ÂŠÂ† LOGCFL Ã¢ÂŠÂ† NC2 Ã¢ÂŠÂ† P.  MODEL CHECKING CTL IS ALMOST ALWAYS INHERENTLY SEQUENTIAL Ã¢ÂˆÂ—  3  Hence, in contrast to inherently sequential P-hard tasks, problems in LOGCFL have very  efficient parallel algorithms.  For the extensions CTL+ and ECTL+ , the situation is more complex. In general, model  checking CTL+ and ECTL+ is Ã¢ÂˆÂ†p2 -complete [LMS01]. We show that for T Ã¢ÂŠÂ† {A, E, X},  both model checking problems restricted to operators from T remain tractable, while for  T * {A, E, X}, they become Ã¢ÂˆÂ†p2 -complete. Yet, for negation restricted fragments with only  existential or only universal path quantifiers, we observe a complexity decrease to NP- resp.  coNP-completeness.  This paper is organized as follows: Section 2 introduces CTL, its model checking problems, and the non-basics of complexity theory we use. Section 3 contains our main results,  separated into upper and lower bounds. We also provide a refined analysis of the reductions  between different model checking problems with restricted use of negation. The results are  then generalized to extensions of CTL in Section 4. Finally, Section 5 concludes with a  graphical overview of the results.  2. Preliminaries  2.1. Temporal Logic. We inductively define CTLÃ¢Â‹Â† -formulae as follows. Let ÃŽÅš be a finite  set of atomic propositions. The symbols used are the atomic propositions in ÃŽÅš, the constant  symbols Ã¢ÂŠÂ¤, Ã¢ÂŠÄ½, the Boolean connectives Ã‚Å¹, Ã¢ÂˆÂ§, and Ã¢ÂˆÂ¨, and the temporal operator symbols A,  E, X, F, G, U, and R.  A and E are called a path quantifiers, temporal operators aside from A and E are pure  temporal operators. The atomic propositions and the constants Ã¢ÂŠÂ¤ and Ã¢ÂŠÄ½ are atomic formulae.  There are two kinds of formulae, state formulae and path formulae. Each atomic formula  is a state formula, and each state formula is a path formula. If ÄŽÂ•, ÄŽÂˆ are state formulae  and ÄŽÂ‡, ÄŽÂ€ are path formulae, then Ã‚Å¹ÄŽÂ•, (ÄŽÂ• Ã¢ÂˆÂ§ ÄŽÂˆ), (ÄŽÂ• Ã¢ÂˆÂ¨ ÄŽÂˆ), AÄŽÂ‡, EÄŽÂ‡ are state formulae, and Ã‚Å¹ÄŽÂ‡,  (ÄŽÂ‡ Ã¢ÂˆÂ§ ÄŽÂ€), (ÄŽÂ‡ Ã¢ÂˆÂ¨ ÄŽÂ€), XÄŽÂ‡, FÄŽÂ‡, GÄŽÂ‡, [ÄŽÂ‡UÄŽÂ€], and [ÄŽÂ‡RÄŽÂ€] are path formulae. The set of CTLÃ¢Â‹Â† -formulae  (or formulae) consists of all state formulae.  A Kripke structure is a triple K = (W, R, ÃŽË‡), where W is a finite set of states, R Ã¢ÂŠÂ†  W Ä‚Â— W a total relation (i.e., for each w Ã¢ÂˆÂˆ W , there exists a wÃ¢Â€Ë› such that (w, wÃ¢Â€Ë› ) Ã¢ÂˆÂˆ R), and  ÃŽË‡ : W Ã¢Â†Â’ P(ÃŽÅš) is a labelling function. A path x is an infinite sequence x = (x1 , x2 , . . .) Ã¢ÂˆÂˆ W ÄŽÂ‰  such that (xi , xi+1 ) Ã¢ÂˆÂˆ R, for all i Ã¢Â‰Ä½ 1. For a path x = (x1 , x2 , . . .) we denote by xi the path  (xi , xi+1 , . . . ).  Let K = (W, R, ÃŽË‡) be a Kripke structure, w Ã¢ÂˆÂˆ W be a state, and x = (x1 , x2 , . . . ) Ã¢ÂˆÂˆ W ÄŽÂ‰  be a path. Further, let ÄŽÂ•, ÄŽÂˆ be state formulae and ÄŽÂ‡, ÄŽÂ€ be path formulae. The truth of a  CTLÃ¢Â‹Â† -formula w.r.t. K is inductively defined as follows:  K, w |= Ã¢ÂŠÂ¤  always,  K, w |= Ã¢ÂŠÄ½  never,  K, w |= p  iff p Ã¢ÂˆÂˆ ÃŽÅš and p Ã¢ÂˆÂˆ ÃŽË‡(w),  K, w |= Ã‚Å¹ÄŽÂ•  iff K, w 6|= ÄŽÂ•,  K, w |= (ÄŽÂ• Ã¢ÂˆÂ§ ÄŽÂˆ) iff K, w |= ÄŽÂ• and K, w |= ÄŽÂˆ,  K, w |= (ÄŽÂ• Ã¢ÂˆÂ¨ ÄŽÂˆ) iff K, w |= ÄŽÂ• or K, w |= ÄŽÂˆ,  K, w |= AÄŽÂ‡  iff K, x |= ÄŽÂ‡ for all paths x = (x1 , x2 , . . .) with x1 = w,  K, x |= ÄŽÂ•  iff K, x1 |= ÄŽÂ•,  K, x |= Ã‚Å¹ÄŽÂ‡  iff K, x 6|= ÄŽÂ‡,  K, x |= (ÄŽÂ‡ Ã¢ÂˆÂ§ ÄŽÂ€) iff K, x |= ÄŽÂ‡ and K, x |= ÄŽÂ€,  4  O. BEYERSDORFF, A. MEIER, M. MUNDHENK, T. SCHNEIDER, M. THOMAS, AND H. VOLLMER  AX, AF, AR  AX, AG, AU  AF, AR  AX, AU  AG, AU  AX, AF, AG  AU  AX, AF  AF, AG  AX, AG  AF  AX  AG  AX, AR  AR  Ã¢Âˆ  Figure 1: The expressive power of CTL(T ).  K, x |= (ÄŽÂ‡ Ã¢ÂˆÂ¨ ÄŽÂ€) iff K, x |= ÄŽÂ‡ or K, x |= ÄŽÂ€,  K, x |= XÄŽÂ‡  iff K, x2 |= ÄŽÂ‡  K, x |= [ÄŽÂ‡UÄŽÂ€] iff there is a k Ã¢ÂˆÂˆ N such that K, xk |= ÄŽÂ€ and K, xi |= ÄŽÂ‡ for 1 Ã¢Â‰Â¤ i < k.  The semantics of the remaining temporal operators is defined via the equivalences: EÄŽÂ‡ Ã¢Â‰Ä„  Ã‚Å¹AÃ‚Å¹ÄŽÂ‡, FÄŽÂ‡ Ã¢Â‰Ä„ [Ã¢ÂŠÂ¤UÄŽÂ‡], GÄŽÂ‡ Ã¢Â‰Ä„ Ã‚Å¹FÃ‚Å¹ÄŽÂ‡, and [ÄŽÂ‡RÄŽÂ€] Ã¢Â‰Ä„ Ã‚Å¹[Ã‚Å¹ÄŽÂ‡UÃ‚Å¹ÄŽÂ€]. A state formula ÄŽÂ• is satisfied by  a Kripke structure K if there exists w Ã¢ÂˆÂˆ W such that K, w |= ÄŽÂ•. We will also denoted this  by K |= ÄŽÂ•.  We use CTLÃ¢Â‹Â† (T ) to denote the set of CTLÃ¢Â‹Â† -formulae using the Boolean connectives  {Ã¢ÂˆÂ§, Ã¢ÂˆÂ¨, Ã‚Å¹}, and the temporal operators in T only. If T does not contain any quantifiers, then  including any pure temporal operators in T is meaningless.  A CTL-formula is a CTLÃ¢Â‹Â† -formula in which each path quantifier is followed by exactly  one pure temporal operator and each pure temporal operator is preceded by exactly one path  quantifier. The set of CTL-formulae forms a strict subset of the set of all CTLÃ¢Â‹Â† -formulae.  For example, AGEFp is a CTL-formula, but A(GFp Ã¢ÂˆÂ§ Fq) is not. CTL is less expressive than  CTLÃ¢Â‹Â† [EH85, EH86].  Pairs of path quantifiers and pure temporal operators are called CTL-operators. The  operators AX, AF, AG, AU, and AR are universal CTL-operators, and EX, EF, EG, EU, and  ER are existential CTL-operators. Let ALL denote the set of all universal and existential  CTL-operators. Note that A[ÄŽÂˆUÄŽÂ‡] Ã¢Â‰Ä„ AFÄŽÂ‡ Ã¢ÂˆÂ§ Ã‚Å¹E[Ã‚Å¹ÄŽÂ‡U(Ã‚Å¹ÄŽÂˆ Ã¢ÂˆÂ§ Ã‚Å¹ÄŽÂ‡)], and thus E[ÄŽÂˆRÄŽÂ‡] Ã¢Â‰Ä„ EGÄŽÂ‡ Ã¢ÂˆÂ¨  E[ÄŽÂ‡U(ÄŽÂˆ Ã¢ÂˆÂ§ ÄŽÂ‡)]. Hence {AX, AF, AR} is a minimal set of operators for CTL (in presence of all  Boolean connectives), whereas {AX, AG, AU} is not [Lar95].  By CTL(T ) we denote the set of CTL-formulae using the connectives {Ã¢ÂˆÂ§, Ã¢ÂˆÂ¨, Ã‚Å¹} and  the CTL-operators in T only. Figure 1 shows the structure of sets of CTL-operators with  respect to their expressive power.  MODEL CHECKING CTL IS ALMOST ALWAYS INHERENTLY SEQUENTIAL Ã¢ÂˆÂ—  5  Moreover, we define the following fragments of CTL(T ).  Ã¢ÂˆÂ’ CTLpos (T ) (positive)  CTL-operators may not occur in the scope of a negation.  Ã¢ÂˆÂ’ CTLa.n. (T ) (atomic negation)  Negation signs appear only directly in front of atomic propositions.  Ã¢ÂˆÂ’ CTLmon (T ) (monotone)  No negation signs allowed.  This restricted use of negation was introduced and studied in the context of linear temporal  logic, LTL, by Sistla and Clarke [SC85] and Markey [Mar04]. Their original notation was  e ) for CTLa.n. (T ) and L+ (T ) for CTLpos (T ).  L(T  2.2. Model Checking. Now we define the model checking problems for the above mentioned fragments of CTL. Let L be CTL, CTLmon , CTLa.n. , or CTLpos .  Problem: L-MC(T )  Input: A Kripke structure K = (W, R, ÃŽË‡), a state w Ã¢ÂˆÂˆ W , and an L(T )-formula ÄŽÂ•.  Question: Does K, w |= ÄŽÂ• hold?  2.3. Complexity Theory. We assume familiarity with standard notions of complexity  theory as introduced in, e.g., [Pap94]. Next we will introduce the notions from circuit  complexity that we use for our results. All reductions in this paper are Ã¢Â‰Â¤cd -reductions  defined as follows: A language A is constant-depth reducible to B, A Ã¢Â‰Â¤cd B, if there is a  logtime-uniform AC0 -circuit family with oracle gates for B that decides membership in A.  That is, there is a circuit family C = (C1 , C2 , C3 , . . . ) such that  Ã¢ÂˆÂ’ for every n, Cn computes the characteristic function of A for inputs of length n,  Ã¢ÂˆÂ’ there is a polynomial p and a constant d such that for all input lengths n, the size of Cn  is bounded by p(n) and the depth of Cn is bounded by d,  Ã¢ÂˆÂ’ each circuit Cn consists of unbounded fan-in AND and OR gates, negation gates, and  gates that compute the characteristic function of B (the oracle gates),  Ã¢ÂˆÂ’ there is a linear-time Turing machine M that can check the structure of the circuit family,  i.e., given a tuple hn, g, t, hi where n, g, h are binary numbers and t Ã¢ÂˆÂˆ {AND, OR, NOT, ORACLE},  M accepts if Cn contains a gate g of type t with predecessor h.  Circuit families C with this last property are called logtime-uniform (the name stems from  the fact that the time needed by M is linear in the length of its input tuple, hence logarithmic  in n). For background information we refer to [RV97, Vol99].  We easily obtain the following relations between model checking for fragments of CTL  with restricted negation:  Lemma 2.1. For every set T of CTL-operators, we have  CTLmon -MC(T ) Ã¢Â‰Â¤cd CTLa.n. -MC(T ) Ã¢Â‰Â¤cd CTLpos -MC(T ).  Further, for model checking, atomic negation can be eluded, that is, CTLa.n. -MC(T ) Ã¢Â‰Â¤cd  CTLmon -MC(T ).  6  O. BEYERSDORFF, A. MEIER, M. MUNDHENK, T. SCHNEIDER, M. THOMAS, AND H. VOLLMER  Proof. The first part is straightforward, using the identity function as reduction function.  For the second part, let K = (W, R, ÃŽË‡) be a Kripke structure and let ÄŽÂ• be a CTLa.n. (T )formula over the propositions ÃŽÅš = {p1 , . . . , pn }. Every negation in ÄŽÂ• appears inside a  negative literal. We obtain ÄŽÂ•Ã¢Â€Ë› by replacing every negative literal Ã‚Å¹pi with a fresh atomic  proposition qi . Further define K Ã¢Â€Ë› = (W, R, ÃŽË‡ Ã¢Â€Ë› ), where ÃŽË‡ Ã¢Â€Ë› (w) = ÃŽË‡(w) Ã¢ÂˆÅž {qi | pi Ã¢ÂˆÂˆ  / ÃŽË‡(w)}.  Obviously, K, w |= ÄŽÂ• iff K Ã¢Â€Ë› , w |= ÄŽÂ•Ã¢Â€Ë› for all w Ã¢ÂˆÂˆ W . The mapping (K, w, ÄŽÂ•) 7Ã¢Â†Â’ (K Ã¢Â€Ë› , w, ÄŽÂ•Ã¢Â€Ë› )  can be performed by an AC0 -circuit.  In Section 3.3, we complete the picture by proving CTLpos -MC(T ) Ã¢Â‰Â¤cd CTLmon -MC(T ).  The class P consists of all languages that have a polynomial-time decision algorithm. A  problem is P-complete if it is in P and every other problem in P reduces to it. P-complete  problems are sometimes referred to as inherently sequential, because P-complete problems  most likely (formally: if P 6= NC) do not possess NC-algorithms, that is, algorithms running in polylogarithmic time on a parallel computer with a polynomial number of processors. Formally, NC contains all problems solvable by polynomial-size polylogarithmic-depth  logtime-uniform families of circuits with bounded fan-in AND, OR, NOT gates.  There is an NC-algorithm for parsing context-free languages, that is, CFL Ã¢ÂŠÂ† NC. Therefore, complexity theorists have studied the class LOGCFL of all problems reducible to  context-free languages (the name Ã¢Â€ÂœLOGCFLÃ¢Â€Â refers to the original definition of the class in  terms of logspace-reductions, however it is known that the class does not change if instead,  as everywhere else in this paper, Ã¢Â‰Â¤cd -reductions are used). Hence, LOGCFL Ã¢ÂŠÂ† NC (even  LOGCFL Ã¢ÂŠÂ† NC2 , the second level of the NC-hierarchy, where the depth of the occurring  circuits is restricted to O(log2 n)). The class LOGCFL has a number of different maybe  even somewhat surprising characterizations, e.g., languages in LOGCFL are those that can  be decided by nondeterministic Turing machines operating in polynomial time that have a  worktape of logarithmic size and additionally a stack whose size is not bounded.  More important for this paper is the characterization of LOGCFL as those problems  computable by SAC1 circuit families, that is, families of circuits that  Ã¢ÂˆÂ’ have polynomial size and logarithmic depth,  Ã¢ÂˆÂ’ consist of unbounded fan-in OR gates and bounded fan-in AND gates and negation gates,  but the latter are only allowed at the input-level,  Ã¢ÂˆÂ’ are logtime-uniform (as defined above).  Since the class LOGCFL is known to be closed under complementation, the second  condition can equivalently be replaced to allow unbounded fan-in AND gates and restrict  the fan-in of OR gates to be bounded.  To summarize:  NC1 Ã¢ÂŠÂ† L Ã¢ÂŠÂ† NL Ã¢ÂŠÂ† LOGCFL = SAC1 Ã¢ÂŠÂ† NC2 ;  and problems in these classes possess very efficient parallel algorithms: they can be solved  in time O(log2 n) on a parallel machine with a tractable number of processors. For more  background on these and related complexity classes, we refer the reader to [Vol99].  3. Model Checking CTL and CTLpos  This section contains our main results on the complexity of model checking for CTL and  CTLpos . We defer the analysis of the fragments CTLa.n. and CTLmon to Section 3.3, where  MODEL CHECKING CTL IS ALMOST ALWAYS INHERENTLY SEQUENTIAL Ã¢ÂˆÂ—  7  we will see that their model-checking problems are computationally equivalent to model  checking for CTLpos .  While model checking for CTL in general is known to be polynomial time solvable and  in fact P-complete [CES86, Sch03], we improve the lower bound by showing that only one  temporal operator is sufficient to obtain hardness for P.  Theorem 3.1. For each nonempty set T of CTL-operators, CTL-MC(T ) is P-complete. If  T = Ã¢ÂˆÂ…, then CTL-MC(T ) is NC1 -complete.  If we consider only formulae from CTLpos , where no CTL-operators are allowed inside  the scope of a negation, the situation changes and the complexity of model checking exhibits  a dichotomous behavior. As long as EG or AF are expressible the model checking problem  remains P-complete. Otherwise, its complexity drops to LOGCFL.  Theorem 3.2. Let T be any set of CTL-operators. Then CTLpos -MC(T ) is  Ã¢ÂˆÂ’ NC1 -complete if T = Ã¢ÂˆÂ…,  Ã¢ÂˆÂ’ LOGCFL-complete if Ã¢ÂˆÂ… ( T Ã¢ÂŠÂ† {EX, EF} or Ã¢ÂˆÂ… ( T Ã¢ÂŠÂ† {AX, AG}, and  Ã¢ÂˆÂ’ P-complete otherwise.  We split the proofs of Theorems 3.1 and 3.2 into the upper and lower bounds in the  following two subsections.  3.1. Upper Bounds. In general, model checking for CTL is known to be solvable in P  [CES86]. While this upper bound also applies to CTLpos -MC(T ) (for every T ), we improve  it for positive CTL-formulae using only EX and EF, or only AX and AG.  Proposition 3.3. Let T be a set of CTL-operators such that T Ã¢ÂŠÂ† {EX, EF} or T Ã¢ÂŠÂ†  {AX, AG}. Then CTLpos -MC(T ) is in LOGCFL.  Proof. First consider the case T Ã¢ÂŠÂ† {EX, EF}. We claim that Algorithm 1 recursively decides  whether the Kripke structure K = (W, R, ÃŽË‡) satisfies the CTLpos (T )-formula ÄŽÂ• in state  w0 Ã¢ÂˆÂˆ W . There, S is a stack that stores pairs (ÄŽÂ•, w) Ã¢ÂˆÂˆ CTLpos (T ) Ä‚Â— W and RÃ¢Â‹Â† denotes the  transitive closure of R.  Algorithm 1 always terminates because each subformula of ÄŽÂ• is pushed to the stack  S at most once. For correctness, an induction on the structure of formulae shows that  Algorithm 1 returns false if and only if for the most recently popped pair (ÄŽÂˆ, w) from S,  we have K, w 6|= ÄŽÂˆ. Thence, in particular, Algorithm 1 returns true iff K, w |= ÄŽÂ•.  Algorithm 1 can be implemented on a nondeterministic polynomial-time Turing machine  that besides its (unbounded) stack uses only logarithmic memory for the local variables.  Thus CTLpos -MC(T ) is in LOGCFL.  The case T Ã¢ÂŠÂ† {AX, AG} is analogous and follows from closure of LOGCFL under complementation.  Finally, for the trivial case where no CTL-operators are present, model checking CTL(Ã¢ÂˆÂ…)formulae is equivalent to the problem of evaluating a propositional formula. This problem  is known to be solvable in NC1 [Bus87].  8  O. BEYERSDORFF, A. MEIER, M. MUNDHENK, T. SCHNEIDER, M. THOMAS, AND H. VOLLMER  Algorithm 1 Determine whether K, w0 |= ÄŽÂ•.  Require: a Kripke structure K = (W, R, ÃŽË‡), w0 Ã¢ÂˆÂˆ W , ÄŽÂ• Ã¢ÂˆÂˆ CTLpos (T )  1: push(S, (ÄŽÂ•, w0 ))  2: while S is not empty do  3:  (ÄŽÂ•, w) Ã¢Â†Â pop(S)  4:  if ÄŽÂ• is a propositional formula then  5:  if ÄŽÂ• evaluates to false in w under ÃŽË‡ then  6:  return false  7:  end if  8:  else if ÄŽÂ• = ÃŽÄ… Ã¢ÂˆÂ§ ÃŽË› then  9:  push(S, (ÃŽË›, w))  10:  push(S, (ÃŽÄ…, w))  11:  else if ÄŽÂ• = ÃŽÄ… Ã¢ÂˆÂ¨ ÃŽË› then  12:  nondet. push(S, (ÃŽÄ…, w)) or push(S, (ÃŽË›, w))  13:  else if ÄŽÂ• = EXÃŽÄ… then  14:  nondet. choose wÃ¢Â€Ë› Ã¢ÂˆÂˆ {wÃ¢Â€Ë› | (w, wÃ¢Â€Ë› ) Ã¢ÂˆÂˆ R}  15:  push(S, (ÃŽÄ…, wÃ¢Â€Ë› ))  16:  else if ÄŽÂ• = EFÃŽÄ… then  17:  nondet. choose wÃ¢Â€Ë› Ã¢ÂˆÂˆ {wÃ¢Â€Ë› | (w, wÃ¢Â€Ë› ) Ã¢ÂˆÂˆ RÃ¢Â‹Â† }  18:  push(S, (ÃŽÄ…, wÃ¢Â€Ë› ))  19:  end if  20: end while  21: return true  3.2. Lower Bounds. The P-hardness of model checking for CTL was first stated in [Sch03].  We improve this lower bound and concentrate on the smallest fragments of monotone CTLÃ¢Â€Â”  w.r.t. CTL-operatorsÃ¢Â€Â”with P-hard model checking.  Proposition 3.4. Let T denote a set of CTL-operators. Then CTLmon -MC(T ) is P-hard  if T contains an existential and a universal CTL-operator.  Proof. First, assume that T = {AX, EX}. We give a generic reduction from the word problem  for alternating Turing machines working in logarithmic space, which follows the same line  as the classical proof idea (see [Sch03, Theorem 3.8]), and which we will modify in order  to be useful for other combinations of CTL-operators. Let M be an alternating logspace  Turing machine, and let x be an input to M . We may assume w.l.o.g. that each transition  of M leads from an existential to a universal configuration and vice versa. Further we may  assume that each computation of M ends after the same number p(n) of steps, where p is a  polynomial and n is the length of M Ã¢Â€Â™s input. Furthermore we may assume that there exists  a polynomial q such that q(n) is the number of configurations of M on any input of length  n.  Let c1 , . . . , cq(n) be an enumeration of all possible configurations of M on input x,  starting with the initial configuration c1 . We construct a Kripke structure K := (W, R, ÃŽË‡)  MODEL CHECKING CTL IS ALMOST ALWAYS INHERENTLY SEQUENTIAL Ã¢ÂˆÂ—  9  by defining the set W := {cji | 1 Ã¢Â‰Â¤ i Ã¢Â‰Â¤ q(n), 0 Ã¢Â‰Â¤ j Ã¢Â‰Â¤ p(n)} and the relation R Ã¢ÂŠÂ† W Ä‚Â— W as    R := (cji , cj+1  k ) M reaches configuration ck from ci in one step, 0 Ã¢Â‰Â¤ j < p(n)   j j  Ã¢ÂˆÅž (ci , ci ) cji has no successor, 1 Ã¢Â‰Â¤ i Ã¢Â‰Â¤ q(n), 0 Ã¢Â‰Â¤ j < p(n)   p(n) p(n)  Ã¢ÂˆÅž (ci , ci ) 1 Ã¢Â‰Â¤ i Ã¢Â‰Â¤ q(n) .  The labelling function ÃŽË‡ is defined for all cji Ã¢ÂˆÂˆ W as    {t}, if ci is an accepting configuration and j = p(n)  j  ÃŽË‡(ci ) :=  Ã¢ÂˆÂ…, otherwise  where t is the only atom used by this labelling. It then holds that       M accepts x Ã¢Â‡ÂÃ¢Â‡Â’ K, c01 |= ÄŽÂˆ1 ÄŽÂˆ2 Ã‚Ë‡ Ã‚Ë‡ Ã‚Ë‡ ÄŽÂˆp(n) (t) Ã‚Ë‡ Ã‚Ë‡ Ã‚Ë‡ ,  where ÄŽÂˆi (x) := AX(x) if M Ã¢Â€Â™s configurations before the ith step are universal, and ÄŽÂˆi (x) :=  EX(x) otherwise. Notice that the constructed CTL-formula does not contain any Boolean  connective. Since p(n) and q(n) are polynomials, the size of K and ÄŽÂ• is polynomial in the  size of (M, x). Moreover, K and ÄŽÂ• can be constructed from M and x using AC0 -circuits.  Thus, A Ã¢Â‰Â¤cd CTLmon -MC({AX, EX}) for all A Ã¢ÂˆÂˆ ALOGSPACE = P.  For T = {AF, EG} we modify the above reduction by defining the labelling function ÃŽË‡  and the formula ÄŽÂˆi as follows:    {dj , t}, if ci is an accepting configuration and j = p(n)  ÃŽË‡(cji ) :=  {dj }, otherwise    (3.1)  AF(di Ã¢ÂˆÂ§ x), if M Ã¢Â€Â™s configurations before step i are universal,  ÄŽÂˆi (x) :=  EG(Di Ã¢ÂˆÂ¨ x), otherwise,  where dj are  W atomic propositions encoding the Ã¢Â€Â˜time stampsÃ¢Â€Â™ of the respective configurations  and Di = i6=jÃ¢ÂˆÂˆ{0,...,p(n)} dj .  For the combinations of T being one of {AF, EF}, {AF, EX}, {AG, EG}, {AG, EX},  {AX, EF}, and {AX, EG}, the P-hardness of CTLmon -MC(T ) is obtained using analogous  modifications to ÃŽË‡ and the ÄŽÂˆi Ã¢Â€Â™s.  For the remaining combinations involving the until or the release operator, observe that  w.r.t. the Kripke structure K as defined in (3.1), AF(di Ã¢ÂˆÂ§ x) and EG(Di Ã¢ÂˆÂ¨ x) are equivalent  to A[diÃ¢ÂˆÂ’1 Ux] and E[diÃ¢ÂˆÂ’1 Ux], and that R and U are duals.  In the presence of arbitrary negation, universal operators are definable by existential  operators and vice versa. Hence, from Proposition 3.4 we obtain the following corollary.  Corollary 3.5. The model checking problem CTL-MC(T ) is P-hard for each nonempty set  T of CTL-operators.  Returning to monotone CTL, in most cases even one operator suffices to make model  checking P-hard:  Proposition 3.6. Let T denote a set of CTL-operators. Then CTLmon -MC(T ) is P-hard  if T contains at least one of the operators EG, EU, ER, AF, AU, or AR.  Proof. We modify the proof of Proposition 3.4 to work with EG only. The remaining fragments follow from the closure of P under complementation and FÄŽÂ‡ Ã¢Â‰Ä„ Ã‚Å¹GÃ‚Å¹ÄŽÂ‡ Ã¢Â‰Ä„ [Ã¢ÂŠÂ¤UÄŽÂ‡],  [ÄŽÂ‡UÄŽÂ€] Ã¢Â‰Ä„ Ã‚Å¹[Ã‚Å¹ÄŽÂ‡RÃ‚Å¹ÄŽÂ€].  10  O. BEYERSDORFF, A. MEIER, M. MUNDHENK, T. SCHNEIDER, M. THOMAS, AND H. VOLLMER  0  d 0 c1  0  d 0 c2  0  d 0 c1  Ã‚Ë‡Ã‚Ë‡Ã‚Ë‡  1  d 1 c1  d1  c12  1  d 1 c1  d0  d1  Ã‚Ë‡Ã‚Ë‡Ã‚Ë‡  c21  d2  2  d 2 c2  c21  d2  d1  ..  .  p(n)  dp(n c1  )  p(n  t,d c2 )  p(n)  c0  Ã‚Ë‡Ã‚Ë‡Ã‚Ë‡  d0  q(n)  d2  ..  .  d1  c2  p(n)  dp(n c1  )  Ã‚Ë‡Ã‚Ë‡Ã‚Ë‡  d2  ..  .  ..  .  Ã‚Ë‡Ã‚Ë‡Ã‚Ë‡  t,d  cp(n)  q  p(n) (n)  layer  1  d2  ..  .  q  p(n) (n)  layer  2  c2  d2  ..  .  ..  .  ..  .  q(n)  ..  .  p(n  t,d c2 )  p(n)  t,d  z  Ã‚Ë‡Ã‚Ë‡Ã‚Ë‡  p(n)  dp(n c1  cp(n)  q(n)  2  d 2 c2  )  Ã‚Ë‡Ã‚Ë‡Ã‚Ë‡  c1  d1  c21  c2  p(n  t,d c2 )  p(n)  Ã‚Ë‡Ã‚Ë‡Ã‚Ë‡  q(n)  q(n)  q(n)  c12  c1  Ã‚Ë‡Ã‚Ë‡Ã‚Ë‡  q(n)  c0  d0  1  d 1 c1  d1  Ã‚Ë‡Ã‚Ë‡Ã‚Ë‡  q(n)  ..  .  ..  .  Ã‚Ë‡Ã‚Ë‡Ã‚Ë‡  q(n)  c12  c1  0  d 0 c2  c0  2  d 2 c2  Ã‚Ë‡Ã‚Ë‡Ã‚Ë‡  ..  .  0  d 0 c1  0  d 0 c2  Ã‚Ë‡Ã‚Ë‡Ã‚Ë‡  p(n)  t,d cq(n)  p(n)  layer  q(  n) +  1  Figure 2: The Kripke structure K Ã¢Â€Ë› ; dashed (resp. solid) arrows correspond to transitions  leaving existential (resp. universal) configurations.  Let the machine M , the word x, the polynomials p, q, and K be as above. Further  assume w.l.o.g. that M branches only binary in each step. Denote by WÃ¢ÂˆÂƒ (resp. WÃ¢ÂˆÂ€ ) the  set of states corresponding to existential (resp. universal) configurations. The purpose  of the introduced layers below is to ensure the uniqueness of the successors of universal  configurations which is essential in the construction of ÄŽÂˆi later. We construct a Kripke  structure K Ã¢Â€Ë› := (W Ã¢Â€Ë› , R, ÃŽË‡) consisting of q(n) + 1 layers and a Ã¢Â€Â˜trapÃ¢Â€Â™ as follows: let W Ã¢Â€Ë› :=  W Ä‚Â— {1, . . . , q(n) + 1} Ã¢ÂˆÅž {z}. The transition relation R Ã¢ÂŠÂ† W Ã¢Â€Ë› Ä‚Â— W Ã¢Â€Ë› is defined as       cj Ã¢ÂˆÂˆ WÃ¢ÂˆÂƒ , M reaches ck from ci in one step,  j  j+1  i  R := (ci , Ã¢Â„Â“), (ck , Ã¢Â„Â“)  1 Ã¢Â‰Â¤ Ã¢Â„Â“ Ã¢Â‰Â¤ q(n) + 1, 0 Ã¢Â‰Â¤ j < p(n)    ÄÅÄ… j  ÄÅÅº  j+1  (c  ,  Ã¢Â„Â“),  (c  ,  i)  ,  ÄÅË› i  j  k   c Ã¢ÂˆÂˆ WÃ¢ÂˆÂ€ , M reaches ck and ckÃ¢Â€Ë› from ci inÄÅË  j+1  Ã¢ÂˆÅž  (cj+1  ,  i),  (c  ,  q(n)  +  1)  , i  Ã¢Â€Ë›  k    one step, ck Ã¢Â‰Â¤ ckÃ¢Â€Ë› , 0 Ã¢Â‰Â¤ j < p(n)  ÄÅÅ‚ kj+1  ÄÅÅ¾  (ckÃ¢Â€Ë› , q(n) + 1), z   p(n)    p(n)  Ã¢ÂˆÅž  (ci , Ã¢Â„Â“), (ci , Ã¢Â„Â“) | 1 Ã¢Â‰Â¤ i Ã¢Â‰Â¤ q(n), 1 Ã¢Â‰Â¤ Ã¢Â„Â“ Ã¢Â‰Â¤ q(n) + 1  Ã¢ÂˆÅž (z, z) .  That is, the arcs leaving an existential configurations ci lead to the successor configurations  of ci inside each layer; while any universal configuration ci has exactly one outgoing arc  pointing to its (lexicographically) first successor configuration in the layer i, from where  another arc leads to the second successor of ci in layer q(n) + 1, which in turn has an  outgoing arc to the state z (see Figure 2). The labelling function ÃŽË‡ is defined as ÃŽË‡(z) := {z},  ÃŽË‡((cji , Ã¢Â„Â“)) := {Ã¢Â„Â“, dj , t} if ci is an accepting configuration, and otherwise ÃŽË‡((cji , Ã¢Â„Â“)) := {Ã¢Â„Â“, dj }  for (1 Ã¢Â‰Â¤ Ã¢Â„Â“ Ã¢Â‰Â¤ q(n) + 1). Define  (  EG(diÃ¢ÂˆÂ’1 Ã¢ÂˆÂ¨ (di Ã¢ÂˆÂ§ x) Ã¢ÂˆÂ¨ z), if M Ã¢Â€Â™s configurations before step i are universal,  ÄŽÂˆi (x) :=  EG(Di Ã¢ÂˆÂ¨ x), if M Ã¢Â€Â™s configurations before step i are existential,  MODEL CHECKING CTL IS ALMOST ALWAYS INHERENTLY SEQUENTIAL Ã¢ÂˆÂ—  11  W  and Di = i6=jÃ¢ÂˆÂˆ{0,...,p(n)} dj . The correctness of the equivalence K, w |= AF(di Ã¢ÂˆÂ§ x) iff    K Ã¢Â€Ë› , (w, Ã¢Â„Â“) |= EG diÃ¢ÂˆÂ’1 Ã¢ÂˆÂ¨ (di Ã¢ÂˆÂ§ x) Ã¢ÂˆÂ¨ z) , for all w Ã¢ÂˆÂˆ WÃ¢ÂˆÂ€ , 1 Ã¢Â‰Â¤ Ã¢Â„Â“ Ã¢Â‰Â¤ q(n) + 1 and 1 Ã¢Â‰Â¤ i Ã¢Â‰Â¤ p(n)  can be verified through the following observations. Ã¢Â‡Â’: if di and x hold in all successors  of w in K, then there exists a path from (w, Ã¢Â„Â“) to both of the series-connected successors  reaching the trap and looping there. This is the only possibility for the path as neither diÃ¢ÂˆÂ’1  nor di hold below that level. As in each successor configuration the subformula di Ã¢ÂˆÂ§ x must  be satisfied the composition of the ÄŽÂˆi s ensures that in each such state there must start an  EG-path for each universal successor. Ã¢Â‡Â: the only path which satisfies at least one of the  three disjuncts ranges through both series-connected successor configurations and ends in  the trap. For each of the two successor states di and x hold. Thus AF(di Ã¢ÂˆÂ§ x) is true in the  state w in the structure K.  From this, it easily follows that for        M accepts x Ã¢Â‡ÂÃ¢Â‡Â’ K Ã¢Â€Ë› , (c01 , 1) |= ÄŽÂˆ1 ÄŽÂˆ2 Ã‚Ë‡ Ã‚Ë‡ Ã‚Ë‡ ÄŽÂˆp(n) (t) Ã‚Ë‡ Ã‚Ë‡ Ã‚Ë‡ .  As we essentially only duplicated the set of states in K and R can be constructed from all  triples of states in W Ã¢Â€Ë› , K Ã¢Â€Ë› remains AC0 constructible. Concluding A Ã¢Â‰Â¤cd CTLmon -MC({EG})  for all A Ã¢ÂˆÂˆ P.  By Lemma 2.1, CTLmon -MC(T ) Ã¢Â‰Â¤cd CTLpos -MC(T ) and hence the above results  directly translate to model checking for CTLpos : for any set T of temporal operators,  CTLpos -MC(T ) is P-hard if T * {EX, EF} or if T * {AX, AG}. These results cannot  be improved w.r.t. T , as for T Ã¢ÂŠÂ† {EX, EF} and T Ã¢ÂŠÂ† {AX, AG} we obtain a LOGCFL upper  bound for model checking from Proposition 3.3. In the following proposition we prove the  matching LOGCFL lower bound.  Proposition 3.7. For every nonempty set T of CTL-operators, the model checking problem  CTLmon -MC(T ) is LOGCFL-hard.  Proof. As explained in Section 2.3, LOGCFL can be characterized as the set of languages  recognizable by logtime-uniform SAC1 circuits, i.e., circuits of logarithmic depth and polynomial size consisting of Ã¢ÂˆÂ¨-gates with unbounded fan-in and Ã¢ÂˆÂ§-gates with fan-in 2. For  every single CTL-operator O, we will show that CTLmon -MC(T ) is LOGCFL-hard for all  T Ã¢ÂŠÂ‡ {O} by giving a generic Ã¢Â‰Â¤cd -reduction f from the word problem for SAC1 circuits to  CTLmon -MC(T ).  First, consider EX Ã¢ÂˆÂˆ T . Let C be a logtime-uniform SAC1 circuit of depth Ã¢Â„Â“ with  n inputs and let x = x1 . . . xn Ã¢ÂˆÂˆ {0, 1}n . Assume w.l.o.g. that C is connected, layered  into alternating layers of Ã¢ÂˆÂ§-gates and Ã¢ÂˆÂ¨-gates, and that the output gate of C is an Ã¢ÂˆÂ¨gate. We number the layers bottom-up, that is, the layer containing (only) the output gate  has level 0, whereas the input-gates and negations of the input-gates are situated in layer  Ã¢Â„Â“. Denote the graph of C by G = (V, E), where V := Vin Ã¢ÂŠÂŽ VÃ¢ÂˆÂ§ Ã¢ÂŠÂŽ VÃ¢ÂˆÂ¨ is partitioned into  the sets corresponding to the (possibly negated) input-gates, the Ã¢ÂˆÂ§-gates, and the Ã¢ÂˆÂ¨-gates,  respectively. G is acyclic and directed with paths leading from the input to the output  gates. From (V, E) we construct a Kripke structure that allows to distinguish the two  predecessors of an Ã¢ÂˆÂ§-gate from each other. This will be required to model proof trees using  CTLmon ({EX})-formulae.  12  O. BEYERSDORFF, A. MEIER, M. MUNDHENK, T. SCHNEIDER, M. THOMAS, AND H. VOLLMER  i  For i Ã¢ÂˆÂˆ {1, 2}, let Vini := {v i | v Ã¢ÂˆÂˆ Vin }, VÃ¢ÂˆÂ¨i := {v i | v Ã¢ÂˆÂˆ VÃ¢ÂˆÂ¨ } and define Vin,Ã¢ÂˆÂ¨  := Vini Ã¢ÂˆÅž VÃ¢ÂˆÂ¨i .  Further define    i  E Ã¢Â€Ë› := (v, ui ) Ã¢ÂˆÂˆ VÃ¢ÂˆÂ§ Ä‚Â— Vin,Ã¢ÂˆÂ¨  | (u, v) Ã¢ÂˆÂˆ E and u is the ith predecessor of v  [     i  1  2  (v i , u) Ã¢ÂˆÂˆ Vin,Ã¢ÂˆÂ¨  Ä‚Â— VÃ¢ÂˆÂ§ | (u, v) Ã¢ÂˆÂˆ E ,  Ã¢ÂˆÅž (v, v) | v Ã¢ÂˆÂˆ Vin Ã¢ÂˆÅž Vin Ã¢ÂˆÅž  iÃ¢ÂˆÂˆ{1,2}  where the ordering of the predecessors is implicitly given in the encoding of C. We now  1 Ã¢ÂˆÅž V 2 Ã¢ÂˆÅž V , transition  define a Kripke structure K := (V Ã¢Â€Ë› , E Ã¢Â€Ë› , ÃŽË‡) with states V Ã¢Â€Ë› := Vin,Ã¢ÂˆÂ¨  Ã¢ÂˆÂ§  in,Ã¢ÂˆÂ¨  relation E Ã¢Â€Ë› , and labelling function ÃŽË‡ : V Ã¢Â€Ë› Ã¢Â†Â’ P({1, 2, t}),  ÄÅÄ…  i  i  ÄÅÂ´  ÄÅË›{i, t}, if (v = vinj Ã¢ÂˆÂˆ Vin and xj = 1) or (v = v inj Ã¢ÂˆÂˆ Vin and xj = 0),  ÃŽË‡(v) := {i},  if (v = vinj Ã¢ÂˆÂˆ Vini and xj = 0) or (v = v inj Ã¢ÂˆÂˆ Vini and xj = 1) or v Ã¢ÂˆÂˆ VÃ¢ÂˆÂ¨i ,  ÄÅÂ´  ÄÅÅ‚  Ã¢ÂˆÂ…,  otherwise,  where i = 1, 2, j = 1, . . . , n and vin1 , . . . , vinn , v in1 , . . . , v inn enumerate the input gates  and their negations. The formula ÄŽÂ• that is to be evaluated on K will consist of atomic  propositions 1, 2 and t, Boolean connectives Ã¢ÂˆÂ§ and Ã¢ÂˆÂ¨, and the CTL-operator EX. To  construct ÄŽÂ• we recursively define formulae (ÄŽÂ•i )0Ã¢Â‰Â¤iÃ¢Â‰Â¤Ã¢Â„Â“ by  ÄÅÄ…  ÄÅÂ´  if i = Ã¢Â„Â“,  ÄÅË›t,  ÄŽÂ•i := EXÄŽÂ•i+1 ,  if i is even (Ã¢ÂˆÂ¨-layers),  ÄÅÂ´  ÄÅÅ‚V  i=1,2 EX(i Ã¢ÂˆÂ§ ÄŽÂ•i+1 ), if i is odd (Ã¢ÂˆÂ§-layers).  We define the reduction function f as the mapping (C, x) 7Ã¢Â†Â’ (K, v0 , ÄŽÂ•), where v0 is the  node corresponding to the output gate of C and ÄŽÂ• := ÄŽÂ•0 . We stress that the size of ÄŽÂ• is  polynomial, for the depth of C is logarithmic only. Clearly, each minimal accepting subtree  (cf. [Ruz80] or [Vol99, Definition 4.15]) of C on input x translates into a sub-structure K Ã¢Â€Ë›  of K such that K Ã¢Â€Ë› , v0 |= ÄŽÂ•, where  (1) K Ã¢Â€Ë› includes v0 ,  (2) K Ã¢Â€Ë› includes one successor for every node corresponding to an Ã¢ÂˆÂ¨-gate, and  (3) K Ã¢Â€Ë› includes the two successors of every node corresponding to an Ã¢ÂˆÂ§-gate.  As C(x) = 1 iff there exists a minimal accepting subtree of C on x, the LOGCFL-hardness  of CTLmon -MC(T ) for EX Ã¢ÂˆÂˆ T follows.  Second, consider EF Ã¢ÂˆÂˆ T . We have to extend our Kripke structure to contain information about the depth of the corresponding gate. We may assume w.l.o.g. that C is encoded  such that each gate contains an additional counter holding the distance to the output gate  (which is equal to the number of the layer it is contained in, cf. [Vol99]). We extend ÃŽË‡  to encode this distance i, 1 Ã¢Â‰Â¤ i Ã¢Â‰Â¤ Ã¢Â„Â“, into the Ã¢Â€Âœdepth-propositionsÃ¢Â€Â di as in the proof of  Proposition 3.4. Denote this modified Kripke structure by K Ã¢Â€Ë› . Further, we define (ÄŽÂ•Ã¢Â€Ë›i )0Ã¢Â‰Â¤iÃ¢Â‰Â¤Ã¢Â„Â“  as  ÄÅÄ…  ÄÅÂ´  if i = Ã¢Â„Â“,  ÄÅË›t,  Ã¢Â€Ë›  Ã¢Â€Ë›  ÄŽÂ•i := EF(di+1 Ã¢ÂˆÂ§ ÄŽÂ•i+1 ),  if i is even,  ÄÅÂ´  ÄÅÅ‚V  Ã¢Â€Ë›  i=1,2 EF(di+1 Ã¢ÂˆÂ§ i Ã¢ÂˆÂ§ ÄŽÂ•i+1 ), if i is odd.  Redefining the reduction f as (C, x) 7Ã¢Â†Â’ (K Ã¢Â€Ë› , v0 , ÄŽÂ•Ã¢Â€Ë›0 ) hence yields the LOGCFL-hardness of  CTLmon -MC(T ) for EF Ã¢ÂˆÂˆ T .  Third, consider AX Ã¢ÂˆÂˆ T . Consider the reduction in case 1 for CTLmon ({EX})-formulae,  and let f (C, x) = (K, v0 , ÄŽÂ•) be the value computed by the reduction function. It holds that  MODEL CHECKING CTL IS ALMOST ALWAYS INHERENTLY SEQUENTIAL Ã¢ÂˆÂ—  13  C(x) = 1 iff K, v0 |= ÄŽÂ•, and equivalently C(x) = 0 iff K, v0 |= Ã‚Å¹ÄŽÂ•. Let ÄŽÂ•Ã¢Â€Ë› be the formula  obtained from Ã‚Å¹ÄŽÂ• by multiplying the negation into the formula. Then ÄŽÂ•Ã¢Â€Ë› is a CTLa.n. ({AX})formula. Since LOGCFL is closed under complement, it follows that CTLa.n. -MC({AX}) is  LOGCFL-hard. Using Lemma 2.1, we obtain that CTLmon -MC({AX}) is LOGCFL-hard,  too. An analogous argument works for the case AG Ã¢ÂˆÂˆ T . The remaining fragments are even  P-complete by Proposition 3.6.  Using Lemma 2.1 we obtain LOGCFL-hardness of CTLpos -MC(T ) for all nonempty  sets T of CTL-operators.  In the absence of CTL-operators, the lower bound for the model checking problem again  follows from the lower bound for evaluating monotone propositional formulae. This problem  is known to be hard for NC1 [Bus87, Sch10].  3.3. The Power of Negation. We will now show that model checking for the fragments  CTLa.n. and CTLpos is computationally equivalent to model checking for CTLmon , for any  set T of CTL-operators. Since we consider Ã¢Â‰Â¤cd -reductions, this is not immediate.  From Lemma 2.1 it follows that the hardness results for CTLmon -MC(T ) also hold for  CTLa.n. -MC(T ) and CTLpos -MC(T ). Moreover, the algorithms for CTLpos -MC(T ) also  work for CTLmon -MC(T ) and CTLa.n. -MC(T ) without using more computation resources.  Both observations together yield the same completeness results for all CTL-fragments with  restricted negations.  Theorem 3.8. Let T be any set of CTL-operators. Then CTLmon -MC(T ), CTLa.n. -MC(T ),  and CTLpos -MC(T ) are  Ã¢ÂˆÂ’ NC1 -complete if T is empty,  Ã¢ÂˆÂ’ LOGCFL-complete if Ã¢ÂˆÂ… ( T Ã¢ÂŠÂ† {EX, EF} or Ã¢ÂˆÂ… ( T Ã¢ÂŠÂ† {AX, AG},  Ã¢ÂˆÂ’ P-complete otherwise.  Moreover, the problems CTLmon -MC(T ), CTLa.n. -MC(T ), and CTLpos -MC(T ) are equivalent w.r.t. Ã¢Â‰Â¤cd -reductions.  This equivalence extends Lemma 2.1. We remark that this equivalence is not straightforward. Simply applying de MorganÃ¢Â€Â™s laws to transform one problem into another requires  counting the number of negations on top of Ã¢ÂˆÂ§- and Ã¢ÂˆÂ¨-connectives. This counting cannot  be achieved by an AC0 -circuit and does not lead to the aspired reduction. Here we obtain  equivalence of the problems as a consequence of our generic hardness proofs in Section 3.2.  4. Model Checking Extensions of CTL  It has been argued that CTL lacks the ability to express fairness properties. To address  this shortcoming, Emerson and Halpern introduced ECTL in [EH86]. ECTL extends CTL  Ã¢ÂˆÂž  with the F-operator, which states that for every moment in the future, the enclosed formula  will eventually be satisfied again: for a Kripke structure K, a path x = (x1 , x2 , . . . ), and a  path formula ÄŽÂ‡  Ã¢ÂˆÂž  K, x |= FÄŽÂ‡ iff K, xi |= FÄŽÂ‡ for all i Ã¢ÂˆÂˆ N.  Ã¢ÂˆÂž  The dual operator G is defined analogously. As for CTL, model checking for ECTL is known  to be tractable. Moreover, our next result shows that even for all fragments, model checking  for ECTL is not harder than for CTL.  14  O. BEYERSDORFF, A. MEIER, M. MUNDHENK, T. SCHNEIDER, M. THOMAS, AND H. VOLLMER  Ã¢ÂˆÂž  Algorithm 2 Case distinction for EF  Ã¢ÂˆÂž  1:  2:  3:  4:  else if ÄŽÂ• = EFÃŽÄ… then  nondet. choose k Ã¢Â‰Â¤ |W | and a path (wi )1Ã¢Â‰Â¤iÃ¢Â‰Â¤k such that (w, w1 ) Ã¢ÂˆÂˆ RÃ¢Â‹Â† , (wk , w1 ) Ã¢ÂˆÂˆ R  nondet. choose some 1 Ã¢Â‰Â¤ i Ã¢Â‰Â¤ k and push(S, (ÃŽÄ…, wi ))  end if  Theorem 4.1. Let T be a set of temporal operators. Then ECTL-MC(T ) Ã¢Â‰Ä„cd CTL-MC(T Ã¢Â€Ë› )  Ã¢ÂˆÂž  and ECTLpos -MC(T ) Ã¢Â‰Ä„cd CTLpos -MC(T Ã¢Â€Ë› ), where T Ã¢Â€Ë› is obtained from T by substituting F  Ã¢ÂˆÂž  with F and G with G.  Ã¢ÂˆÂž  Ã¢ÂˆÂž  Proof. For the upper bounds, notice that ECTL-MC(ALL Ã¢ÂˆÅž {EF, AF}) Ã¢ÂˆÂˆ P. It thus remains  Ã¢ÂˆÂž  Ã¢ÂˆÂž  to show that ECTLpos -MC(T ) Ã¢ÂˆÂˆ LOGCFL for T Ã¢ÂŠÂ† {EX, EF, EF} and T Ã¢ÂŠÂ† {AX, AG, AG}  Ã¢ÂˆÂž  Ã¢ÂˆÂž  First, consider the case that T Ã¢ÂŠÂ† {EX, EF, EF}. We modify Algorithm 1 to handle EF by  extending the case distinction in lines 4Ã¢Â€Â“19 with the code fragment given in Algorithm 1.  Ã¢ÂˆÂž  The algorithm for T Ã¢ÂŠÂ† {AX, AG, AG} is analogous and membership in LOGCFL follows  from its closure under complementation.  For the lower bounds, we extend the proofs of Propositions 3.4, 3.6 and 3.7 to handle  Ã¢ÂˆÂž  Ã¢ÂˆÂž  Ã¢ÂˆÂž  Ã¢ÂˆÂž  sets T involving also the operators AF, AG, EF, and EG. Therefore, we only need modify  the accessibility relation R of respective Kripke structure K to be reflexive. The hardness  Ã¢ÂˆÂž  Ã¢ÂˆÂž  results follow by replacing F with F and G with G in the respective reductions.  First consider the case that T contains an existential and a universal operator, say  Ã¢ÂˆÂž  Ã¢ÂˆÂž  T = {AF, EG}. Let M , x, and p be defined as in the proof of Proposition 3.4. We map (M, x)  to (KÄšÂƒ, c01 , ÄŽÂˆ1 ), where KÄšÂƒ = (W, R, ÃŽË‡) is the reflexive closure of the Kripke   structure K defined      0  for the P-hardness of CTL-MC({AF, EG}), c1 Ã¢ÂˆÂˆ W , and ÄŽÂˆ := ÄŽÂˆ1 ÄŽÂˆ2 Ã‚Ë‡ Ã‚Ë‡ Ã‚Ë‡ ÄŽÂˆp(n) (t) Ã‚Ë‡ Ã‚Ë‡ Ã‚Ë‡ ,  where  ( Ã¢ÂˆÂž  AF(di Ã¢ÂˆÂ§ x), if M Ã¢Â€Â™s configurations in step i are universal,  ÄŽÂˆi (x) :=  Ã¢ÂˆÂž  EG(Di Ã¢ÂˆÂ¨ x), otherwise,  In KÄšÂƒ it now holds that di Ã¢ÂˆÂˆ ÃŽË‡(w) and (w, wÃ¢Â€Ë› ) Ã¢ÂˆÂˆ R together imply that either w = wÃ¢Â€Ë› or  Ã¢ÂˆÂž  di Ã¢ÂˆÂˆ  / ÃŽË‡(wÃ¢Â€Ë› ). Hence, for all w Ã¢ÂˆÂˆ W and 1 Ã¢Â‰Â¤ i Ã¢Â‰Â¤ p(|x|), KÄšÂƒ, w |= AF(di Ã¢ÂˆÂ§x) iff K, w |= AF(di Ã¢ÂˆÂ§x),  Ã¢ÂˆÂž W  W  and KÄšÂƒ, w |= EG( i6=jÃ¢ÂˆÂˆ{0,...,p(n)} dj Ã¢ÂˆÂ¨ x) iff K, w |= EG( i6=jÃ¢ÂˆÂˆ{0,...,p(n)} dj Ã¢ÂˆÂ¨ x). From this,  correctness of the reduction follows. The P-hardness of CTL-MC(T ) for the remaining  fragments follows analogously.  Ã¢ÂˆÂž  As for T Ã¢ÂŠÂ† {EX, EF, EF}, we will show that ECTLmon -MC(T ) is LOGCFL-hard under  Ã¢ÂˆÂž  Ã¢Â‰Â¤cd -reductions for T = {EF}. Let C, x, and Ã¢Â„Â“ be as in the proof of Proposition 3.7. We  map the pair (C, x) to the triple (KÄšÂƒ Ã¢Â€Ë› , v0 , ÄŽÂ•0 ), where KÄšÂƒ Ã¢Â€Ë› = (V Ã¢Â€Ë› , E Ã¢Â€Ë› , ÃŽË‡) is the reflexive closure  of the Kripke structure K Ã¢Â€Ë› defined for the LOGCFL-hardness of CTL-MC({EF}), v0 Ã¢ÂˆÂˆ V Ã¢Â€Ë› ,  and ÄŽÂ•0 is recursively defined via (ÄŽÂ•Ã¢Â€Ë›i )0Ã¢Â‰Â¤iÃ¢Â‰Â¤Ã¢Â„Â“ as  ÄÅÄ…  ÄÅÂ´  if i = Ã¢Â„Â“,  ÄÅË›t,Ã¢ÂˆÂž  ÄŽÂ•i := EF(di+1 Ã¢ÂˆÂ§ ÄŽÂ•i+1 ),  if i is even,  ÄÅÂ´  Ã¢ÂˆÂž  ÄÅÅ‚V  i=1,2 EF(di+1 Ã¢ÂˆÂ§ i Ã¢ÂˆÂ§ ÄŽÂ•i+1 ), if i is odd.  Again, we have that in KÄšÂƒ Ã¢Â€Ë› , di Ã¢ÂˆÂˆ ÃŽË‡(v) and (v, v Ã¢Â€Ë› ) Ã¢ÂˆÂˆ E Ã¢Â€Ë› together imply that either v = v Ã¢Â€Ë› or  Ã¢ÂˆÂž  di Ã¢ÂˆÂˆ  / ÃŽË‡(v Ã¢Â€Ë› ). It hence follows KÄšÂƒ Ã¢Â€Ë› , v |= EF(di Ã¢ÂˆÂ§ ÄŽÂ•i ) iff K Ã¢Â€Ë› , v |= EF(di Ã¢ÂˆÂ§ ÄŽÂ•i ), for all v Ã¢ÂˆÂˆ V Ã¢Â€Ë› and  MODEL CHECKING CTL IS ALMOST ALWAYS INHERENTLY SEQUENTIAL Ã¢ÂˆÂ—  Ã¢ÂˆÂž  15  Ã¢ÂˆÂž  1 Ã¢Â‰Â¤ i Ã¢Â‰Â¤ Ã¢Â„Â“. We conclude that ECTLmon -MC({EF}) is LOGCFL-hard. The case T = {AG}  follows analogously.  We will now consider CTL+ , the extension of CTL by Boolean combinations of path  formulae which is defined as follows. A CTL+ -formula is a CTLÃ¢Â‹Â† -formula where each pure  temporal operator in a state formula occurs in the scope of a path quantifier. The set of  all CTL-formulae is a strict subset of the set of all CTL+ -formulae, which again forms a  strict subset of the set of all CTLÃ¢Â‹Â† -formulae. For example, AGEFp and A(Gp Ã¢ÂˆÂ§ Fq) are  CTL+ -formulae, but AGFp is not. However, CTL is as expressive as CTL+ [EH85].  By CTL+ (T ) we denote the set of CTL+ -formulae using the connectives {Ã¢ÂˆÂ§, Ã¢ÂˆÂ¨, Ã‚Å¹}  and temporal operators in T only. Analogous to the fragments CTLpos (T ), CTLa.n. (T ),  +  +  and CTLmon (T ), we define CTL+  pos (T ), CTLa.n. (T ), and CTLmon (T ) as those fragments  +  of CTL (T ) that disallow temporal operators in the scope of negations, contain negation  signs only directly in front of atomic propositions, and do not contain negation signs at all,  respectively.  In contrast to CTL, model checking for CTL+ is not tractable, but Ã¢ÂˆÂ†p2 -complete  [LMS01]. Below we classify the complexity of model checking for both the full and the  positive fragments of CTL+ .  Theorem 4.2. Let T be a set of temporal operators containing at least one path quantifier.  Then CTL+ -MC(T ) is  Ã¢ÂˆÂ’ NC1 -complete if T Ã¢ÂŠÂ† {A, E},  Ã¢ÂˆÂ’ P-complete if {X} ( T Ã¢ÂŠÂ† {A, E, X}, and  Ã¢ÂˆÂ’ Ã¢ÂˆÂ†p2 -complete otherwise.  Proof. If T Ã¢ÂŠÂ† {A, E} then deciding CTL+ -MC(T ) is equivalent to the problem of evaluating  a propositional formula, which is known to be NC1 -complete [Bus87, Sch10].  If {X} ( T Ã¢ÂŠÂ† {A, E, X}, then CTL+ -MC(T ) can be solved using a labelling algorithm:  Let K = (W, R, ÃŽË‡) be a Kripke structure, and ÄŽÂ• be a CTL+ ({A, E, X})-formula. Assume  w.l.o.g. that ÄŽÂ• starts with an E and that it does not contain any AÃ¢Â€Â™s. Compute K, w |= ÄŽÂˆ for  all w Ã¢ÂˆÂˆ W and all subformulae EÄŽÂˆ of ÄŽÂ• such that ÄŽÂˆ is free of path quantifiers, and replace  EÄŽÂˆ in ÄŽÂ• with a new proposition pÄŽÂˆ while extending the labelling function ÃŽË‡ such that  pÄŽÂˆ Ã¢ÂˆÂˆ ÃŽË‡(w) Ã¢Â‡ÂÃ¢Â‡Â’ K, w |= ÄŽÂˆ. Repeat this step until ÄŽÂ• is free of path quantifiers and denote  the resulting (propositional) formula by ÄŽÂ•Ã¢Â€Ë› . To decide whether K, w |= ÄŽÂ• for some w Ã¢ÂˆÂˆ W , it  now suffices to check whether ÄŽÂ•Ã¢Â€Ë› is satisfied by the assignment implied by ÃŽË‡(w). As for all of  the above subformulae EÄŽÂˆ of ÄŽÂ•, ÄŽÂˆ Ã¢ÂˆÂˆ CTL+ ({X}), it follows that K, w |= ÄŽÂˆ can be determined  in polynomial time in the size of K and ÄŽÂˆ. Considering that the number of labelling steps  is at most O(|ÄŽÂ•| Ã‚Ë‡ |W |) it follows that CTL+ -MC(T ) is in P. The P-hardness follows from  CTL-MC({EX}) Ã¢Â‰Â¤cd CTL+ -MC({E, X}) resp. CTL-MC({AX}) Ã¢Â‰Â¤cd CTL+ -MC({A, X}).  For all other possible sets T , we have T Ã¢ÂˆÅ {E, A} =  6 Ã¢ÂˆÂ… and T Ã¢ÂˆÅ {F, G, U} =  6 Ã¢ÂˆÂ…. Consequently,  each of the temporal operators A, E, F, and G can be expressed in CTL+ (T ). The claim  now follows from [LMS01].  For the positive fragments of CTL+ we obtain a more complex picture:  Theorem 4.3. Let T be a set of temporal operators containing at least one path quantifier.  Then CTL+  pos -MC(T ) is  Ã¢ÂˆÂ’ NC1 -complete if T Ã¢ÂŠÂ† {A, E},  Ã¢ÂˆÂ’ LOGCFL-complete if T = {A, X} or T = {E, X},  16  O. BEYERSDORFF, A. MEIER, M. MUNDHENK, T. SCHNEIDER, M. THOMAS, AND H. VOLLMER  Ã¢ÂˆÂ’ P-complete if T = {A, E, X},  Ã¢ÂˆÂ’ NP-complete if E Ã¢ÂˆÂˆ T , A 6Ã¢ÂˆÂˆ T and T contains a pure temporal operator aside from X,  Ã¢ÂˆÂ’ coNP-complete if A Ã¢ÂˆÂˆ T , E 6Ã¢ÂˆÂˆ T and T contains a pure temporal operator aside from X,  and  Ã¢ÂˆÂ’ Ã¢ÂˆÂ†p2 -complete otherwise.  Proof. The first and third claim follow from Theorem 4.2 and the monotone formula value  problem being NC1 -complete [Sch10].  For the second claim, consider the case T = {E, X}. It is straightforward to adopt  Algorithm 1 to guess a successor wÃ¢Â€Ë› of the current state once for every path quantifier  E that has been read and decompose the formula w.r.t. wÃ¢Â€Ë› . For T = {A, X} analogous  arguments hold.  The fourth claim can be solved with a labelling algorithm analogously to the algorithm  for CTL+ -MC({A, E, X}). In this case, however, whole paths need to be guessed in the  Kripke structures. Hence, we obtain a polynomial time algorithm deciding CTL+  pos -MC(T )  using an oracle B Ã¢ÂˆÂˆ NP (resp. B Ã¢ÂˆÂˆ coNP) . This algorithm is furthermore a monotone Ã¢Â‰Â¤pT reduction from CTL+  pos -MC(T ) to B, in the sense that for any deterministic oracle Turing  machine M that executes the algorithm,  A Ã¢ÂŠÂ† B =Ã¢Â‡Â’ L(M, A) Ã¢ÂŠÂ† L(M, B),  where L(M, X) is the language recognized by M with oracle X. Both NP and coNP are  closed under monotone Ã¢Â‰Â¤pT -reductions [Sel82]. We thus conclude that CTL+  pos -MC(T ) Ã¢ÂˆÂˆ NP  (resp. CTL+  -MC(T  )  Ã¢ÂˆÂˆ  coNP).  pos  As for the NP-hardness of CTL+  pos -MC(T ), note that the reduction from 3SAT to  LTL-MC({F}), the model checking problem for linear temporal logic using the F-operator  only, given by Sistla and Clarke in [SC85] is a reduction to CTL+  pos -MC({E, F}) indeed.  The NP-hardness of CTL+  -MC({E,  G})  is  obtained  by  a  similar  reduction: let ÄŽÂ• be a  pos  Vn  propositional formula in 3CNF, i.e., ÄŽÂ• = i=1 Ci with Ci = Ã¢Â„Â“i1 Ã¢ÂˆÂ¨ Ã¢Â„Â“i2 Ã¢ÂˆÂ¨ Ã¢Â„Â“i3 and Ã¢Â„Â“ij = xk  or Ã¢Â„Â“ij = W  Ã‚Å¹xk for all 1 Ã¢Â‰Â¤ i Ã¢Â‰Â¤ n, all 1 WÃ¢Â‰Â¤ j Ã¢Â‰Â¤ 3, and some 1 Ã¢Â‰Â¤ k Ã¢Â‰Â¤ m. Recall that for  a set A, A denotes the disjunction aÃ¢ÂˆÂˆA a. We map ÄŽÂ• to the triple (K, y0 , ÄŽÂˆ), where  W  V W  K = (W, R, ÃŽË‡) is the Kripke structure given in (4.1) and ÄŽÂˆ := E ni=1 3j=1 G (ÃŽÅš \ {Ã¢ÂˆÅºÃ¢Â„Â“ij })  with ÃŽÅš := {y0 , yi , xi , xi | 1 Ã¢Â‰Â¤ i Ã¢Â‰Â¤ m} and Ã¢ÂˆÅºÃ¢Â„Â“ij denoting the complementary literal of Ã¢Â„Â“ij .  W := {y0 } Ã¢ÂˆÅž {xi , xi , yi | 1 Ã¢Â‰Â¤ i Ã¢Â‰Â¤ m},  R := {(yiÃ¢ÂˆÂ’1 , xi ), (xi , yi ), (yiÃ¢ÂˆÂ’1 , xi ), (xi , yi ) | 1 Ã¢Â‰Â¤ i Ã¢Â‰Â¤ m} Ã¢ÂˆÅž {(ym , ym )},  (4.1)  ÃŽË‡(w) := {w} for all w Ã¢ÂˆÂˆ W.  Note that the above reductions prove hardness for CTL+  mon -MC(T ) already. The coNP+  hardness of CTL+  pos -MC({A, G}) and CTLpos -MC({A, F}) follows from the same reductions.  As for the the last claim, note that the Ã¢ÂˆÂ†p2 -hardness of CTL+ -MC({A, E, F, G}) carries  +  over to CTL+  mon -MC({A, E, F, G}), because any CTL ({A, E, F, G})-formula can be trans+  formed into a CTLa.n. ({A, E, F, G})-formula, in which all negated atoms Ã‚Å¹p may be replaced  by fresh propositions p that are mapped into all states of the Kripke structure whose label  does not contain p. It thus remains to prove the Ã¢ÂˆÂ†p2 -hardness of CTL+  pos -MC({A, E, F}) and  +  +  CTLpos -MC({A, E, G}). Consider CTLpos -MC({A, E, G}). Laroussinie et al reduce from  SNSAT, that is the problem to decide, given disjoint sets Z1 , . . . , Zn of propositional variables from {z1 , . . . , zp } and a list ÄŽÂ•1 (Z1 ), ÄŽÂ•2 (x1 , Z2 ), . . . , ÄŽÂ•n (x1 , . . . , xn , Zn ) of formulae in  MODEL CHECKING CTL IS ALMOST ALWAYS INHERENTLY SEQUENTIAL Ã¢ÂˆÂ—  xn  xnÃ¢ÂˆÂ’1  s00  n  cn  cnÃ¢ÂˆÂ’1  xnÃ¢ÂˆÂ’1  s11  n  x1  Ã‚Ë‡Ã‚Ë‡Ã‚Ë‡  z1  z2  Ã‚Ë‡Ã‚Ë‡Ã‚Ë‡  zp  s11  1  z1  z2  Ã‚Ë‡Ã‚Ë‡Ã‚Ë‡  zp  c1  s10  1  s10  2  s11  nÃ¢ÂˆÂ’1  s00  1  s01  1  ...  s10  nÃ¢ÂˆÂ’1  s10  n  s00  2  s01  2  s01  nÃ¢ÂˆÂ’1  s01  n  xn  Ã‚Ë‡Ã‚Ë‡Ã‚Ë‡  s00  nÃ¢ÂˆÂ’1  17  s11  2  x1  Figure 3: Extended version of the Kripke structure constructed in [LMS01, Figure 3].  conjunctive normal form, whether xn holds in the unique valuation ÄŽÂƒ defined by  ÄŽÂƒ(xi ) = Ã¢ÂŠÂ¤ Ã¢Â‡ÂÃ¢Â‡Â’ ÄŽÂ•i (x1 , . . . , xiÃ¢ÂˆÂ’1 , Zi ) is satisfiable.  (4.2)  An instance I of SNSAT is transformed to the Kripke structure K depicted in Figure 3 and  the formula ÄŽÂˆ2nÃ¢ÂˆÂ’1 that is recursively defined as   _  n  n  n  _  _    01  10  11  x  Ã¢Â†Â’  6  ÄŽÂˆ  )  Ã¢ÂˆÂ¨  s  Ã¢ÂˆÂ¨  s  Ã¢ÂˆÂ¨  s  )  Ã¢ÂˆÂ§  F(  xi Ã¢Â†Â’ E Ã‚Å¹F (s00  ÄŽÂˆk := E G  i  kÃ¢ÂˆÂ’1  i  i  i  i  |  i=1  i=1  i=1  {z  (A)  Ã¢ÂˆÂ§ G  |  n  ^  Ã‚Å¹ci  i=1  {z  (B)    }  Ã¢ÂˆÂ§  n   ^  Fxi Ã¢Â†Â’  i=1  ^_  j  {z  |  m  (C)  }  FÃ¢Â„Â“i,j,m    }  ,  V W  for 1 Ã¢Â‰Â¤ k Ã¢Â‰Â¤ n, ÄŽÂˆ0 := Ã¢ÂŠÂ¤, and ÄŽÂ•i = j m Ã¢Â„Â“i,j,m, where the Ã¢Â„Â“i,j,mÃ¢Â€Â™s are literals over  {x1 , . . . , xn }Ã¢ÂˆÅž Zi . Note that the structure K from Figure 3 differs from the Kripke structure  constructed in [LMS01] in that we introduce different labels ci and sji for 1 Ã¢Â‰Â¤ i Ã¢Â‰Â¤ n and  j Ã¢ÂˆÂˆ {00, 01, 10, 11}, as we need to distinguish between the states later on. The intuitive  interpretation of (B) is that the existentially quantified path does actually encode an assignment of {x1 , . . . , xn } to {Ã¢ÂŠÄ½, Ã¢ÂŠÂ¤}, while (C) states that this assignment coincides with  ÄŽÂƒ on all propositions that are set to Ã¢ÂŠÂ¤. Lastly (A) expresses the recursion inherent in the  definition of SNSAT. It holds that I Ã¢ÂˆÂˆ SNSAT Ã¢Â‡ÂÃ¢Â‡Â’ K, xn |= ÄŽÂˆ2nÃ¢ÂˆÂ’1 (see [LMS01] for the  correctness of this argument).  We modify the given reduction to not use F. First note that ÄŽÂˆkÃ¢ÂˆÂ’1 occurs negatively in ÄŽÂˆk .  We will therefore consider the formulae ÄŽÂˆ2nÃ¢ÂˆÂ’1 , ÄŽÂˆ2nÃ¢ÂˆÂ’3 , . . . , ÄŽÂˆ1 and Ã‚Å¹ÄŽÂˆ2nÃ¢ÂˆÂ’2 , Ã‚Å¹ÄŽÂˆ2nÃ¢ÂˆÂ’4 , . . . , Ã‚Å¹ÄŽÂˆ2  separately. In ÄŽÂˆ2nÃ¢ÂˆÂ’1 , ÄŽÂˆ2nÃ¢ÂˆÂ’3 , . . . , ÄŽÂˆ1 replace  n  n  n  n  _  _  ^  _    00  01  10  11  ci Ã¢ÂˆÂ¨ Ã‚Å¹ÄŽÂˆkÃ¢ÂˆÂ’1 ) ,  xi Ã¢Â†Â’ E G (Ã‚Å¹si Ã¢ÂˆÂ§ Ã‚Å¹si Ã¢ÂˆÂ§ Ã‚Å¹si Ã¢ÂˆÂ§ Ã‚Å¹si ) Ã¢ÂˆÂ§ G( xi Ã¢ÂˆÂ¨  Ã¢ÂˆÂ’ (A) with G  i=1  i=1  n     ^  ^_ _  GÃ‚Å¹xi Ã¢ÂˆÂ¨  G (ÃŽÅš \ {Ã¢ÂˆÅºÃ¢Â„Â“i,j,m}) ;  Ã¢ÂˆÂ’ (C) with  i=1  j  i=1  m  and in Ã‚Å¹ÄŽÂˆ2nÃ¢ÂˆÂ’2 , Ã‚Å¹ÄŽÂˆ2nÃ¢ÂˆÂ’4 , . . . , Ã‚Å¹ÄŽÂˆ2 replace  _  _ _    (ÃŽÅš \ {xi }) Ã¢ÂˆÂ¨ A G( ÃŽÅš \ {ci }) Ã¢ÂˆÂ¨ G(ci Ã¢ÂˆÂ¨ ÄŽÂˆkÃ¢ÂˆÂ’1 ,  G  Ã¢ÂˆÂ’ (A) with  1Ã¢Â‰Â¤iÃ¢Â‰Â¤n  i=1  18  O. BEYERSDORFF, A. MEIER, M. MUNDHENK, T. SCHNEIDER, M. THOMAS, AND H. VOLLMER  Ã¢ÂˆÂ’ (B) with  Ã¢ÂˆÂ’ (C) with  n  _  G  i=2  n   _  _  01 01  11  (ÃŽÅš \ {s00  i , si , siÃ¢ÂˆÂ’1 , siÃ¢ÂˆÂ’1 }), and  G    _  _^  (ÃŽÅš \ {xi }) Ã¢ÂˆÂ§  GÃ‚Å¹Ã¢Â„Â“i,j,m ,  j m  00  01  10  {xi , xi , ci , si , si , si , s11  i |  i=1  1 Ã¢Â‰Â¤ i Ã¢Â‰Â¤ n} Ã¢ÂˆÅž {zi , z i | 1 Ã¢Â‰Â¤ i Ã¢Â‰Â¤ p} is the set of all  where ÃŽÅš :=  propositions used in K. Denote the resulting formulae by ÄŽÂˆkÃ¢Â€Ë› , k Ã¢Â‰Ä½ 0. In ÄŽÂˆkÃ¢Â€Ë› , all negations  are atomic and only the temporal operators E, A and G are used.  To verify that K, xk |= ÄŽÂˆk Ã¢Â‡ÂÃ¢Â‡Â’ K, xk |= ÄŽÂˆkÃ¢Â€Ë› for all 0 Ã¢Â‰Â¤ k < 2n, consider ÄŽÂˆk with k odd  first. Suppose K, xk |= ÄŽÂˆk . Then, by (A), there exists a path ÄŽÂ€ in K such that whenever  some xi is labelled in the current state ÄŽÂ€p , then there exists a path ÄŽÂ€ Ã¢Â€Ë› starting in ÄŽÂ€p that  never visits any state labelled with sji , 1 Ã¢Â‰Â¤ i Ã¢Â‰Â¤ n, j Ã¢ÂˆÂˆ {00, 01, 10, 11}, and eventually falsifies  ÄŽÂˆkÃ¢ÂˆÂ’1 because it reaches a state where neither xi nor ci holds for all 1 Ã¢Â‰Â¤ i Ã¢Â‰Â¤ n. Hence, by  construction of K, ÄŽÂ€ Ã¢Â€Ë› has to visit the states labelled with ci and xi for i such that xi Ã¢ÂˆÂˆ ÃŽË‡(ÄŽÂ€p ).  This is equivalent to the existence of a path ÄŽÂ€ Ã¢Â€Ë› starting in ÄŽÂ€p which never visits any state  labelled with sji , 1 Ã¢Â‰Â¤ i Ã¢Â‰Â¤ n, j Ã¢ÂˆÂˆ {00, 01, 10, 11}, and that falsifies ÄŽÂˆkÃ¢ÂˆÂ’1 if the current state is  not labelled with ci or xi for all 1 Ã¢Â‰Â¤ i Ã¢Â‰Â¤ n. Hence the substitution performed on (A) does  not alter the set of states in K on which the formula is satisfied.  The formula (C), on the other hand, states that whenever the path ÄŽÂ€ quantified by the  outmost E in ÄŽÂˆk visits the state labelled xi , then for every clause j in the ith formula ÄŽÂ•i of  given SNSAT instance at least one literal Ã¢Â„Â“i,j,m occurs in the labels on ÄŽÂ€ (i.e., ÄŽÂ•i is satisfied  by the assignment induced by ÄŽÂ€). The path ÄŽÂ€ is guaranteed to visit either a state labelled  xi or a state labelled xi but not both, by virtue of the subformula (B). Therefore, the  eventual satisfaction of xi is equivalent to globally satisfying Ã‚Å¹xi , whereas the satisfaction  of ÄŽÂ•i can be asserted by requiring that for any clause some literal is globally absent from  the labels on ÄŽÂ€. Thus the substitution performed on (C) does not alter the set of states on  which the formula is satisfied either. Concluding, K, xk |= ÄŽÂˆk Ã¢Â‡ÂÃ¢Â‡Â’ K, xk |= ÄŽÂˆkÃ¢Â€Ë› for all odd  0 Ã¢Â‰Â¤ k < 2n.  Now, if k is even, then   _  n  n  n  _  _    00  01  10  11  xi Ã¢ÂˆÂ§ A F (si Ã¢ÂˆÂ¨ si Ã¢ÂˆÂ¨ si Ã¢ÂˆÂ¨ si ) Ã¢ÂˆÂ¨ G( xi Ã¢Â†Â’ ÄŽÂˆkÃ¢ÂˆÂ’1 )  Ã‚Å¹ÄŽÂˆk Ã¢Â‰Ä„ A F  |  i=1  i=1  i=1  {z  }  (A)  n  n     _    _  _^  Ã¢ÂˆÂ¨ F  ci Ã¢ÂˆÂ¨  Fxi Ã¢ÂˆÂ§  GÃ‚Å¹Ã¢Â„Â“i,j,m .  |  i=1  {z  (B)  }  i=1  |  j  {z  m  (C)  }  Here, (A) asserts that on all paths ÄŽÂ€ there is a state ÄŽÂ€p such that xi Ã¢ÂˆÂˆ ÃŽË‡(ÄŽÂ€p ) for some  1 Ã¢Â‰Â¤ i Ã¢Â‰Â¤ n and all paths ÄŽÂ€ Ã¢Â€Ë› starting in ÄŽÂ€p eventually visit a state labelled with sji , 1 Ã¢Â‰Â¤ i Ã¢Â‰Â¤ n,  j Ã¢ÂˆÂˆ {00, 01, 10, 11}, or satisfy ÄŽÂˆkÃ¢ÂˆÂ’1 whenever xi Ã¢ÂˆÂˆ ÃŽË‡(ÄŽÂ€p ) for some 1 Ã¢Â‰Â¤ i Ã¢Â‰Â¤ n. By construction  of K, this is equivalent to stating the all paths ÄŽÂ€ Ã¢Â€Ë› either pass the state labelled ci and globally  satisfy  As for the states   or   in K the formula  Wndo not pass the state labelled  Wn ci . W  Wn ci Ã¢ÂˆÂ¨ ÄŽÂˆkÃ¢ÂˆÂ’1  F i=1 xi Ã¢ÂˆÂ§ ÄŽÂ‡ Ã¢Â‰Ä„ i=1 F xi Ã¢ÂˆÂ§ ÄŽÂ‡ is satisfied iff i=1 G (ÃŽÅš \ {xi }) Ã¢ÂˆÂ¨ ÄŽÂ‡ is satisfied, the set  of  when substituting (A) with  k is satisfied remains unaltered    W states inWK on which the ÄŽÂˆW  .  })  Ã¢ÂˆÂ¨  A  G(  ÃŽÅš  \  {c  })  Ã¢ÂˆÂ¨  G(c  Ã¢ÂˆÂ¨  ÄŽÂˆ  G  (ÃŽÅš  \  {x  i  i  i  kÃ¢ÂˆÂ’1  1Ã¢Â‰Â¤iÃ¢Â‰Â¤n  MODEL CHECKING CTL IS ALMOST ALWAYS INHERENTLY SEQUENTIAL Ã¢ÂˆÂ—  19  Similarly, the set ofW statesWin K on which the ÄŽÂˆk is satisfied remains unaltered when  01 01  11  substituting (B) with ni=2 G (ÃŽÅš \ {s00  i , si , siÃ¢ÂˆÂ’1 , siÃ¢ÂˆÂ’1 }), as any path in K that visits a  01  01  11  state labelled with some ci cannot pass via states labelled with s00  i , si , siÃ¢ÂˆÂ’1 , or siÃ¢ÂˆÂ’1 .  W V  Wn  W  Finally, the equivalence of ÄŽÂˆk with i=1 G (ÃŽÅš \ {xi }) Ã¢ÂˆÂ§ j m GÃ‚Å¹Ã¢Â„Â“i,j,m follows from  arguments similar to those for the (C) part in the case that k is odd. We conclude that  p  K, xk |= ÄŽÂˆk Ã¢Â‡ÂÃ¢Â‡Â’ K, xk |= ÄŽÂˆkÃ¢Â€Ë› for all 0 Ã¢Â‰Â¤ k < 2n. Hence, CTL+  pos -MC({A, E, G}) is Ã¢ÂˆÂ†2 -hard.  p  +  For T = {A, E, F} similar modifications show that CTLpos -MC(T ) is Ã¢ÂˆÂ†2 -hard, too. This  concludes to proof of Theorem 4.3.  Finally consider ECTL+ , the combination of ECTL and CTL+ . One can adapt the  Ã¢ÂˆÂž  Ã¢ÂˆÂž  above hardness and membership proofs to hold for F and G instead of F and G: For example,  Ã¢ÂˆÂž  to establish the Ã¢ÂˆÂ†p2 -hardness of ECTL+  pos -MC(T ) in case T = {A, E, G} we modify K such  that the states labelled xn and xn are reachable from zp and z p and assert that (a) the  path quantified by the outmost path quantifier in ÄŽÂˆk , 1 Ã¢Â‰Â¤ i < 2n, additionally satisfies  Ã¢ÂˆÂž  Vn Ã¢ÂˆÂž  that all but a  i=1 (GÃ‚Å¹xi Ã¢ÂˆÂ¨ GÃ‚Å¹xi ) and (b) whenever xi is labelled,Ã¢ÂˆÂž then there exists a path  Ã¢ÂˆÂž  finite number of times satisfies xi . The changes if F is available instead of G follow by the  duality principle of these operators. For its model checking problem we hence obtain:  Corollary 4.4. Let T be a set of temporal operators containing at least one path quantifier  Ã¢ÂˆÂž  Ã¢ÂˆÂž  and let T Ã¢Â€Ë› by obtained from T by substituting F with F and G with G. Then ECTL+ -MC(T ) Ã¢Â‰Ä„cd  +  CTL+ -MC(T Ã¢Â€Ë› ) and ECTL+  pos -MC(T ) Ã¢Â‰Ä„cd CTLpos -MC(T ).  5. Conclusion  We have shown (Theorem 3.2) that model checking for CTLpos (T ) is already P-complete  for most fragments of CTL. Only for some weak fragments, model checking becomes easier:  if T Ã¢ÂŠÂ† {EX, EF} or T Ã¢ÂŠÂ† {AX, AG}, then CTLpos -MC(T ) is LOGCFL-complete. In the case  that no CTL-operators are used, NC1 -completeness of evaluating propositional formulae  applies. As a direct consequence (Theorem 3.1), model checking for CTL(T ) is P-complete  for every nonempty T . This shows that for the majority of interesting fragments, model  checking CTL(T ) is inherently sequential and cannot be sped up using parallelism.  While all the results above can be transferred to ECTL (Theorem 4.1), CTL+ and  ECTL+ exhibit different properties. For both logics, the general model checking problem  was shown to be complete for Ã¢ÂˆÂ†p2 in [LMS01]. Here we proved that model checking fragments  of CTL+ (T ) and ECTL+ (T ) for T Ã¢ÂŠÂ† {A, E, X} remains tractable, while the existential and  +  the universal fragments of CTL+  pos (T ) and ECTLpos (T ) containing temporal operators other  than X are complete for NP and coNP, respectively.  Instead of restricting only the use of negation as done in this paper, one might go one  step further and restrict the allowed Boolean connectives in an arbitrary way. One might,  e.g., allow the exclusive-OR as the only propositional connective. This has been done for  the case of linear temporal logic LTL in [BMS+ 09], where the complexity of LTL-MC(T, B)  for an arbitrary set T of temporal operators and B of propositional connectives was studied.  For example, restricting the Boolean connectives to only one of the functions AND or OR  leads to many NL-complete fragments in the presence of certain sets of temporal operators.  However a full classification is still open.  Considering the CTL variants considered in this paper, plus CTLÃ¢Â‹Â† , over arbitrary sets  of Boolean operators would be one way to generalise our results. In the case of CTL+ and  20  O. BEYERSDORFF, A. MEIER, M. MUNDHENK, T. SCHNEIDER, M. THOMAS, AND H. VOLLMER  EX, EF  LOGCFL-c.  AX, AG, O  EX, EF  O  NC1 -c.  P-c.  ALL  EX, EF, O  AX, AG  LOGCFL-c.  AX, AG  O = AF, AU, AR, EG, EU, ER  Figure 4: Complexity of CTLpos -MC(T ) for all sets T of CTL-operators (depicted as a  Ã¢Â€Âœfinite automatonÃ¢Â€Â where states indicate completeness results and arrows indicate  an increase of the set of CTL-operators).  CTLÃ¢Â‹Â† , where model checking is intractable [EL87, Sch03, LMS01], such a more fine-grained  complexity analysis could help draw a tighter border between fragments with tractable  and intractable model checking problems. As for the corresponding satisfiability problems  CTL-SAT(T, B) and CTLÃ¢Â‹Â† -SAT(T, B), their complexity has been determinedÃ¢Â€Â”with respect  to the set of Boolean operators, completelyÃ¢Â€Â”in [MMTV09].  Throughout this paper, we have assumed that the formula and the Kripke structure  are part of the input and can vary in size. The case where the complexity is measured  in terms of the size of the formula (or the Kripke structure), and the other component is  assumed to be fixed, is usually referred to as specification complexity (or system complexity).  Our approach measures the joint complexity. In applications, where usually the structure  is significantly bigger than the specification, an analysis of the system complexity becomes  interesting. For system complexity, model checking for CTL and CTLÃ¢Â‹Â† is already NLcomplete [BVW94, KVW00]. Still, the hope for a significant drop of system complexity  justifies a systematic analysis of fragments of these logics.  References  +  [BMM 09] O. Beyersdorff, A. Meier, M. Mundhenk, T. Schneider, M. Thomas, and H. Vollmer. Model  checking CTL is almost always inherently sequential. In Proc. 16th International Symposium on  Temporal Representation and Reasoning. IEEE Computer Society Press, 2009.  [BMS+ 09] M. Bauland, M. Mundhenk, T. Schneider, H. Schnoor, I. Schnoor, and H. Vollmer. The tractability of model checking for LTL: the good, the bad, and the ugly fragments. In Proc. 5th Methods  for Modalities, volume 231 of Electronic Notes in Theoretical Computer Science, pages 277Ã¢Â€Â“292,  2009.  [Bus87]  S. R. Buss. The Boolean formula value problem is in ALOGTIME. In Proc. 19th Symposium on  Theory of Computing, pages 123Ã¢Â€Â“131. ACM Press, 1987.  [BVW94] O. Bernholtz, M. Vardi, and P. Wolper. An automata-theoretic approach to branching-time  model checking (extended abstract). In Proc. 6th International Conference on Computer Aided  Verification, volume 818 of Lecture Notes in Computer Science, pages 142Ã¢Â€Â“155. Springer, 1994.  [CES86]  E. Clarke, E. A. Emerson, and A. Sistla. Automatic verification of finite-state concurrent systems  using temporal logic specifications. ACM Transactions on Programming Languages and Systems,  8(2):244Ã¢Â€Â“263, 1986.  [EC82]  E. A. Emerson and E. M. Clarke. Using branching time temporal logic to synthesize synchronization skeletons. Science of Computer Programming, 2(3):241Ã¢Â€Â“266, 1982.  MODEL CHECKING CTL IS ALMOST ALWAYS INHERENTLY SEQUENTIAL Ã¢ÂˆÂ—  21  [EH85]  E. A. Emerson and J. Y. Halpern. Decision procedures and expressiveness in the temporal logic  of branching time. Journal of Computer and System Sciences, 30(1):1Ã¢Â€Â“24, 1985.  [EH86]  E. A. Emerson and J. Y. Halpern. Ã¢Â€ÂœSometimesÃ¢Â€Â and Ã¢Â€Âœnot neverÃ¢Â€Â revisited: on branching versus  linear time temporal logic. Journal of the ACM, 33(1):151Ã¢Â€Â“178, 1986.  [EL87]  E. A. Emerson and C.-L. Lei. Modalities for model checking: Branching time logic strikes back.  Science of Computer Programming, 8(3):275Ã¢Â€Â“306, 1987.  [KF09]  L. Kuhtz and B. Finkbeiner. LTL Path Checking is Efficiently Parallelizable. International Colloquium on Automata, Languages and Programming, 2009.  [KVW00] O. Kupferman, M. Y. Vardi, and P. Wolper. An automata-theoretic approach to branching-time  model checking. Journal of the ACM, 47(2):312Ã¢Â€Â“360, 2000.  [Lar95]  F. Laroussinie. About the expressive power of CTL combinators. Information Processing Letters,  54(6):343Ã¢Â€Â“345, 1995.  [LMS01]  F. Laroussinie, N. Markey, and P. Schnoebelen. Model checking CTL+ and FCTL is hard. In  Proc. 4th Foundations of Software Science and Computation Structure, volume 2030 of Lecture  Notes in Computer Science, pages 318Ã¢Â€Â“331. Springer Verlag, 2001.  [Mar04]  N. Markey. Past is for free: on the complexity of verifying linear temporal properties with past.  Acta Informatica, 40(6-7):431Ã¢Â€Â“458, 2004.  [MMTV09] A. Meier, M. Mundhenk, M. Thomas, and H. Vollmer. The complexity of satisfiability for fragments of CTL and CTLÃ¢Â‹Â† . International Journal of Foundations of Computer Science, 20(5):901Ã¢Â€Â“  918, 2009.  [Pap94]  C. H. Papadimitriou. Computational Complexity. Addison-Wesley, Reading, MA, 1994.  [Pnu77]  A. Pnueli. The temporal logic of programs. In Proc. 18th Symposium on Foundations of Computer Science, pages 46Ã¢Â€Â“57. IEEE Computer Society Press, 1977.  [Ruz80]  W. L. Ruzzo. Tree-size bounded alternation. Journal of Computer and System Sciences, 21:218Ã¢Â€Â“  235, 1980.  [RV97]  K. Regan and H. Vollmer. Gap-languages and log-time complexity classes. Theoretical Computer  Science, 188:101Ã¢Â€Â“116, 1997.  [SC85]  A. Sistla and E. Clarke. The complexity of propositional linear temporal logics. Journal of the  ACM, 32(3):733Ã¢Â€Â“749, 1985.  [Sch03]  Ph. Schnoebelen. The Complexity of Temporal Logic Model Checking, volume 4 of Advances in  Modal Logic, pages 393Ã¢Â€Â“436. KingÃ¢Â€Â™s College Publications, 2003.  [Sch10]  H. Schnoor. The complexity of model checking for Boolean formulas. Int. Journal on Foundations  of Computer Science, 21(3):289Ã¢Â€Â“309, 2010.  [Sel82]  A. L. Selman. Reductions on NP and P-selective sets. Theoretical Computer Science, 19:287Ã¢Â€Â“304,  1982.  [Vol99]  H. Vollmer. Introduction to Circuit Complexity Ã¢Â€Â“ A Uniform Approach. Texts in Theoretical  Computer Science. Springer Verlag, Berlin Heidelberg, 1999.  This work is licensed under the Creative Commons Attribution-NoDerivs License. To view  a copy of this license, visit http://creativecommons.org/licenses/by-nd/2.0/ or send a  letter to Creative Commons, 171 Second St, Suite 300, San Francisco, CA 94105, USA, or  Eisenacher Strasse 2, 10777 Berlin, Germany 