A Labeled Tableaux System for the Distributed Temporal Logic DTL  David Basin  Department of Computer Science, ETH Zurich, Switzerland  basin@inf.ethz.ch  Carlos Caleiro  Jaime Ramos  SQIG-Instituto de TelecomunicacĚ§oĚes and Department of Mathematics, IST, TU Lisbon, Portugal  {ccal | jabr}@math.ist.utl.pt  Luca ViganoĚ  Department of Computer Science, University of Verona, Italy  luca.vigano@univr.it  Abstract  DTL is a distributed temporal logic for reasoning about  temporal properties of distributed systems from the local  point of view of the systemâs agents, which are assumed  to execute sequentially and to interact by means of synchronous event sharing. We present a sound and complete  labeled tableaux system for future-time DTL. To achieve  this, we first formalize a labeled tableaux system for reasoning locally at each agent, which provides a system for  full future-time LTL, and afterwards we combine the local  systems into a global one by adding rules that capture the  distributed nature of DTL.  1  Introduction  The distributed temporal logic DTL [8] is a logic for  reasoning about temporal properties of distributed systems  from the local point of view of the systemâs agents, which  are assumed to execute sequentially and to interact by  means of synchronous event sharing. Distribution is implicit and properties of entire systems are formulated in  terms of the local properties of the agents and their interaction. DTL is closely related to the family of temporal logics  whose semantics are based on the models of true concurrency introduced and developed in [14, 15, 19]. In particular, the semantics of these logics are based on a conflict-free  version of Winskelâs event structures [26], enriched with information about sequential agents. Different versions have  been given, reflecting different perspectives on how nonlocal information can be accessed by each agent.  DTL was first proposed in [8] as a logic for specifying  and reasoning about distributed information systems. The  logic has also been used in the context of security protocol  analysis for reasoning about the interplay between protocol  models and security properties [3, 4]. However, all of the  previous results have been obtained directly by semantic arguments. It would be reassuring, and useful in general, to  have a usable deductive system for DTL. An attractive possibility in this regard is a labeled tableaux system as deductions will then closely follow semantic arguments.  In this paper, we present a sound and complete labeled  tableaux system for future-time DTL. Our main contributions are two-fold. First, we introduce a labeled tableaux  system for full future-time LTL, where reasoning is local.  Due to lack of space, we do not consider here past-time operators like since, although all the results presented in this  paper extend straightforwardly to full LTL (and thus to full  DTL) as we show in [1].  Second, we combine the LTL systems local to each agent  with rules that capture the distributed nature of DTL, via  communication. The tableaux systems for local reasoning  (in LTL) are, as expected, built from formulas labeled with  local state information and relations between these labels  (order and equality). We integrate these systems into a system for global reasoning, where we introduce an additional  relation expressing synchronization. We prove the soundness and completeness of the system with respect to DTL  entailment and provide examples of its use. We have not,  for now, addressed the question of efficient proof search and  have included an infinite closure rule that captures eventualities which are always delayed. Note, in this regard,  that DTL entailment is decidable as it can be reduced to  entailment in LTL by a suitable polynomial-time syntactic translation and linearization of the distributed models.  Here we use the subscript âŚ to denote the reflexive versions  of the operators. Note also that calling is specific to DTL  as it involves communication: @i [Ď j Ď] means that if Ď  holds for agent i then he calls (synchronizes with) agent j,  for whom Ď must hold.  A local life-cycle of an agent i is a countable (finite or  infinite), discrete, well-founded, total order Îťi = hEi , â¤i i,  where Ei is the set of local events and â¤i the local order  of causality. We define the corresponding local successor  relation âi â Ei Ă Ei to be the relation such that e âi e0  if e <i e0 and there is no e00 such that e <i e00 <i e0 .  As a consequence, we have that â¤i = ââi , i.e., â¤i is the  reflexive and transitive closure of âi .  A distributed life-cycle is a family  Îť = {Îťi }iâId of loS  cal life-cycles such that â¤ = ( iâId â¤i )â defines a partial  S order of global causality on the set of all events E =  iâId Ei . Note that communication is modeled by event  sharing and thus for some event e we may have e â Ei âŠ Ej  for i 6= j. In that case, requiring â¤ to be a partial order  amounts to requiring that the local orders are globally compatible, thus excluding the existence of another e0 â Ei âŠEj  where both e <i e0 and e0 <j e.  A local state of agent i is a finite set Îž â Ei that is  downward-closed for local causality, i.e., if e â¤i e0 and e0 â  Îž then also e â Îž. The set Îi of all local states of an agent  i is totally ordered by inclusion and has â as the minimal  element. In general, each non-empty local state Îž is reached  from the local state Îž \ {last i (Îž)} by the occurrence of an  event that we call last i (Îž). The local states of each agent  are totally ordered as a consequence of the total order on  local events. Since they are discrete and well-founded, we  enumerate them as follows: â is the 0th state; {e}, where e  is the minimum of hEi , â¤i i, is the first state; and, in general,  if Îž is the k th state of agent i and last i (Îž) âi e0 , then Îž âŞ  {e0 } is the (k+1)th state of agent i. We denote by Îžik the k th  state of agent i. Îži0 = â is the initial state and Îžik is the state  reached from the initial state after the occurrence of the first  k events. In fact, Îžik is the only state of agent i that contains  k elements, i.e., where |Îžik | = k. Given e â Ei , observe  that (e â i) = {e0 â Ei | e0 â¤i e} is always a local state.  Furthermore, if Îž is non-empty, then (last i (Îž) â i) = Îž.  An interpretation structure Âľ = hÎť, Ďi consists of a distributed life-cycle Îť and a family Ď = {Ďi }iâId of labeling  functions. For each i â Id, Ďi : Îi â â(Propi ) associates a  set of local state propositions to each local state. We denote  hÎťi , Ďi i by Âľi and define the global satisfaction relation by  However, the distributed properties expressible in DTL are  trace-consistent, or invariant under different linearizations,  and this suggests developing a simpler, dedicated deductive  system for DTL along the lines that we follow here.  We proceed as follows. In Â§2, we introduce DTL. In  Â§3, we present our tableaux system for local reasoning and  establish its soundness and completeness with respect to entailment. In Â§4, we extend our local system into a system for  global reasoning by including a new synchronization relation between local labels and we also prove soundness and  completeness with respect to entailment. We conclude, in  Â§5, by comparing with related work and discussing future  work. Due to lack of space, examples have been shortened  and proofs have been omitted; full details are given in [1].  Applications of the logic are also presented in [1], as well  as in [3, 4, 8, 9].  2  The distributed temporal logic DTL  2.1  The syntax and semantics of DTL  DTL is defined over a distributed signature ÎŁ =  hId, {Propi }iâId i of a system, where Id is a finite set of  agents and, for each i â Id, Propi is a set of local state  propositions. The global language LDTL is defined by the  grammar  LDTL ::= @i1 [Li1 ] | Âˇ Âˇ Âˇ | @in [Lin ] ,  for Id = {i1 , . . . , in }. The local languages Li , for each  i â Id, are in turn defined by  Li ::= Propi | ÂŹ Li | Li â Li | F Li | G Li | X Li |  Li W Li | c j [Lj ] ,  with j â Id. A global formula @i [Ď] means that Ď holds for  agent i. Local formulas, as the name suggests, hold locally  for the different agents. For instance, locally for an agent  i, the operators F, G, X, and W are the usual sometime in  the future, always in the future, next, and weak until (unless)  temporal operators, respectively, while the communication  formula c j [Ď] means that agent i has just communicated  (synchronized) with agent j, for whom Ď held1 . We will  c  use L6i to denote the set of all purely temporal formulas of  Li , that is, excluding communication formulas.  Other logical connectives (conjunction, disjunction, etc.)  and temporal operators can be defined as abbreviations, e.g. :  ĎUĎ  FâŚ Ď  GâŚ Ď  Ď j Ď  âĄ  âĄ  âĄ  âĄ  (F Ď) â§ (Ď W Ď)  Ď â¨ FĎ  Ď â§ GĎ  Ď â c j [Ď]  â˘ Âľ  strong until;  now or sometime in the future;  now and always in the future;  calling.  DTL  @i [Ď] iff Âľi  i  Ď iff Âľi , Îž  i  Ď for every Îž â Îi ,  where the local satisfaction relations at local states are defined by  1 Note  that the DTL syntax here differs from, and improves upon, the  original presentation in [8]. Previously, the operator c i was overloaded  with @i and its interpretation was therefore context dependent.  â˘ Âľi , Îž  i  p if p â Ďi (Îž);  â˘ Âľi , Îž  i  ÂŹ Ď if Âľi , Îž 6  i  Ď â Ď if Âľi , Îž 6  â˘ Âľi , Îž  2  i  Ď;  i  Ď or Âľi , Îž  i  Ď;  â˘ Âľi , Îž i F Ď if |Îž| = k and there exists Îžin â Îi such that k < n  with Âľi , Îžin i Ď;  â˘ Âľi , Îž i G Ď if |Îž| = k and Âľi , Îžin  that k < n;  â˘ Âľi , Îž  â˘  i  i  distributed model, as opposed to checking all possible linearizations. This makes DTL properties particularly wellsuited for efficient model checking using partial-order reduction techniques [17], which was explored in [9]. Furthermore, this fact suggests that proof techniques tailored  directly to DTL might have advantages over off-the-shelf  techniques operating on the translations in LTL. This is yet  another motivation for developing a labeled tableaux system  for DTL.  Ď for every Îžin â Îi such  X Ď if |Îž| = k, Îžik+1 exists and Âľi , Îžik+1  Âľi , Îž i Ď W Ď if |Îž| = k and Âľi , Îžin i  k < n; or there exists Îžin â Îi such that  and Âľi , Îžim i Ď for every k < m < n;  i  Ď;  Ď for every Îžin â Îi with  k < n with Âľi , Îžin i Ď,  â˘ Âľi , Îž i c j [Ď] if |Îž| > 0, last i (Îž) â Ej , and Âľj , (last i (Îž) â  j) j Ď.  The satisfaction conditions for the connectives and the temporal operators defined as abbreviations can be obtained  from the primitive ones in a straightforward way. For example, for strong until we have that  3  We start by developing a labeled tableaux system for reasoning locally at each agent. This essentially amounts to a  tableaux system for full future-time LTL (see [1] for the extension with past-time operators).  From now on, we consider fixed a distributed signature  ÎŁ. Our tableaux for local reasoning handles four kinds of  local judgments for each agent i â Id: labeled local formulas (excluding communication), equality between labels,  inequality between labels, and a special judgment indicating absurdity. Local labels denote the local states of agent  i. To define the language of labels, for the given signature  ÎŁ, we assume fixed a family V = {V i }iâId of sets of label  variables and also use a family F = {Fi }iâId of sets of  Skolem function symbols defined as follows:  â˘ Âľi , Îž i Ď U Ď if |Îž| = k and there exists Îžin â Îi such that k < n  with Âľi , Îžin i Ď, and Âľi , Îžim i Ď for every k < m < n.  We say that Âľ is a model of Î â LDTL if Âľ globally satisfies  each of the formulas in Î, and given Î´ â LDTL we say that  Î entails Î´, written Î DTL Î´, if every global model of Î is  also a model of Î´. Given ÎŚ âŞ {Ď} â Li , we write ÎŚ i Ď to  denote the fact that every local model of ÎŚ is also a model  of Ď or, equivalently, that {@i [Ď] | Ď â ÎŚ} DTL @i [Ď].  For instance, @i [p â F c j [X q]] holds in a model if  whenever proposition p holds locally at a state of agent i  then there must be a future state of agent i where he has just  synchronized with agent j, for whom q will hold in the next  state. Additional examples can be found in [1].  Note that, as is well known, the expressive power of the  U operator is exactly the same of the set {F, G, X, W}. This  can be seen from the following equivalences.  FĎ  GĎ  XĎ  ĎWĎ  2.2  âĄ  âĄ  âĄ  âĄ  >UĎ  ÂŹFÂŹĎ  âĽUĎ  (G Ď) â¨ (Ď U Ď)  Tableaux for local reasoning  Fi  = {fĎWĎ | Ď, Ď â L6i } âŞ {fÂŹ(ĎWĎ) | Ď, Ď â L6i }.  c  c  Note that while N denotes the natural numbers with 0, we  write N+ to denote the positive natural numbers, N \ {0}.  The syntax of the local labels of agent i is defined by  sometime in the future;  always in the future;  tomorrow (next);  weak until (unless).  Ti ::= N | V i + Z | Fi (Ti ) + Z ,  Si ::= (i, Ti ).  Labels involving the Skolem function symbols will be  used in the tableaux to guarantee the existence of certain  local states associated with the satisfaction of formulas involving the weak until. Although the use of fresh variables  suffices in some cases, weak until, as well as its negation,  may require the existence of states in the model with specific properties. This requirement makes the use of the  Skolem functions an essential ingredient of our system. We  write v to denote an arbitrary label variable, x, y, and z to  denote arbitrary label terms, and si to denote an arbitrary  element of Si . We abbreviate x + 0 as x and if c â N+ then  we write x â c instead of x + (âc), as usual.  The syntax of local judgments of agent i can now be defined by  Decidability of DTL  It is not difficult to show, as suggested in [8], that DTL  is decidable by means of a translation to LTL. We omit  this translation for the sake of space and refer the reader  to [1]. Since LTL is decidable, any decision procedure for  LTL entailment can thus also be used for DTL (and since  our translation is polynomial, the asymptotic complexity is  identical). The translation relies on the fact that given a distributed life-cycle Îť = {hEi , â¤i i}iâId , it is always possible  to linearize the global order on events hE, â¤i: one can define an injective function f : E â N that preserves the  global causality relation, i.e., if e < e0 then f (e) < f (e0 ).  However, the result given in [1] is actually independent of  the chosen linearization function f and in general there may  be many such functions. This means that DTL is traceconsistent in the sense of [24]; namely, DTL properties can  be checked by considering one arbitrary linearization of the  Ji ::= Si : L6i | Si = Si | Si < Si |  c  s0i  s00i  CLOSED .  When convenient, we write si < < instead of si <  s0i and s0i < s00i . The intended meaning of a labeled formula  3  â˘ Âľ, Ď  si = s0i if [[si ]]Âľ,Ď and [[s0i ]]Âľ,Ď are both defined and  [[si ]]Âľ,Ď = [[s0i ]]Âľ,Ď ;  si : Ď is that Ď holds at the local state (denoted by) si of  agent i. Equalities and inequalities of local labels of agent i  are interpreted directly over the causality ordering. To make  this formal, we extend our notion of interpretation structure  with information concerning labels: we interpret labels as  natural numbers in such a way that the interpretation of a  given local label identifies, by its value, the local state of  the corresponding agent. An assignment on label variables  is a function Ďi : V i â N. We also need to consider a  fixed interpretation structure Âľ. The denotation of labels  over Âľ and Ď = {Ďi }iâId , for each agent i â Id, in symbols  [[Âˇ]]Âľ,Ď : Si â N, is defined as the following partial function:  â˘ Âľ, Ď  si < s0i if [[si ]]Âľ,Ď and [[s0i ]]Âľ,Ď are both defined and  [[si ]]Âľ,Ď < [[s0i ]]Âľ,Ď ;  â˘ Âľ, Ď 6  [[s ]]  Recall that Îži i Âľ,Ď denotes the [[si ]]th  Âľ,Ď local state of agent i  in Âľ. We can finally define our tableaux for local reasoning.  Definition 3.1 The local tableaux system Ti , for agent i â  Id, built over sets of local judgments in Ji , consists of the  rules shown in Figures 1â2.    â˘ [[(i, k)]]Âľ,Ď = k;  We assume that the reader is familiar with standard terminology and notation for tableaux, for example from [7].  As usual, a branch of a (possibly infinite) tableau is exhausted if no more rules are applicable, closed if it contains CLOSED, and open if it is exhausted but not closed. A  tableau is closed if all of its branches are closed.  Figure 1 contains the rules for the logical connectives,  which are straightforward, and the rules for the temporal  operators, most of which are standard. For instance, the rule  (F) guarantees that in order for F Ď to hold at state x, there  must exist a future state v where Ď holds, which is enforced  by the freshness of v (i.e., v is a new variable, not occurring  in the tableaux). In contrast, the rule (ÂŹ F) concludes that if  ÂŹ F Ď holds at state x then Ď cannot hold in any state y in the  future of x. The additional premise (i, y) : Ď is there only  to control the introduction of labeled formulas. The rules  (G) and (ÂŹ G) are justified similarly. The rule (X) simply requires the existence of a suitable next state. The rule  (ÂŹ X) follows a pattern similar to the ones above. The rules  for weak until follow closely the operatorâs semantics, but  some explanation is needed to clarify the use of the Skolem  function symbols. Rule (W1 ) splits the satisfaction of ĎWĎ  at state x into two cases: either Ď holds always in the future,  or there is a future state fĎWĎ (x) where Ď holds. Of course,  this future state, which we have required to be the earliest  possible, defines together with x an interval where Ď must  hold. These requirements are then imposed by rule (W2 ),  hence justifying the use of the Skolem function fĎWĎ . The  rules for negated weak until (ÂŹ W1 ) and (ÂŹ W2 ) are similar.  The rules in Figure 2 define the properties of the relations. Note that we use Î¸(i, x) to denote any local judgment  of agent i where x occurs. The rule (P OS) states that the  values of the labels are either 0 or greater than 0. The rule  (C ONG) expresses the congruence of =, i.e., if two labels  (i, x) and (i, y) denote the same local state, then we may  replace some occurrences of x by occurrences of y in any  judgment. Similarly, rule (R EFL) asserts the reflexivity of  equality. With rule (F ILL), we âfill downâ the set of states:  if (i, x) denotes a state and if (i, y) is smaller than (i, x),  then it should also denote a state (which we express by having truth hold there). (T R) forces the order relation to be  â˘ [[(i, v)]]Âľ,Ď = Ďi (v);  â˘ [[(i, fĎWĎ (x))]]Âľ,Ď = n provided that  â [[(i, x)]]Âľ,Ď is defined;  â n > [[(i, x)]]Âľ,Ď is the least number, if it exists, such that  âŚ Îžin â Îi and Âľi , Îžin i Ď;  âŚ Âľi , Îžik i Ď, for every k such that [[(i, x)]]Âľ,Ď < k < n;  â˘ [[(i, fÂŹ(ĎWĎ) (x))]]Âľ,Ď = n, provided that  â [[(i, x)]]Âľ,Ď is defined;  â n > [[(i, x)]]Âľ,Ď is the least number, if it exists, such that  âŚ Îžin â Îi , Âľi , Îžin 6 i Ď and Âľi , Îžin 6 i Ď;  âŚ Âľi , Îžik 6 i Ď, for every k such that [[(i, x)]]Âľ,Ď < k < n;  â˘ [[(i, x + k)]]Âľ,Ď = [[(i, x)]]Âľ,Ď + k, provided that [[(i, x)]]Âľ,Ď is  defined and [[(i, x)]]Âľ,Ď + k âĽ 0.  For simplicity, when [[(i, x)]]Âľ,Ď depends only on Ď, we  may write Ďi (x).  One reason why the denotation of labels is partial is that  we do not consider negative values. This is, however, unproblematic as the labels appearing in relevant places in our  tableaux will always denote non-negative values. A second  reason for the partiality is due to the interpretations of the  Skolem functions. The interpretations of the function symbols for negated weak until fÂŹ(ĎWĎ) are defined depending  on the satisfaction of the corresponding formulas ÂŹ(ĎWĎ),  in which case the interpretations will have the value of the  first state in the future where Ď does not hold. The interpretations of the function symbols for weak until (i.e., fĎWĎ ) do  not mimic the satisfaction of the corresponding formulas so  closely. Actually, it is enough for our purposes that they are  only defined under the assumption that Ď does not hold forever in the future. In this case, their interpretations will take  the value of the first state where Ď holds. In any case, the  relevant labels of this form appearing in our tableaux will  always arise in contexts where their denotation is defined.  We can now define the satisfaction of local judgments of  agent i at Âľ, given an assignment Ď:  â˘ Âľ, Ď  si  [[s ]]  Âľi , Îži i Âľ,Ď  [[si ]]Âľ,Ď  : Ď if [[si ]]Âľ,Ď is defined, Îži  i  CLOSED .  â Îi , and  Ď;  4  si : ÂŹ Ď  si : Ď  si : ÂŹ ÂŹ Ď  (ÂŹ ÂŹ)  si : Ď  CLOSED  (i, x) : F Ď  (i, x) < (i, v) , (i, v) : Ď  (i, x) : G Ď  (i, y) : Ď  (i, y) : Ď  (i, x) : X Ď  (i, x) < (i, y)  (i, y) : Ď  (i, y) : ÂŹ Ď  (i, x) : ÂŹ G Ď  (G)  (i, x) < (i, y)  (i, y) : Ď  (i, x + 1) : ÂŹ Ď  (i, x) : Ď W Ď  (i, x) : G Ď | (i, x) < (i, fĎWĎ (x)) , (i, fĎWĎ (x)) : Ď  (W1 )  (i, x) : ÂŹ(Ď W Ď)  (i, x) < (i, fÂŹ(ĎWĎ) (x)) , (i, fÂŹ(ĎWĎ) (x)) : ÂŹ Ď , (i, fÂŹ(ĎWĎ) (x)) : ÂŹ Ď  (ÂŹ F)  (ÂŹ G) [v fresh]  (i, x) < (i, v) , (i, v) : ÂŹ Ď  (i, x) : ÂŹ X Ď  (X)  (i, x + 1) : Ď  (i, x) : ÂŹ F Ď  (F) [v fresh]  (i, x) < (i, y)  si : ÂŹ(Ď â Ď)  (ÂŹ â)  s i : Ď , si : ÂŹ Ď  si : Ď â Ď  (â)  si : ÂŹ Ď | s i : Ď  (A BS)  (ÂŹ X)  (i, x) < si < (i, fĎWĎ (x))  s i : Ď , si : ÂŹ Ď  (W2 )  (i, x) < si < (i, fÂŹ(ĎWĎ) (x))  (ÂŹ W1 )  s i : ÂŹ Ď , si : Ď  (ÂŹ W2 )  Figure 1. Rules for the logical connectives and the temporal operators.  Î¸(i, x)  (i, x) = (i, 0) | (i, 0) < (i, x)  Î¸(i, x)  (i, x) = (i, y)  (P OS)  Î¸(i, y)  Î¸(i, y + c)  (i, x + c) < (i, y + c)  (i, 0) < (i, x)  (i, x â 1) < (i, x)  (T R)  (RS HIFT) [c > 0]  (P RED)  (C ONG)  Î¸(i, y)  (i, x) < (i, y) | (i, x) = (i, y) | (i, y) < (i, x)  (i, x) < (i, y)  Î¸(i, x)  (i, x) < (i, y)  Î¸(i, y + c)  (i, x) < (i, y + c)  (i, x) < (i, y)  Î¸(i, x + c)  (i, x + c) < (i, y + c)  (i, x) < (i, x + c)  CLOSED  (NL OOP) [c â¤ 0]  Î¸(i, x)  (i, x) = (i, x)  si : Ď  (R EFL)  s0i  s0i < si  :>  (i, x) < (i, y) < (i, z)  (M ON) [c > 0]  (i, x) < (i, z â 1)  (LS HIFT) [c < 0]  Î¸(i, x + 1)  (i, x) < (i, x + 1)  (i, x + c) < (i, y)  CLOSED  ââ c âĽ 0  (F ILL)  (DT RANS)  (S UCC)  (I NF)  Figure 2. Rules for the relations.  trichotomic2 . (M ON) is a form of transitivity, given that y  precedes y + c when c > 0. (DT RANS) is discrete transitivity: if (i, x) is smaller than (i, y) and (i, y) is smaller than  (i, z), then (i, x) is also smaller than (i, z). In fact, our rule  is more specific and formalizes that (i, x) is actually smaller  than (i, zâ1). (RS HIFT) and (LS HIFT) shift the precedence  order along with addition, taking care that no new states are  introduced. (S UCC) and (P RED) order successive states in  appropriate conditions. The closure rule (NL OOP) states  that x cannot precede x + c when c â¤ 0. Finally, (I NF) is  an infinitary closure rule: if in a branch there are infinitely  many, distinct, non-negative constants that when added to  (i, x) denote a value smaller than (i, y), then the branch is  closed.  We illustrate the use of the tableaux system with an ex-  ample. To prove that ((ĎWĎ)â§X(ÂŹ Ď))âX Ď is a theorem,  we give a closed tableau in Figure 3 for the negated formula.  Further examples are provided in [1].  Note that we do not claim the independence of all the  proposed rules of our tableaux system Ti . For instance,  it is easy to obtain the rule (NL OOP) from (I NF) by infinitely many applications of (RS HIFT) and (DT RANS). We  leave the identification of a minimal, equivalent, set of rules  for future work and instead we now establish the soundness and completeness of Ti . We first consider soundness,  where, as usual, a rule is sound if every model that satisfies its premises also satisfies at least one of its conclusions.  Of course, a closure rule, i.e., a rule whose conclusion is  CLOSED , is sound if no model satisfies its premises.  Proposition 3.2 The rules of Ti are sound.  2 Note  that the trichotomy rule may lead to considerable branching in  the tableaux. In [1], we have replaced this rule by a set of rules that permit  only controlled forms of trichotomy.  Before we proceed to the completeness result, we recall [18] some technical results about integer constraints  5  (i, v) : ÂŹ(((Ď W Ď) â§ X(ÂŹ Ď)) â X Ď)  ÂŹâ  (i, v) : (Ď W Ď) â§ X(ÂŹ Ď)  (i, v) : ÂŹ X Ď  â§  (i, v) : (Ď W Ď)  (i, v) : X(ÂŹ Ď)  X  (i, v + 1) : ÂŹ Ď  S UCC  (i, v) < (i, v + 1)  UUUU  kkk  UUUU W1  k  k  k  k  UUUU  kkk  UUUU  k  k  k  k  kk  (i, v) < (i, fĎWĎ (v))  (i, v) : G Ď  (i, fĎWĎ (v)) : ĎRR  RRR T R  iiii  i  i  RRR  i  ii  G  RRR  i  i  i  i  RR  i  i  i  (i, v + 1) < (i, fĎWĎ (v))  (i, v + 1) = (i, fĎWĎ (v)) (i, fĎWĎ (v)) < (i, v + 1)  (i, v + 1) : Ď  ÂŹX  (i, v + 1) : ÂŹ Ď  A BS  C LOSED  W2  DT RANS  C ONG  (i, v + 1) : Ď  (i, v + 1) : ÂŹ Ď  (i, v + 1) : Ď  ÂŹX  (i, v) < (i, v)  NL OOP  A BS  (i, v + 1) : ÂŹ Ď  C LOSED  C LOSED  A BS  C LOSED  Figure 3. Tableau for ÂŹ(((Ď W Ď) â§ X(ÂŹ Ď)) â X Ď).  c  of the form x â¤ y, where (i, x) and (i, y) are local labels  in Si . It is clear that any such constraint is of the form  u1 + n â¤ u2 + m, where u1 and u2 are either label variables, label terms whose head is a Skolem function, or 0.  Let A = {A1 , A2 , . . . } be a (possibly infinite) set of such  constraints. The constraint graph for A is a weighted, directed graph GA = hVA , EA i constructed as follows:  As notation, u1 â u2 represents the directed edge  (u1 , u2 ) with weight c. Intuitively, this means that u1 is  at most c larger than u2 . So, for instance, edges of the sec0  ond kind, 0 â u, express that 0 â¤ u + 0, which is satisfied  when u is non-negative, i.e., a natural number. As usual, a  path p in a graph is a finite sequence of vertices u1 , . . . , un ,  where (ui , ui+1 ) is an edge, for all i such that 1 â¤ i â¤ n.  The weight of a path is the sum of the weights of its edges.  â˘ VA = V(A) âŞ {0}, where V(A) is the set of V i variables and of label terms headed by a Skolem function  occurring in A3 ;  mân  Lemma 3.3 A (possibly infinite) set of constraints A is satisfiable if and only if for each non-zero node in GA , there  exists a minimum-weight path in GA among all the paths  from 0 to that node.  0  â˘ EA = {u1 ââ u2 | u1 + n â¤ u2 + m â A} âŞ {0 â  u | u â V(A)}.  In our tableaux, every judgment of the form (i, x) <  (i, y) can be equivalently stated as a constraint of the form  3 At this point, labels whose head is a Skolem function symbol are  treated as if they were simply variables.  6  x â¤ y â 1. Similarly, a judgment of the form (i, x) = (i, y)  can be equivalently formalized as the pair of constraints  x â¤ y and y â¤ x.  We can now prove our completeness result for the  tableaux system Ti . Since the Skolem function symbols are  intended to be used only as an internal tool of the system,  we will assume that the initial set of judgments contains no  Skolem functions at all. Note, still, that this requirement  could be dropped if we added additional constraints to the  graphs GA , (1) imposing the required ordering between labels whose head is a Skolem function and their subterms  (e.g., stating that (i, si ) < (i, fĎWĎ (si ))), and (2) splitting  the rules (W1 ) and (ÂŹ W1 ) in two, one for introducing the  Skolem symbols and another for introducing their properties.  where the local judgments are extended to also incorporate  communication formulas  Ji ::= Si : Li | Si = Si | Si < Si |  The intended meaning of a synchronization judgment  (i, x) ./ (j, y) is that the event leading to state x of agent i  is synchronized with the event leading to state y of agent j.  Semantically, we require a distributed assignment on label  variables Ď = {Ďi }iâId . The denotation of labels is defined as before. The satisfaction of judgments is also just  extended with  â˘ Âľ, Ď  [[si ]]Âľ,Ď  ./ sj if Îži  =  [[sj ]]Âľ,Ď  6= â, Îžj  6= â and  [[s ]]  last j (Îžj j Âľ,Ď ).  We finally define our tableaux for global reasoning,  which we show to be sound and complete.  Definition 4.1 The global tableaux system T for DTL,  built over sets of global judgments in J , consists of the  rules of Ti for each agent i â Id, together with the global  rules in Figure 4.  We can then reason about entailment in the logic:  Corollary 3.5 Given ÎŚ âŞ {Ď} â Li , ÎŚ i Ď if and only if  every exhausted Ti -tableau for {(i, 0) : GâŚ Ď | Ď â ÎŚ} âŞ  {(i, v) : ÂŹ Ď} is closed.  Figure 4 contains the rules for communication and synchronization. The rules for communication, ( c ) and  (ÂŹ c ), follow closely the semantics. Consider, for instance,  ( c ): if agent i, in state x, just communicated with agent j,  for whom Ď held, then the event leading to state x is synchronized with an event leading to some state v of agent j,  where Ď holds (and where v is fresh). The rules for synchronization are also quite intuitive. For instance, (E VT) guarantees that since there is no event leading to the initial state,  synchronization is not possible. The rules (S YM), (S ELF),  and (T RANS) are straightforward. The rule (O RDER) guarantees that local orders are globally compatible. If there is  a chain of synchronizations linking two events of agent i,  then these two events preserve the ordering imposed by the  synchronization chain. For instance, assume that the events  leading to states si and s0i of agent i have just synchronized  with the events leading to states sj and s0j of agent j, respectively. Furthermore, assume that sj precedes s0j . Then this  order must be reflected in agent i and so si must precede s0i .  This extends to more than two agents in a straightforward  way.  The tableau in Figure 3 shows that i ((Ď W Ď) â§  X(ÂŹ Ď)) â X Ď.  Tableaux for global reasoning  Our aim is to build a tableaux system T for full DTL  by capitalizing on the local tableaux systems for each agent  i â Id. We will now introduce an additional kind of global  judgment: synchronization between labels. Labeled local  formulas will also be unrestricted, i.e., communication formulas are allowed. Of course, the language of labels is now  distributed. That is, if Id = {i1 , . . . , in } then  S ::= Si1 | Âˇ Âˇ Âˇ | Sin ,  where the local labels of agent i are defined, as before, by  Ti ::= N | V i + Z | Fi (Ti ) + Z ,  Si ::= (i, Ti ),  Proposition 4.2 The rules of T are sound.  The completeness of T builds on the completeness result  for each of the local systems Ti .  but where the Skolem function symbols extend now also to  formulas involving communication, that is,  Fi  si  [[s ]]  last i (Îži i Âľ,Ď )  Proposition 3.4 Let Î be a set of local judgments without  Skolem functions. Then Î is satisfiable if and only if there  is a Ti -tableau for Î with an open branch.  4  CLOSED .  Proposition 4.3 T is complete, i.e., a set of global judgments Î without Skolem functions is satisfiable if and only  if there is a T -tableau for Î with an open branch.  = {fĎWĎ | Ď, Ď â Li } âŞ {fÂŹ(ĎWĎ) | Ď, Ď â Li }.  The syntax of global judgments can now be defined by  J ::= Ji1 | Âˇ Âˇ Âˇ | Jin | Si ./ Sj ,  We can then reason about entailment in DTL:  7  (i, x) : c j [Ď]  (j, v) : Ď , (i, x) ./ (j, v)  (i, x) ./ (i, y)  (i, 0) < (i, x)  (E VT)  si1 ./ si2  (i, x) : ÂŹ c j Ď  ( c ) [v fresh]  si ./ sj  sj ./ si (S YM)  si2 < s0i2  s0i2 ./ si3  (i, x) ./ (j, y)  (ÂŹ c )  (j, y) : ÂŹ Ď  si ./ s0i  si = s0i  si3 < s0i3  si1 < s0i1  (S ELF)  ...  si ./ sj sj ./ sk  (T RANS)  si ./ sk  s0ip ./ s0i1  (O RDER)  Figure 4. Rules for communication and synchronization.  Corollary 4.4 Given Î âŞ {@i [Ď]} â L, Î DTL @i [Ď] if  and only if every exhausted T -tableau for {(j, 0) : G0 Ď |  @j [Ď] â Î} âŞ {(i, v) : ÂŹ Ď} is closed.  past and future-time DTL, and plan to report on this soon.  This might be useful since, as noted in the introduction, we  have not yet addressed the question of efficient proof search  and have thus considered an infinite closure rule that captures eventualities which are always delayed. We will address alternative rules, leading to more efficient deduction,  in future work, by adding loop checking as is usually done.  When doing so, we also expect to be able to capitalize on  having based our tableaux system on constraint graphs. Actually, in the finite case, our Lemma 3.3 is well known to  amount to checking that there are no cycles with negative  sum in the graph [18], which can be done efficiently using  the Bellman-Ford algorithm [6].  For example, as is done in [1], we can show  that {@i [ c j [>] â c j [X c k [>]]], @j [ c k [>] â  c k [X c i [>]]]} DTL @i [ c j [>] â F c k [>]] by building  a closed T -tableau for the corresponding judgments.  5  Related and future work  We have given the first sound and complete tableaux system for the distributed temporal logic DTL. To do so, we  first gave a system for reasoning locally (in LTL) at each  agent and afterwards we combined the local systems into  one for global reasoning. We again note that our tableaux  system can be smoothly extended to deal also with past operators, like since, as shown in the full paper [1].  A number of tableaux and other deductive systems have  been given for fragments of LTL, e.g., [5, 7, 10, 11, 12, 13,  16, 20, 21, 22, 23, 25, 27] to name a few. In particular, different kinds of labels are employed to guide the proof search  in the different labeled systems. For instance, [13] considers time points as labels for formulas, while [5, 20, 21] consider time intervals. It is interesting to note that Schmitt and  Goubault-Larrecq employ constraint graphs to reason about  the completeness of their rules, where labels are time intervals, similar to what we did for our time-point labels. Most  importantly, different fragments of the logic are considered  in the different systems to cope with the difficulties of the  full logic, e.g., the difficulties of formalizing rules for until  and since. The manuscript [20] is an attempt to give a labeled tableaux system for the full logic, but unfortunately it  has never been completed.  We have designed our systems with the aim of providing tableaux for full DTL, including past, but it is interesting to note that our system for local reasoning seems to be  closely related to the natural deduction system for futuretime LTL of [2], which was developed in parallel with our  work. We have begun investigating whether the rules of [2]  would also be suited for the extension to global reasoning in  Another direction for future work will be to extend our  system to the Distributed Temporal Protocol Logic DTPL  that we have devised to reason about models and properties  of security protocols. In [3, 4], we have applied DTPL in  two different ways: first to verify (or refute) that security  protocols provide the security properties they have been designed for, and second to prove metatheoretic properties of  protocol models that can be used to simplify the verification  of protocols or to search for attacks against them. All of  these results have been obtained directly by semantic arguments. Hence, extending the tableaux system given here to  DTPL will allow us to formalize, and possibly implement,  (meta)reasoning about security protocols. We will report on  this in a forthcoming paper.  Acknowledgments The first author was partially supported by the Hasler Foundation, ManCom project  2071.  The second and third authors were partially  supported by FCT and EU FEDER, via the projects  KLog PTDC/MAT/68723/2006 of SQIG-IT, and QuantLog POCI/MAT/55796/2004 of CLC. The fourth author  was partially supported by the FP7-ICT-2007-1 Project  no. 216471, âAVANTSSAR: Automated Validation of Trust  and Security of Service-oriented Architecturesâ (www.  avantssar.eu). We thank Matthias Schmalz for useful  comments on a draft of this paper.  8  References  [13] R. HaĚhnle and O. Ibens. Improving Temporal Logic  Tableaux Using Integer Constraints. In Proc. ICTLâ94,  LNAI 827. Springer-Verlag, 1994.  [1] D. Basin, C. Caleiro, J. Ramos, and L. ViganoĚ. Labelled Tableaux for Distributed Temporal  Logic. Submitted for publication, 2008. Available  online at http://wslc.math.ist.utl.pt/ftp/  pub/CaleiroC/07-BCRV-dtl-tableaux.pdf.  [14] K. Lodaya, R. Ramanujam, and P. Thiagarajan. Temporal logics for communicating sequential agents: I.  Intern. Journal of Foundations of Computer Science,  3(1):117â159, 1992.  [2] A. Bolotov, O. Grigoriev, and V. Shangin. Automated Natural Deduction for Propositional LinearTime Temporal Logic. In Proc. TIME07, pages 47â58.  IEEE Computer Society Press, 2007.  [15] K. Lodaya and P. Thiagarajan. A modal logic for  a subclass of event structures. In Proc. ICALP 14,  LNCS 267, pages 290â303. Springer-Verlag, 1987.  [16] Z. Manna and A. Pnueli, editors. Temporal Verification of Reactive Systems: Safety. Springer-Verlag,  1995.  [3] C. Caleiro, L. ViganoĚ, and D. Basin. Metareasoning about Security Protocols using Distributed Temporal Logic. In Proc. ARSPAâ04, pages 67â89. ENTCS  125(1), 2005.  [17] D. Peled. All from one, one for all: on model checking  using representatives. In Proc. CAV â93, pages 409â  423. Springer-Verlag, 1993.  [4] C. Caleiro, L. ViganoĚ, and D. Basin. Relating strand  spaces and distributed temporal logic for security protocol analysis. Logic Journal of the IGPL, 13(6):637â  664, 2005.  [18] V. Pratt. Two easy theories whose combination is hard.  Technical report, MIT, Cambridge, 1977.  [19] R. Ramanujam. Locally linear time temporal logic. In  Proc. LICS 11, pages 118â127. IEEE Computer Society Press, 1996.  [5] S. Cerrito and M. Cialdea Mayer. Labelled tableaux  for propositional linear time logic over finite frames.  In D. Basin, M. DâAgostino, D. M. Gabbay,  S. Matthews, and L. ViganoĚ, editors, Labelled Deduction. Kluwer Academic Publishers, 2000.  [20] P. H. Schmitt and J. Goubault-Larrecq. A tableau  system for full linear temporal logic. Unpublished  manuscript.  [6] T. H. Cormen, C. E. Leiserson, R. L. Rivest, and  C. Stein. Introduction to Algorithms, Second Edition.  MIT Press, 2001.  [21] P. H. Schmitt and J. Goubault-Larrecq. A Tableau  System for Linear-TIME Temporal Logic.  In  Proc. TACASâ97, LNCS 1217, pages 130â144.  Springer-Verlag, 1997.  [7] M. DâAgostino, D. M. Gabbay, R. HaĚhnle, and  J. Posegga, editors. Handbook of Tableau Methods.  Kluwer Academic Publishers, 1999.  [22] S. Schwendimann. A New One-Pass Tableau Calculus  for PLTL. In Proc. Tableauxâ98, LNAI 1397, pages  277â291. Springer-Verlag, 1998.  [8] H.-D. Ehrich and C. Caleiro. Specifying communication in distributed information systems. Acta Informatica, 36:591â616, 2000.  [23] R. Scott, M. Fisher, and J. Keane. Parallel Temporal  Tableaux. In Proc. Euro-Parâ98, LNAI 1470, pages  852â861. Springer-Verlag, 1998.  [9] H.-D. Ehrich, M. Kollmann, and R. Pinger. Checking object system designs incrementally. Journal of  Universal Computer Science, 9(2):106â119, 2003.  [24] P. S. Thiagarajan. A Trace Consistent Subset of PTL.  In Proc. CONCURâ95, LNCS 962, pages 438â452.  Springer-Verlag, 1995.  [10] M. Fisher. Implementing Temporal Logics: Tools for  Execution and Proof. In Proc. CLIMA VI, LNAI 3900,  pages 129â142. Springer-Verlag, 2006.  [25] L. ViganoĚ and M. Volpe. Labeled Natural Deduction  Systems for a Family of Tense Logics. This volume.  [11] M. Fisher, D. M. Gabbay, and L. Vila, editors. Handbook of Temporal Reasoning in Artificial Intelligence  I. Elsevier, 2005.  [26] G. Winskel. Event structures. In W. Brauer, W. Reisig,  and G. Rozenberg, editors, Petri Nets: Applications  and Relationships to Other Models of Concurrency,  LNCS 255, pages 325â392. Springer-Verlag, 1987.  [12] G. D. Gough. Decision procedures for temporal  logic. Technical Report UMCS-89-10-1, Department  of Computer Science, University of Manchester, 1984.  [27] P. Wolper. The tableau method for temporal logic: An  overview. Logique et Analyse, 110:119â136, 1985.  9 