15th International Symposium on Temporal Representation and Reasoning  The Complexity of CaRet + Chop  Laura Bozzelli  UniversitaĚ dellâInsubria, Via Valleggio 11, 22100 - Como, Italy  + Past (obtained by adding non regular past and future versions of the standard LTL temporal modalities), has been  introduced [2] to allow the specification of such a class of  context-free requirements. Even though verifying contextfree properties of pushdown systems is in general undecidable, the pushdown model checking against CaRet is decidable and E XPTIME-complete (the same complexity as  that of pushdown model checking against LTL [5]). In [3],  the class of nondeterministic visibly pushdown automata  (NVPA) is proposed as an automata theoretic generalization  of CaRet. NVPA are pushdown automata where the input  symbol determines when the automaton can push or pop,  and thus the stack depth at every position. The resulting  class of languages (visibly pushdown languages or VPL) is  closed under all boolean operations and problems such as  universality and inclusion that are undecidable for contextâ  free languages are E XPTIMEâcomplete for VPL. Moreover,  NVPA have the same expressiveness as MSOÂľ [3], which extends the classical monadic second order logic (MSO) over  words with a binary matching predicate. The logic CaRet  is less expressive than NVPA and is easily expressible in the  first-order fragment FOÂľ of MSOÂľ . However, it is an open  question whether CaRet is FOÂľ-complete [1].  Abstract  We investigate the complexity of satisfiability and pushdown model-checking of the extension of the logic CaRet  with the binary regular modality âChopâ. We present  automata-theoretic decision procedures based on a direct  and compositional construction, which for finite (resp., infinite) words require time of exponential height equal to the  nesting depth of chop modality plus one (resp., plus two).  Moreover, we provide lower bounds which match the upper  bounds for the case of finite words.  1. Introduction  The modality âChopâ in linear temporal logic. In the literature some extensions of the linear temporal logic LTL [16],  with the same expressiveness as LTL, have been investigated  in order to support a compositional approach to the specification and verification of concurrent systems. These extensions enable modular and compositional reasoning about  sequential constructs as well as about concurrent ones. One  of the most important extensions of LTL is the addition of  the binary âchopâ modality [12, 17, 15], which allows to  âchopâ away parts of the computation. Thus, this modality is useful in cases we want to see subruns inside a run  (e.g., sessions, or specific fragments) and state their temporal specifications. Satisfiability for LTL + chop is nonelementary [17], and the best known upper bound, obtained  by a semantic-tableau method, requires space of exponential height equal to the nesting depth of chop modality (the  existence of a matching lower bound on the exponential  height of this complexity is an open question).  Our contribution. In this paper, we investigate the complexity of satisfiability and pushdown model-checking of  the logic CaRet + Chop (C-CaRet) in terms of the nesting  depth of chop modality. For each h âĽ 1, let C-CaReth be  the fragment of C-CaRet consisting of formulas with chop  nesting depth at most h, and let h-E XPTIME be the class  of languages which can be decided in (deterministic) time  of exponential height h. We show the following results for  C-CaReth : (1) for finite words, the considered problems are  (h + 1)-E XPTIME-complete, (2) for infinite words, the problems are in (h + 2)-E XPTIME and (h + 1)-E XPTIME-hard.  The linear temporal logic CaRet. Model checking of LTL  specification w.r.t. pushdown systems has been shown to be  a useful tool for analysis of programs with recursive procedures [4, 11, 10]. LTL, however, can specify only regular  properties, and properties which require either inspection  of the call-stack of a procedure, or matching of calls and  returns (such as correctness of procedures with respect to  pre and post conditions) are not regular. Recently, the linear temporal logic CaRet, a contextâfree extension of LTL  1530-1311/08 $25.00 ÂŠ 2008 IEEE  DOI 10.1109/TIME.2008.27  The upper bounds are obtained by an automata-theoretic  approach. For finite words, we propose a translation of  C-CaRet formulas into equivalent NVPA, while for infinite  words we exploit the class of alternating jump (finiteâstate)  automata (AJA) [6] which can be translated into equivalent  NVPA [6] with a single exponential-time blow-up. In both  cases, the construction is direct and compositional, and is  based on a non-trivial characterization of the satisfaction  23  relation, for a given formula Ď, in terms of sequences of  pairs of sets associated with Ď (which generalize the classical notion of Hintikka-set of LTL) satisfying determined  requirements which can be checked by NVPA and AJA.  Finally, the lower bounds for C-CaReth are obtained by a  non-trivial reduction from the word problem of alternating  Turing machines operating in space of exponential height  h. A straightforward readaptation of these reductions lead  to h-E XPSPACE-hardness for satisfiability of LTL + Chop  formulas with chop nesting depth at most h.  over ÎŁ, |w| denotes the length of w (we set |w| = â if w is  infinite), and for 0 â¤ i < |w|, w(i) is the ith symbol of w.  A nondeterministic visibly pushdown automaton (NVPA)  [3] is a pushdown automaton operating on words over a  pushdown alphabet which pushes onto the stack only when  it reads a call, pops the stack only at returns, and does not  use the stack on internal actions. Formally, a NVPA over  ÎŁ = ÎŁc âŞ ÎŁr âŞ ÎŁint is a tuple P = ÎŁ, Q, Q0 , Î, â, F, where  Q is a finite set of states, Q0 â Q is a set of initial states, Î is  the finite stack alphabet, F â Q is a set of accepting states,  and â = (Q Ă ÎŁc Ă Q Ă Î) âŞ (Q Ă ÎŁr Ă (Î âŞ {Îł0 }) Ă Q) âŞ  (Q Ă ÎŁint Ă Q) is the transition relation (where Îł0 â  / Î is the  special stack bottom symbol).  A configuration of P is a pair (q, Î˛), where q â Q and  Î˛ â Îâ Âˇ {Îł0 } is a stack content. A run of P over a word w  on ÎŁ is a sequence of configurations r = (q0 , Î˛0 )(q1 , Î˛1 ) . . .  of length |w|+ 1 such that Î˛0 = Îł0 , q0 â Q0 , and for each i <  |w|: [push] if w(i) â ÎŁc , then âB â Î such that Î˛i+1 = B Âˇ Î˛i  and (qi , w(i), qi+1 , B) â â; [pop] if w(i) â ÎŁr , then âB â Î âŞ  {Îł0 } such that (qi , w(i), B, qi+1 ) â â and either Î˛i = Î˛i+1 =  B = Îł0 , or B = Îł0 and Î˛i = B Âˇ Î˛i+1 ; [internal] if w(i) â  ÎŁint , then (qi , w(i), qi+1 ) â â and Î˛i = Î˛i+1 . The run r is  accepting iff either w is finite and q|w| â F, or w is infinite  and for infinitely many i âĽ 0, qi â F. The language L (P ) of  P is the set of words w over ÎŁ such that there is an accepting  run of P over w. A language L of words over ÎŁ is a visibly  pushdown language (VPL) if L = L (P ) for some NVPA P .  In order to model formal verification problems of pushdown systems M using finite specifications (such as NVPA)  denoting VPL languages, we choose a suitable pushdown alphabet ÎŁ = ÎŁc âŞ ÎŁr âŞ ÎŁint , and associate a symbol in ÎŁ with  each transition of M with the restriction that push transitions are mapped to ÎŁc , pop transitions are mapped to ÎŁr ,  and transitions that do not use the stack are mapped to ÎŁint .  Note that M equipped with such a labelling is a NVPA where  all the states are accepting. The specification S describes another VPL L (S) over ÎŁ, and M is correct iff L (M) â L (S).  Given a class C of finite specifications S describing VPL  over a pushdown alphabet ÎŁ, the pushdown model checking  problem against C -specifications for finite (resp., infinite)  words is to decide, given a pushdown system M over ÎŁ and a  specification S in the class C , whether L (M) âŠ ÎŁâ â L (S) âŠ  ÎŁâ (resp., L (M) âŠ ÎŁĎ â L (S) âŠ ÎŁĎ ).  Remark 1. C-CaRet can be easily translated into FOÂľ ,  hence it captures a strict subclass of VPL. Moreover, by results in [7] it easily follows that C-CaRet is FOÂľ -complete.  Related work. In the literature, different extensions of the  logic CaRet, which are expressively complete for FOÂľ , have  been investigated. In particular, Alur et al [1] propose two  extensions of CaRet. One of them is based on the notion of  a summary path that combines both regular and non-regular  next-modalities; for this logic, both satisfiability and pushdown model checking are shown to be E XPTIME-complete,  which is the same complexity as that of CaRet. The other  logic is an extension of CaRet with the non-regular unary  modality âwithinâ W, which essentially evaluates a formula  on a subword corresponding to the computation fragment  associated with a single procedure (including nested procedure calls). This logic is exponentially more succinct than  CaRet, and its satisfiability and pushdown model checking  are both 2E XPTIME-complete. An other extension of CaRet  has been studied in [7], where the extension is obtained  by adding the well-known unary regular modality âfrom  now onâ [14, 13], which allows to model forgettable past.  Satisfiability and pushdown model checking for the resulting logic are shown to be 2E XPTIME-complete. Moreover,  CaRet + W can be linearly translated into this logic.  2. Preliminaries  Let N be the set of natural numbers.  Definition 1. For all n, h â N, let Tower(n, h) be defined as:  Tower(n, 0) = n and Tower(n, h + 1) = 2Tower(n,h) . For each  h âĽ 0, exp[h] denotes the class of functions f : N â N such  that for some constant c âĽ 1, f (n) = Tower(nc , h) for each  n. We denote by h-E XPTIME the class of languages decided  by exp[h]-time bounded deterministic Turing machines.  2.2. The linear temporal logic C-CaRet  First, we recall the syntax and semantics of full CaRet [2].  Fix a pushdown alphabet ÎŁ = ÎŁc âŞ ÎŁr âŞ ÎŁint . For a word  w on ÎŁ and i â¤ j < |w|, w[i, j] denotes the finite word  w(i)w(i + 1) . . . w( j), and wi denotes the suffix of w starting  from position i. A finite word w is well-matched if inductively or (1) w is empty, or (2) w = Ďw , Ď â ÎŁint and w is  well-matched, or (3) w = Ďc w Ďr w , Ďc â ÎŁc , Ďr â ÎŁr , and  2.1. Visibly pushdown languages  A pushdown alphabet ÎŁ is an alphabet which is partitioned in three disjoint finite alphabets ÎŁc , ÎŁr , and ÎŁint ,  where ÎŁc is a finite set of calls, ÎŁr is a finite set of returns,  and ÎŁint is a finite set of internal actions. For a word w  24  operators of LTL. Formally, the syntax is defined as follows:  succ(c, w, 7)  w=  succ(a+ , w, 1)  0  c  1  c  2  i  3  c  4  i  i = internal action;  5  r  Ď ::=  | Ď | ÂŹĎ | Ď â§ Ď | Xdir Ď | Ď U dir Ď  succ(a+ , w, 7)  R  6  r  where  denotes true, Ď â ÎŁ, and dir â {+, â, a+ , aâ , c}.  Note that X+ and U + correspond to the usual ânextâ and  âuntilâ operators of LTL, while Xâ and U â are their past  counterparts. CaRet is interpreted on words w over ÎŁ.  Given a formula Ď and a position i in w, the satisfaction  relation (w, i) |= Ď (which reads as âw satisfies Ď at position iâ) is inductively defined as follows, where dir â  {+, â, a+ , aâ , c} (we omit the rules for atomic actions in  ÎŁ and boolean connectives which are standard):  R  7  c  c = call;  8  i  9  r  10  i  r = return  w and w are well-matched. CaRet is based on five different notions of successor for a position i along a word w:  â˘ The forward local successor of i along w, written  succ(+, w, i), is i + 1 if i + 1 < |w|, and it is âĽ otherwise (the symbol âĽ is for âundefinedâ).  â˘ (w, i) |= Xdir Ď â succ(dir, w, i) = j = âĽ and (w, j) |= Ď  â˘ (w, i) |= Ď1 U dir Ď2 â for the dir-path Î˝ = j0 , j1 , . . . of  w starting from i, ân < |Î˝| such that (w, jn ) |= Ď2 and  â0 â¤ h < n, (w, jh ) |= Ď1 .  â˘ The backward local successor of i along w, written  succ(â, w, i), is i â 1 if i > 0, and it is âĽ otherwise.  The logic C-CaRet extends CaRet with the binary regular  modality âChopâ, written C, whose semantics is given by  â˘ The forward abstract successor of i along w [2],  succ(a+ , w, i). If w(i) â ÎŁc , succ(a+ , w, i) is the matching return position of i if any, i.e. : if there is j > i  s.t. w( j) â ÎŁr and w[i + 1, j â 1] is well-matched, then  succ(a+ , w, i) = j (note that j is uniquely determined),  / ÎŁc , then  otherwise succ(a+ , w, i) = âĽ. If instead w(i) â  succ(a+ , w, i) = i + 1 if i + 1 < |w| and w(i + 1) â  / ÎŁr ,  and succ(a+ , w, i) = âĽ otherwise.  â˘ (w, i) |= Ď1 CĎ2 â âi â¤ n < |w| such that (w[0, n], i) |=  Ď1 and (wn , 0) |= Ď2 .  Note that the future regular fragment of C-CaRet, obtained by disallowing operators Xdir and U dir with dir â  {â, a+ , aâ , c}) corresponds to the logic LTL + C [12]. We  denote by L (Ď) the language of words w over ÎŁ s.t. (w, 0) |=  Ď. The satisfiability problem of C-CaRet for finite words  (resp., infinite words) is to decide whether L (Ď) âŠ ÎŁâ = 0/  / for a given formula Ď.  (resp., L (Ď) âŠ ÎŁĎ = 0)  For a C-CaRet formula Ď, we denote by dC (Ď) the nesting depth of modality C in Ď. Moreover, for each h âĽ 0,  C-CaReth denotes the C-CaRet-fragment consisting of formulas Ď s.t. dC (Ď) â¤ h, and future C-CaRet is the fragment  obtained by disallowing the backward temporal modalities.  â˘ The backward abstract successor of i along w,  succ(aâ , w, i). If w(i) â ÎŁr , then it points to the matching call of i if any; otherwise, succ(aâ , w, i) = âĽ. If instead w(i) â  / ÎŁr , then succ(aâ , w, i) = i â 1 if i â 1 > 0  and w(i â 1) â  / ÎŁc , and succ(aâ , w, i) = âĽ otherwise.  â˘ The caller of i along w [2], succ(c, w, i), points to the  last unmatched call of the prefix w[0, h] (where h =  i â 1 if i is a call position, and h = i otherwise), i.e. :  if there is j < i such that w( j) â ÎŁc and w[ j + 1, h]  is wellâmatched , then succ(c, w, i) = j (note that j is  uniquely determined), otherwise succ(c, w, i) = âĽ.  2.3. Alternating jump automata (AJA)  Alternating jump (finite-state) automata (AJA) [6] operate on infinite words over a pushdown alphabet and capture exactly the class of VPL. AJA extend standard alternating finiteâstate automata by also allowing non-local moves:  on reading a matched-call Ďc , a copy of the automaton can  move (jump) in a single step to the matching-return of Ďc .  For a finite set X, B p (X) denotes the set of positive  boolean formulas over X built from elements in X using  â¨ and â§ (we also allow the formulas true and false). A  subset Y of X satisfies Î¸ â B p (X) iff the truth assignment  assigning true to the elements in Y and false to the elements of X \ Y satisfies Î¸.  A generalized BuĚchi AJA is a tuple A = ÎŁ, Q, Q0 , Î´, F ,  where ÎŁ is a pushdown alphabet, Q is a finite set of states,  For i < |w| and dir â {+, â, a+ , aâ , c}, the dir-path of w  from i, is the maximal sequence of positions Î˝ = j0 , j1 , . . .  s.t. j0 = i and jh = succ(dir, w, jhâ1 ) for each 0 < h < |Î˝|.  Intuitively, the forward abstract paths and the backward abstract paths (i.e., the a+ -paths and aâ -paths) capture the local computation within a procedure removing computation  fragments corresponding to nested calls within the procedure, while a caller path (i.e., a c-path) captures the content  of the call-stack of a procedure. For example, in the figure  above, the sequence of positions 4, 3, 1, 0 is a caller path,  while the sequence 1, 6, 7, 9, 10 is a forward abstract path.  For each type of successor, CaRet provides the corresponding versions of the usual ânextâ (X) and âuntilâ ( U )  25  Q0 â Q is the set of initial states, Î´ : Q Ă ÎŁ â B p ({+, a+ } Ă  Q Ă Q) is the transition function, and F = {F1 , . . . , Fk } is a  set of sets of accepting states. Intuitively, a target of a move  of A is encoded by a triple (dir, q, q ) â {+, a+ } Ă Q Ă Q,  meaning that a copy of A on reading the ith input symbol of  the given word w moves to position succ(dir, w, i) in state q  if succ(dir, w, i) = âĽ , and to position i + 1 in state q otherwise. Formally, a run of A over an infinite word w â ÎŁĎ is a  N Ă Q-labeled tree r such that the root is labeled by (0, q0 )  with q0 â Q0 and for each node x with label (i, q) (describing a copy of A in state q which reads w(i)), there is a (possibly empty) set H = {(dir1 , q1 , q1 ), . . . , (dirm , qm , qm )} â  {+, a+ } Ă QĂ Q satisfying Î´(q, w(i)) such that x has m children x1 , . . . , xm , and for each 1 â¤ h â¤ m: xh has label (i +  1, qh ) if succ(dirh , w, i) = âĽ, and label (succ(dirh , w, i), qh )  otherwise. The run r is accepting if for each infinite path  x0 x1 . . . in the tree and each accepting component F â F ,  there are infinitely many i âĽ 0 s.t. xi is labeled by some state  in F. The Ď-language of A , LĎ (A ), is the set of w â ÎŁĎ such  that there is an accepting run r of A over w.  chop modality is meaningfully different from that proposed  in [17] for LTL + Chop. The regular and non-regular next  requirements are captured locally requiring that consecutive pairs (Ari , Ai ), (Ari+1 , Ai+1 ) along the sequence Ď satisfy  determined syntactical constraints. For example, if w(i) is  a call, w(i + 1) is not a return, and UM(w, i + 1) = âĽ, then  UM(w, i + 1) represents the matching return position of i  along w. Thus, we have to require that the forward-abstractnext requirements in Ai are exactly the ones that hold in  Ari+1 , and the backward-abstract-next requirements in Ari+1  are exactly the ones that hold in Ai . Finally, if w is infinite, then the sequence Ď has to satisfy fairness non-local  additional conditions reflecting the liveness requirements in  forward until subformulas of Ď, and the liveness requirements Ď1 in chop subformulas Ď1 CĎ2 of Ď. Now, we give  the technical details.  A formula Ď is said to be a first-level subformula of Ď if  there is an occurrence of Ď in Ď which is not in the scope of  a chop operator. The closure Cl(Ď) of Ď is the smallest set  containing , Xdir  for each dir â {+, â, a+ , aâ , c}, all the  first-level subformulas of Ď, Xdir (Ď1 U dir Ď2 ) for any firstlevel subformula Ď1 U dir Ď2 of Ď, and the negations of all  these formulas (we identify ÂŹÂŹĎ with Ď). A simple atom A  is a subset of Cl(Ď) such that  â˘ A âŠ ÎŁ is a singleton and  â A;  â˘ if Ď â Cl(Ď), then Ď â A iff ÂŹĎ â  / A;  â˘ if Ď1 â§ Ď2 â Cl(Ď), then Ď1 â§ Ď2 â A iff Ď1 , Ď2 â A;  â˘ if Ď1 U dir Ď2 â Cl(Ď), then Ď1 U dir Ď2 â A iff either Ď2 â  A or Ď1 , Xdir (Ď1 U dir Ď2 ) â A;  â˘ if Xdir Ď â A, then Xdir  â A;  â  â˘ if ÂŹXâ  â A, then ÂŹXa , ÂŹXc  â A;  +  â˘ if ÂŹX+  â A, then ÂŹXa  â A.  where dir â {+, â, a+ , aâ , c}. Intuitively, the set of formulas in a simple atom of Ď represents a maximal set of  first-level subformulas of Ď that can consistently hold at a  position along a word over ÎŁ. For each forward local until formula Ď1 U + Ď2 â Cl(Ď), we introduce a new symbol  ĎĎ2 associated with the liveness requirement Ď2 (whose intuitive meaning will be given later), and denote by P(Ď) the  set of these symbols.  Now, we define the set Atoms(Ď) of atoms of Ď by induction on the chop nesting depth dC (Ď): A â Atoms(Ď) iff      /  A â Cl(Ď)âŞP(Ď)âŞ Ď1 CĎ2 âCl(Ď) h=2  h=1 (Atoms(Ďh )âŞ{0})Ă  Atoms(Ďh ) Ă {Ď1 CĎ2 } Ă {h} Ă {Y ES, NO} and the following additional conditions hold for each subformula  Ď1 CĎ2 â Cl(Ď):  3. Decision Procedures for C-CaRet  In this section we solve satisfiability and pushdown  model-checking of C-CaRet by an automata-theoretic approach. For finite words, we propose a translation of  C-CaRet formulas into equivalent NVPA, while for infinite  words we exploit AJA. In both cases, the construction is direct and compositional. In the rest of this section, first, we  give a non-trivial characterization of the satisfaction relation (w, 0) |= Ď, for a given formula Ď, in terms of sequences  of pairs of sets associated with Ď satisfying determined requirements which can be checked by NVPA and AJA. Then,  we describe the translation into NVPA (for finite words) and  AJA (for infinite words) based on this characterization.  Fix a pushdown alphabet ÎŁ. For a word w over ÎŁ and  i < |w|, the next unmatched return of i in w, UM(w, i), is  defined as: if the caller of i is defined and has matching  return ir , then UM(w, i) = ir ; otherwise, UM(w, i) = âĽ.  In the following, we fix a C-CaRet formula Ď. Essentially, for each finite or infinite word w over ÎŁ, we associate  to w sequences (of length |w|) Ď = (Ar0 , A0 ), (Ar1 , A1 ), . . . of  pairs of sets, where for each 0 â¤ i < |w|, Ai is an atom  and intuitively describes a maximal set of subformulas of  Ď which can hold at position i along w, while Ari = 0/ if  UM(w, i) = âĽ, and Ari = A j with j = UM(w, i) otherwise.  As for LTL, the notion of atom syntactically captures in particular the semantics of boolean connectives and the fixpoint characterization of the until modalities in terms of  the next modalities of the same type. Moreover, the notion of atom also partially (and syntactically) captures the  semantics of chop modality. Since C-CaRet has also backward modalities, the approach proposed here to handle the  1. A âŠ Cl(Ď) is a simple atom;  2. if (Br , B, Ď1 CĎ2 , h, f ) â A, then B âŠ ÎŁ = A âŠ ÎŁ, and if  /  either ÂŹXâ  â B or ÂŹX+  â B, then Br = 0;  3. if (Br , B, Ď1 CĎ2 , 2, f ) â A and dir â {+, a+ }, then  Xdir  â A iff Xdir  â B;  26  / Ă Atoms(Ď) to a set of pairs in (Atoms(Ď) âŞ {0})  / Ă  {0})  Atoms(Ď). Intuitively, if A is the atom associated with  the current position i of the given word w, and Ar is the  atom associated with UM(w, i) if UM(w, i) = âĽ, and Ar =  0/ otherwise, then Jump SuccĎ (Ar , A) contains that pairs  (Ar , A ) such that A is a atom associable to the next position i + 1 and Ar is the corresponding atom associable to  UM(w, i + 1). Formally, (Ar , A ) â Jump SuccĎ (Ar , A) iff  A â SuccĎ (A) and the following is inductively satisfied:  4. if (Br , B, Ď1 CĎ2 , 1, f ) â A, then for each dir â  {â, aâ }, Xdir  â A iff Xdir  â B, and for each dir â  {+, a+ }, if Xdir  â B then Xdir  â A ;  5. Ď1 CĎ2 â A iff â(Br , B, Ď1 CĎ2 , 1,Y ES) â A. Ď1 â B;  6. â(Br , B, Ď1 CĎ2 , 1,Y ES) â A such that ÂŹX+  â B iff  â(Cr ,C, Ď1 CĎ2 , 2, f ) â A such that Ď2 , ÂŹXâ  â C;  7. â(Cr ,C, Ď1 CĎ2 , 2, f ) â A such that ÂŹXâ  â C.  /  1. â(Br , B, Ď1 CĎ2 , 1, f ) â A, Br = 0/ if Ar = 0;  Intuitively, the meaning of a tuple (Br , B, Ď1 CĎ2 , h, f ) â  A is as follows: if h = 1 and the current position is i, then  B describes the set of subformulas of Ď1 which hold at position i of a prefix w p of the given word w, and Br is the set  associated with UM(w p , i) if UM(w p , i) = âĽ, and Br = 0/  otherwise. Moreover, f = Y ES iff the suffix of w starting from the last position of w p initially satisfies Ď2 . If  instead h = 2 and the current position is i, then there is  j â¤ i, such that B describes the set of subformulas of Ď2  which hold at position i â j of w j , and Br is the set associated with UM(w j , i â j) (if any). Note that the value  of f is irrelevant if h = 2 (we introduce it only to have a  uniform notation). By construction it easily follows that  |Atoms(Ď)| = Tower(|Ď|, dC (Ď) + 1).  For A â Atoms(Ď), let Ď(A) be the unique element in  A âŠ ÎŁ, and let CallerFormĎ (A) = {Xc Ď â Cl(Ď) | Xc Ď â  A}. For atoms A and A , the predicate AbsReqĎ (A, A )  +  â  +  holds iff for all Xa Ď, Xa Ď â Cl(Ď), (Xa Ď â A â Ď â  â  A ) and (Xa Ď â A â Ď â A). Similarly, the predicate LocReqĎ (A, A ) holds iff for all X+ Ď, Xâ Ď â Cl(Ď)  (X+ Ď â A â Ď â A ), and (Xâ Ď â A â Ď â A).  Let JumpĎ , SuccĎ : Atoms(Ď) â 2Atoms(Ď) be the functions defined as follows:  2. Case (Ď(A) â ÎŁc and Ď(A ) â ÎŁr ) or (Ď(A) â  / ÎŁc and  / ÎŁr ): Ar = Ar and for each ĎĎ â P(Ď), ĎĎ â A  Ď(A ) â  iff either Ď â A or ĎĎ â A where ĎĎ = Ď if Ar = 0/ and  Ď(A) â ÎŁc , and ĎĎ = ĎĎ otherwise;  3. Case Ď(A) â  / ÎŁc and Ď(A ) â ÎŁr : Ar = Ar = 0/ if  â  / A , and Ar = A and for each ĎĎ â P(Ď),  Xa  â  ĎĎ â A iff Ď â A âŞ A , otherwise. Moreover, if  (Br , Br , Ď1 CĎ2 , h, f ) â A and (Br , B, Ď1 CĎ2 , h, f ) â A,  then (Br , Br ) â Jump SuccĎh (Br , B);  +  /  4. Case Ď(A) â ÎŁc , Ď(A ) â  / ÎŁr , Xa  â  / A: Ar = Ar = 0;  +  5. Case Ď(A) â ÎŁc , Ď(A ) â  / ÎŁr , and Xa  â A: Ar =  / Ar â JumpĎ (A) and for each ĎĎ â P(Ď), ĎĎ â A  0,  / or (ĎĎ â  iff or Ď â A or (ĎĎ â A âŞ Ar and Ar = 0)  /  Also, â (Br , Br , Ď1 CĎ2 , 1, f ) â Ar ,  A and Ar = 0).  â (Br , B , Ď1 CĎ2 , 1, f ) â A , â(Br , B, Ď1 CĎ2 , 1, f ) â A.  (Br , B ) â Jump SuccĎ1 (Br , B);  6. â(Br , B, Ď1 CĎ2 , h, f ) â A such that X+  â B,  â(Br , B , Ď1 CĎ2 , h, f ) â A such that (Br , B ) â  Jump SuccĎh (Br , B); moreover, if Ď(A) â ÎŁc ,  / then (Br , Br , Ď1 CĎ2 , h, f ) â Ar ;  Ď(A ) â  / ÎŁr , and Br = 0,  â˘ A â JumpĎ (A) iff CallerFormĎ (A) = CallerFormĎ (A )  and AbsReqĎ (A, A ).  7. â(Br , B , Ď1 CĎ2 , 1, f ) â A , â(Br , B, Ď1 CĎ2 , 1, f ) â A  such that (Br , B ) â Jump SuccĎ1 (Br , B); moreover,  / then  / ÎŁr , and Br = 0,  if Ď(A) â ÎŁc , Ď(A ) â  (Br , Br , Ď1 CĎ2 , 1, f ) â Ar .  â˘ A â SuccĎ (A) iff LocReqĎ (A, A ) and:  - Case either (Ď(A) â ÎŁc and Ď(A ) â ÎŁr ) or (Ď(A) â  /  ÎŁc and Ď(A ) â  / ÎŁr ): A â JumpĎ (A);  There are many subtleties in definition of Jump SuccĎ  which cannot discussed here due to lack of space. Here, we  only give the intuitive meaning of the rules for the propositions ĎĎ , where Ď1 U + Ď â Cl(Ď) for some Ď1 : if the current position i is a matched call with matching return j,  / A) is the pair associated with posiUM(w, i) = âĽ, and (0,  tion i, then ĎĎ â A iff Ď holds at some position in [i, j].  Given a word w over ÎŁ, i â N, and   j â N âŞ {â} such  that i â¤   j â¤ |w| â 1, a fulfilling (i,   j, Ď)-sequence over  w is a sequence Ď = (Ari , Ai ), (Ari+1 , Ai+1 ), . . . of pairs in  / Ă Atoms(Ď) of length   (Atoms(Ď) âŞ {0})  j â i + 1 such that  â  +  â˘ ÂŹX  â Ai if i = 0, and ÂŹX  â A j if   j = |w|â 1 â N;    â˘ for each i â¤ l â¤ j, Ď(Al ) = w(l);  / ÎŁr : CallerFormĎ (A ) =  - Case Ď(A) â ÎŁc and Ď(A ) â  â  c  {X Ď â Cl(Ď) | Ď â A} and Xa  â  /A;  +  - Case Ď(A) â  / ÎŁc and Ď(A ) â ÎŁr : Xa  â  / A, (Xc  â  aâ  c  c  A iff X  â A ), and X  â  / A if X  â  / A.  Intuitively, SuccĎ (A) is the set of atoms A containing  the first-level subformulas of Ď which can hold at the next  position i + 1 of the current position i. Moreover, assuming  that the forward abstract position j of i along the given word  is defined, JumpĎ (A) gives the set of atoms containing the  first-level subformulas of Ď which can hold at position j.  Now, we define by induction on dC (Ď) the function  Jump SuccĎ which maps each pair (Ar , A) â (Atoms(Ď) âŞ  27  â˘  â˘  â˘  â˘  for each i â¤ l <   j, (Arl+1 , Al+1 ) â Jump SuccĎ (Arl , Al );  for all i â¤ l, l â¤   j, Arl = Arl if UM(w, l) = UM(w, l );  for each i â¤ l â¤   j, if UM(w, l) = l â¤   j, then Arl = Al ;  r  for each i â¤ l â¤   j, Al = 0/ if UM(w, l) = âĽ.  Corollary 1. For each word w over ÎŁ, (w, 0) |= Ď iff there  is a fulfilling Ď-sequence Ď = (Ar0 , A0 ), . . . over w such that  /  Ď â A0 and Ď is fair if w is infinite (note that Ar0 = 0).  Translation into NVPA and AJA For finite fords, the translation of C-CaRet formulas Ď into equivalent NVPA PĎ ,  based on the result of Corollary 1 is simple. Essentially, for  a given input w, the NVPA PĎ guesses (by its finite control)  a sequence Ď = (Ar0 , A0 ), . . . and by using the stack checks  that it is a fulfilling Ď-sequence over w. Details are in [8].  A fulfilling (0, |w| â 1, Ď)-sequence over w is called simply fulfilling Ď-sequence over w. A fulfilling Ď-sequence  Ď = (Ar0 , A0 ), (Ar1 , A1 ), . . . over an infinite word w â ÎŁĎ is  fair if the following is inductively satisfied for each i âĽ 0:  1. if (Cr ,C, Ď1 CĎ2 , 2, f ) â Ai and ÂŹXâ  â C, then there  is a fair fulfilling Ď2 -sequence over wi from (Cr ,C);  Theorem 3. Let Ď be a C-CaRet formula over ÎŁ. Then, one  can construct a NVPA PĎ of size O(Tower(|Ď|, dC (Ď) + 1))  such that L (PĎ ) âŠ ÎŁâ = L (Ď) âŠ ÎŁâ .  / then there  2. if (Br , B, Ď1 CĎ2 , 1,Y ES) â Ai and Ari = 0,  are m âĽ i, a fulfilling (i, m, Ď1 )-sequence over w[0, m]  starting from (Br , B), and a fulfilling fair Ď2 -sequence  (Cr ,C), . . . over wm such that Ď2 â C;  For infinite words, we obtain the following result.  Theorem 4. Let Ď be a C-CaRet formula over ÎŁ. Then,  one can construct a generalized BuĚchi AJA AĎ of size  O(Tower(|Ď|, dC (Ď) + 1)) such that LĎ (AĎ ) = L (Ď) âŠ ÎŁĎ .  a+  3. if Ď1 U Ď2 â Cl(Ď) , then for infinitely many h âĽ 0,  +  /  Arh = 0/ and {Ď2 , ÂŹ(Ď1 U a Ď2 )} âŠ Ah = 0;  Proof. We construct a generalized BuĚchi AJA AĎ of  size O(Tower(|Ď|, dC (Ď) + 1)) with set of states QĎ â  / Ă Atoms(Ď) and initial states of the form  (Atoms(Ď) âŞ {0})  / A)  / A) with Ď, ÂŹXâ  â A s.t. for each state of the form (0,  (0,  with ÂŹXâ  â A and infinite word w, AĎ has an accepting  / A) iff there is a fair fulfilling Ď-sequence  run over w from (0,  / A). Hence, the result follows from Corolover w from (0,  lary 1. The construction is given by induction on dC (Ď).  Thus, we can assume that for each Ď1 CĎ2 â Cl(Ď) (note  that if dC (Ď) = 0, there is no such a formula), one can construct the AJA AĎ2 associated with Ď2 . Here, we describe  informally the main aspects of the AJA AĎ (the formal definition is given in [8]). Essentially, AĎ guesses a fulfilling  Ď-sequence over the input word w and checks that it is fair.  Assume that AĎ starts the computation in a state of the  / A) with ÂŹXâ  â A. Then, the first-level copy of  form (0,  AĎ behaves as follows. When a symbol w(i) is read in a  / A) (where Ď(A) = w(i)) and i is not a matchedstate (0,  call position (note that AĎ can check whether this condi/ A)â  tion is satisfied or not), then AĎ guesses a pair (0,  / A) and proceeds as follows. A copy (the  Jump SuccĎ (0,  first-level copy) moves to the next input symbol in state  / A ). Moreover, in order to check that Properties 1 and  (0,  2 in def. of fair fulfilling Ď-sequence are satisfied, for each  (Cr ,C, Ď1 CĎ2 , 2, f ) â A with ÂŹXâ  â C (note that by def.  / AĎ starts an additional copy of the AJA AĎ2  of atom Cr = 0),  in state (Cr ,C), and for each (Br , B, Ď1 CĎ2 , 1,Y ES) â A, AĎ  starts a copy in a state of the form (Br , B, Ď1 CĎ2 , ÂŹUM).  The behavior of this last copy will be explained later. Now,  assume that i is a matched-call position and w(i + 1) â  / ÎŁr  (the case w(i + 1) â ÎŁr is simpler). As above, AĎ starts  additional copies to check Properties 1 and 2 in def. of  fair fulfilling Ď-sequence. Moreover, AĎ guesses a pair  / A). Assume that Ď(A ) = w(i + 1)  (Ar , A ) â Jump SuccĎ (0,  4. if Ď1 U + Ď2 â Cl(Ď), then for infinitely many h âĽ 0,  / and or Ď2 â Ah , or ÂŹ(Ď1 U + Ď2 ) â Ah , or  Arh = 0,  +  (ĎĎ2 , Xa  â Ah and Ď(Ah ) â ÎŁc ).  The notion of fairness is used to capture recursively the  liveness requirements in forward until subformulas of Ď  (Properties 1, 3, and 4 above), and the liveness requirements  Ď1 in chop subformulas Ď1 CĎ2 of Ď (Property 3 above). As  we will see, the AJA associated with Ď guesses a fulfilling  Ď-sequence Ď over the infinite input word and checks that  it is fair. The automaton keeps tracks by its finite control  of the current pair of Ď, and in particular, its âmainâ copy  tracks an infinite path in the run which visits all and only  the nodes which are associated with the pairs (Ar , A) of Ď  / Thus, the acceptance condition of the AJA  such that Ar = 0.  (when interpreted on the main path) exactly reflects Properties 3 and 4 above. In particular, the propositions ĎĎ2 are  used to guarantee that in case Ď1 U + Ď2 is asserted at a node  x of the main path and the liveness requirement Ď2 does not  hold along the suffix of the main path from x, then Ď2 holds  at some other position j âĽ i (i.e., there is a pair (Ar , A) with  Ar = 0/ of the guessed Ď-sequence associated with position  j for some j âĽ i such that Ď2 â A).  The proofs of the following results are given in [8].  Theorem 1 (Correctness). Let Ď = (Ar0 , A0 ), (Ar1 , A1 ) . . . be  a fair fulfilling Ď-sequence on w which is fair if w is infinite.  Then, for all i < |w| and Ď â Cl(Ď), (w, i) |= Ď iff Ď â Ai .  Theorem 2 (Completeness). For each word w over ÎŁ, there  is a fulfilling Ď-sequence over w, which is fair if w is infinite.  By Theorems 1 and 2 we obtain the following characterization of the satisfaction relation (w, 0) |= Ď.  28  (otherwise the input is rejected). Then, Ar = 0/ represents  the guessed atom associated with the matching return position ir of i. Thus, a copy (the first-level copy) jumps  / Ar ) (note that  to the matching-return ir of i in state (0,  UM(w, i) = UM(w, ir ) = âĽ), and another copy moves to position i + 1 in state (Ar , A ). The goal of this last copy is  also to check that the guess Ar is correct. The behavior  of these auxiliary copies, which are in states of the form  (Ar , A) with Ar = 0/ is as follows. If the input symbol w(i)  is a call (note that i is a matched call-position) or (w(i) â  / ÎŁc  and w(i + 1) â  / ÎŁr ), the behavior is similar to that of the  first-level copy. If instead, w(i) = Ď(A) is not a call, and  w(i + 1) is a return, then Ar = 0/ is the guessed atom associated with w(i + 1). Thus, the considered copy terminates with success its computation iff Ď(Ar ) = w(i + 1) and  (Ar , Ar ) â Jump SuccĎ (Ar , A) for some Ar (note that since  Ď(A) â  / ÎŁc and Ď(Ar ) â ÎŁr , by def. of Jump SuccĎ the fulfilment of this condition is independent on the value of Ar ).  Now, we describe the behavior of AĎ in states of the form  (Br , B, Ď1 CĎ2 , f ), where f â {STOP,UM, ÂŹUM}. Assume  that the current symbol is w(i). Essentially, AĎ guesses a  fulfilling (i, m, Ď1 )-sequence Ď over w[0, m] starting form  (Br , B) for some m âĽ i, and on reading w(m) starts an addi/  s.t. Ď2 , ÂŹXâ  â C.  tion copy of the AJA AĎ2 in a state (0,C)  In order to check the existence of Ď, AĎ proceeds similarly  to the first-level copy. The unique difference is that now  Br can be empty even if UM(w, i) = âĽ. Thus, the flag f is  used to keep track if this last condition is satisfied or not. If  / and  for example, w(i) is not a call, w(i + 1) â ÎŁr , Br = 0,  f = UM (i.e., UM(w, i) = âĽ), then m must be equal to i.  Finally, the BuĚchi acceptance condition of AĎ extends  the acceptance conditions of the AJAs AĎ2 with additional  / A)  sets used to check that the infinite sequence of states (0,  visited by the first-level copy of AĎ (note that these states  correspond to the pairs (Ar , A) visited by the simulated ful/ satisfies Properfilling Ď-sequence over w such that Ar = 0)  ties 3 and 4 in def. of fair fulfilling Ď-sequence.  4. Lower Bounds  In this section we show that for each h âĽ 0, satisfiability and pushdown model-checking of C-CaReth for both  finite and infinite runs are (h + 1)-E XPTIME-hard (also  for future C-CaReth ) by a reduction from the word problem for exp[h]âspace bounded alternating Turing Machines.  It is well-known [9] that the class of all languages accepted by these machines coincides with (h + 1)-E XPTIME.  Formally, an alternating Turing Machine is a tuple M =  A, Q, Qâ , Qâ , q0 , Î´, F, where A is the input alphabet, Q =  Qâ âŞQâ is the finite set of states, q0 is the initial state, F â Q  is the set of accepting states, and Î´ : Q Ă A â (Q Ă A Ă {â  , â}) Ă (Q Ă A Ă {â, â}) is the transition function.  Configurations of M are words in Aâ Âˇ (Q Ă A) Âˇ Aâ . A  configuration C = Îą Âˇ (q, a) Âˇ Îą denotes that the tape content is Îą Âˇ a Âˇ Îą , the current state is q, and the reading head  is at position |Îą| + 1. For the configuration C, we denote  by succl (C) and succr (C) the successors of C obtained by  choosing respectively the left and the right triple in Î´(q, a).  C is accepting if the associated state q belongs to F. Given  an input Îą â Aâ , a (finite) computation tree of M over Îą  is a finite tree in which each node is labelled by a configuration. The root of the tree corresponds to the initial configuration associated with Îą. An internal node that corresponds to a universal configuration (i.e., the associated state  is in Qâ ) has two successors, corresponding to succl (C) and  succr (C), while an internal node that corresponds to an existential configuration (i.e., the associated state is in Qâ )  has a single successor, corresponding to either succl (C) or  succr (C). The tree is accepting if every leaf is labelled by  an accepting configuration. An input Îą â ÎŁâ is accepted by  M if there is an accepting computation tree of M over Îą.  Fix n âĽ 1, a finite alphabet ÎŁ âŞ {0, 1}, and a countable  set {$1 , $2 , . . .} of symbols non in ÎŁ âŞ {0, 1}. First, for each  h âĽ 1, we define by induction on h an encoding of the integers in [0, Tower(n, h) â 1] by words, called (h, n)-codes,  over {$1 , . . . , $h , 0, 1} of the form $h w$h , where w does not  contain occurrences of $h .  For a pushdown system M and C-CaRet formula Ď, checking whether L (M) âŠ ÎŁâ â L (Ď) âŠ ÎŁâ (resp., L (M) âŠ ÎŁĎ â  L (Ď)âŠÎŁĎ ) reduces to check emptiness of L (M)âŠ L (PÂŹĎ )âŠ  ÎŁâ (resp., L (M) âŠ LĎ (AÂŹĎ )), where PÂŹĎ (rep., AÂŹĎ ) is the  NVPA (resp., the AJA) of Theorem 3 (resp., Theorem 4) associated with ÂŹĎ. By [3] (resp., [6]) this can be done in  time polynomial in the size of M and polynomial (resp.,  singly exponential) in the size of PÂŹĎ (rep., AÂŹĎ ). Since  nonemptiness of NVPA (resp., AJA) is in in P TIME (resp.,  E XPTIME), by Theorems 3â4 we obtain the following.  Base Step: h = 1. A (1, n)-block over ÎŁ is a finite word  w over {$1 , 0, 1} âŞ ÎŁ having the form w = $1 Ďb1 . . . bn $1 ,  where Ď â ÎŁ âŞ {0, 1} and b1 , . . . , bn â {0, 1}. The blockcontent CON(w) of w is Ď, and the block-number NUM(w)  of w is the natural number in [0, Tower(n, 1) â 1] (recall that  Tower(n, 1) = 2n ) whose binary code is b1 . . . bn .1 An (1, n)code is a (1, n)-block w such that CON(w) â {0, 1}  Induction Step: let h âĽ 1. A (h + 1, n)-block over ÎŁ  is a finite word w on the alphabet {$1 , . . . , $h+1 , 0, 1} âŞ ÎŁ  of the form w = $h+1 Ď$h w1 $h w2 $h . . . $h wK $h $h+1 , where  Ď â {0, 1} âŞ ÎŁ, K = Tower(n, h) and for each 1 â¤ i â¤  K, $h wi $h is a (h, n)-code such that NUM($h wi $h ) =  Theorem 5. For each h âĽ 1, satisfiability and pushdown  model-checking of C-CaReth for finite (resp., infinite) words  are in (h + 1)-E XPTIME (resp., (h + 2)-E XPTIME).  1 we  29  assume that b1 is the least significant bit  i â 1. The block-content CON(w) of w is the symbol  Ď, and the block-number NUM(w) of w is the natural  number in [0, Tower(n, h + 1) â 1] whose binary code is  CON($h w1 $h ) . . . CON($h wK $h ). A (h + 1, n)-code is a  (h + 1, n)-block w such that CON(w) â {0, 1}.  For each h âĽ 1, a (h, n)-configuration over ÎŁ is a finite  word w of the form w = $h+1 $h w1 $h w2 $h . . . $h wK $h $h+1 ,  where K = Tower(n, h) and for each 1 â¤ i â¤ K, $h wi $h  is a (h, n)-block such that NUM($h wi $h ) = i â 1 and  CON($h wi $h ) â ÎŁ. As we will see, (h, n)-configurations are  used to encode the configurations reachable by exp[h]-space  bounded alternating Turing machines on input of size n.  We will use the following result, whose proof is given in  [8]. For a word w, let wâ1 be the reverse of w.  over ÎŁP given by (b, w(0))(b, w(1)) . . .. In the following for  a LTL + C formula Ď over ÎŁ , [Ď]c (resp., [Ď]r ) denotes the LTL  + C formula over ÎŁP obtained by replacing each occurrence  of an action Ď â ÎŁ in Ď with (c, Ď) (resp., (r, Ď)).  Now, we describe the encoding of (finite) computation  trees of M over Îą. The code of a TM configuration C =  u1 . . . uTower(n,h) is the (n, h)-configuration over ÎŁ given by  $h+1 $h w1 $h . . . $h wTower(n,h) $h $h+1 , where for each 1 â¤ i â¤  Tower(n, h), CON($h wi $h ) = ui . The code of a computation  tree T of M over Îą is the infinite string over ÎŁP given by  wPT (null)Ď , where wPT is a well-matched word defined as  follows. The tree T is traversed in depth-first order as follows: for each node x, we first visit the subtree associated  with the left child (if any), and successively, the subtree associated with the right child (if any). Note that each internal  node x is visited exactly twice: the first time is when we enter the node x coming from its parent node (in case x is the  root, then x is the first node to be examined), and the second  time is when we reach x from its right child if it exists, and  from its left child otherwise. Moreover, we assume that also  each leaf is visited twice. When a node x with TM configuration C is visited for the first time, we write the subword  (c, d Âˇ wC Âˇ w ) (consisting of calls), where wC is the code of  C, w = end if x is a leaf-node, and w is empty otherwise,  d = âl if x is the root, and d is defined as follows otherwise, where C is the configuration of the parent node of x  and b â {l, r}: d = âb if C = succb (C ) and C is existential,  and d = âb if C = succb (C ) and C is universal. Finally,  when we visit the node x for the last time, then we write the  subword (r, (d Âˇ wC Âˇ w )â1 ) (consisting of returns).  Note that our encoding ensures that any subword (c, wC )  of wT , which encodes the first visit of a non-leaf node xC  with TM configuration C, is followed by a subword (c, wl )  which corresponds to the left child of xC in T if C is an  universal configuration, and the unique child of xC in T otherwise. Also, if C is an universal configuration, then the  subword (r, wâ1  R ) of w corresponding to the last visit of the  right child xR of xC in T is followed by the subword (r, wCâ1 )  corresponding to the last visit of xC .  =,R  Thus, by using the formulas LTL + C formulas Ď=  h , Ďh ,  con f  Ďh of Proposition 1, whose chop nesting depth is h â 1,  it is easy to construct a future C-CaReth formula of polynomial size which is (initially) satisfied by a word w over ÎŁP  iff w is the code of an accepting computation tree of M over  Îą. Essentially, ĎM ,Îą uses a CaRet formula (without chop)  to check that a computation tree T is traversed correctly,  con f  the formula [Ďh ]c to check that each TM configuration  r  in T is encoded correctly, and the formulas [Ď=,R  h ] and  =  c  [Ďh ] to check that T is faithful to the evolution of M . Details of the construction are given in [8]. Pushdown modelchecking against future C-CaReth is also (h + 1)-E XPTIMEhard since satisfiability is linearly reducible to pushdown  model-checking by using a NVPA over ÎŁ with a unique con-  Proposition 1. For each h âĽ 1, we can construct three LTL  con f  =,R  + C formulas Ďh , Ď=  over {$1 , . . . , $h+1 , 0, 1} âŞ  h , Ďh  con f  3  ÎŁ of sizes O(n Âˇ h Âˇ |ÎŁ|) such that dC (Ďh ) = dC (Ď=  h)=  )  =  h  â  1  and  for  each  word  w  and  0  â¤  i  <  |w|,  dC (Ď=,R  h  con f  â˘ (w, i) |= Ďh  iff wi has a prefix that is a (h, n)configuration over ÎŁ;  â˘ if wi is finite and has the form w1 w w2 (resp.,  (w1 )â1 w (w2 )â1 ) such that w1 and w2 are (h, n)-blocks  =,R  over ÎŁ, then (w, i) |= Ď=  h (resp., (w, i) |= Ďh ) iff  NUM(w1 ) = NUM(w2 ).  Now, we can prove the desired result.  Theorem 6. For each h âĽ 0, the satisfiability and pushdown  model-checking problems of future C-CaReth for both finite  and infinite runs are (h + 1)-E XPTIME-hard.  Proof. We assume that h âĽ 1, since for h = 0, the result is well known [2, 3]. Moreover, we only examine  the case of infinite words (the other case being similar).  First, we consider the satisfiability problem. Let M =  A, Q, Qâ , Qâ , q0 , Î´, F be an exp[h]âspace bounded alternating Turing Machine (TM), and let c âĽ 1 be a constant  such that for each Îą â Aâ , the space needed by M on input  Îą is bounded by Tower(|Îą|c , h). For Îą â Aâ , we construct  a future C-CaReth formula ĎM ,Îą over a pushdown alphabet  ÎŁP of size polynomial in n = |Îą|c and in the size of M , such  that M accepts Îą iff ĎM ,Îą is satisfiable.  Note that any reachable configuration of M over Îą can  be seen as a word Îą1 Âˇ (q, a) Âˇ Îą2 in Aâ Âˇ (Q Ă A) Âˇ Aâ of length  Tower(n, h). If Îą = a1 . . . ar (where r = |Îą|), then the initial configuration is the word of length Tower(n, h) given  by (q0 , a1 )a2 . . . ar ## . . . #, where # is the blank symbol.  Let ÎŁ = A âŞ (Q Ă A) and ÎŁ = ÎŁ âŞ {0, 1, $1, . . . , $h+1 } âŞ  {âl , âr , âl , âr , end}. The pushdown alphabet ÎŁP is given by  ÎŁP = {c, r} Ă ÎŁ âŞ{null}, where null is a return and {c} Ă ÎŁ  (resp., {r} Ă ÎŁ ) is a set of calls (resp., returns). Given a  word w over ÎŁ and b â {c, r}, we denote by (b, w) the word  30  trol state and accepting the language ÎŁĎ âŞ ÎŁâ .  [6] L. Bozzelli. Alternating automata and a temporal fixpoint  calculus for visibly pushdown languages. In Proc. 18th  CONCUR, LNCS 4703, pages 476â491. Springer, 2007.  [7] L. Bozzelli. Caret with forgettable past. In Proc. 5th Workshop on Methods for Modalities, ENTCS. Elsevier, 2008.  [8] L. Bozzelli. The Complexity of CARET + Chop. Technical  report - http://dscpi.uninsubria.it/ staff/Bozzelli, 2008.  [9] A. Chandra, D. Kozen, and L. Stockmeyer. Alternation.  Journal of the ACM, 28(1):114â133, 1981.  [10] H. Chen and D. Wagner. Mops: an infrastructure for examining security properties of software. In Proc. 9th CCS,  pages 235â244. ACM, 2002.  [11] J. Esparza, A. Kucera, and S. Schwoon. Model checking  LTL with regular valuations for pushdown systems. Information and Computation, 186(2):355â376, 2003.  [12] D. Harel, D. Kozen, and R. Parikh. Process logic: Expressiveness, decidability, completeness. In Proc. 21st FOCS,  pages 129â142, 1980.  [13] F. Laroussinie, N. Markey, and P. Schnoebelen. Temporal  logic with forgettable past. In Proc. 17th LICS, pages 383â  392. IEEE Comp. Soc. Press, 2002.  [14] F. Laroussinie and P. Schnoebelen. A hierarchy of temporal logics with past. Theoretical Computer Science,  148(2):303â324, 1995.  [15] N. Markey and P. Schnoebelen. Model checking a path.  In Proc. 14th CONCUR, LNCS 2761, pages 251â265.  Springer-Verlag, 2003.  [16] A. Pnueli. The temporal logic of programs. In Proc. 18th  FOCS, pages 46â57, 1977.  [17] R. Rosner and A. Pnueli. A choppy logic. In Proc. 1st LICS,  pages 306â313. IEEE Comp. Soc. Press, 1986.  5. Conclusions  In this paper, we have studied the complexity of satisfiability and pushdown model-checking of the non-regular linear temporal logic C-CaRet. In particular, we have shown  that for the class of formulas with chop nesting depth at  most h, the problems are (h + 1)-E XPTIME-complete for  the case of finite words, and are in (h + 2)-E XPTIME and  (h + 1)-E XPTIME-hard for the case of infinite words. The  different upper bounds for the finite and infinite cases are  due to the different classes of automata (with the same  expressiveness) which have been exploited, namely BuĚchi  NVPA for finite words, and BuĚchi AJA for infinite words.  For both cases, the obtained automaton has size of exponential height equal to the chop nesting depth (of the given  formula) plus one. However, while non-emptiness of NVPA  is in P TIME, non-emptiness of AJA is in general E XPTIMEcomplete. The need to use AJA instead of NVPA for the  case of infinite words was due to our difficulty in capturing  âparallelâ liveness requirements by using only nondeterminism. In other terms, alternation seems necessary to capture  in a clean way the semantics of C-CaRet for the case of infinite words. However, we conjecture that non-emptiness  for the subclass of AJA associated with C-CaRet formulas  (see Theorem 4) is in P TIME (in particular, we conjecture  that such AJA can be translated into equivalent NVPA with  only a polynomial time blowup). The main reason is that in  each (minimal) accepting run of the AJA associated with a  given formula Ď, there is exactly one infinite path (the âmain  pathâ) whose nodes are labeled by atoms of Ď, while each  other infinite path satisfies the following: the suffix starting  from the first node that is not on the main path only visits  nodes labeled by atoms of subformulas of Ď whose chop  nesting depth is strictly less than that of Ď.  References  [1] R. Alur, M. Arenas, P. Barcelo, K. Etessami, N. Immerman,  and L. Libkin. First-order and temporal logics for nested  words. In Proc. 22nd LICS, pages 151â160. IEEE Comp.  Soc. Press, 2007.  [2] R. Alur, K. Etessami, and P. Madhusudan. A Temporal  Logic of Nested Calls and Returns. In Proc. 10th TACAS,  LNCS 2988, pages 467â481. Springer, 2004.  [3] R. Alur and P. Madhusudan. Visibly pushdown languages.  In Proc. 36th STOC, pages 202â211. ACM, 2004.  [4] T. Ball and S. Rajamani. Bebop: a symbolic model checker  for boolean programs. In 7th SPIN Workshop, LNCS 1885,  pages 113â130. Springer, 2000.  [5] A. Bouajjani, J. Esparza, and O. Maler. Reachability  Analysis of Pushdown Automata: Application to ModelChecking. In Proc. 8th CONCUR, LNCS 1243, pages 135â  150. Springer, 1997.  31 