15th International Symposium on Temporal Representation and Reasoning  The Complexity of CaRet + Chop  Laura Bozzelli  UniversitaÄšÂ€ dellÃ¢Â€Â™Insubria, Via Valleggio 11, 22100 - Como, Italy  + Past (obtained by adding non regular past and future versions of the standard LTL temporal modalities), has been  introduced [2] to allow the specification of such a class of  context-free requirements. Even though verifying contextfree properties of pushdown systems is in general undecidable, the pushdown model checking against CaRet is decidable and E XPTIME-complete (the same complexity as  that of pushdown model checking against LTL [5]). In [3],  the class of nondeterministic visibly pushdown automata  (NVPA) is proposed as an automata theoretic generalization  of CaRet. NVPA are pushdown automata where the input  symbol determines when the automaton can push or pop,  and thus the stack depth at every position. The resulting  class of languages (visibly pushdown languages or VPL) is  closed under all boolean operations and problems such as  universality and inclusion that are undecidable for contextÃ¢Â€Â“  free languages are E XPTIMEÃ¢Â€Â“complete for VPL. Moreover,  NVPA have the same expressiveness as MSOÃ‚Ä¾ [3], which extends the classical monadic second order logic (MSO) over  words with a binary matching predicate. The logic CaRet  is less expressive than NVPA and is easily expressible in the  first-order fragment FOÃ‚Ä¾ of MSOÃ‚Ä¾ . However, it is an open  question whether CaRet is FOÃ‚Ä¾-complete [1].  Abstract  We investigate the complexity of satisfiability and pushdown model-checking of the extension of the logic CaRet  with the binary regular modality Ã¢Â€Â˜ChopÃ¢Â€Â™. We present  automata-theoretic decision procedures based on a direct  and compositional construction, which for finite (resp., infinite) words require time of exponential height equal to the  nesting depth of chop modality plus one (resp., plus two).  Moreover, we provide lower bounds which match the upper  bounds for the case of finite words.  1. Introduction  The modality Ã¢Â€Â˜ChopÃ¢Â€Â™ in linear temporal logic. In the literature some extensions of the linear temporal logic LTL [16],  with the same expressiveness as LTL, have been investigated  in order to support a compositional approach to the specification and verification of concurrent systems. These extensions enable modular and compositional reasoning about  sequential constructs as well as about concurrent ones. One  of the most important extensions of LTL is the addition of  the binary Ã¢Â€Â˜chopÃ¢Â€Â™ modality [12, 17, 15], which allows to  Ã¢Â€Â˜chopÃ¢Â€Â™ away parts of the computation. Thus, this modality is useful in cases we want to see subruns inside a run  (e.g., sessions, or specific fragments) and state their temporal specifications. Satisfiability for LTL + chop is nonelementary [17], and the best known upper bound, obtained  by a semantic-tableau method, requires space of exponential height equal to the nesting depth of chop modality (the  existence of a matching lower bound on the exponential  height of this complexity is an open question).  Our contribution. In this paper, we investigate the complexity of satisfiability and pushdown model-checking of  the logic CaRet + Chop (C-CaRet) in terms of the nesting  depth of chop modality. For each h Ã¢Â‰Ä½ 1, let C-CaReth be  the fragment of C-CaRet consisting of formulas with chop  nesting depth at most h, and let h-E XPTIME be the class  of languages which can be decided in (deterministic) time  of exponential height h. We show the following results for  C-CaReth : (1) for finite words, the considered problems are  (h + 1)-E XPTIME-complete, (2) for infinite words, the problems are in (h + 2)-E XPTIME and (h + 1)-E XPTIME-hard.  The linear temporal logic CaRet. Model checking of LTL  specification w.r.t. pushdown systems has been shown to be  a useful tool for analysis of programs with recursive procedures [4, 11, 10]. LTL, however, can specify only regular  properties, and properties which require either inspection  of the call-stack of a procedure, or matching of calls and  returns (such as correctness of procedures with respect to  pre and post conditions) are not regular. Recently, the linear temporal logic CaRet, a contextÃ¢Â€Â“free extension of LTL  1530-1311/08 $25.00 Ã‚Å  2008 IEEE  DOI 10.1109/TIME.2008.27  The upper bounds are obtained by an automata-theoretic  approach. For finite words, we propose a translation of  C-CaRet formulas into equivalent NVPA, while for infinite  words we exploit the class of alternating jump (finiteÃ¢Â€Â“state)  automata (AJA) [6] which can be translated into equivalent  NVPA [6] with a single exponential-time blow-up. In both  cases, the construction is direct and compositional, and is  based on a non-trivial characterization of the satisfaction  23  relation, for a given formula ÄÂ•, in terms of sequences of  pairs of sets associated with ÄÂ• (which generalize the classical notion of Hintikka-set of LTL) satisfying determined  requirements which can be checked by NVPA and AJA.  Finally, the lower bounds for C-CaReth are obtained by a  non-trivial reduction from the word problem of alternating  Turing machines operating in space of exponential height  h. A straightforward readaptation of these reductions lead  to h-E XPSPACE-hardness for satisfiability of LTL + Chop  formulas with chop nesting depth at most h.  over ÃÅ, |w| denotes the length of w (we set |w| = Ã¢ÂˆÂ if w is  infinite), and for 0 Ã¢Â‰Â¤ i < |w|, w(i) is the ith symbol of w.  A nondeterministic visibly pushdown automaton (NVPA)  [3] is a pushdown automaton operating on words over a  pushdown alphabet which pushes onto the stack only when  it reads a call, pops the stack only at returns, and does not  use the stack on internal actions. Formally, a NVPA over  ÃÅ = ÃÅc Ã¢ÂˆÅ ÃÅr Ã¢ÂˆÅ ÃÅint is a tuple P = ÃÅ, Q, Q0 , ÃÂ“, Ã¢ÂˆÂ†, F, where  Q is a finite set of states, Q0 Ã¢ÂŠÂ† Q is a set of initial states, ÃÂ“ is  the finite stack alphabet, F Ã¢ÂŠÂ† Q is a set of accepting states,  and Ã¢ÂˆÂ† = (Q Ä‚Â— ÃÅc Ä‚Â— Q Ä‚Â— ÃÂ“) Ã¢ÂˆÅ (Q Ä‚Â— ÃÅr Ä‚Â— (ÃÂ“ Ã¢ÂˆÅ {ÃÅ‚0 }) Ä‚Â— Q) Ã¢ÂˆÅ  (Q Ä‚Â— ÃÅint Ä‚Â— Q) is the transition relation (where ÃÅ‚0 Ã¢ÂˆÂˆ  / ÃÂ“ is the  special stack bottom symbol).  A configuration of P is a pair (q, ÃË›), where q Ã¢ÂˆÂˆ Q and  ÃË› Ã¢ÂˆÂˆ ÃÂ“Ã¢ÂˆÂ— Ã‚Ë‡ {ÃÅ‚0 } is a stack content. A run of P over a word w  on ÃÅ is a sequence of configurations r = (q0 , ÃË›0 )(q1 , ÃË›1 ) . . .  of length |w|+ 1 such that ÃË›0 = ÃÅ‚0 , q0 Ã¢ÂˆÂˆ Q0 , and for each i <  |w|: [push] if w(i) Ã¢ÂˆÂˆ ÃÅc , then Ã¢ÂˆÂƒB Ã¢ÂˆÂˆ ÃÂ“ such that ÃË›i+1 = B Ã‚Ë‡ ÃË›i  and (qi , w(i), qi+1 , B) Ã¢ÂˆÂˆ Ã¢ÂˆÂ†; [pop] if w(i) Ã¢ÂˆÂˆ ÃÅr , then Ã¢ÂˆÂƒB Ã¢ÂˆÂˆ ÃÂ“ Ã¢ÂˆÅ  {ÃÅ‚0 } such that (qi , w(i), B, qi+1 ) Ã¢ÂˆÂˆ Ã¢ÂˆÂ† and either ÃË›i = ÃË›i+1 =  B = ÃÅ‚0 , or B = ÃÅ‚0 and ÃË›i = B Ã‚Ë‡ ÃË›i+1 ; [internal] if w(i) Ã¢ÂˆÂˆ  ÃÅint , then (qi , w(i), qi+1 ) Ã¢ÂˆÂˆ Ã¢ÂˆÂ† and ÃË›i = ÃË›i+1 . The run r is  accepting iff either w is finite and q|w| Ã¢ÂˆÂˆ F, or w is infinite  and for infinitely many i Ã¢Â‰Ä½ 0, qi Ã¢ÂˆÂˆ F. The language L (P ) of  P is the set of words w over ÃÅ such that there is an accepting  run of P over w. A language L of words over ÃÅ is a visibly  pushdown language (VPL) if L = L (P ) for some NVPA P .  In order to model formal verification problems of pushdown systems M using finite specifications (such as NVPA)  denoting VPL languages, we choose a suitable pushdown alphabet ÃÅ = ÃÅc Ã¢ÂˆÅ ÃÅr Ã¢ÂˆÅ ÃÅint , and associate a symbol in ÃÅ with  each transition of M with the restriction that push transitions are mapped to ÃÅc , pop transitions are mapped to ÃÅr ,  and transitions that do not use the stack are mapped to ÃÅint .  Note that M equipped with such a labelling is a NVPA where  all the states are accepting. The specification S describes another VPL L (S) over ÃÅ, and M is correct iff L (M) Ã¢ÂŠÂ† L (S).  Given a class C of finite specifications S describing VPL  over a pushdown alphabet ÃÅ, the pushdown model checking  problem against C -specifications for finite (resp., infinite)  words is to decide, given a pushdown system M over ÃÅ and a  specification S in the class C , whether L (M) Ã¢ÂˆÅ  ÃÅÃ¢ÂˆÂ— Ã¢ÂŠÂ† L (S) Ã¢ÂˆÅ   ÃÅÃ¢ÂˆÂ— (resp., L (M) Ã¢ÂˆÅ  ÃÅÄÂ‰ Ã¢ÂŠÂ† L (S) Ã¢ÂˆÅ  ÃÅÄÂ‰ ).  Remark 1. C-CaRet can be easily translated into FOÃ‚Ä¾ ,  hence it captures a strict subclass of VPL. Moreover, by results in [7] it easily follows that C-CaRet is FOÃ‚Ä¾ -complete.  Related work. In the literature, different extensions of the  logic CaRet, which are expressively complete for FOÃ‚Ä¾ , have  been investigated. In particular, Alur et al [1] propose two  extensions of CaRet. One of them is based on the notion of  a summary path that combines both regular and non-regular  next-modalities; for this logic, both satisfiability and pushdown model checking are shown to be E XPTIME-complete,  which is the same complexity as that of CaRet. The other  logic is an extension of CaRet with the non-regular unary  modality Ã¢Â€ÂœwithinÃ¢Â€Â W, which essentially evaluates a formula  on a subword corresponding to the computation fragment  associated with a single procedure (including nested procedure calls). This logic is exponentially more succinct than  CaRet, and its satisfiability and pushdown model checking  are both 2E XPTIME-complete. An other extension of CaRet  has been studied in [7], where the extension is obtained  by adding the well-known unary regular modality Ã¢Â€Âœfrom  now onÃ¢Â€Â [14, 13], which allows to model forgettable past.  Satisfiability and pushdown model checking for the resulting logic are shown to be 2E XPTIME-complete. Moreover,  CaRet + W can be linearly translated into this logic.  2. Preliminaries  Let N be the set of natural numbers.  Definition 1. For all n, h Ã¢ÂˆÂˆ N, let Tower(n, h) be defined as:  Tower(n, 0) = n and Tower(n, h + 1) = 2Tower(n,h) . For each  h Ã¢Â‰Ä½ 0, exp[h] denotes the class of functions f : N Ã¢Â†Â’ N such  that for some constant c Ã¢Â‰Ä½ 1, f (n) = Tower(nc , h) for each  n. We denote by h-E XPTIME the class of languages decided  by exp[h]-time bounded deterministic Turing machines.  2.2. The linear temporal logic C-CaRet  First, we recall the syntax and semantics of full CaRet [2].  Fix a pushdown alphabet ÃÅ = ÃÅc Ã¢ÂˆÅ ÃÅr Ã¢ÂˆÅ ÃÅint . For a word  w on ÃÅ and i Ã¢Â‰Â¤ j < |w|, w[i, j] denotes the finite word  w(i)w(i + 1) . . . w( j), and wi denotes the suffix of w starting  from position i. A finite word w is well-matched if inductively or (1) w is empty, or (2) w = ÄÂƒw , ÄÂƒ Ã¢ÂˆÂˆ ÃÅint and w is  well-matched, or (3) w = ÄÂƒc w ÄÂƒr w , ÄÂƒc Ã¢ÂˆÂˆ ÃÅc , ÄÂƒr Ã¢ÂˆÂˆ ÃÅr , and  2.1. Visibly pushdown languages  A pushdown alphabet ÃÅ is an alphabet which is partitioned in three disjoint finite alphabets ÃÅc , ÃÅr , and ÃÅint ,  where ÃÅc is a finite set of calls, ÃÅr is a finite set of returns,  and ÃÅint is a finite set of internal actions. For a word w  24  operators of LTL. Formally, the syntax is defined as follows:  succ(c, w, 7)  w=  succ(a+ , w, 1)  0  c  1  c  2  i  3  c  4  i  i = internal action;  5  r  ÄÂ• ::=  | ÄÂƒ | Ã‚Å¹ÄÂ• | ÄÂ• Ã¢ÂˆÂ§ ÄÂ• | Xdir ÄÂ• | ÄÂ• U dir ÄÂ•  succ(a+ , w, 7)  R  6  r  where  denotes true, ÄÂƒ Ã¢ÂˆÂˆ ÃÅ, and dir Ã¢ÂˆÂˆ {+, Ã¢ÂˆÂ’, a+ , aÃ¢ÂˆÂ’ , c}.  Note that X+ and U + correspond to the usual Ã¢Â€Â˜nextÃ¢Â€Â™ and  Ã¢Â€Â˜untilÃ¢Â€Â™ operators of LTL, while XÃ¢ÂˆÂ’ and U Ã¢ÂˆÂ’ are their past  counterparts. CaRet is interpreted on words w over ÃÅ.  Given a formula ÄÂ• and a position i in w, the satisfaction  relation (w, i) |= ÄÂ• (which reads as Ã¢Â€Âœw satisfies ÄÂ• at position iÃ¢Â€Â) is inductively defined as follows, where dir Ã¢ÂˆÂˆ  {+, Ã¢ÂˆÂ’, a+ , aÃ¢ÂˆÂ’ , c} (we omit the rules for atomic actions in  ÃÅ and boolean connectives which are standard):  R  7  c  c = call;  8  i  9  r  10  i  r = return  w and w are well-matched. CaRet is based on five different notions of successor for a position i along a word w:  Ã¢Â€Ë˜ The forward local successor of i along w, written  succ(+, w, i), is i + 1 if i + 1 < |w|, and it is Ã¢ÂŠÄ½ otherwise (the symbol Ã¢ÂŠÄ½ is for Ã¢Â€Â˜undefinedÃ¢Â€Â™).  Ã¢Â€Ë˜ (w, i) |= Xdir ÄÂ• Ã¢Â‡Â” succ(dir, w, i) = j = Ã¢ÂŠÄ½ and (w, j) |= ÄÂ•  Ã¢Â€Ë˜ (w, i) |= ÄÂ•1 U dir ÄÂ•2 Ã¢Â‡Â” for the dir-path ÃË = j0 , j1 , . . . of  w starting from i, Ã¢ÂˆÂƒn < |ÃË| such that (w, jn ) |= ÄÂ•2 and  Ã¢ÂˆÂ€0 Ã¢Â‰Â¤ h < n, (w, jh ) |= ÄÂ•1 .  Ã¢Â€Ë˜ The backward local successor of i along w, written  succ(Ã¢ÂˆÂ’, w, i), is i Ã¢ÂˆÂ’ 1 if i > 0, and it is Ã¢ÂŠÄ½ otherwise.  The logic C-CaRet extends CaRet with the binary regular  modality Ã¢Â€ÂœChopÃ¢Â€Â, written C, whose semantics is given by  Ã¢Â€Ë˜ The forward abstract successor of i along w [2],  succ(a+ , w, i). If w(i) Ã¢ÂˆÂˆ ÃÅc , succ(a+ , w, i) is the matching return position of i if any, i.e. : if there is j > i  s.t. w( j) Ã¢ÂˆÂˆ ÃÅr and w[i + 1, j Ã¢ÂˆÂ’ 1] is well-matched, then  succ(a+ , w, i) = j (note that j is uniquely determined),  / ÃÅc , then  otherwise succ(a+ , w, i) = Ã¢ÂŠÄ½. If instead w(i) Ã¢ÂˆÂˆ  succ(a+ , w, i) = i + 1 if i + 1 < |w| and w(i + 1) Ã¢ÂˆÂˆ  / ÃÅr ,  and succ(a+ , w, i) = Ã¢ÂŠÄ½ otherwise.  Ã¢Â€Ë˜ (w, i) |= ÄÂ•1 CÄÂ•2 Ã¢Â‡Â” Ã¢ÂˆÂƒi Ã¢Â‰Â¤ n < |w| such that (w[0, n], i) |=  ÄÂ•1 and (wn , 0) |= ÄÂ•2 .  Note that the future regular fragment of C-CaRet, obtained by disallowing operators Xdir and U dir with dir Ã¢ÂˆÂˆ  {Ã¢ÂˆÂ’, a+ , aÃ¢ÂˆÂ’ , c}) corresponds to the logic LTL + C [12]. We  denote by L (ÄÂ•) the language of words w over ÃÅ s.t. (w, 0) |=  ÄÂ•. The satisfiability problem of C-CaRet for finite words  (resp., infinite words) is to decide whether L (ÄÂ•) Ã¢ÂˆÅ  ÃÅÃ¢ÂˆÂ— = 0/  / for a given formula ÄÂ•.  (resp., L (ÄÂ•) Ã¢ÂˆÅ  ÃÅÄÂ‰ = 0)  For a C-CaRet formula ÄÂ•, we denote by dC (ÄÂ•) the nesting depth of modality C in ÄÂ•. Moreover, for each h Ã¢Â‰Ä½ 0,  C-CaReth denotes the C-CaRet-fragment consisting of formulas ÄÂ• s.t. dC (ÄÂ•) Ã¢Â‰Â¤ h, and future C-CaRet is the fragment  obtained by disallowing the backward temporal modalities.  Ã¢Â€Ë˜ The backward abstract successor of i along w,  succ(aÃ¢ÂˆÂ’ , w, i). If w(i) Ã¢ÂˆÂˆ ÃÅr , then it points to the matching call of i if any; otherwise, succ(aÃ¢ÂˆÂ’ , w, i) = Ã¢ÂŠÄ½. If instead w(i) Ã¢ÂˆÂˆ  / ÃÅr , then succ(aÃ¢ÂˆÂ’ , w, i) = i Ã¢ÂˆÂ’ 1 if i Ã¢ÂˆÂ’ 1 > 0  and w(i Ã¢ÂˆÂ’ 1) Ã¢ÂˆÂˆ  / ÃÅc , and succ(aÃ¢ÂˆÂ’ , w, i) = Ã¢ÂŠÄ½ otherwise.  Ã¢Â€Ë˜ The caller of i along w [2], succ(c, w, i), points to the  last unmatched call of the prefix w[0, h] (where h =  i Ã¢ÂˆÂ’ 1 if i is a call position, and h = i otherwise), i.e. :  if there is j < i such that w( j) Ã¢ÂˆÂˆ ÃÅc and w[ j + 1, h]  is wellÃ¢Â€Â“matched , then succ(c, w, i) = j (note that j is  uniquely determined), otherwise succ(c, w, i) = Ã¢ÂŠÄ½.  2.3. Alternating jump automata (AJA)  Alternating jump (finite-state) automata (AJA) [6] operate on infinite words over a pushdown alphabet and capture exactly the class of VPL. AJA extend standard alternating finiteÃ¢Â€Â“state automata by also allowing non-local moves:  on reading a matched-call ÄÂƒc , a copy of the automaton can  move (jump) in a single step to the matching-return of ÄÂƒc .  For a finite set X, B p (X) denotes the set of positive  boolean formulas over X built from elements in X using  Ã¢ÂˆÂ¨ and Ã¢ÂˆÂ§ (we also allow the formulas true and false). A  subset Y of X satisfies ÃÂ¸ Ã¢ÂˆÂˆ B p (X) iff the truth assignment  assigning true to the elements in Y and false to the elements of X \ Y satisfies ÃÂ¸.  A generalized BuÄšÂˆchi AJA is a tuple A = ÃÅ, Q, Q0 , ÃÂ´, F ,  where ÃÅ is a pushdown alphabet, Q is a finite set of states,  For i < |w| and dir Ã¢ÂˆÂˆ {+, Ã¢ÂˆÂ’, a+ , aÃ¢ÂˆÂ’ , c}, the dir-path of w  from i, is the maximal sequence of positions ÃË = j0 , j1 , . . .  s.t. j0 = i and jh = succ(dir, w, jhÃ¢ÂˆÂ’1 ) for each 0 < h < |ÃË|.  Intuitively, the forward abstract paths and the backward abstract paths (i.e., the a+ -paths and aÃ¢ÂˆÂ’ -paths) capture the local computation within a procedure removing computation  fragments corresponding to nested calls within the procedure, while a caller path (i.e., a c-path) captures the content  of the call-stack of a procedure. For example, in the figure  above, the sequence of positions 4, 3, 1, 0 is a caller path,  while the sequence 1, 6, 7, 9, 10 is a forward abstract path.  For each type of successor, CaRet provides the corresponding versions of the usual Ã¢Â€Â˜nextÃ¢Â€Â™ (X) and Ã¢Â€Â˜untilÃ¢Â€Â™ ( U )  25  Q0 Ã¢ÂŠÂ† Q is the set of initial states, ÃÂ´ : Q Ä‚Â— ÃÅ Ã¢Â†Â’ B p ({+, a+ } Ä‚Â—  Q Ä‚Â— Q) is the transition function, and F = {F1 , . . . , Fk } is a  set of sets of accepting states. Intuitively, a target of a move  of A is encoded by a triple (dir, q, q ) Ã¢ÂˆÂˆ {+, a+ } Ä‚Â— Q Ä‚Â— Q,  meaning that a copy of A on reading the ith input symbol of  the given word w moves to position succ(dir, w, i) in state q  if succ(dir, w, i) = Ã¢ÂŠÄ½ , and to position i + 1 in state q otherwise. Formally, a run of A over an infinite word w Ã¢ÂˆÂˆ ÃÅÄÂ‰ is a  N Ä‚Â— Q-labeled tree r such that the root is labeled by (0, q0 )  with q0 Ã¢ÂˆÂˆ Q0 and for each node x with label (i, q) (describing a copy of A in state q which reads w(i)), there is a (possibly empty) set H = {(dir1 , q1 , q1 ), . . . , (dirm , qm , qm )} Ã¢ÂŠÂ†  {+, a+ } Ä‚Â— QÄ‚Â— Q satisfying ÃÂ´(q, w(i)) such that x has m children x1 , . . . , xm , and for each 1 Ã¢Â‰Â¤ h Ã¢Â‰Â¤ m: xh has label (i +  1, qh ) if succ(dirh , w, i) = Ã¢ÂŠÄ½, and label (succ(dirh , w, i), qh )  otherwise. The run r is accepting if for each infinite path  x0 x1 . . . in the tree and each accepting component F Ã¢ÂˆÂˆ F ,  there are infinitely many i Ã¢Â‰Ä½ 0 s.t. xi is labeled by some state  in F. The ÄÂ‰-language of A , LÄÂ‰ (A ), is the set of w Ã¢ÂˆÂˆ ÃÅÄÂ‰ such  that there is an accepting run r of A over w.  chop modality is meaningfully different from that proposed  in [17] for LTL + Chop. The regular and non-regular next  requirements are captured locally requiring that consecutive pairs (Ari , Ai ), (Ari+1 , Ai+1 ) along the sequence ÄÂ€ satisfy  determined syntactical constraints. For example, if w(i) is  a call, w(i + 1) is not a return, and UM(w, i + 1) = Ã¢ÂŠÄ½, then  UM(w, i + 1) represents the matching return position of i  along w. Thus, we have to require that the forward-abstractnext requirements in Ai are exactly the ones that hold in  Ari+1 , and the backward-abstract-next requirements in Ari+1  are exactly the ones that hold in Ai . Finally, if w is infinite, then the sequence ÄÂ€ has to satisfy fairness non-local  additional conditions reflecting the liveness requirements in  forward until subformulas of ÄÂ•, and the liveness requirements ÄÂˆ1 in chop subformulas ÄÂˆ1 CÄÂˆ2 of ÄÂ•. Now, we give  the technical details.  A formula ÄÂˆ is said to be a first-level subformula of ÄÂ• if  there is an occurrence of ÄÂˆ in ÄÂ• which is not in the scope of  a chop operator. The closure Cl(ÄÂ•) of ÄÂ• is the smallest set  containing , Xdir  for each dir Ã¢ÂˆÂˆ {+, Ã¢ÂˆÂ’, a+ , aÃ¢ÂˆÂ’ , c}, all the  first-level subformulas of ÄÂ•, Xdir (ÄÂˆ1 U dir ÄÂˆ2 ) for any firstlevel subformula ÄÂˆ1 U dir ÄÂˆ2 of ÄÂ•, and the negations of all  these formulas (we identify Ã‚Å¹Ã‚Å¹ÄÂˆ with ÄÂˆ). A simple atom A  is a subset of Cl(ÄÂ•) such that  Ã¢Â€Ë˜ A Ã¢ÂˆÅ  ÃÅ is a singleton and  Ã¢ÂˆÂˆ A;  Ã¢Â€Ë˜ if ÄÂˆ Ã¢ÂˆÂˆ Cl(ÄÂ•), then ÄÂˆ Ã¢ÂˆÂˆ A iff Ã‚Å¹ÄÂˆ Ã¢ÂˆÂˆ  / A;  Ã¢Â€Ë˜ if ÄÂˆ1 Ã¢ÂˆÂ§ ÄÂˆ2 Ã¢ÂˆÂˆ Cl(ÄÂ•), then ÄÂˆ1 Ã¢ÂˆÂ§ ÄÂˆ2 Ã¢ÂˆÂˆ A iff ÄÂˆ1 , ÄÂˆ2 Ã¢ÂˆÂˆ A;  Ã¢Â€Ë˜ if ÄÂˆ1 U dir ÄÂˆ2 Ã¢ÂˆÂˆ Cl(ÄÂ•), then ÄÂˆ1 U dir ÄÂˆ2 Ã¢ÂˆÂˆ A iff either ÄÂˆ2 Ã¢ÂˆÂˆ  A or ÄÂˆ1 , Xdir (ÄÂˆ1 U dir ÄÂˆ2 ) Ã¢ÂˆÂˆ A;  Ã¢Â€Ë˜ if Xdir ÄÂˆ Ã¢ÂˆÂˆ A, then Xdir  Ã¢ÂˆÂˆ A;  Ã¢ÂˆÂ’  Ã¢Â€Ë˜ if Ã‚Å¹XÃ¢ÂˆÂ’  Ã¢ÂˆÂˆ A, then Ã‚Å¹Xa , Ã‚Å¹Xc  Ã¢ÂˆÂˆ A;  +  Ã¢Â€Ë˜ if Ã‚Å¹X+  Ã¢ÂˆÂˆ A, then Ã‚Å¹Xa  Ã¢ÂˆÂˆ A.  where dir Ã¢ÂˆÂˆ {+, Ã¢ÂˆÂ’, a+ , aÃ¢ÂˆÂ’ , c}. Intuitively, the set of formulas in a simple atom of ÄÂ• represents a maximal set of  first-level subformulas of ÄÂ• that can consistently hold at a  position along a word over ÃÅ. For each forward local until formula ÄÂˆ1 U + ÄÂˆ2 Ã¢ÂˆÂˆ Cl(ÄÂ•), we introduce a new symbol  ÄÂ„ÄÂˆ2 associated with the liveness requirement ÄÂˆ2 (whose intuitive meaning will be given later), and denote by P(ÄÂ•) the  set of these symbols.  Now, we define the set Atoms(ÄÂ•) of atoms of ÄÂ• by induction on the chop nesting depth dC (ÄÂ•): A Ã¢ÂˆÂˆ Atoms(ÄÂ•) iff      /  A Ã¢ÂŠÂ† Cl(ÄÂ•)Ã¢ÂˆÅP(ÄÂ•)Ã¢ÂˆÅ ÄÂˆ1 CÄÂˆ2 Ã¢ÂˆÂˆCl(ÄÂ•) h=2  h=1 (Atoms(ÄÂˆh )Ã¢ÂˆÅ{0})Ä‚Â—  Atoms(ÄÂˆh ) Ä‚Â— {ÄÂˆ1 CÄÂˆ2 } Ä‚Â— {h} Ä‚Â— {Y ES, NO} and the following additional conditions hold for each subformula  ÄÂˆ1 CÄÂˆ2 Ã¢ÂˆÂˆ Cl(ÄÂ•):  3. Decision Procedures for C-CaRet  In this section we solve satisfiability and pushdown  model-checking of C-CaRet by an automata-theoretic approach. For finite words, we propose a translation of  C-CaRet formulas into equivalent NVPA, while for infinite  words we exploit AJA. In both cases, the construction is direct and compositional. In the rest of this section, first, we  give a non-trivial characterization of the satisfaction relation (w, 0) |= ÄÂ•, for a given formula ÄÂ•, in terms of sequences  of pairs of sets associated with ÄÂ• satisfying determined requirements which can be checked by NVPA and AJA. Then,  we describe the translation into NVPA (for finite words) and  AJA (for infinite words) based on this characterization.  Fix a pushdown alphabet ÃÅ. For a word w over ÃÅ and  i < |w|, the next unmatched return of i in w, UM(w, i), is  defined as: if the caller of i is defined and has matching  return ir , then UM(w, i) = ir ; otherwise, UM(w, i) = Ã¢ÂŠÄ½.  In the following, we fix a C-CaRet formula ÄÂ•. Essentially, for each finite or infinite word w over ÃÅ, we associate  to w sequences (of length |w|) ÄÂ€ = (Ar0 , A0 ), (Ar1 , A1 ), . . . of  pairs of sets, where for each 0 Ã¢Â‰Â¤ i < |w|, Ai is an atom  and intuitively describes a maximal set of subformulas of  ÄÂ• which can hold at position i along w, while Ari = 0/ if  UM(w, i) = Ã¢ÂŠÄ½, and Ari = A j with j = UM(w, i) otherwise.  As for LTL, the notion of atom syntactically captures in particular the semantics of boolean connectives and the fixpoint characterization of the until modalities in terms of  the next modalities of the same type. Moreover, the notion of atom also partially (and syntactically) captures the  semantics of chop modality. Since C-CaRet has also backward modalities, the approach proposed here to handle the  1. A Ã¢ÂˆÅ  Cl(ÄÂ•) is a simple atom;  2. if (Br , B, ÄÂˆ1 CÄÂˆ2 , h, f ) Ã¢ÂˆÂˆ A, then B Ã¢ÂˆÅ  ÃÅ = A Ã¢ÂˆÅ  ÃÅ, and if  /  either Ã‚Å¹XÃ¢ÂˆÂ’  Ã¢ÂˆÂˆ B or Ã‚Å¹X+  Ã¢ÂˆÂˆ B, then Br = 0;  3. if (Br , B, ÄÂˆ1 CÄÂˆ2 , 2, f ) Ã¢ÂˆÂˆ A and dir Ã¢ÂˆÂˆ {+, a+ }, then  Xdir  Ã¢ÂˆÂˆ A iff Xdir  Ã¢ÂˆÂˆ B;  26  / Ä‚Â— Atoms(ÄÂ•) to a set of pairs in (Atoms(ÄÂ•) Ã¢ÂˆÅ {0})  / Ä‚Â—  {0})  Atoms(ÄÂ•). Intuitively, if A is the atom associated with  the current position i of the given word w, and Ar is the  atom associated with UM(w, i) if UM(w, i) = Ã¢ÂŠÄ½, and Ar =  0/ otherwise, then Jump SuccÄÂ• (Ar , A) contains that pairs  (Ar , A ) such that A is a atom associable to the next position i + 1 and Ar is the corresponding atom associable to  UM(w, i + 1). Formally, (Ar , A ) Ã¢ÂˆÂˆ Jump SuccÄÂ• (Ar , A) iff  A Ã¢ÂˆÂˆ SuccÄÂ• (A) and the following is inductively satisfied:  4. if (Br , B, ÄÂˆ1 CÄÂˆ2 , 1, f ) Ã¢ÂˆÂˆ A, then for each dir Ã¢ÂˆÂˆ  {Ã¢ÂˆÂ’, aÃ¢ÂˆÂ’ }, Xdir  Ã¢ÂˆÂˆ A iff Xdir  Ã¢ÂˆÂˆ B, and for each dir Ã¢ÂˆÂˆ  {+, a+ }, if Xdir  Ã¢ÂˆÂˆ B then Xdir  Ã¢ÂˆÂˆ A ;  5. ÄÂˆ1 CÄÂˆ2 Ã¢ÂˆÂˆ A iff Ã¢ÂˆÂƒ(Br , B, ÄÂˆ1 CÄÂˆ2 , 1,Y ES) Ã¢ÂˆÂˆ A. ÄÂˆ1 Ã¢ÂˆÂˆ B;  6. Ã¢ÂˆÂƒ(Br , B, ÄÂˆ1 CÄÂˆ2 , 1,Y ES) Ã¢ÂˆÂˆ A such that Ã‚Å¹X+  Ã¢ÂˆÂˆ B iff  Ã¢ÂˆÂƒ(Cr ,C, ÄÂˆ1 CÄÂˆ2 , 2, f ) Ã¢ÂˆÂˆ A such that ÄÂˆ2 , Ã‚Å¹XÃ¢ÂˆÂ’  Ã¢ÂˆÂˆ C;  7. Ã¢ÂˆÂƒ(Cr ,C, ÄÂˆ1 CÄÂˆ2 , 2, f ) Ã¢ÂˆÂˆ A such that Ã‚Å¹XÃ¢ÂˆÂ’  Ã¢ÂˆÂˆ C.  /  1. Ã¢ÂˆÂ€(Br , B, ÄÂˆ1 CÄÂˆ2 , 1, f ) Ã¢ÂˆÂˆ A, Br = 0/ if Ar = 0;  Intuitively, the meaning of a tuple (Br , B, ÄÂˆ1 CÄÂˆ2 , h, f ) Ã¢ÂˆÂˆ  A is as follows: if h = 1 and the current position is i, then  B describes the set of subformulas of ÄÂˆ1 which hold at position i of a prefix w p of the given word w, and Br is the set  associated with UM(w p , i) if UM(w p , i) = Ã¢ÂŠÄ½, and Br = 0/  otherwise. Moreover, f = Y ES iff the suffix of w starting from the last position of w p initially satisfies ÄÂˆ2 . If  instead h = 2 and the current position is i, then there is  j Ã¢Â‰Â¤ i, such that B describes the set of subformulas of ÄÂˆ2  which hold at position i Ã¢ÂˆÂ’ j of w j , and Br is the set associated with UM(w j , i Ã¢ÂˆÂ’ j) (if any). Note that the value  of f is irrelevant if h = 2 (we introduce it only to have a  uniform notation). By construction it easily follows that  |Atoms(ÄÂ•)| = Tower(|ÄÂ•|, dC (ÄÂ•) + 1).  For A Ã¢ÂˆÂˆ Atoms(ÄÂ•), let ÄÂƒ(A) be the unique element in  A Ã¢ÂˆÅ  ÃÅ, and let CallerFormÄÂ• (A) = {Xc ÄÂˆ Ã¢ÂˆÂˆ Cl(ÄÂ•) | Xc ÄÂˆ Ã¢ÂˆÂˆ  A}. For atoms A and A , the predicate AbsReqÄÂ• (A, A )  +  Ã¢ÂˆÂ’  +  holds iff for all Xa ÄÂˆ, Xa ÄÂˆ Ã¢ÂˆÂˆ Cl(ÄÂ•), (Xa ÄÂˆ Ã¢ÂˆÂˆ A Ã¢Â‡Â” ÄÂˆ Ã¢ÂˆÂˆ  Ã¢ÂˆÂ’  A ) and (Xa ÄÂˆ Ã¢ÂˆÂˆ A Ã¢Â‡Â” ÄÂˆ Ã¢ÂˆÂˆ A). Similarly, the predicate LocReqÄÂ• (A, A ) holds iff for all X+ ÄÂˆ, XÃ¢ÂˆÂ’ ÄÂˆ Ã¢ÂˆÂˆ Cl(ÄÂ•)  (X+ ÄÂˆ Ã¢ÂˆÂˆ A Ã¢Â‡Â” ÄÂˆ Ã¢ÂˆÂˆ A ), and (XÃ¢ÂˆÂ’ ÄÂˆ Ã¢ÂˆÂˆ A Ã¢Â‡Â” ÄÂˆ Ã¢ÂˆÂˆ A).  Let JumpÄÂ• , SuccÄÂ• : Atoms(ÄÂ•) Ã¢Â†Â’ 2Atoms(ÄÂ•) be the functions defined as follows:  2. Case (ÄÂƒ(A) Ã¢ÂˆÂˆ ÃÅc and ÄÂƒ(A ) Ã¢ÂˆÂˆ ÃÅr ) or (ÄÂƒ(A) Ã¢ÂˆÂˆ  / ÃÅc and  / ÃÅr ): Ar = Ar and for each ÄÂ„ÄÂˆ Ã¢ÂˆÂˆ P(ÄÂ•), ÄÂ„ÄÂˆ Ã¢ÂˆÂˆ A  ÄÂƒ(A ) Ã¢ÂˆÂˆ  iff either ÄÂˆ Ã¢ÂˆÂˆ A or ÄÂ„ÄÂˆ Ã¢ÂˆÂˆ A where ÄÂ„ÄÂˆ = ÄÂˆ if Ar = 0/ and  ÄÂƒ(A) Ã¢ÂˆÂˆ ÃÅc , and ÄÂ„ÄÂˆ = ÄÂ„ÄÂˆ otherwise;  3. Case ÄÂƒ(A) Ã¢ÂˆÂˆ  / ÃÅc and ÄÂƒ(A ) Ã¢ÂˆÂˆ ÃÅr : Ar = Ar = 0/ if  Ã¢ÂˆÂ’  / A , and Ar = A and for each ÄÂ„ÄÂˆ Ã¢ÂˆÂˆ P(ÄÂ•),  Xa  Ã¢ÂˆÂˆ  ÄÂ„ÄÂˆ Ã¢ÂˆÂˆ A iff ÄÂˆ Ã¢ÂˆÂˆ A Ã¢ÂˆÅ A , otherwise. Moreover, if  (Br , Br , ÄÂˆ1 CÄÂˆ2 , h, f ) Ã¢ÂˆÂˆ A and (Br , B, ÄÂˆ1 CÄÂˆ2 , h, f ) Ã¢ÂˆÂˆ A,  then (Br , Br ) Ã¢ÂˆÂˆ Jump SuccÄÂˆh (Br , B);  +  /  4. Case ÄÂƒ(A) Ã¢ÂˆÂˆ ÃÅc , ÄÂƒ(A ) Ã¢ÂˆÂˆ  / ÃÅr , Xa  Ã¢ÂˆÂˆ  / A: Ar = Ar = 0;  +  5. Case ÄÂƒ(A) Ã¢ÂˆÂˆ ÃÅc , ÄÂƒ(A ) Ã¢ÂˆÂˆ  / ÃÅr , and Xa  Ã¢ÂˆÂˆ A: Ar =  / Ar Ã¢ÂˆÂˆ JumpÄÂ• (A) and for each ÄÂ„ÄÂˆ Ã¢ÂˆÂˆ P(ÄÂ•), ÄÂ„ÄÂˆ Ã¢ÂˆÂˆ A  0,  / or (ÄÂ„ÄÂˆ Ã¢ÂˆÂˆ  iff or ÄÂˆ Ã¢ÂˆÂˆ A or (ÄÂ„ÄÂˆ Ã¢ÂˆÂˆ A Ã¢ÂˆÅ Ar and Ar = 0)  /  Also, Ã¢ÂˆÂ€ (Br , Br , ÄÂˆ1 CÄÂˆ2 , 1, f ) Ã¢ÂˆÂˆ Ar ,  A and Ar = 0).  Ã¢ÂˆÂƒ (Br , B , ÄÂˆ1 CÄÂˆ2 , 1, f ) Ã¢ÂˆÂˆ A , Ã¢ÂˆÂƒ(Br , B, ÄÂˆ1 CÄÂˆ2 , 1, f ) Ã¢ÂˆÂˆ A.  (Br , B ) Ã¢ÂˆÂˆ Jump SuccÄÂˆ1 (Br , B);  6. Ã¢ÂˆÂ€(Br , B, ÄÂˆ1 CÄÂˆ2 , h, f ) Ã¢ÂˆÂˆ A such that X+  Ã¢ÂˆÂˆ B,  Ã¢ÂˆÂƒ(Br , B , ÄÂˆ1 CÄÂˆ2 , h, f ) Ã¢ÂˆÂˆ A such that (Br , B ) Ã¢ÂˆÂˆ  Jump SuccÄÂˆh (Br , B); moreover, if ÄÂƒ(A) Ã¢ÂˆÂˆ ÃÅc ,  / then (Br , Br , ÄÂˆ1 CÄÂˆ2 , h, f ) Ã¢ÂˆÂˆ Ar ;  ÄÂƒ(A ) Ã¢ÂˆÂˆ  / ÃÅr , and Br = 0,  Ã¢Â€Ë˜ A Ã¢ÂˆÂˆ JumpÄÂ• (A) iff CallerFormÄÂ• (A) = CallerFormÄÂ• (A )  and AbsReqÄÂ• (A, A ).  7. Ã¢ÂˆÂ€(Br , B , ÄÂˆ1 CÄÂˆ2 , 1, f ) Ã¢ÂˆÂˆ A , Ã¢ÂˆÂƒ(Br , B, ÄÂˆ1 CÄÂˆ2 , 1, f ) Ã¢ÂˆÂˆ A  such that (Br , B ) Ã¢ÂˆÂˆ Jump SuccÄÂˆ1 (Br , B); moreover,  / then  / ÃÅr , and Br = 0,  if ÄÂƒ(A) Ã¢ÂˆÂˆ ÃÅc , ÄÂƒ(A ) Ã¢ÂˆÂˆ  (Br , Br , ÄÂˆ1 CÄÂˆ2 , 1, f ) Ã¢ÂˆÂˆ Ar .  Ã¢Â€Ë˜ A Ã¢ÂˆÂˆ SuccÄÂ• (A) iff LocReqÄÂ• (A, A ) and:  - Case either (ÄÂƒ(A) Ã¢ÂˆÂˆ ÃÅc and ÄÂƒ(A ) Ã¢ÂˆÂˆ ÃÅr ) or (ÄÂƒ(A) Ã¢ÂˆÂˆ  /  ÃÅc and ÄÂƒ(A ) Ã¢ÂˆÂˆ  / ÃÅr ): A Ã¢ÂˆÂˆ JumpÄÂ• (A);  There are many subtleties in definition of Jump SuccÄÂ•  which cannot discussed here due to lack of space. Here, we  only give the intuitive meaning of the rules for the propositions ÄÂ„ÄÂˆ , where ÄÂˆ1 U + ÄÂˆ Ã¢ÂˆÂˆ Cl(ÄÂ•) for some ÄÂˆ1 : if the current position i is a matched call with matching return j,  / A) is the pair associated with posiUM(w, i) = Ã¢ÂŠÄ½, and (0,  tion i, then ÄÂ„ÄÂˆ Ã¢ÂˆÂˆ A iff ÄÂˆ holds at some position in [i, j].  Given a word w over ÃÅ, i Ã¢ÂˆÂˆ N, and   j Ã¢ÂˆÂˆ N Ã¢ÂˆÅ {Ã¢ÂˆÂ} such  that i Ã¢Â‰Â¤   j Ã¢Â‰Â¤ |w| Ã¢ÂˆÂ’ 1, a fulfilling (i,   j, ÄÂ•)-sequence over  w is a sequence ÄÂ€ = (Ari , Ai ), (Ari+1 , Ai+1 ), . . . of pairs in  / Ä‚Â— Atoms(ÄÂ•) of length   (Atoms(ÄÂ•) Ã¢ÂˆÅ {0})  j Ã¢ÂˆÂ’ i + 1 such that  Ã¢ÂˆÂ’  +  Ã¢Â€Ë˜ Ã‚Å¹X  Ã¢ÂˆÂˆ Ai if i = 0, and Ã‚Å¹X  Ã¢ÂˆÂˆ A j if   j = |w|Ã¢ÂˆÂ’ 1 Ã¢ÂˆÂˆ N;    Ã¢Â€Ë˜ for each i Ã¢Â‰Â¤ l Ã¢Â‰Â¤ j, ÄÂƒ(Al ) = w(l);  / ÃÅr : CallerFormÄÂ• (A ) =  - Case ÄÂƒ(A) Ã¢ÂˆÂˆ ÃÅc and ÄÂƒ(A ) Ã¢ÂˆÂˆ  Ã¢ÂˆÂ’  c  {X ÄÂˆ Ã¢ÂˆÂˆ Cl(ÄÂ•) | ÄÂˆ Ã¢ÂˆÂˆ A} and Xa  Ã¢ÂˆÂˆ  /A;  +  - Case ÄÂƒ(A) Ã¢ÂˆÂˆ  / ÃÅc and ÄÂƒ(A ) Ã¢ÂˆÂˆ ÃÅr : Xa  Ã¢ÂˆÂˆ  / A, (Xc  Ã¢ÂˆÂˆ  aÃ¢ÂˆÂ’  c  c  A iff X  Ã¢ÂˆÂˆ A ), and X  Ã¢ÂˆÂˆ  / A if X  Ã¢ÂˆÂˆ  / A.  Intuitively, SuccÄÂ• (A) is the set of atoms A containing  the first-level subformulas of ÄÂ• which can hold at the next  position i + 1 of the current position i. Moreover, assuming  that the forward abstract position j of i along the given word  is defined, JumpÄÂ• (A) gives the set of atoms containing the  first-level subformulas of ÄÂ• which can hold at position j.  Now, we define by induction on dC (ÄÂ•) the function  Jump SuccÄÂ• which maps each pair (Ar , A) Ã¢ÂˆÂˆ (Atoms(ÄÂ•) Ã¢ÂˆÅ  27  Ã¢Â€Ë˜  Ã¢Â€Ë˜  Ã¢Â€Ë˜  Ã¢Â€Ë˜  for each i Ã¢Â‰Â¤ l <   j, (Arl+1 , Al+1 ) Ã¢ÂˆÂˆ Jump SuccÄÂ• (Arl , Al );  for all i Ã¢Â‰Â¤ l, l Ã¢Â‰Â¤   j, Arl = Arl if UM(w, l) = UM(w, l );  for each i Ã¢Â‰Â¤ l Ã¢Â‰Â¤   j, if UM(w, l) = l Ã¢Â‰Â¤   j, then Arl = Al ;  r  for each i Ã¢Â‰Â¤ l Ã¢Â‰Â¤   j, Al = 0/ if UM(w, l) = Ã¢ÂŠÄ½.  Corollary 1. For each word w over ÃÅ, (w, 0) |= ÄÂ• iff there  is a fulfilling ÄÂ•-sequence ÄÂ€ = (Ar0 , A0 ), . . . over w such that  /  ÄÂ• Ã¢ÂˆÂˆ A0 and ÄÂ€ is fair if w is infinite (note that Ar0 = 0).  Translation into NVPA and AJA For finite fords, the translation of C-CaRet formulas ÄÂ• into equivalent NVPA PÄÂ• ,  based on the result of Corollary 1 is simple. Essentially, for  a given input w, the NVPA PÄÂ• guesses (by its finite control)  a sequence ÄÂ€ = (Ar0 , A0 ), . . . and by using the stack checks  that it is a fulfilling ÄÂ•-sequence over w. Details are in [8].  A fulfilling (0, |w| Ã¢ÂˆÂ’ 1, ÄÂ•)-sequence over w is called simply fulfilling ÄÂ•-sequence over w. A fulfilling ÄÂ•-sequence  ÄÂ€ = (Ar0 , A0 ), (Ar1 , A1 ), . . . over an infinite word w Ã¢ÂˆÂˆ ÃÅÄÂ‰ is  fair if the following is inductively satisfied for each i Ã¢Â‰Ä½ 0:  1. if (Cr ,C, ÄÂˆ1 CÄÂˆ2 , 2, f ) Ã¢ÂˆÂˆ Ai and Ã‚Å¹XÃ¢ÂˆÂ’  Ã¢ÂˆÂˆ C, then there  is a fair fulfilling ÄÂˆ2 -sequence over wi from (Cr ,C);  Theorem 3. Let ÄÂ• be a C-CaRet formula over ÃÅ. Then, one  can construct a NVPA PÄÂ• of size O(Tower(|ÄÂ•|, dC (ÄÂ•) + 1))  such that L (PÄÂ• ) Ã¢ÂˆÅ  ÃÅÃ¢ÂˆÂ— = L (ÄÂ•) Ã¢ÂˆÅ  ÃÅÃ¢ÂˆÂ— .  / then there  2. if (Br , B, ÄÂˆ1 CÄÂˆ2 , 1,Y ES) Ã¢ÂˆÂˆ Ai and Ari = 0,  are m Ã¢Â‰Ä½ i, a fulfilling (i, m, ÄÂˆ1 )-sequence over w[0, m]  starting from (Br , B), and a fulfilling fair ÄÂˆ2 -sequence  (Cr ,C), . . . over wm such that ÄÂˆ2 Ã¢ÂˆÂˆ C;  For infinite words, we obtain the following result.  Theorem 4. Let ÄÂ• be a C-CaRet formula over ÃÅ. Then,  one can construct a generalized BuÄšÂˆchi AJA AÄÂ• of size  O(Tower(|ÄÂ•|, dC (ÄÂ•) + 1)) such that LÄÂ‰ (AÄÂ• ) = L (ÄÂ•) Ã¢ÂˆÅ  ÃÅÄÂ‰ .  a+  3. if ÄÂˆ1 U ÄÂˆ2 Ã¢ÂˆÂˆ Cl(ÄÂ•) , then for infinitely many h Ã¢Â‰Ä½ 0,  +  /  Arh = 0/ and {ÄÂˆ2 , Ã‚Å¹(ÄÂˆ1 U a ÄÂˆ2 )} Ã¢ÂˆÅ  Ah = 0;  Proof. We construct a generalized BuÄšÂˆchi AJA AÄÂ• of  size O(Tower(|ÄÂ•|, dC (ÄÂ•) + 1)) with set of states QÄÂ• Ã¢ÂŠÂƒ  / Ä‚Â— Atoms(ÄÂ•) and initial states of the form  (Atoms(ÄÂ•) Ã¢ÂˆÅ {0})  / A)  / A) with ÄÂ•, Ã‚Å¹XÃ¢ÂˆÂ’  Ã¢ÂˆÂˆ A s.t. for each state of the form (0,  (0,  with Ã‚Å¹XÃ¢ÂˆÂ’  Ã¢ÂˆÂˆ A and infinite word w, AÄÂ• has an accepting  / A) iff there is a fair fulfilling ÄÂ•-sequence  run over w from (0,  / A). Hence, the result follows from Corolover w from (0,  lary 1. The construction is given by induction on dC (ÄÂ•).  Thus, we can assume that for each ÄÂˆ1 CÄÂˆ2 Ã¢ÂˆÂˆ Cl(ÄÂ•) (note  that if dC (ÄÂ•) = 0, there is no such a formula), one can construct the AJA AÄÂˆ2 associated with ÄÂˆ2 . Here, we describe  informally the main aspects of the AJA AÄÂ• (the formal definition is given in [8]). Essentially, AÄÂ• guesses a fulfilling  ÄÂ•-sequence over the input word w and checks that it is fair.  Assume that AÄÂ• starts the computation in a state of the  / A) with Ã‚Å¹XÃ¢ÂˆÂ’  Ã¢ÂˆÂˆ A. Then, the first-level copy of  form (0,  AÄÂ• behaves as follows. When a symbol w(i) is read in a  / A) (where ÄÂƒ(A) = w(i)) and i is not a matchedstate (0,  call position (note that AÄÂ• can check whether this condi/ A)Ã¢ÂˆÂˆ  tion is satisfied or not), then AÄÂ• guesses a pair (0,  / A) and proceeds as follows. A copy (the  Jump SuccÄÂ• (0,  first-level copy) moves to the next input symbol in state  / A ). Moreover, in order to check that Properties 1 and  (0,  2 in def. of fair fulfilling ÄÂ•-sequence are satisfied, for each  (Cr ,C, ÄÂˆ1 CÄÂˆ2 , 2, f ) Ã¢ÂˆÂˆ A with Ã‚Å¹XÃ¢ÂˆÂ’  Ã¢ÂˆÂˆ C (note that by def.  / AÄÂ• starts an additional copy of the AJA AÄÂˆ2  of atom Cr = 0),  in state (Cr ,C), and for each (Br , B, ÄÂˆ1 CÄÂˆ2 , 1,Y ES) Ã¢ÂˆÂˆ A, AÄÂ•  starts a copy in a state of the form (Br , B, ÄÂˆ1 CÄÂˆ2 , Ã‚Å¹UM).  The behavior of this last copy will be explained later. Now,  assume that i is a matched-call position and w(i + 1) Ã¢ÂˆÂˆ  / ÃÅr  (the case w(i + 1) Ã¢ÂˆÂˆ ÃÅr is simpler). As above, AÄÂ• starts  additional copies to check Properties 1 and 2 in def. of  fair fulfilling ÄÂ•-sequence. Moreover, AÄÂ• guesses a pair  / A). Assume that ÄÂƒ(A ) = w(i + 1)  (Ar , A ) Ã¢ÂˆÂˆ Jump SuccÄÂ• (0,  4. if ÄÂˆ1 U + ÄÂˆ2 Ã¢ÂˆÂˆ Cl(ÄÂ•), then for infinitely many h Ã¢Â‰Ä½ 0,  / and or ÄÂˆ2 Ã¢ÂˆÂˆ Ah , or Ã‚Å¹(ÄÂˆ1 U + ÄÂˆ2 ) Ã¢ÂˆÂˆ Ah , or  Arh = 0,  +  (ÄÂ„ÄÂˆ2 , Xa  Ã¢ÂˆÂˆ Ah and ÄÂƒ(Ah ) Ã¢ÂˆÂˆ ÃÅc ).  The notion of fairness is used to capture recursively the  liveness requirements in forward until subformulas of ÄÂ•  (Properties 1, 3, and 4 above), and the liveness requirements  ÄÂˆ1 in chop subformulas ÄÂˆ1 CÄÂˆ2 of ÄÂ• (Property 3 above). As  we will see, the AJA associated with ÄÂ• guesses a fulfilling  ÄÂ•-sequence ÄÂ€ over the infinite input word and checks that  it is fair. The automaton keeps tracks by its finite control  of the current pair of ÄÂ€, and in particular, its Ã¢Â€Â˜mainÃ¢Â€Â™ copy  tracks an infinite path in the run which visits all and only  the nodes which are associated with the pairs (Ar , A) of ÄÂ€  / Thus, the acceptance condition of the AJA  such that Ar = 0.  (when interpreted on the main path) exactly reflects Properties 3 and 4 above. In particular, the propositions ÄÂ„ÄÂˆ2 are  used to guarantee that in case ÄÂˆ1 U + ÄÂˆ2 is asserted at a node  x of the main path and the liveness requirement ÄÂˆ2 does not  hold along the suffix of the main path from x, then ÄÂˆ2 holds  at some other position j Ã¢Â‰Ä½ i (i.e., there is a pair (Ar , A) with  Ar = 0/ of the guessed ÄÂ•-sequence associated with position  j for some j Ã¢Â‰Ä½ i such that ÄÂˆ2 Ã¢ÂˆÂˆ A).  The proofs of the following results are given in [8].  Theorem 1 (Correctness). Let ÄÂ€ = (Ar0 , A0 ), (Ar1 , A1 ) . . . be  a fair fulfilling ÄÂ•-sequence on w which is fair if w is infinite.  Then, for all i < |w| and ÄÂˆ Ã¢ÂˆÂˆ Cl(ÄÂ•), (w, i) |= ÄÂˆ iff ÄÂˆ Ã¢ÂˆÂˆ Ai .  Theorem 2 (Completeness). For each word w over ÃÅ, there  is a fulfilling ÄÂ•-sequence over w, which is fair if w is infinite.  By Theorems 1 and 2 we obtain the following characterization of the satisfaction relation (w, 0) |= ÄÂ•.  28  (otherwise the input is rejected). Then, Ar = 0/ represents  the guessed atom associated with the matching return position ir of i. Thus, a copy (the first-level copy) jumps  / Ar ) (note that  to the matching-return ir of i in state (0,  UM(w, i) = UM(w, ir ) = Ã¢ÂŠÄ½), and another copy moves to position i + 1 in state (Ar , A ). The goal of this last copy is  also to check that the guess Ar is correct. The behavior  of these auxiliary copies, which are in states of the form  (Ar , A) with Ar = 0/ is as follows. If the input symbol w(i)  is a call (note that i is a matched call-position) or (w(i) Ã¢ÂˆÂˆ  / ÃÅc  and w(i + 1) Ã¢ÂˆÂˆ  / ÃÅr ), the behavior is similar to that of the  first-level copy. If instead, w(i) = ÄÂƒ(A) is not a call, and  w(i + 1) is a return, then Ar = 0/ is the guessed atom associated with w(i + 1). Thus, the considered copy terminates with success its computation iff ÄÂƒ(Ar ) = w(i + 1) and  (Ar , Ar ) Ã¢ÂˆÂˆ Jump SuccÄÂ• (Ar , A) for some Ar (note that since  ÄÂƒ(A) Ã¢ÂˆÂˆ  / ÃÅc and ÄÂƒ(Ar ) Ã¢ÂˆÂˆ ÃÅr , by def. of Jump SuccÄÂ• the fulfilment of this condition is independent on the value of Ar ).  Now, we describe the behavior of AÄÂ• in states of the form  (Br , B, ÄÂˆ1 CÄÂˆ2 , f ), where f Ã¢ÂˆÂˆ {STOP,UM, Ã‚Å¹UM}. Assume  that the current symbol is w(i). Essentially, AÄÂ• guesses a  fulfilling (i, m, ÄÂˆ1 )-sequence ÄÂ over w[0, m] starting form  (Br , B) for some m Ã¢Â‰Ä½ i, and on reading w(m) starts an addi/  s.t. ÄÂˆ2 , Ã‚Å¹XÃ¢ÂˆÂ’  Ã¢ÂˆÂˆ C.  tion copy of the AJA AÄÂˆ2 in a state (0,C)  In order to check the existence of ÄÂ, AÄÂ• proceeds similarly  to the first-level copy. The unique difference is that now  Br can be empty even if UM(w, i) = Ã¢ÂŠÄ½. Thus, the flag f is  used to keep track if this last condition is satisfied or not. If  / and  for example, w(i) is not a call, w(i + 1) Ã¢ÂˆÂˆ ÃÅr , Br = 0,  f = UM (i.e., UM(w, i) = Ã¢ÂŠÄ½), then m must be equal to i.  Finally, the BuÄšÂˆchi acceptance condition of AÄÂ• extends  the acceptance conditions of the AJAs AÄÂˆ2 with additional  / A)  sets used to check that the infinite sequence of states (0,  visited by the first-level copy of AÄÂ• (note that these states  correspond to the pairs (Ar , A) visited by the simulated ful/ satisfies Properfilling ÄÂ•-sequence over w such that Ar = 0)  ties 3 and 4 in def. of fair fulfilling ÄÂ•-sequence.  4. Lower Bounds  In this section we show that for each h Ã¢Â‰Ä½ 0, satisfiability and pushdown model-checking of C-CaReth for both  finite and infinite runs are (h + 1)-E XPTIME-hard (also  for future C-CaReth ) by a reduction from the word problem for exp[h]Ã¢Â€Â“space bounded alternating Turing Machines.  It is well-known [9] that the class of all languages accepted by these machines coincides with (h + 1)-E XPTIME.  Formally, an alternating Turing Machine is a tuple M =  A, Q, QÃ¢ÂˆÂ€ , QÃ¢ÂˆÂƒ , q0 , ÃÂ´, F, where A is the input alphabet, Q =  QÃ¢ÂˆÂ€ Ã¢ÂˆÅQÃ¢ÂˆÂƒ is the finite set of states, q0 is the initial state, F Ã¢ÂŠÂ† Q  is the set of accepting states, and ÃÂ´ : Q Ä‚Â— A Ã¢Â†Â’ (Q Ä‚Â— A Ä‚Â— {Ã¢Â†Â  , Ã¢Â†Â’}) Ä‚Â— (Q Ä‚Â— A Ä‚Â— {Ã¢Â†Â, Ã¢Â†Â’}) is the transition function.  Configurations of M are words in AÃ¢ÂˆÂ— Ã‚Ë‡ (Q Ä‚Â— A) Ã‚Ë‡ AÃ¢ÂˆÂ— . A  configuration C = ÃÄ… Ã‚Ë‡ (q, a) Ã‚Ë‡ ÃÄ… denotes that the tape content is ÃÄ… Ã‚Ë‡ a Ã‚Ë‡ ÃÄ… , the current state is q, and the reading head  is at position |ÃÄ…| + 1. For the configuration C, we denote  by succl (C) and succr (C) the successors of C obtained by  choosing respectively the left and the right triple in ÃÂ´(q, a).  C is accepting if the associated state q belongs to F. Given  an input ÃÄ… Ã¢ÂˆÂˆ AÃ¢ÂˆÂ— , a (finite) computation tree of M over ÃÄ…  is a finite tree in which each node is labelled by a configuration. The root of the tree corresponds to the initial configuration associated with ÃÄ…. An internal node that corresponds to a universal configuration (i.e., the associated state  is in QÃ¢ÂˆÂ€ ) has two successors, corresponding to succl (C) and  succr (C), while an internal node that corresponds to an existential configuration (i.e., the associated state is in QÃ¢ÂˆÂƒ )  has a single successor, corresponding to either succl (C) or  succr (C). The tree is accepting if every leaf is labelled by  an accepting configuration. An input ÃÄ… Ã¢ÂˆÂˆ ÃÅÃ¢ÂˆÂ— is accepted by  M if there is an accepting computation tree of M over ÃÄ….  Fix n Ã¢Â‰Ä½ 1, a finite alphabet ÃÅ Ã¢ÂˆÅ {0, 1}, and a countable  set {$1 , $2 , . . .} of symbols non in ÃÅ Ã¢ÂˆÅ {0, 1}. First, for each  h Ã¢Â‰Ä½ 1, we define by induction on h an encoding of the integers in [0, Tower(n, h) Ã¢ÂˆÂ’ 1] by words, called (h, n)-codes,  over {$1 , . . . , $h , 0, 1} of the form $h w$h , where w does not  contain occurrences of $h .  For a pushdown system M and C-CaRet formula ÄÂ•, checking whether L (M) Ã¢ÂˆÅ  ÃÅÃ¢ÂˆÂ— Ã¢ÂŠÂ† L (ÄÂ•) Ã¢ÂˆÅ  ÃÅÃ¢ÂˆÂ— (resp., L (M) Ã¢ÂˆÅ  ÃÅÄÂ‰ Ã¢ÂŠÂ†  L (ÄÂ•)Ã¢ÂˆÅ ÃÅÄÂ‰ ) reduces to check emptiness of L (M)Ã¢ÂˆÅ  L (PÃ‚Å¹ÄÂ• )Ã¢ÂˆÅ   ÃÅÃ¢ÂˆÂ— (resp., L (M) Ã¢ÂˆÅ  LÄÂ‰ (AÃ‚Å¹ÄÂ• )), where PÃ‚Å¹ÄÂ• (rep., AÃ‚Å¹ÄÂ• ) is the  NVPA (resp., the AJA) of Theorem 3 (resp., Theorem 4) associated with Ã‚Å¹ÄÂ•. By [3] (resp., [6]) this can be done in  time polynomial in the size of M and polynomial (resp.,  singly exponential) in the size of PÃ‚Å¹ÄÂ• (rep., AÃ‚Å¹ÄÂ• ). Since  nonemptiness of NVPA (resp., AJA) is in in P TIME (resp.,  E XPTIME), by Theorems 3Ã¢Â€Â“4 we obtain the following.  Base Step: h = 1. A (1, n)-block over ÃÅ is a finite word  w over {$1 , 0, 1} Ã¢ÂˆÅ ÃÅ having the form w = $1 ÄÂƒb1 . . . bn $1 ,  where ÄÂƒ Ã¢ÂˆÂˆ ÃÅ Ã¢ÂˆÅ {0, 1} and b1 , . . . , bn Ã¢ÂˆÂˆ {0, 1}. The blockcontent CON(w) of w is ÄÂƒ, and the block-number NUM(w)  of w is the natural number in [0, Tower(n, 1) Ã¢ÂˆÂ’ 1] (recall that  Tower(n, 1) = 2n ) whose binary code is b1 . . . bn .1 An (1, n)code is a (1, n)-block w such that CON(w) Ã¢ÂˆÂˆ {0, 1}  Induction Step: let h Ã¢Â‰Ä½ 1. A (h + 1, n)-block over ÃÅ  is a finite word w on the alphabet {$1 , . . . , $h+1 , 0, 1} Ã¢ÂˆÅ ÃÅ  of the form w = $h+1 ÄÂƒ$h w1 $h w2 $h . . . $h wK $h $h+1 , where  ÄÂƒ Ã¢ÂˆÂˆ {0, 1} Ã¢ÂˆÅ ÃÅ, K = Tower(n, h) and for each 1 Ã¢Â‰Â¤ i Ã¢Â‰Â¤  K, $h wi $h is a (h, n)-code such that NUM($h wi $h ) =  Theorem 5. For each h Ã¢Â‰Ä½ 1, satisfiability and pushdown  model-checking of C-CaReth for finite (resp., infinite) words  are in (h + 1)-E XPTIME (resp., (h + 2)-E XPTIME).  1 we  29  assume that b1 is the least significant bit  i Ã¢ÂˆÂ’ 1. The block-content CON(w) of w is the symbol  ÄÂƒ, and the block-number NUM(w) of w is the natural  number in [0, Tower(n, h + 1) Ã¢ÂˆÂ’ 1] whose binary code is  CON($h w1 $h ) . . . CON($h wK $h ). A (h + 1, n)-code is a  (h + 1, n)-block w such that CON(w) Ã¢ÂˆÂˆ {0, 1}.  For each h Ã¢Â‰Ä½ 1, a (h, n)-configuration over ÃÅ is a finite  word w of the form w = $h+1 $h w1 $h w2 $h . . . $h wK $h $h+1 ,  where K = Tower(n, h) and for each 1 Ã¢Â‰Â¤ i Ã¢Â‰Â¤ K, $h wi $h  is a (h, n)-block such that NUM($h wi $h ) = i Ã¢ÂˆÂ’ 1 and  CON($h wi $h ) Ã¢ÂˆÂˆ ÃÅ. As we will see, (h, n)-configurations are  used to encode the configurations reachable by exp[h]-space  bounded alternating Turing machines on input of size n.  We will use the following result, whose proof is given in  [8]. For a word w, let wÃ¢ÂˆÂ’1 be the reverse of w.  over ÃÅP given by (b, w(0))(b, w(1)) . . .. In the following for  a LTL + C formula ÄÂ† over ÃÅ , [ÄÂ†]c (resp., [ÄÂ†]r ) denotes the LTL  + C formula over ÃÅP obtained by replacing each occurrence  of an action ÄÂƒ Ã¢ÂˆÂˆ ÃÅ in ÄÂ† with (c, ÄÂƒ) (resp., (r, ÄÂƒ)).  Now, we describe the encoding of (finite) computation  trees of M over ÃÄ…. The code of a TM configuration C =  u1 . . . uTower(n,h) is the (n, h)-configuration over ÃÅ given by  $h+1 $h w1 $h . . . $h wTower(n,h) $h $h+1 , where for each 1 Ã¢Â‰Â¤ i Ã¢Â‰Â¤  Tower(n, h), CON($h wi $h ) = ui . The code of a computation  tree T of M over ÃÄ… is the infinite string over ÃÅP given by  wPT (null)ÄÂ‰ , where wPT is a well-matched word defined as  follows. The tree T is traversed in depth-first order as follows: for each node x, we first visit the subtree associated  with the left child (if any), and successively, the subtree associated with the right child (if any). Note that each internal  node x is visited exactly twice: the first time is when we enter the node x coming from its parent node (in case x is the  root, then x is the first node to be examined), and the second  time is when we reach x from its right child if it exists, and  from its left child otherwise. Moreover, we assume that also  each leaf is visited twice. When a node x with TM configuration C is visited for the first time, we write the subword  (c, d Ã‚Ë‡ wC Ã‚Ë‡ w ) (consisting of calls), where wC is the code of  C, w = end if x is a leaf-node, and w is empty otherwise,  d = Ã¢ÂˆÂƒl if x is the root, and d is defined as follows otherwise, where C is the configuration of the parent node of x  and b Ã¢ÂˆÂˆ {l, r}: d = Ã¢ÂˆÂƒb if C = succb (C ) and C is existential,  and d = Ã¢ÂˆÂ€b if C = succb (C ) and C is universal. Finally,  when we visit the node x for the last time, then we write the  subword (r, (d Ã‚Ë‡ wC Ã‚Ë‡ w )Ã¢ÂˆÂ’1 ) (consisting of returns).  Note that our encoding ensures that any subword (c, wC )  of wT , which encodes the first visit of a non-leaf node xC  with TM configuration C, is followed by a subword (c, wl )  which corresponds to the left child of xC in T if C is an  universal configuration, and the unique child of xC in T otherwise. Also, if C is an universal configuration, then the  subword (r, wÃ¢ÂˆÂ’1  R ) of w corresponding to the last visit of the  right child xR of xC in T is followed by the subword (r, wCÃ¢ÂˆÂ’1 )  corresponding to the last visit of xC .  =,R  Thus, by using the formulas LTL + C formulas ÄÂˆ=  h , ÄÂˆh ,  con f  ÄÂˆh of Proposition 1, whose chop nesting depth is h Ã¢ÂˆÂ’ 1,  it is easy to construct a future C-CaReth formula of polynomial size which is (initially) satisfied by a word w over ÃÅP  iff w is the code of an accepting computation tree of M over  ÃÄ…. Essentially, ÄÂ•M ,ÃÄ… uses a CaRet formula (without chop)  to check that a computation tree T is traversed correctly,  con f  the formula [ÄÂˆh ]c to check that each TM configuration  r  in T is encoded correctly, and the formulas [ÄÂˆ=,R  h ] and  =  c  [ÄÂˆh ] to check that T is faithful to the evolution of M . Details of the construction are given in [8]. Pushdown modelchecking against future C-CaReth is also (h + 1)-E XPTIMEhard since satisfiability is linearly reducible to pushdown  model-checking by using a NVPA over ÃÅ with a unique con-  Proposition 1. For each h Ã¢Â‰Ä½ 1, we can construct three LTL  con f  =,R  + C formulas ÄÂˆh , ÄÂˆ=  over {$1 , . . . , $h+1 , 0, 1} Ã¢ÂˆÅ  h , ÄÂˆh  con f  3  ÃÅ of sizes O(n Ã‚Ë‡ h Ã‚Ë‡ |ÃÅ|) such that dC (ÄÂˆh ) = dC (ÄÂˆ=  h)=  )  =  h  Ã¢ÂˆÂ’  1  and  for  each  word  w  and  0  Ã¢Â‰Â¤  i  <  |w|,  dC (ÄÂˆ=,R  h  con f  Ã¢Â€Ë˜ (w, i) |= ÄÂˆh  iff wi has a prefix that is a (h, n)configuration over ÃÅ;  Ã¢Â€Ë˜ if wi is finite and has the form w1 w w2 (resp.,  (w1 )Ã¢ÂˆÂ’1 w (w2 )Ã¢ÂˆÂ’1 ) such that w1 and w2 are (h, n)-blocks  =,R  over ÃÅ, then (w, i) |= ÄÂˆ=  h (resp., (w, i) |= ÄÂˆh ) iff  NUM(w1 ) = NUM(w2 ).  Now, we can prove the desired result.  Theorem 6. For each h Ã¢Â‰Ä½ 0, the satisfiability and pushdown  model-checking problems of future C-CaReth for both finite  and infinite runs are (h + 1)-E XPTIME-hard.  Proof. We assume that h Ã¢Â‰Ä½ 1, since for h = 0, the result is well known [2, 3]. Moreover, we only examine  the case of infinite words (the other case being similar).  First, we consider the satisfiability problem. Let M =  A, Q, QÃ¢ÂˆÂ€ , QÃ¢ÂˆÂƒ , q0 , ÃÂ´, F be an exp[h]Ã¢Â€Â“space bounded alternating Turing Machine (TM), and let c Ã¢Â‰Ä½ 1 be a constant  such that for each ÃÄ… Ã¢ÂˆÂˆ AÃ¢ÂˆÂ— , the space needed by M on input  ÃÄ… is bounded by Tower(|ÃÄ…|c , h). For ÃÄ… Ã¢ÂˆÂˆ AÃ¢ÂˆÂ— , we construct  a future C-CaReth formula ÄÂ•M ,ÃÄ… over a pushdown alphabet  ÃÅP of size polynomial in n = |ÃÄ…|c and in the size of M , such  that M accepts ÃÄ… iff ÄÂ•M ,ÃÄ… is satisfiable.  Note that any reachable configuration of M over ÃÄ… can  be seen as a word ÃÄ…1 Ã‚Ë‡ (q, a) Ã‚Ë‡ ÃÄ…2 in AÃ¢ÂˆÂ— Ã‚Ë‡ (Q Ä‚Â— A) Ã‚Ë‡ AÃ¢ÂˆÂ— of length  Tower(n, h). If ÃÄ… = a1 . . . ar (where r = |ÃÄ…|), then the initial configuration is the word of length Tower(n, h) given  by (q0 , a1 )a2 . . . ar ## . . . #, where # is the blank symbol.  Let ÃÅ = A Ã¢ÂˆÅ (Q Ä‚Â— A) and ÃÅ = ÃÅ Ã¢ÂˆÅ {0, 1, $1, . . . , $h+1 } Ã¢ÂˆÅ  {Ã¢ÂˆÂƒl , Ã¢ÂˆÂƒr , Ã¢ÂˆÂ€l , Ã¢ÂˆÂ€r , end}. The pushdown alphabet ÃÅP is given by  ÃÅP = {c, r} Ä‚Â— ÃÅ Ã¢ÂˆÅ{null}, where null is a return and {c} Ä‚Â— ÃÅ  (resp., {r} Ä‚Â— ÃÅ ) is a set of calls (resp., returns). Given a  word w over ÃÅ and b Ã¢ÂˆÂˆ {c, r}, we denote by (b, w) the word  30  trol state and accepting the language ÃÅÄÂ‰ Ã¢ÂˆÅ ÃÅÃ¢ÂˆÂ— .  [6] L. Bozzelli. Alternating automata and a temporal fixpoint  calculus for visibly pushdown languages. In Proc. 18th  CONCUR, LNCS 4703, pages 476Ã¢Â€Â“491. Springer, 2007.  [7] L. Bozzelli. Caret with forgettable past. In Proc. 5th Workshop on Methods for Modalities, ENTCS. Elsevier, 2008.  [8] L. Bozzelli. The Complexity of CARET + Chop. Technical  report - http://dscpi.uninsubria.it/ staff/Bozzelli, 2008.  [9] A. Chandra, D. Kozen, and L. Stockmeyer. Alternation.  Journal of the ACM, 28(1):114Ã¢Â€Â“133, 1981.  [10] H. Chen and D. Wagner. Mops: an infrastructure for examining security properties of software. In Proc. 9th CCS,  pages 235Ã¢Â€Â“244. ACM, 2002.  [11] J. Esparza, A. Kucera, and S. Schwoon. Model checking  LTL with regular valuations for pushdown systems. Information and Computation, 186(2):355Ã¢Â€Â“376, 2003.  [12] D. Harel, D. Kozen, and R. Parikh. Process logic: Expressiveness, decidability, completeness. In Proc. 21st FOCS,  pages 129Ã¢Â€Â“142, 1980.  [13] F. Laroussinie, N. Markey, and P. Schnoebelen. Temporal  logic with forgettable past. In Proc. 17th LICS, pages 383Ã¢Â€Â“  392. IEEE Comp. Soc. Press, 2002.  [14] F. Laroussinie and P. Schnoebelen. A hierarchy of temporal logics with past. Theoretical Computer Science,  148(2):303Ã¢Â€Â“324, 1995.  [15] N. Markey and P. Schnoebelen. Model checking a path.  In Proc. 14th CONCUR, LNCS 2761, pages 251Ã¢Â€Â“265.  Springer-Verlag, 2003.  [16] A. Pnueli. The temporal logic of programs. In Proc. 18th  FOCS, pages 46Ã¢Â€Â“57, 1977.  [17] R. Rosner and A. Pnueli. A choppy logic. In Proc. 1st LICS,  pages 306Ã¢Â€Â“313. IEEE Comp. Soc. Press, 1986.  5. Conclusions  In this paper, we have studied the complexity of satisfiability and pushdown model-checking of the non-regular linear temporal logic C-CaRet. In particular, we have shown  that for the class of formulas with chop nesting depth at  most h, the problems are (h + 1)-E XPTIME-complete for  the case of finite words, and are in (h + 2)-E XPTIME and  (h + 1)-E XPTIME-hard for the case of infinite words. The  different upper bounds for the finite and infinite cases are  due to the different classes of automata (with the same  expressiveness) which have been exploited, namely BuÄšÂˆchi  NVPA for finite words, and BuÄšÂˆchi AJA for infinite words.  For both cases, the obtained automaton has size of exponential height equal to the chop nesting depth (of the given  formula) plus one. However, while non-emptiness of NVPA  is in P TIME, non-emptiness of AJA is in general E XPTIMEcomplete. The need to use AJA instead of NVPA for the  case of infinite words was due to our difficulty in capturing  Ã¢Â€Â˜parallelÃ¢Â€Â™ liveness requirements by using only nondeterminism. In other terms, alternation seems necessary to capture  in a clean way the semantics of C-CaRet for the case of infinite words. However, we conjecture that non-emptiness  for the subclass of AJA associated with C-CaRet formulas  (see Theorem 4) is in P TIME (in particular, we conjecture  that such AJA can be translated into equivalent NVPA with  only a polynomial time blowup). The main reason is that in  each (minimal) accepting run of the AJA associated with a  given formula ÄÂ•, there is exactly one infinite path (the Ã¢Â€Â˜main  pathÃ¢Â€Â™) whose nodes are labeled by atoms of ÄÂ•, while each  other infinite path satisfies the following: the suffix starting  from the first node that is not on the main path only visits  nodes labeled by atoms of subformulas of ÄÂ• whose chop  nesting depth is strictly less than that of ÄÂ•.  References  [1] R. Alur, M. Arenas, P. Barcelo, K. Etessami, N. Immerman,  and L. Libkin. First-order and temporal logics for nested  words. In Proc. 22nd LICS, pages 151Ã¢Â€Â“160. IEEE Comp.  Soc. Press, 2007.  [2] R. Alur, K. Etessami, and P. Madhusudan. A Temporal  Logic of Nested Calls and Returns. In Proc. 10th TACAS,  LNCS 2988, pages 467Ã¢Â€Â“481. Springer, 2004.  [3] R. Alur and P. Madhusudan. Visibly pushdown languages.  In Proc. 36th STOC, pages 202Ã¢Â€Â“211. ACM, 2004.  [4] T. Ball and S. Rajamani. Bebop: a symbolic model checker  for boolean programs. In 7th SPIN Workshop, LNCS 1885,  pages 113Ã¢Â€Â“130. Springer, 2000.  [5] A. Bouajjani, J. Esparza, and O. Maler. Reachability  Analysis of Pushdown Automata: Application to ModelChecking. In Proc. 8th CONCUR, LNCS 1243, pages 135Ã¢Â€Â“  150. Springer, 1997.  31 