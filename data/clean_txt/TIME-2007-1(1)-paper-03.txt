Author manuscript, published in "14th International Symposium on Temporal Representation and Reasoning (TIME), France (2007)"  On the Equivalence of Automaton-based Representations of Time Granularities  Ugo Dal Lago  Dipartimento di Scienze dellÃ¢Â€Â™Informazione, UniversitaÄšÂ€ di Bologna, Italy  dallago@cs.unibo.it  Angelo Montanari  Dipartimento di Matematica e Informatica, UniversitaÄšÂ€ di Udine, Italy  montana@dimi.uniud.it  hal-00878435, version 1 - 30 Oct 2013  Gabriele Puppis  Dipartimento di Matematica e Informatica, UniversitaÄšÂ€ di Udine, Italy  puppis@dimi.uniud.it  Abstract  A time granularity can be viewed as the partitioning  of a temporal domain in groups of elements, where each  group is perceived as an indivisible unit. In this paper we  explore an automaton-based approach to the management  of time granularity that compactly represents time granularities as single-string automata with counters, that is,  BuÄšÂˆchi automata, extended with counters, that accept a single infinite word. We focus our attention on the equivalence  problem for the class of restricted labeled single-string automata (RLA for short). The equivalence problem for RLA  is the problem of establishing whether two given RLA represent the same time granularity. The main contribution of  the paper is the reduction of the (non-)equivalence problem  for RLA to the satisfiability problem for linear diophantine  equations with bounds on variables. Since the latter problem has been shown to be NP-complete, we have that the  RLA equivalence problem is in co-NP.  1. Introduction  The notion of time granularity comes into play in a number of computer science scenarios, ranging from the specification and verification of timed workflow systems to the  management of temporal constraints, from the design of  temporal databases to temporal data mining applications.  According to a commonly accepted perspective, any  time granularity can be viewed as the partitioning of a temporal domain in groups of elements, where each group is  perceived as an indivisible unit (a granule). Most granularities of practical interest are modeled as infinite sequences  of time granules, which present a repeating pattern and,  possibly, temporal gaps within and between granules. A  number of different formalisms to finitely represent infinite  time granularities have been proposed in the literature [11],  based on algebraic [3, 15, 17, 18], logical [5, 10], stringbased [20], and automaton-based [7, 4] approaches.  We restrict our attention to the automaton-based approach. First, we introduce single-string automata and we  show that they are as expressive as WijsenÃ¢Â€Â™s string-based  models. Next, we show how to extend single-string automata with counters to take advantage of regularities of  modeled granularities. Besides making the structure of the  automata more compact, this allow us to efficiently deal  with those granularities which have a quasi-periodic structure. Single-string automata with counters are then used to  provide an effective solution to the equivalence problem for  granularity specifications. The decidability of such a problem implies the possibility of effectively testing the semantic equivalence of two different specifications, thus making  it possible to use smaller, or more tractable, representations  in place of bigger, or less tractable, ones.  The rest of the paper is organized as follows. In Section  2 we define the notion of time granularity and we briefly describe the string-based model of time granularities. In Section 3 we outline the distinctive features of the automatonbased approach, focusing our attention counters and multiple transitions, and we show how the fundamental problem of granularity equivalence can be formulated in terms  of the proposed class of automata. In addition, we briefly  analyze the relationships between the automaton-based approach and the logical one. In Section 4 we introduce Restricted Labeled single-string Automata and we provide a  formal characterization of the words they recognize. Fi-  Day  ...  ...  1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26  Week  ...  ...  1  BusinessWeek  2  4  ...  ...  1  BusinessMonth  3  2  3  4  ...  ...  1  Figure 1. Some examples of time granularities.  nally, in Section 5 we show how the equivalence problem  for RLA can be efficiently solved by reducing it to the  satisfiability problem for linear diophantine equations with  bounds on variables. The last section provides an assessment of the work and outlines future research directions.  periodically group instants of the temporal domain (most  granularity applications are only concerned with such a kind  of structures), one can easily succeed in representing and  manipulating them through finite objects.  In [20], Wijsen proposes a string-based framework for  time granularities. Infinite granularities are modeled as infinite words over an alphabet consisting of three symbols,  namely,  (filler),  (gap), and o (separator), which are  respectively used to denote time points covered by some  granule, to denote time points not covered by any granule,  and to delimit granules. A typical example is the infinite  (ultimately periodic) word  o  o ...,  which represents the granularity BusinessWeek over the  temporal domain of days. In order to guarantee a one-to-one  correspondence between infinite strings and granularities,  as well as to ease the treatment of the problems of granularity equivalence and granule conversion, Wijsen introduces  an aligned form for string-based specifications of granularities. Such a form forces any separator o to occur immediately after an occurrence of . As pointed out by Dal Lago  and Montanari [7], if we encode each occurrence of the substring  o by a single symbol J, we align the symbols of the  string-based representation and the elements of the temporal domain, thus establishing a one-to-one correspondence  between strings and granularities. Formally, we say that an  ÄÂ‰  infinite word w Ã¢ÂˆÂˆ {, , J} represents a granularity G  +  if, for every t, x Ã¢ÂˆÂˆ N , we have t Ã¢ÂˆÂˆ G(x) iff w[t] 6=   and the substring w[1, t Ã¢ÂˆÂ’ 1] contains exactly x Ã¢ÂˆÂ’ 1 occurrences of J. In the following, we shall adopt this simplified  setting to represent granularities. In particular, we can identify ultimately periodical granularities with ultimately periodic words and we can finitely represent them by specifying  their prefix and repeating pattern. Hence, any (finite or infinite) ultimately periodic time granularity can be modeled  as an ordered pair (u, v) of finite words over the alphabet  {, , J}, called granspec, where v differs from the empty  string ÃÄ¾. As an example, the granularity BusinessWeek is  represented by the granspec (ÃÄ¾, J).  hal-00878435, version 1 - 30 Oct 2013  2. A Framework for Time Granularity  The idea underlying all different notions of time granularity that have been proposed in the literature is that any  time granularity can be viewed as a suitable partition of a  fixed temporal domain. The temporal domain is usually assumed to be left-bounded and discrete (for instance, the linear order (N+ , <)). As a matter of fact, one of the main motivations for such an assumption is the observation that most  problems of practical interest involve granularities that are  ultimately periodic with respect to a fixed bottom granularity and left-bounded (that is, they have an initial granule). It  should be also noted that, by viewing (Z, <) as the disjoint  union of (N+ , <) and its reverse order, it is not difficult to  extend any given formalism from the case of left-bounded  granularities to the case of bi-infinite granularities (the interested reader can read [19] for an application of such an  idea in the field of formal languages and automata).  Definition 1. A time granularity is a partition G of a subset  T of the temporal domain (N+ , <) such that for every pair  of distinct sets g, g 0 Ã¢ÂˆÂˆ G (hereafter called granules), either  t < t0 holds for all t Ã¢ÂˆÂˆ g, t0 Ã¢ÂˆÂˆ g 0 or t0 < t holds for all  t Ã¢ÂˆÂˆ g, t0 Ã¢ÂˆÂˆ g 0 .  The ordering on N+ induces an ordering on the set of granules of G: given g, g 0 Ã¢ÂˆÂˆ G, g < g 0 holds iff t < t0 holds  for every t Ã¢ÂˆÂˆ g, t0 Ã¢ÂˆÂˆ g 0 . Such an ordering naturally yields  a labeling of granules: we say that x is the label of a granule g Ã¢ÂˆÂˆ G, and we write G(x) = g, if g is the x-th element of G according to the induced order <. Note that  Definition 1 captures both granularities that cover the whole  temporal domain, such as Day and Week, and granularities  with gaps within and between granules, like, for instance,  BusinessWeek and BusinessMonth (see Figure 1).  Clearly, since the set of all structures that satisfy Definition 1 is uncountable, it is not possible to deal with all possible granularities by means of a finitary formalism. However, by restricting to those granularities that, ultimately,  3. From Strings to Automata  The idea of viewing granularities as ultimately periodic  words naturally connects time granularity to the fields of  2  s6    s5  J  As for the repeating pattern of the ultimately periodic  word recognized by an SSA, one can exploit Knuth-MorrisPratt string matching algorithm [14] to compute the first  non-trivial occurrence of v in v Ã‚Ë‡ v (if v occurs as a substring  in v Ã‚Ë‡ v starting from the position i > 1, then v[1, i Ã¢ÂˆÂ’ 1] is  the minimum repeating pattern of u Ã‚Ë‡ v ÄÂ‰ , for any finite word  u).  These properties lead to a straightforward algorithm that  tests the equivalence of two given single-string automata M  and N in time O(|M | + |N |), where |M | and |N | denote  the number of states of M and N , respectively.  s4      s0    s1    s2    s3  Figure 2. An SSA representing BusinessWeek.  hal-00878435, version 1 - 30 Oct 2013  formal languages and automata. An automaton-based approach to time granularity, which generalizes the stringbased one in several respects, was originally proposed in  [7]. The basic idea underlying the automaton-based approach to time granularity is the following one: we take  a sequential BuÄšÂˆchi automaton M recognizing a single infiÄÂ‰  nite word w Ã¢ÂˆÂˆ {, , J} (hence the name single-string  automaton) and we say that M represents the granularity G  iff w represents G.  3.1. Counters and Multiple Transitions  A major limitation of both string-based and automatonbased formalisms is that, whenever the granularity to be  represented has a long prefix and/or a long repeating pattern, they produce lengthy representations. As an example,  recall that leap years recur with exactly the same pattern  every 400 years; then, it is easy to see that the size of any  granspec/SSA representing years (or months) of the Gregorian Calendar in terms of days, must have size greater than  105 . In such cases, computations on representations of time  granularities may become rather expensive. In the following, we extend and refine the automaton-based approach by  introducing counters in order to compactly encode redundancies of temporal structures. Precisely, we exploit the  possibility of activating different transitions from the same  (control) state and we rule them through guards envisaging  the values of the counters.  Definition 2. A single-string automaton (SSA for short) is  a quadruple M = (S, ÃÅ, ÃÂ´, s0 ), where  Ã¢Â€Ë˜ S is a finite set of states,  Ã¢Â€Ë˜ ÃÅ is a finite alphabet (usually {, , J}),  Ã¢Â€Ë˜ ÃÂ´ is a total transition function from S to ÃÅ Ä‚Â— S,  Ã¢Â€Ë˜ s0 Ã¢ÂˆÂˆ S is the initial state.  The run of M is the (unique) pair (s, w) Ã¢ÂˆÂˆ S ÄÂ‰ Ä‚Â— ÃÅÄÂ‰  such that s[1] = s0 and, for every i > 0, ÃÂ´ s[i] =  w[i], s[i + 1] . We say that w is the infinite word recognized by M if there exists s Ã¢ÂˆÂˆ S ÄÂ‰ such that the pair (s, w)  is the unique run of M . It is immediate to see that singlestring automata capture all and only the ultimately periodic  granularities, namely, those granularities that can be represented by granspecs. Figure 2 depicts an SSA representing  the granularity BusinessWeek.  Definition 3. An extended single-string automaton (ESSA  for short) is a tuple M = (S, I, ÃÅ, ÃÂ´, ÃÅ‚, s0 , c0 ), where  Ã¢Â€Ë˜ S is a finite set of control states,  Ã¢Â€Ë˜ I is a finite set of counters, whose valuations belong to  the set CI of functions from I to N,  Ã¢Â€Ë˜ ÃÅ is a finite alphabet,  Ã¢Â€Ë˜ ÃÂ´ is a total primary transition function from S to CI CI Ä‚Â—  ÃÅ Ä‚Â— S,  Ã¢Â€Ë˜ ÃÅ‚ is a partial secondary transition function from S to  LI Ä‚Â— CI CI Ä‚Â— ÃÅ Ä‚Â— S, with LI being a suitable logical  language interpreted over N with free variables belonging to I,  Ã¢Â€Ë˜ s0 Ã¢ÂˆÂˆ S is the initial state,  Ã¢Â€Ë˜ c0 Ã¢ÂˆÂˆ CI is the initial valuation.  The equivalence problem for SSA-based representations  of time granularities trivially reduces to testing whether two  given SSA recognize the same ultimately periodic word  (i.e., automata equivalence problem).  Such a problem can be easily solved in linear time with  respect to the number of states of the involved automata:  given two SSA M and N recognizing two ultimately periodic words w1 and w2 , (i) compute the minimum prefix  u1 (respectively, u2 ) and the minimum repeating pattern v1  (respectively, v2 ) of w1 (resp. w2 ), and (ii) test whether  u1 = u2 and v1 = v2 (notice that this holds iff w1 = w2 ,  namely, M and N are equivalent SSA).  As regards the prefix of the ultimately periodic word recognized by an SSA, one can exploit the following property  to test whether u is the minimum prefix of w = u Ã‚Ë‡ v ÄÂ‰ : u  is the minimum prefix of w = u Ã‚Ë‡ v ÄÂ‰ iff u[|u|] 6= v[|v|] (if  this is not the case, then consider the proper prefix u[|u|Ã¢ÂˆÂ’1]  instead of u).  As in the case of single-string automata, the run of an  ESSA is unique. In order to formally define it, we need to  introduce the notion of configuration. A configuration for  an ESSA M is a pair state-valuation (s, c), where s Ã¢ÂˆÂˆ S  and c Ã¢ÂˆÂˆ CI . The transitions of M are taken according to a  total function Ã¢ÂˆÂ†M : S Ä‚Â— CI Ã¢Â†Â’ ÃÅ Ä‚Â— S Ä‚Â— CI such that  i) if ÃÅ‚(s) = (ÄÂ•, ÄÂƒ, a, r) and c satisfies ÄÂ•, then Ã¢ÂˆÂ†M (s, c) =  (a, r, ÄÂƒ(c)),  3  j mod 12 = 0  i Ã¢Â†Â 0; j Ã¢Â†Â 0; k Ã¢Â†Â k + 1  J    s7  i Ã¢Â†Â 0; j Ã¢Â†Â j + 1  s8  i  s0  i Ã¢Â†Â i+1  Ã¢Â†Â  i mod 26 = 0  s1  k mod 400 6= 200 Ã¢ÂˆÂ§  k mod 400 6= 300    j mod 12 6= 10  J  k mod 400 6= 100 Ã¢ÂˆÂ§  j mod 12 =  6 8 Ã¢ÂˆÂ§  j  1  j mod 12 =  6 5 Ã¢ÂˆÂ§  0;  +  s6  k mod 4 = 0 Ã¢ÂˆÂ§    j  Ã¢Â†Â  j mod 12 = 1  s5  j mod 12 =  6 3 Ã¢ÂˆÂ§  J    s2      s3    s4      i Ã¢Â†Â 0; j Ã¢Â†Â j + 1  J  i Ã¢Â†Â 0; j Ã¢Â†Â j + 1  hal-00878435, version 1 - 30 Oct 2013  J  Figure 3. An ESSA representing Month.  ii) if ÃÅ‚(s) is not defined or c does not satisfy the formula in the first component of ÃÅ‚(s), then Ã¢ÂˆÂ†M (s, c) =  (a, r, ÄÂƒ(c)), where ÃÂ´(s) = (ÄÂƒ, a, r).  Intuitively, a secondary transition of an ESSA is activated if  its guard is satisfied by the valuation c; otherwise, a primary  transition is activated. The (unique) run of an ESSA M is  then defined as the triple (s, c, w) Ã¢ÂˆÂˆ S ÄÂ‰ Ä‚Â— CIÄÂ‰ Ä‚Â— ÃÅÄÂ‰ such  that (i) s[1] = s0 , (ii) c[1] = c0 , and (iii) Ã¢ÂˆÂ†M (s[i], c[i]) =  (w[i], s[i + 1], c[i + 1]) for all i > 0. Given an ESSA M  and its (unique) run (s, c, w), we say that w is the word  recognized by M .  ondary transitions, several fundamental problems turn out  to be undecidable. As an example, if we allow guards of the  form x = 0 and update operators of the form x Ã¢Â†Â x Ã¢ÂˆÂ’ 1  and x Ã¢Â†Â x + 1, then the halting problem for Minsky (twocounters) machines [16] can be easily reduced to the equivalence problem for ESSA, thus showing that the latter problem is undecidable.  In [7], Dal Lago and Montanari suggest to  i) restrict to guards which are conjunctions of atomic formulas of the form t1 = t2 or t1 6= t2 , where both t1 and  t2 are integer constants or terms of the form i mod d,  with i Ã¢ÂˆÂˆ I and d Ã¢ÂˆÂˆ N+ ;  ii) restrict to update operators which are functional compositions of the basic operators i Ã¢Â†Â 0 and i Ã¢Â†Â i + 1,  where i ranges in I and the operator i Ã¢Â†Â 0 (respectively, i Ã¢Â†Â i + 1) maps a valuation c to the valuation c[0/i] (respectively, c[c(i) + 1/i]), with c[x/i]  denoting the valuation such that c[x/i](i) = x and  c[x/i](j) = c(j) for every j 6= i.  An interesting example of ESSA is given by Figure 3  which depicts an ESSA representing the granularity Month  in terms of the granularity Day. The automaton uses three  counters, i, j, and k, to store the index of the current day,  current month, and current year, respectively. Each counter  is initialized to 0, that is, the initial valuation c0 is such  that c0 (i) = c0 (j) = c0 (k) = 0. Control states are represented by circles, while transitions are represented by arrows annotated with the update operators. e.g., j Ã¢Â†Â j + 1,  and the recognized symbol, e.g., ). Primary and secondary transitions are identified by continuous and dashed  arrows, respectively; secondary transitions have guards,  e.g., k mod 4 = 0, which are specified as additional annotations of the corresponding dashed arrows.  The resulting class of automata, called reducible extended single-string automata (shortly RESSA), is expressive enough to compactly encode granularities of practical  interest and well behaved, namely, they guarantee decidability results for many relevant problems. As an example, the automaton in Figure 3 is a RESSA. Moreover, one  can effectively map a RESSA to an equivalent SSA, thus  proving that RESSA are as expressive as (but more compact than) SSA.  The equivalence between RESSA and SSA is obtained  by defining, for any given RESSA M , an abstraction rela-  From the above example, it is clear how ESSA can be  exploited to compactly encode redundancies of temporal  structures. However, the notion of ESSA is too general to be  of practical interest: if we do not restrict the set of admissible formulas and update operators for primary and sec4  hal-00878435, version 1 - 30 Oct 2013  tion over the configurations of M , which turns out to be  an equivalence of finite index compatible with the transition function Ã¢ÂˆÂ†M (see [2, 10] for similar constructions).  Formally, we say that a relation Ã¢ÂˆÅº over a (possibly infinite) set X is compatible with a function f : X Ã¢Â†Â’ X  iff, for every x, x0 Ã¢ÂˆÂˆ X, x Ã¢ÂˆÅº x0 implies f (x) Ã¢ÂˆÅº f (x0 ).  If M = (S, I, ÃÅ, ÃÂ´, ÃÅ‚, s0 , c0 ) is a RESSA and, for each  counter i Ã¢ÂˆÂˆ I, di is the least common multiple of all constants d that appear inside terms of the form i mod d in  ÃÅ‚(S), then we can define the relation Ã¢ÂˆÅº  =M over the set SÄ‚Â—CI  of configurations of M in such a way that (s, c) Ã¢ÂˆÅº  =M (s0 , c0 )  0  0  iff s = s and, for all i Ã¢ÂˆÂˆ I, c(i) = c (i) (mod di ). It  is easy to show that Ã¢ÂˆÅº  =M is an equivalence of finite index  which is compatible with the transition function Ã¢ÂˆÂ†M . As  a matter of fact, according to the classification introduced  by Henzinger and Majumdar [13], this means that RESSA  belong to the first class of symbolic transition systems (i.e.,  infinite-state systems having finite bisimilarity quotients).  One can also prove that there is an exponential bound  on the size of the SSA equivalent to a given RESSA. This  shows that the equivalence problem for RESSA is in EXPTIME.  propositional letters are replaced with formulas of the form  ÄÂ•[ i1 xj1 , ..., ik xjk ], which are obtained by substituting  il  xjl for all free occurrences of yl in the IPC++ -formula  ÄÂ•(y1 , ..., yk ), for l = 1, . . . , k. A model of a PLTLmod formula is an infinite sequence of valuations, namely, a  function of the form c : N Ä‚Â— {x, y, ...} Ã¢Â†Â’ Z.  As an example, we show the encoding of some granularities of the Gregorian Calendar taken from [10]. These  granularities are modeled as infinite sequences of valuations  for the corresponding integer variables as follows:  Ã¢Â€Ë˜ sec Ã¢Â‰Ä„60 0 Ã¢ÂˆÂ§ (0 Ã¢Â‰Â¤ sec < 60 Ã¢ÂˆÂ§  sec Ã¢Â‰Ä„60 sec + 1),  Ã¢Â€Ë˜ min Ã¢Â‰Ä„60 0 Ã¢ÂˆÂ§ (0 Ã¢Â‰Â¤ min < 60 Ã¢ÂˆÂ§ (sec = 59 Ã¢Â†Â’  min Ã¢Â‰Ä„60 min + 1) Ã¢ÂˆÂ§ (sec 6= 59 Ã¢Â†Â’  min =  min)),  Ã¢Â€Ë˜ hour Ã¢Â‰Ä„24 0 Ã¢ÂˆÂ§ (0 Ã¢Â‰Â¤ hour < 24 Ã¢ÂˆÂ§ (min =  59 Ã¢ÂˆÂ§ sec = 59 Ã¢Â†Â’  hour Ã¢Â‰Ä„24 hour +1) Ã¢ÂˆÂ§ (min 6=  59 Ã¢ÂˆÂ¨ sec 6= 59 Ã¢Â†Â’  hour = hour )),  Ã¢Â€Ë˜ day Ã¢Â‰Ä„7 0 Ã¢ÂˆÂ§ (0 Ã¢Â‰Â¤ day < 7 Ã¢ÂˆÂ§ (hour = 23 Ã¢ÂˆÂ§ min =  59 Ã¢ÂˆÂ§ sec = 59 Ã¢Â†Â’  day Ã¢Â‰Ä„7 day + 1) Ã¢ÂˆÂ§ (hour 6=  23 Ã¢ÂˆÂ¨ min 6= 59 Ã¢ÂˆÂ¨ sec 6= 59 Ã¢Â†Â’  day = day)),  3.2. The logical counterpart of RESSA  Ã¢Â€Ë˜ as for the granularities Month and Year, one can encode them by fixing some end dates far ahead in the  time line (such an assumption is necessary since we  cannot use constraints like year = year + 1 without incurring in undecidability [6, 10]).  In [10] Demri describes a logical framework that allows  one to express, in a concise way, integer periodicity constraints over a linear temporal domain. The formalism is  based on a fragment of Presburger linear temporal logic, denoted PLTLmod . More precisely, the logical language is obtained by combining PLTL (i.e., linear temporal logic with  past-time operators) with a suitable first-order constraint  language IPC++ , whose formulas are built via standard  Boolean connectives and existential quantifications, starting from basic atomic formulas of the form x = d, x < d,  x > d, x = y, x Ã¢Â‰Ä„k d, and x Ã¢Â‰Ä„k y + [d1 , d2 ], where x, y, ...  are variables interpreted over Z and d, k, d1 , d2 , ... are integer constants. Given a valuation c : {x, y, ...} Ã¢Â†Â’ Z for the  variables x, y, ..., the semantics of an atomic formula is the  obvious one:  Ã¢Â€Ë˜ c  (x = d) iff c(x) = d,  Ã¢Â€Ë˜ c  (x < d) iff c(x) < d,  Ã¢Â€Ë˜ c  (x > d) iff c(x) > d,  Ã¢Â€Ë˜ c  (x = y) iff c(x) = c(y),  Ã¢Â€Ë˜ c  (x Ã¢Â‰Ä„k d) iff c(x) Ã¢Â‰Ä„k d,  Ã¢Â€Ë˜ c  (x Ã¢Â‰Ä„k y + [d1 , d2 ]) iff c(x) Ã¢Â‰Ä„k c(y) + d for some  d1 Ã¢Â‰Â¤ d Ã¢Â‰Â¤ d2 .  The constraint language IPC++ is a strict fragment of Presburger arithmetic [12].  The language PLTLmod can be viewed as the temporalization (via PLTL) of IPC++ . Formally, let i xj be the  value of the variable xj at the i-th successor of the current  time point. PLTLmod formulas are PLTL formulas whose  Notice that no propositional variables appear in  PLTLmod . However, any propositional variable P can be  easily encoded by an IPC++ -formula of the form xP = 1,  where xP is a fresh variable associated with P .  Demri shows that, like plain LTL but unlike full Presburger LTL, PLTLmod enjoys a PSPACE-complete satisfiability problem [10]. Such a result is achieved by first  defining suitable automaton-based representations for (abstracted) models of PLTLmod -formulas and then by reducing the satisfiability problem to the emptiness problem for  these automata.  In [10], Demri establishes an interesting connection between RESSA and linear temporal logics with integer periodicity constraints by reducing the equivalence problem for  RESSA to a satisfiability problem for a suitable fragment of  PLTLmod . To this end, the guards associated with RESSA  secondary transitions are rewritten as Boolean combinations of formulas like x Ã¢Â‰Ä„k d and Ã¢ÂˆÂƒ z. (x Ã¢Â‰Ä„k z Ã¢ÂˆÂ§ y Ã¢Â‰Ä„k0 z),  and thus they belong to a (strict) fragment of IPC++ , denoted IPCÃ¢ÂˆÂ— in [10].  Let PLTLÃ¢ÂˆÂ— be the Presburger LTL fragment obtained by  combining PLTL and IPCÃ¢ÂˆÂ— . Demri shows that the equivalence problem for RESSA is reducible to the satisfiability  5  problem for PLTLÃ¢ÂˆÂ— -formulas or, equivalently, to the emptiness problem for a suitable class of BuÄšÂˆchi automata, where  the input symbols are atomic IPCÃ¢ÂˆÂ— -formulas. The size of  the formulas corresponding to a given instance of the equivalence problem for RESSA is shown to be polynomially  bounded with respect to the size of the automata, thus proving that the equivalence problem for RESSA is in PSPACE.  Such a result improves the previously known EXPTIME upper bound given by Dal Lago and Montanari in [7].  Moreover, in [10] a reduction from the satisfiability  problem for quantified boolean formulas to the equivalence problem for RESSA is also given, thus showing that  the equivalence problem for RESSA is actually PSPACEcomplete.    J  ÄÂ‰  Figure 4. An RLA representing Monday.  circles, while states in SÃÄ¾ are represented by triangles. Primary and secondary transitions are represented by continuous and dashed arrows, respectively. The (initial values  of) counters are associated with states in SÃÄ¾ (for the sake of  readability, we depict them as labels of the secondary transitions exiting states in SÃÄ¾ ).  4. Restricted Labeled Single-string Automata  hal-00878435, version 1 - 30 Oct 2013  6  Definition 4. A restricted labeled (single-string) automaton (RLA for short) is a tuple M = (SÃÅ , SÃÄ¾ , ÃÅ,  Ã¢Â„Åš, ÃÂ´, ÃÅ‚, s0 , c0 ), where  Ã¢Â€Ë˜ SÃÅ and SÃÄ¾ are disjoint finite sets of (control) states  (hereafter, we shall denote by S the set SÃÅ Ã¢ÂˆÅ SÃÄ¾ );  Ã¢Â€Ë˜ ÃÅ is a finite alphabet;  Ã¢Â€Ë˜ Ã¢Â„Åš : SÃÅ Ã¢Â†Â’ ÃÅ is a total labeling function;  Ã¢Â€Ë˜ ÃÂ´ : S * S is a partial primary transition function  whose transitive closure ÃÂ´ + is irreflexive (namely, it  never happens that (s, s) Ã¢ÂˆÂˆ ÃÂ´ + );  Ã¢Â€Ë˜ ÃÅ‚ : SÃÄ¾ Ã¢Â†Â’ S is a total secondary transition function  such that for every s Ã¢ÂˆÂˆ SÃÄ¾ , (ÃÅ‚(s), s) Ã¢ÂˆÂˆ ÃÂ´ + ;  Ã¢Â€Ë˜ s0 Ã¢ÂˆÂˆ S is the initial state;  Ã¢Â€Ë˜ c0 : SÃÄ¾ Ã¢Â†Â’ N+ Ã¢ÂˆÅ {ÄÂ‰} is the initial valuation.  In this section we introduce a new class of automata,  called restricted labeled single-string automata (RLA for  short), which are an attempt to find a suitable trade-off between the handiness of SSA and the compactness of (reducible) ESSA [9]. RLA are similar to RESSA, since they  exploit counters to compactly encode repeating patterns of  time granularities. However, the distinctive feature of this  class of automata lies in the structure of the transition functions, which is now more restricted. As an example, we  define a uniform policy of counter update. By exploiting  such restrictions, we will be able to devise improved algorithms for several problems on time granularities, including  the equivalence one.  Counters of RLA range over the natural numbers extended with a special value ÄÂ‰; they can be either set to their  initial value or decremented (we tacitly assume that n < ÄÂ‰  for all n Ã¢ÂˆÂˆ N and ÄÂ‰ Ã¢ÂˆÂ’ 1 = ÄÂ‰).  Let us denote by CSÃÄ¾ the set of all valuations of the form  c : SÃÄ¾ Ã¢Â†Â’ (N Ã¢ÂˆÅ {ÄÂ‰}) for the counters of an RLA M =  (SÃÅ , SÃÄ¾ , ÃÅ, Ã¢Â„Åš, ÃÂ´, ÃÅ‚, s0 , c0 ). A configuration for M is a pair  (s, c), where s Ã¢ÂˆÂˆ S and c Ã¢ÂˆÂˆ CSÃÄ¾ .  The transitions of M are taken according to a partial  function Ã¢ÂˆÂ†M : S Ä‚Â— CSÃÄ¾ * S Ä‚Â— CSÃÄ¾ satisfying the following  conditions:  i) if s Ã¢ÂˆÂˆ SÃÅ and ÃÂ´(s) is defined, then Ã¢ÂˆÂ†M (s, c) =  (ÃÂ´(s), c), namely, if the automaton lies in a labeled state  and there is an exiting primary transition, then it takes  the primary transition, which does not change the valuation,  ii) if s Ã¢ÂˆÂˆ SÃÄ¾ and c(s) > 0, then Ã¢ÂˆÂ†M (s, c) = (ÃÅ‚(s), c0 ),  where c0 = c[c(s) Ã¢ÂˆÂ’ 1/s], namely, if the automaton  lies in a non-labeled state whose counter has a positive value, then it takes the secondary transition and it  decrements the counter by 1,  iii) if s Ã¢ÂˆÂˆ SÃÄ¾ , c(s) = 0, and ÃÂ´(s) is defined, then  Ã¢ÂˆÂ†M (s, c) = (ÃÂ´(s), c0 ), where c0 = c[c0 (s)/s], namely,  We now give an intuitive description of RLA structure  and behavior. First of all, to simplify the notation and the  formalization of properties, labels are moved from transitions to states. Moreover, the set of states is partitioned into  two groups, respectively denoted by SÃÅ and SÃÄ¾ . SÃÅ is the  set of states where the labeling function is defined, while SÃÄ¾  is the set of states where it is not defined. Furthermore, like  in the case of ESSA, we distinguish between two kinds of  transition, respectively called primary and secondary transitions. At any point of the computation, at most one (primary  or secondary) transition is taken according to an appropriate rule envisaging the state at which the automaton lies and  the value of the counter associated with that state. Primary  transition functions can be defined in any state, while secondary transition functions are only defined in non-labeled  states. A primary transition can be taken in a non-labeled  state s only once the secondary transition associated with  s has been consecutively taken c0 (s) times, where c0 (s) is  the initial valuation for the counter associated with s.  Figure 4 depicts an RLA recognizing the word (J6 )ÄÂ‰ ,  which represents the granularity Monday in terms of the  granularity Day. States in SÃÅ are represented by ÃÅ-labeled  6  hal-00878435, version 1 - 30 Oct 2013  As an example, if we denote by s0 the initial state of the  RLA of Figure 4, by s1 its successor, by s2 the top-most  state, and by s3 the right-most state, we have that  if the automaton lies in a non-labeled state whose  counter has value 0 and if there is an exiting primary  transition, then it takes the primary transition and it reinitializes the counter,  iv) if none of the above conditions holds, then Ã¢ÂˆÂ†M (s, c) is  undefined.  Notice that, since Ã¢ÂˆÂ†M may be not defined on some configurations, the run of an RLA may be finite.  The run of an RLA M is defined as follows. Let X Ã¢ÂˆÂ  be the set of all (finite and infinite) words over X, namely,  X Ã¢ÂˆÂ = X Ã¢ÂˆÂ— Ã¢ÂˆÅ X ÄÂ‰ . The run of an RLA M is the pair  (s, c) Ã¢ÂˆÂˆ S Ã¢ÂˆÂ Ä‚Â— CSÃ¢ÂˆÂÃÄ¾ of maximum (possibly infinite) sequences of states and valuations such that (i) s[1] = s0 ,  (ii) c[1] = c0 , and (iii) Ã¢ÂˆÂ†M (s[i], c[i]) = (s[i + 1], c[i + 1])  for all 1 Ã¢Â‰Â¤ i < |s| (= |c|). Given the RLA M and its  run (s, c), one can extract a (finite or infinite) sequence of  Ã¢ÂˆÂ  labeled states sÃÅ Ã¢ÂˆÂˆ SÃÅ  by discarding the valuations and  the non-labeled states. Such a sequence is said to be the labeled run of M . We say that M recognizes the word w iff  w = Ã¢Â„Åš(sÃÅ ) (here Ã¢Â„Åš is extended from states to sequences of  states in the natural way).  Ã¢Â€Ë˜ the ÃÂ´-degree of s0 (respectively, s1 , s2 , s3 ) is 2 (respectively, 1, 2, 0),  Ã¢Â€Ë˜ the ÃÅ‚-degree of s1 is 1 and the ÃÅ‚-degree of s3 is 2,  Ã¢Â€Ë˜ ÃÂ“M = {(s1 , s3 )} and ÃÂ“Ã¢ÂˆÂ—M consists the pair in ÃÂ“M plus  the pairs (s1 , s1 ) and (s3 , s3 ).  For every state s, let ÄÂƒsM be the finite or infinite word  inductively defined as follows:  Ã¢Â€Ë˜ if s Ã¢ÂˆÂˆ SÃÅ , then ÄÂƒsM = Ã¢Â„Åš(s),  Ã¢Â€Ë˜ if s Ã¢ÂˆÂˆ SÃÄ¾ and m is the ÃÅ‚-degree of s, then ÄÂƒsM =  c0 (s)  M  M  ÄÂƒÃÅ‚(s)  Ã‚Ë‡ ÄÂƒÃÂ´(ÃÅ‚(s))  Ã‚Ë‡ ... Ã‚Ë‡ ÄÂƒÃÂ´MmÃ¢ÂˆÂ’1 (ÃÅ‚(s))  .  The well-definedness of ÄÂƒsM directly follows from the principle of ÃÅ‚-induction.  RLA-recognizable words can be characterized as expressions like (4 J2 )ÄÂ‰ and 6 ((2 )2 2 )ÄÂ‰ , which feature  nested repetitions, as stated by the following proposition.  Notice that Definition 4 allows situations where states  and transitions of an RLA form an unconnected (directed)  graph. We can overcome these clumsy situations by discarding useless states and transitions. Since counters of  reachable configurations range over finite domains, it is immediate to see that RLA recognize either finite or ultimately  periodic words.  Proposition 1 (Dal Lago, Montanari, Puppis [9]). The word  recognized by an RLA M = (SÃÅ , SÃÄ¾ , ÃÅ, Ã¢Â„Åš, ÃÂ´, ÃÅ‚, s0 , c0 ) is of  M  the form ÄÂƒsM0 Ã‚Ë‡ ÄÂƒÃÂ´(s  Ã‚Ë‡ ... Ã‚Ë‡ ÄÂƒÃÂ´Mn (s0 ) , where n is the ÃÂ´-degree  0)  of s0 .  4.2. A Complexity Measure for RLA  4.1. RLA-recognizable Words  We now briefly describe a measure of complexity for  RLA (for further details, we refer the reader to [9]). Besides the usual complexity measure based on the number of  states of the automaton, there is another natural complexity  measure which takes into account the nesting structure of  RLA transition relations. Such a complexity measure plays  a fundamental role in the analysis of main algorithms on  RLA [9] and it will be used in the next section in the proof  of one basic lemma.  For every state s of an RLA M and every integer n, let  CM  s,n be defined as follows (here we use double induction  on s and n, where the ordering for the first, dominant, argument is induced by the relation ÃÂ“Ã¢ÂˆÂ—M ):  The solution to the equivalence problem for RLA takes  advantage of the following characterization of the words  recognized by RLA, based on the notions of ÃÂ´-degree and  ÃÅ‚-degree of states.  The ÃÂ´-degree of a state s Ã¢ÂˆÂˆ S is the (unique) natural  number n such that ÃÂ´ n (s) is defined, but ÃÂ´ n+1 (s) is not.  For instance, the initial state of the automaton of Figure 4  has ÃÂ´-degree 2. For each non-labeled state s Ã¢ÂˆÂˆ SÃÄ¾ , the ÃÅ‚degree of s is the least n Ã¢ÂˆÂˆ N such that (ÃÅ‚(s), s) Ã¢ÂˆÂˆ ÃÂ´ n . For  instance, the lower-middle state of the automaton of Figure  4 has ÃÅ‚-degree 1.  The notion of ÃÅ‚-degree can then be used to represent the  nested structure of RLA transitions in terms of a binary relation ÃÂ“M over the set SÃÄ¾ defined as follows: (s, r) Ã¢ÂˆÂˆ ÃÂ“M  iff s = ÃÂ´ i (ÃÅ‚(r)), where i is less than the ÃÅ‚-degree of r. Note  that the reflexive and transitive closure ÃÂ“Ã¢ÂˆÂ—M is antisymmetric, namely, (s, r) Ã¢ÂˆÂˆ ÃÂ“Ã¢ÂˆÂ—M and (r, s) Ã¢ÂˆÂˆ ÃÂ“Ã¢ÂˆÂ—M imply s = r.  Thus, ÃÂ“Ã¢ÂˆÂ—M can be given the status of a well-founded partial order over the set of non-labeled states. Such a partial  order immediately suggests an induction principle, called ÃÅ‚induction, which we will extensively use in both definitions  and proofs.  Ã¢Â€Ë˜ if n < 0, then CM  s,n = 0;  Ã¢Â€Ë˜ if n Ã¢Â‰Ä½ 0, s Ã¢ÂˆÂˆ SÃÅ , and ÃÂ´(s) is undefined, then CM  s,n = 1;  Ã¢Â€Ë˜ if n Ã¢Â‰Ä½ 0, s Ã¢ÂˆÂˆ SÃÅ , and ÃÂ´(s) is defined, then CM  s,n =  M  1 + CÃÂ´(s),nÃ¢ÂˆÂ’1 ;  Ã¢Â€Ë˜ if n Ã¢Â‰Ä½ 0, s Ã¢ÂˆÂˆ SÃÄ¾ , m is the ÃÅ‚-degree of s, and ÃÂ´(s) is  M  undefined, then CM  s,n = 1 + CÃÅ‚(s),mÃ¢ÂˆÂ’1 ;  7  Ã¢Â€Ë˜ if n Ã¢Â‰Ä½ 0, s Ã¢ÂˆÂˆ SÃÄ¾ , m is the ÃÅ‚-degree of s, and ÃÂ´(s) is  M  M  defined, then CM  s,n = 1+max CÃÂ´(s),nÃ¢ÂˆÂ’1 , CÃÅ‚(s),mÃ¢ÂˆÂ’1 .  equivalence of two given RLA in non-deterministic polynomial time. Our solution is based on a reduction of the  non-equivalence problem to a number-theoretic problem,  precisely, the problem of testing the satisfiability of linear  diophantine equations, where variables are constrained by  lower and upper bounds.  hal-00878435, version 1 - 30 Oct 2013  The complexity kM k of M is defined as kM k = CM  s0 ,n ,  where s0 is the initial state of M and n is the ÃÂ´-degree of  2  s0 . It is easy to show that kM k Ã¢Â‰Â¤ |M | . As an example,  the complexity of the automaton in Figure 4 is 6.  We start by giving some preliminary definitions. The  operations of addition + and multiplication Ã‚Ë‡ in Z can be  naturally extended to the power-set 2Z as follows: if S, T Ã¢ÂŠÂ†  Z, then S + T = {x + y Ã¢ÂˆÂˆ Z : x Ã¢ÂˆÂˆ S, y Ã¢ÂˆÂˆ T } and S Ã‚Ë‡ T =  {x Ã‚Ë‡ y Ã¢ÂˆÂˆ Z : x Ã¢ÂˆÂˆ S, y Ã¢ÂˆÂˆ T }. By a slight abuse of notation,  we shall write expressions of the form k Ã‚Ë‡ S, denoting the  set {k Ã‚Ë‡ x : x Ã¢ÂˆÂˆ S}. Furthermore, we call interval any  subset of Z of the form [i, j] = {x : i Ã¢Â‰Â¤ x Ã¢Â‰Â¤ j}, where  i Ã¢ÂˆÂˆ Z Ã¢ÂˆÅ {Ã¢ÂˆÂ’ÄÂ‰} and j Ã¢ÂˆÂˆ Z Ã¢ÂˆÅ {ÄÂ‰}.  The running time of several algorithms operating on  RLA-based representations of time granularities, e.g., granule conversion ones, can be expressed in terms of the complexities of the involved automata. This is the case, for instance, with simple algorithms that look for occurrences of  particular symbols in the word recognized by a given RLA  M , which require time O(kM k). In many cases, the running time of such algorithms turns out to be sub-linear with  respect to the number of transitions to be taken to reach  the addressed symbol occurrence, thus showing that algorithms working on RLA-based representations outperform  those running on equivalent granspecs/SSA.  As an example, by exploiting the optimization algorithms described in [9], we can obtain an RLA representing  the granularity Month in terms of days with 87 control states  and complexity 14. Both these values are significantly less  than the size of any equivalent granspec/SSA (see Section  3). Such an automaton is described by the following expression:  Ã¢Â€Â  Intuitively, the idea underlying our solution to the equivalence problem for RLA is to represent the set of positions  of all the occurrences of a labeled state in the labeled run  of an RLA M by a union of m distinct sets of the form  k1 I1 + ... + kn In , where the values m and n are polynomially bounded with respect to the number of states of M and  each Ij is a suitable interval of Z.  Given two RLA M and N , one can decide whether  M and N recognize the same infinite word by testing the  emptiness of every set resulting from the intersection of two  expressions E1 and E2 , where E1 represents the positions  of the occurrences of an a-labeled state of M and E2 represents the positions of the occurrences of a b-labeled state of  N , with a 6= b.  The latter problem can then be reduced to the problem  of testing the non-satisfiability of some linear diophantine  equations with lower and upper bounds on the variables.  Even though the satisfiability problem for linear diophantine equations with bounds on variables is known be NPcomplete, several solutions that perform well in practice  (even on equations with thousands of variables) have been  proposed in literature (see, for instance, [1]).  The above argument shows that the equivalence problem  for RLA is in co-NP. We provide no proof of the co-NPhardness of the equivalence problem for RLA. As a matter  of fact, we conjecture that the problem can be solved by a  deterministic algorithm which takes polynomial time with  respect to the size of the input automata. Unfortunately, at  the moment we are only able to provide a non-deterministic  algorithm for the non-equivalence problem of RLA.  Ã¢Â€Âœ  `  Ã‚Â´2 Ã¢Â€Â2  2 (28 J)2 30 (J29 )2  J  Ã¢Â€Â  Ã¢Â€ÂÃ¢Â€Â  Ã¢Â€Â  Ã‚Å¤ Ã‚Å¤  Ã¢Â€Âœ  `  Ã‚Â´2 Ã¢Â€Â2 3 25  3 (27 J)2 30 (J29 )2  J  Ã‚Å¤  Ã¢Â€Âœ  `  Ã‚Â´2 Ã¢Â€Â2 4  3 (27 J)2 30 (J29 )2  J  Ã¢Â€Âœ  `  Ã‚Â´2 Ã¢Â€Â2  2 (28 J)2 30 (J29 )2  J  Ã¢Â€Â  Ã‚Å¤ Ã‚Å¤ Ã‚Å¤  Ã¢Â€Âœ  `  Ã‚Â´2 Ã¢Â€Â2 3 24 3  3 (27 J)2 30 (J29 )2  J  !ÄÂ‰  The above arguments account for the compactness and  tractableness of RLA compared to granspecs/SSA.  5. The Equivalence Problem for RLA  In this section we focus our attention on the equivalence  problem for RLA-based representations of time granularities. As we previously pointed out, two single-string automata represent the same time granularity iff they accept  the same ultimately periodic word. In Section 3 the equivalence problem for RESSA has been shown to be solvable  in polynomial space with respect to the size of the input  automata. Here we show that in the case of RLA we can  devise a more efficient algorithm, which tests the (non-)  The argument can be formalized as follows. Given an  RLA M = (SÃÅ , SÃÄ¾ , ÃÅ, Ã¢Â„Åš, ÃÂ´, ÃÅ‚, s0 , c0 ), let us denote by  (s, c) its (unique) run and by sÃÅ the corresponding labeled  run. Without loss of generality, we can temporarily assume  that Ã¢Â„Åš is the identity function, which maps a labeled state  s to itself (hence, we have ÃÅ = SÃÅ ). Such an assumption  allows us to think of ÄÂƒsM , as defined in Section 4, as a se8  quence of labeled states, rather than a sequence of symbols.  From Proposition 1, we immediately have  4:  5:  6:  M  Ã‚Ë‡ ... Ã‚Ë‡ ÄÂƒÃÂ´Mn (s0 ) ,  sÃÅ = ÄÂƒsM0 Ã‚Ë‡ ÄÂƒÃÂ´(s  0)  7:  8:  where n is the ÃÂ´-degree of s0 . In addition, for every nonlabeled state s Ã¢ÂˆÂˆ SÃÄ¾ , with ÃÅ‚-degree m, we set:  9:  10:  11:  M  M  M  ÄÂM  s = ÄÂƒÃÅ‚(s) Ã‚Ë‡ ÄÂƒÃÂ´(ÃÅ‚(s)) Ã‚Ë‡ ... Ã‚Ë‡ ÄÂƒÃÂ´ mÃ¢ÂˆÂ’1 (ÃÅ‚(s)) .  12:  13:  hal-00878435, version 1 - 30 Oct 2013  To keep track of the set of positions of any labeled state,  we introduce the notion of (p, q-succinct) linear progression.  14:  15:  16:  17:  Definition 5. Given a set P Ã¢ÂŠÂ† Z and two positive integers  p, q, we say that P is a p, q-succinct linear progression if  there exist m Ã¢Â‰Â¤ p, n1 , ..., nm Ã¢Â‰Â¤ q, k1,1 , ..., k1,n1 , ..., km,1 ,  ..., km,nm Ã¢ÂˆÂˆ Z, and someSintervalsP  I1,1 , ..., I1,n1 , ..., Im,1 ,  ..., Im,nm such that P = 1Ã¢Â‰Â¤iÃ¢Â‰Â¤m 1Ã¢Â‰Â¤jÃ¢Â‰Â¤ni ki,j Ii,j .  18:  19:  20:  21:  22:  23:  24:  25:  For every s Ã¢ÂˆÂˆ SÃÅ , every r Ã¢ÂˆÂˆ S, and every n Ã¢ÂˆÂˆ Z less  than or equal to the ÃÂ´-degree of s, we denote by Ps,r,n the  set of positions of all the occurrences of s in the sequence  M  Ã‚Ë‡ ... Ã‚Ë‡ ÄÂƒÃÂ´Mn (r) . Clearly, the set of positions of all  ÄÂƒrM Ã‚Ë‡ ÄÂƒÃÂ´(r)  the occurrences of s in the labeled run sÃÅ of M is Ps,s0 ,n ,  where n is the ÃÂ´-degree of s0 .  26:  27:  28:  Now, by exploiting the definition of ÄÂƒrM , we can easily  verify the following recursive equations:  else if r Ã¢ÂˆÂˆ SÃÅ then  if ÃÂ´(r) = Ã¢ÂŠÄ½ then  if r 6= s then  return Ã¢Âˆ  else  return {1}  end if  else  P Ã¢Â†Â 1 + RLAPositions(M, s, ÃÂ´(r), n Ã¢ÂˆÂ’ 1)  if r 6= s then  return P  else  return {1} Ã¢ÂˆÅ P  end if  end if  else  m Ã¢Â†Â ÃÅ‚-degree(r)  P Ã¢Â†Â RLAPositions(M, s, ÃÅ‚(r), m Ã¢ÂˆÂ’ 1) +  |ÄÂM  r | Ã¢ÂˆÂ— [0, c0 (r) Ã¢ÂˆÂ’ 1]  if ÃÂ´(r) = Ã¢ÂŠÄ½ then  return P  else  Q Ã¢Â†Â RLAPositions(M, s, ÃÂ´(r), n Ã¢ÂˆÂ’ 1) + |ÄÂƒrM |  return P Ã¢ÂˆÅ Q  end if  end if  The following lemma shows that the set Ps,r,n is actually  2  2  an |S| , |S| -succinct linear progression.  Ã¢Â€Ë˜ Ps,r,n = Ã¢ÂˆÂ…, if n < 0;  Ã¢Â€Ë˜ Ps,r,n = Ã¢ÂˆÂ…, if n Ã¢Â‰Ä½ 0, r Ã¢ÂˆÂˆ SÃÅ \ {s}, and ÃÂ´(r) is undefined;  Lemma 2. For every s Ã¢ÂˆÂˆ SÃÅ , every r Ã¢ÂˆÂˆ S, and every  n Ã¢ÂˆÂˆ Z less than or equal to the ÃÂ´-degree of r, Ps,r,n is a  2  2  |S| , |S| -succinct linear progression.  Ã¢Â€Ë˜ Ps,r,n = {1}, if n Ã¢Â‰Ä½ 0, r = s, and ÃÂ´(r) is undefined;  Ã¢Â€Ë˜ Ps,r,n = Ps,ÃÂ´(r),nÃ¢ÂˆÂ’1 + 1, if n Ã¢Â‰Ä½ 0, r Ã¢ÂˆÂˆ SÃÅ \ {s}, and  ÃÂ´(r) is defined;    Ã¢Â€Ë˜ Ps,r,n = {1} Ã¢ÂˆÅ Ps,ÃÂ´(r),nÃ¢ÂˆÂ’1 + 1 , if n Ã¢Â‰Ä½ 0, r = s,  and ÃÂ´(r) is defined;  Proof. First of all, note that the succinct linear progressions  satisfy the following properties (compositionality):  Ã¢Â€Ë˜ if P is a p, q-succinct linear progression, then P + kI is  a p, q + 1-succinct linear progression for every integer  k and every interval I,  Ã¢Â€Ë˜ Ps,r,n = Ps,ÃÅ‚(r),mÃ¢ÂˆÂ’1 + |ÄÂM  r | Ã‚Ë‡ [0, c0 (r) Ã¢ÂˆÂ’ 1], if n Ã¢Â‰Ä½ 0,  r Ã¢ÂˆÂˆ SÃÄ¾ , m is the ÃÅ‚-degree of r, and ÃÂ´(r) is undefined;    M  Ã¢Â€Ë˜ Ps,r,n = Ps,ÃÅ‚(r),mÃ¢ÂˆÂ’1  +  |ÄÂ  |  Ã‚Ë‡  [0,  c  (r)  Ã¢ÂˆÂ’  1]  Ã¢ÂˆÅ  0  r    M  Ps,ÃÂ´(r),nÃ¢ÂˆÂ’1 + |ÄÂƒr | , if n Ã¢Â‰Ä½ 0, r Ã¢ÂˆÂˆ SÃÄ¾ , m is the ÃÅ‚degree of r, and ÃÂ´(r) is defined.  Ã¢Â€Ë˜ if P is a p, q-succinct linear progression and P 0 is a  p0 , q 0 -succinct linear progression, then P Ã¢ÂˆÅ P 0 is a p +  p0 , max (q, q 0 )-succinct linear progression.  Now, on the grounds of the recursive definition of Ps,r,n , for  every pair of states s, r and every integer n, we can write  [  X  Ps,r,n =  ki,j Ii,j  The above equations lead to a straightforward procedure  RLAPositions(M, s, r, n) that computes (a progressionbased representation of) the set Ps,r,n for the automaton M .  1Ã¢Â‰Â¤iÃ¢Â‰Â¤m 1Ã¢Â‰Â¤jÃ¢Â‰Â¤ni  RLAPositions(M, s, r, n)  1: let M = (SÃÅ , SÃÄ¾ , ÃÅ, Ã¢Â„Åš, ÃÂ´, ÃÅ‚, s0 , c0 )  2: if n < 0 then  3:  return Ã¢Âˆ  for some integers m, n1 , ..., nm and then denote by pr,n (respectively, qr,n ) a suitable upper bound for m (respectively,  for n1 , ..., nm ). Clearly, Ps,r,n is a pr,n , qr,n -succinct linear  progression, where pr,n and qr,n may depend on r and n,  9  but not on s. Moreover, by exploiting the compositionality  of succinct linear progressions, we can assume that pr,n and  qr,n satisfy the following recursive equations:  Moreover, the values defining each term of P of the form  k Ã‚Ë‡I can be represented using polynomial space with respect  to the size of the automaton (here the size of the automaton  comprises the number of the control states and the size of  the initial valuation for the counters).  This basically means that the size of P is polynomially  bounded by the size of the automaton. It also follows that  RLAPositions(M, s, s0 , n) takes polynomial time with respect to the size of the input.  Ã¢Â€Ë˜ pr,n = 0, if n < 0;  Ã¢Â€Ë˜ pr,n = 1, if n Ã¢Â‰Ä½ 0, r Ã¢ÂˆÂˆ SÃÅ , and ÃÂ´(r) is undefined;  Ã¢Â€Ë˜ pr,n = 1 + pÃÂ´(r),nÃ¢ÂˆÂ’1 , if n Ã¢Â‰Ä½ 0, r Ã¢ÂˆÂˆ SÃÅ , and ÃÂ´(r) is  defined;  Ã¢Â€Ë˜ pr,n = pÃÅ‚(r),mÃ¢ÂˆÂ’1 , if n Ã¢Â‰Ä½ 0, r Ã¢ÂˆÂˆ SÃÄ¾ , m is the ÃÅ‚-degree  of r, and ÃÂ´(r) is undefined;  We conclude the section by showing how to reduce the  non-equivalence problem for RLA to the satisfiability problem for linear diophantine equations.  Ã¢Â€Ë˜ pr,n = pÃÅ‚(r),mÃ¢ÂˆÂ’1 + pÃÂ´(r),nÃ¢ÂˆÂ’1 , if n Ã¢Â‰Ä½ 0, r Ã¢ÂˆÂˆ SÃÄ¾ , m is  the ÃÅ‚-degree of r, and ÃÂ´(r) is defined;  Theorem 4. Two RLA M = (SÃÅ , SÃÄ¾ , ÃÅ, Ã¢Â„Åš, ÃÂ´, ÃÅ‚, s0 , c0 ) and  0  N = (SÃÅ  , SÃÄ¾0 , ÃÅ, Ã¢Â„Åš0 , ÃÂ´ 0 , ÃÅ‚ 0 , s00 , c00 ) recognize two different  0  words iff there exist a state s Ã¢ÂˆÂˆ SÃÅ and a state s0 Ã¢ÂˆÂˆ SÃÅ  ,  0 0  with Ã¢Â„Åš(s) 6= Ã¢Â„Åš (s ), such that  Ã¢Â€Ë˜ qr,n = 0, if n < 0;  hal-00878435, version 1 - 30 Oct 2013  Ã¢Â€Ë˜ qr,n = 1, if n Ã¢Â‰Ä½ 0, r Ã¢ÂˆÂˆ SÃÅ , and ÃÂ´(r) is undefined;  Ã¢Â€Ë˜ qr,n = 1 + qÃÂ´(r),nÃ¢ÂˆÂ’1 , if n Ã¢Â‰Ä½ 0, r Ã¢ÂˆÂˆ SÃÅ , and ÃÂ´(r) is  defined;  Ps Ã¢ÂˆÅ  Qs0 6= Ã¢ÂˆÂ…,  Ã¢Â€Ë˜ qr,n = 1 + qÃÅ‚(r),mÃ¢ÂˆÂ’1 , if n Ã¢Â‰Ä½ 0, r Ã¢ÂˆÂˆ SÃÄ¾ , m is the  ÃÅ‚-degree of r, and ÃÂ´(r) is undefined;  where Ps (respectively, Qs0 ) is the set of positions of all the  occurrences of s (respectively, s0 ) in the labeled run of M  (resp. N ).  Ã¢Â€Ë˜ qr,n = 1 + max (qÃÂ´(r),nÃ¢ÂˆÂ’1 , qÃÅ‚(r),mÃ¢ÂˆÂ’1 ), if n Ã¢Â‰Ä½ 0, r Ã¢ÂˆÂˆ  SÃÄ¾ , m is the ÃÅ‚-degree of r, and ÃÂ´(r) is defined.  Proof. If M and N recognize two different words, say w  and w0 , we let i be the first position such that w[i] 6= w0 [i].  We then define s = sÃÅ [i] and s0 = s0ÃÅ . Clearly, Ã¢Â„Åš(s) 6=  Ã¢Â„Åš(s0 ) holds and i belongs to both Ps and Qs0 . Conversely,  if M and N recognize the same word w, then w = Ã¢Â„Åš(sÃÅ ) =  Ã¢Â„Åš0 (s0ÃÅ ), where sÃÅ (respectively, s0ÃÅ ) is the labeled run of M  (respectively, N ). This implies that, for every s Ã¢ÂˆÂˆ SÃÅ and  0  , with Ã¢Â„Åš(s) 6= Ã¢Â„Åš0 (s0 ), Ps Ã¢ÂˆÅ  Qs0 = Ã¢ÂˆÂ… holds.  s0 Ã¢ÂˆÂˆ SÃÅ  Finally, by exploiting double induction on r and n, it is easy  to verify that  (  )  0  i    t  =  ÃÂ´  (r),  0  Ã¢Â‰Â¤  i  Ã¢Â‰Â¤  n,  2  t, t0 :  pr,n Ã¢Â‰Â¤  Ã¢Â‰Â¤ |S|  t = t0 Ã¢ÂˆÂˆ SÃÅ Ã¢ÂˆÂ¨ (t, t0 ) Ã¢ÂˆÂˆ ÃÂ“Ã¢ÂˆÂ—M  2  qr,n = CM  r,n Ã¢Â‰Â¤ |S| .  Let P and Q be two linear progressions. If we write  [    P =  ki,1 Ii,1 + ... + ki,ni Ii,ni ,  Consider now the generic case of an RLA whose labeling  function Ã¢Â„Åš is not necessarily the identity function.  1Ã¢Â‰Â¤iÃ¢Â‰Â¤m  Q=  Proposition 3. For every RLA M = (SÃÅ , SÃÄ¾ , ÃÅ, Ã¢Â„Åš, ÃÂ´, ÃÅ‚, s0 ,  c0 ) and every labeled state s Ã¢ÂˆÂˆ SÃÅ , the set of positions of  2  2  all the occurrences of s in sÃÅ is a |S| , |S| -succinct linear  progression.  [    hi,1 Ji,1 + ... + hi,n0i Ji,n0i ,  1Ã¢Â‰Â¤iÃ¢Â‰Â¤m0  then we have  P Ã¢ÂˆÅ  Q 6= Ã¢Âˆ  Proof. Given an RLA M = (SÃÅ , SÃÄ¾ , ÃÅ, Ã¢Â„Åš, ÃÂ´, ÃÅ‚, s0 , c0 ), we  define a new RLA M 0 = (SÃÅ , SÃÄ¾ , SÃÅ , Ã¢Â„Åš0 , ÃÂ´, ÃÅ‚, s0 , c0 ),  where Ã¢Â„Åš0 (s) = s for every s Ã¢ÂˆÂˆ SÃÅ . Clearly, the labeled  run of M coincides with the labeled run of M 0 . Therefore,  the claim trivially follows from Lemma 2.  iff, for some 1 Ã¢Â‰Â¤ i Ã¢Â‰Â¤ m and 1 Ã¢Â‰Â¤ i0 Ã¢Â‰Â¤ m0 , the following linear diophantine equation with bounds on variables is  satisfiable:  ÄÅÄ…  ÄÅÂ´  ÄÅË›ki,1 xi,1 + ... + ki,ni xi,ni = hi0 ,1 yi0 ,1 + ... + hi0 ,ni yi0 ,n0i0  Ã¢ÂˆÂ€ 1 Ã¢Â‰Â¤ j Ã¢Â‰Â¤ ni . min(Ii,j ) Ã¢Â‰Â¤ xi,j Ã¢Â‰Â¤ max (Ii,j )  ÄÅÂ´  ÄÅÅ‚  Ã¢ÂˆÂ€ 1 Ã¢Â‰Â¤ j Ã¢Â‰Â¤ n0i0 . min(Ji0 ,j ) Ã¢Â‰Â¤ yi0 ,j Ã¢Â‰Â¤ max (Ji0 ,j )  As a consequence of Proposition 3, we have that the set  of positions of all the occurrences of a labeled state in the  labeled run of an RLA can be effectively represented by a  succinct linear progression P , where the number of its terms  (i.e., sets of the form k Ã‚Ë‡ I) is polynomially bounded by the  number of control states of the automaton.  Checking the satisfiability of a generic linear diophantine equation with bounds on variables is known to be an  NP-complete problem. As a matter of fact, as regards the  NP-hardness, one can reduce the well-known subset sum  10  hal-00878435, version 1 - 30 Oct 2013  problem (i.e., given a finite set Z of integers, decide whether  there exists a subset Z 0 of Z that exactly sums to 0) to  the satisfiability problem for linear diophantine equations.  More precisely, given a finite set Z = {k1 , ..., kn } of integers, we define the linear diophantine equation k1 z1 + ... +  kn zn = 0, where each variable zi can be either 0 or 1. It  clearly follows that the equation is satisfiable iff Z is a positive instance of the subset sum problem.  Even though the satisfiability problem for linear diophantine equations with bounds on variables is NPcomplete, several efficient algorithms, based on non-trivial  properties of rings and lattices, have been proposed in the  literature, e.g., [1]. These algorithms can solve (systems of)  linear diophantine equations with thousands of variables in  a reasonable time and thus they can be effectively exploited  to test the emptiness of sets resulting from the intersection  of two linear progressions.  Then, we focused our attention on equivalence problems  for automaton-based specifications of time granularities,  proving that (i) the equivalence problem for single-string  automata is decidable in linear time, (ii) the equivalence  problem for reducible extended single-string automata is  decidable in polynomial space and it is complete for such  a class (this result is due to Demri [10]), and (iii) the (non)equivalence problem for restricted labeled single-string automata is decidable in non-deterministic polynomial time.  As for the non-equivalence problem for restricted labeled single-string automata, we exactly showed that it can  be reduced to the satisfiability problem for linear diophantine equations with bounds on variables. This latter problem is known to be NP-complete, which immediately provides an upper bound to the complexity of the original problem. However, it remains an open question to establish  whether such an upper bound is optimal or not, that is, to  establish whether the equivalence problem for restricted labeled single-string automata is co-NP-complete or not. It  is conceivable that the equivalence problem for restricted  labeled single-string automata may enjoy a deterministic  polynomial-time solution, as happens, for instance, for a  number of different problems over restricted labeled singlestring automata, e.g., granule conversion problems and optimization problems [8, 9].  The following (non-deterministic) algorithm solves the  non-equivalence problem for RLA (namely, it has a computation that returns true iff the two input automata were not  equivalent) by reducing it to the satisfiability problem for  linear diophantine equations.  RLANonEquivalence(M, N )  1: let M = (SÃÅ , SÃÄ¾ , ÃÅ, Ã¢Â„Åš, ÃÂ´, ÃÅ‚, s0 , c0 )  0  , SÃÄ¾0 , ÃÅ, Ã¢Â„Åš0 , ÃÂ´ 0 , ÃÅ‚ 0 , s00 , c00 )  2: let N = (SÃÅ  3: n Ã¢Â†Â ÃÂ´-degree(s0 )  4: for all s Ã¢ÂˆÂˆ SÃÅ do  5:  P [s] Ã¢Â†Â RLAPositions(M, s, s0 , n)  6: end for  7: n0 Ã¢Â†Â ÃÂ´-degree(s00 )  0  do  8: for all s0 Ã¢ÂˆÂˆ SÃÅ  9:  Q[s0 ] Ã¢Â†Â RLAPositions(N, s0 , s00 , n0 )  10: end for  0  11: choose s Ã¢ÂˆÂˆ SÃÅ , s0 Ã¢ÂˆÂˆ SÃÅ  with Ã¢Â„Åš(s) 6= Ã¢Â„Åš0 (s0 )  0  12: if P [s] Ã¢ÂˆÅ  Q[s ] 6= Ã¢ÂˆÂ… then  13:  return true  14: else  15:  return false  16: end if  Acknowledgements  We would like to thank the anonymous referees for their  useful remarks and constructive criticisms.  References  [1] K. Aardal, C. A. Hurkens, and A. Lenstra. Solving a system of linear diophantine equations with lower and upper  bounds on the variables. Mathematics of Operations Research, 25(3):427Ã¢Â€Â“442, 2000.  [2] R. Alur and D. Dill. A theory of timed automata. Theoretical  Computer Science, 126:183Ã¢Â€Â“235, 1994.  [3] C. Bettini, S. Jajodia, and X. Wang. Time Granularities in Databases, Data Mining, and Temporal Reasoning.  Springer, July 2000.  [4] D. Bresolin, A. Montanari, and G. Puppis. Time granularities and ultimately periodic automata. In Proceedings of the  9th European Conference on Logics in Artificial Intelligence  (JELIA), volume 3229 of LNCS, pages 513Ã¢Â€Â“525. Springer,  2004.  [5] C. Combi, M. Franceschet, and A. Peron. Representing and  reasoning about temporal granularities. Journal of Logic and  Computation, 14:51Ã¢Â€Â“77, 2004.  [6] H. Comon and V. Cortier. Flatness is not a weakness. In  Proceedings of the 14th International Conference on Computer Science Logic (CSL), volume 1862 of LNCS, pages  262Ã¢Â€Â“276. Springer, 2000.  6. Conclusions  In this paper, we considered the problem of modeling  time granularities and that of testing the equivalence of their  specifications. We first showed how to finitely represent ultimately periodic time granularities in terms of automata,  starting from the most basic notion of automaton (singlestring automaton) and then extending it with counters in order to compactly encode repetitions (extended single-string  automaton and restricted labeled single-string automaton).  11  hal-00878435, version 1 - 30 Oct 2013  [7] U. Dal Lago and A. Montanari. Calendars, time granularities, and automata. In Proceedings of the 7th International  Symposium on Spatial and Temporal Databases (SSTD),  volume 2121 of LNCS, pages 279Ã¢Â€Â“298. Springer, 2001.  [8] U. Dal Lago, A. Montanari, and G. Puppis. Towards compact and tractable automaton-based representations of time  granularity. In Proceedings of the 8th Italian Conference  on Theoretical Computer Science (ICTCS), volume 2841 of  LNCS, pages 72Ã¢Â€Â“85. Springer, 2003.  [9] U. Dal Lago, A. Montanari, and G. Puppis. Compact and  tractable automaton-based representations for time granularities. Theoretical Computer Science, 373(1-2):115Ã¢Â€Â“141,  2007.  [10] S. Demri. LTL over integer periodicity constraints. In  I. Walukiewicz, editor, Proceedings of the 7th International  Conference on Foundations of Software Science and Computation Structures (FOSSACS), volume 2987 of LNCS, pages  121Ã¢Â€Â“135. Springer, 2004.  [11] J. Euzenat and A. Montanari. Time granularity. In M. Fisher,  D. Gabbay, and L. Vila, editors, Handbook of Temporal  Reasoning in Artificial Intelligence, pages 59Ã¢Â€Â“118. Elsevier,  2005.  [12] S. Ginsburg and E. Spanier. Semigroups, Presburger formulas and languages. Pacific Journal of Mathematics,  16(2):285Ã¢Â€Â“296, 1966.  [13] T. Henzinger and R. Majumdar. A classification of symbolic  transition systems. In Proceedings of the 17th International  Symposium on Theoretical Aspects of Computer Science  (STACS), volume 1770 of LNCS, pages 13Ã¢Â€Â“34. Springer,  2000.  [14] D. Knuth, J. Morris, and V. Pratt. Fast pattern matching in  strings. SIAM Journal on Computing, 6:323Ã¢Â€Â“350, 1977.  [15] B. Leban, D. McDonald, and D. Foster. A representation  for collections of temporal intervals. In Proceedings of the  AAAI National Conference on Artificial Intelligence, volume 1, pages 367Ã¢Â€Â“371. AAAI Press, 1986.  [16] M. Minsky. Computation: Finite and Infinite Machines.  Prentice-Hall, 1967.  [17] M. Niezette and J. Stevenne. An efficient symbolic representation of periodic time. In Proceedings of the International Conference on Information and Knowledge Management (CIKM), pages 161Ã¢Â€Â“168, Baltimore, MD, 1992. ACM  Press.  [18] P. Ning, S. Jajodia, and X. Wang. An algebraic representation of calendars. Annals of Mathematics and Artificial  Intelligence, 36:5Ã¢Â€Â“38, 2002.  [19] D. Perrin and P. Schupp. Automata on integers, recurrence  distinguishability, and the equivalence and decidability of  monadic theories. In Proceedings of the Symposium on  Logic in Computer Science (LICS), pages 301Ã¢Â€Â“304. IEEE  Computer Society, 1986.  [20] J. Wijsen. A string-based model for infinite granularities.  In C. Bettini and A. Montanari, editors, Proceedings of  the AAAI Workshop on Spatial and Temporal Granularities,  pages 9Ã¢Â€Â“16. AAAI Press, 2000.  12 