Data & Knowledge Engineering 44 (2003) 219Ã¢Â€Â“238  www.elsevier.com/locate/datak  Deciding LTL over Mazurkiewicz traces  Benedikt Bollig a, Martin Leucker  b,*,1  a  b  Lehrstuhl fÃ¢Â‚Å¹ur Informatik II, RWTH Aachen, 52074 Aachen, Germany  Department of Computer and Information Science, University of Pennsylvania, Philadelphia PA 19104, USA  Received 10 December 2001; accepted 3 July 2002  Abstract  Linear temporal logic (LTL) has become a well established tool for specifying the dynamic behaviour of  reactive systems with an interleaving semantics, and the automataÃ¢Â€Â“theoretic approach has proven to be a  very useful mechanism for performing automatic veriÄÅ¹Âcation in this setting. Especially alternating automata turned out to be a powerful tool in constructing eÄÅ¹Âƒcient yet simple to understand decision procedures  and directly yield further on-the-ÄÅ¹Â‚y model checking procedures. In this paper, we exhibit a decision procedure for LTL over Mazurkiewicz traces that generalises the classical automataÃ¢Â€Â“theoretic approach to a  LTL interpreted no longer over sequences but certain partial orders. SpeciÄÅ¹Âcally, we construct a (linear)  alternating BÃ¢Â‚Å¹  uchi automaton (ABA) accepting the set of linearisations of traces satisfying the formula at  hand. The salient point of our technique is to apply a notion of independence-rewriting to formulas of the  logic. Furthermore, we show that the class of linear and trace-consistent ABA corresponds exactly to LTL  formulas over Mazurkiewicz traces, lifting a similar result from LÃ¢Â‚Å¹  oding and Thomas formulated in the  framework of LTL over words.   2002 Elsevier Science B.V. All rights reserved.  Keywords: LTL; Model checking; Mazurkiewicz traces; Alternating automata  *  Corresponding author.  E-mail addresses: bollig@informatik.rwth-aachen.de (B. Bollig), leucker@cis.upenn.edu (M. Leucker).  1  Part of this work was done during the second authorÃ¢Â€Â™s stay at BRICS and RWTH Aachen. He is grateful for the  hospitality and the overall support.  0169-023X/03/$ - see front matter  2002 Elsevier Science B.V. All rights reserved.  PII: S 0 1 6 9 - 0 2 3 X ( 0 2 ) 0 0 1 3 6 - 2  220  B. Bollig, M. Leucker / Data & Knowledge Engineering 44 (2003) 219Ã¢Â€Â“238  1. Introduction  Linear time temporal logic (LTL) as proposed by Pnueli [17] has become a well established tool  for specifying the dynamic behaviour of distributed systems. The traditional approach towards  automatic program veriÄÅ¹Âcation is model checking speciÄÅ¹Âcations in LTL. A basic feature of LTL  has been that its formulas are interpreted over sequences. Typically, such a sequence will model a  computation of a system: a sequence of states visited by the system or a sequence of actions  executed by the system during the course of the computation.  The automataÃ¢Â€Â“theoretic approach of Vardi and Wolper [22] for satisÄÅ¹Âability checking has  proven to be very useful and eÄÅ¹Âƒcient for performing the automatic program veriÄÅ¹Âcation. In its  purest form, this amounts to the construction of a BÃ¢Â‚Å¹  uchi automaton accepting precisely the set of  sequences that satisÄÅ¹Âes the speciÄÅ¹Âcation expressed as an assertion of LTL. In the last years, a shift  towards the employment of alternating automata for deÄÅ¹Âning decision procedures took place.  Alternating automata provide simple, eÄÅ¹Âƒcient, and easy to understand decision procedures. They  have proven to be useful for deÄÅ¹Âning satisÄÅ¹Âability algorithms for LTL over words [23], branching  time logics [2,12] over ÄÅ¹Ânite transition systems, and the l-calculus over (inÄÅ¹Ânite) preÄÅ¹Âx-recognisable graphs [11]. The idea is that the states of the automaton are constructed essentially from the  subformula closure of the speciÄÅ¹Âcation formula, and the automaton operates in a tableau-like  fashion. The satisÄÅ¹Âability problem is then solved by checking whether the constructed automaton  accepts any strings.  This approach forms the conceptual basis of many veriÄÅ¹Âcation algorithms. Several tools (e.g.,  SPIN [8]) being employed in industry are built upon this translation from formulas to automata.  To improve performance, however, a number of substantial optimisations must be incorporated.  One observation is that the state space of the product automaton needs seldomly to be fully  constructed. Often the answer to the veriÄÅ¹Âcation problem can be established by investigating only  a subset of states, and this subset might be considerably smaller than the entire state space. This is  the main idea underlying the so-called on-the-ÄÅ¹Â‚y veriÄÅ¹Âcation techniques. To support on-the-ÄÅ¹Â‚y  checking, an automaton corresponding to a formula should be deÄÅ¹Âned in a topÃ¢Â€Â“down manner.  This means that, given a formula u and one of its subformulas w, a part of the automaton Au  should be constructible without constructing Aw , where Ag denotes the automaton accepting the  models of g. In this way, the automaton for a given formula and an underlying transition system  may only be constructed partly viz if the model-checking or satisÄÅ¹Âability question can already be  answered by considering this part.  In many applications, the computations of a distributed system will constitute interleavings of the occurrences of causally independent actions. Consequently, the computations can  be naturally grouped together into equivalence classes where two computations are equated  in case they are two diÄÅ¹Â€erent interleavings of the same partially ordered stretch of behaviour. It  turns out that many of the properties expressed as LTL-formulas happen to have the so called  Ã¢Â€Â˜Ã¢Â€Â˜all-or-noneÃ¢Â€Â™Ã¢Â€Â™ property. Either all members of an equivalence class of computations will have  the desired property or none will do (Ã¢Â€Â˜Ã¢Â€Â˜leads to deadlockÃ¢Â€Â™Ã¢Â€Â™ is one such property). For verifying such properties, one has to check them for just one member of each equivalence class. This  is the insight underlying many of the partial-order based veriÄÅ¹Âcation methods (e.g., [16,21]).  As may be guessed, the importance of these methods lies in the fact that via these methods  B. Bollig, M. Leucker / Data & Knowledge Engineering 44 (2003) 219Ã¢Â€Â“238  221  the computational resources required for the veriÄÅ¹Âcation task can often be dramatically reduced.  Often, the equivalence classes of computations generated by a distributed system constitute objects called Mazurkiewicz traces [4,15]. They can be canonically represented as restricted  labelled partial orders. This opens up an alternative way of exploiting the non-sequential  nature of the computations of a distributed system and the attendant partial-order based  methods. It consists of developing LTLs that can be interpreted directly over Mazurkiewicz  traces. In these logics, every speciÄÅ¹Âcation is guaranteed to have the Ã¢Â€Â˜Ã¢Â€Â˜all-or-noneÃ¢Â€Â™Ã¢Â€Â™ property and  hence can be subjected to the partial-order based reduction methods during the veriÄÅ¹Âcation  process.  A number of LTLs to be interpreted over Mazurkiewicz traces directly (e.g., [1,19,20]) has been  proposed starting with TrPTL [19]. There are several possible routes towards extending LTLs to  traces. TrPTL is based on locations, where one reasons explicitly about a distribution of computing agents cooperating through some communication structure given as an alphabet distribution. Another option [1] is to view events as the partial-order computation points in time, and  base the speciÄÅ¹Âcations upon the relationship between individual events. Together, these paradigms  constitute the local trace logics. In contrast, in the global view of computations, conÄÅ¹Âgurations are  seen as instantaneous snapshots of the system at hand. In this sense, a conÄÅ¹Âguration is a global  view capturing a collection of simultaneous local views.  The Ã¢Â€Â˜Ã¢Â€Â˜rightÃ¢Â€Â™Ã¢Â€Â™ temporal logic for traces should be equal in expressive power to ÄÅ¹Ârst-order logic for  traces (FO). It follows from [5] that such a logic would capture exactly those properties of LTL  that have the Ã¢Â€Â˜Ã¢Â€Â˜all-or-noneÃ¢Â€Â™Ã¢Â€Â™ property and hence are amenable to partial-order veriÄÅ¹Âcation.  However, none of the local logics are known to be expressively equivalent to FO. This led Thiagarajan and Walukiewicz to deÄÅ¹Âne the conÄÅ¹Âguration based LTrL [20], which they indeed prove  equivalent to FO. LTrL was later reÄÅ¹Âned [3] to a straightforward formulation of LTL for traces  essentially extending KampÃ¢Â€Â™s Theorem [10] to the setting of traces.  While both the event based and location based logics have elegant (exponential-time) decision  procedures smoothly extending the classical automataÃ¢Â€Â“theoretic approach to the setting of traces,  no such smooth extension exists for global logics such as LTL. The essence of this anomaly is the  complications that arise as a consequence of the fact that the satisÄÅ¹Âability problem for LTL has a  non-elementary lower bound [24]. However, experience [9] has shown that decision procedures  can still be useful in practice despite discouraging lower bounds.  Gastin et al [6,7] do give a direct decision procedure for LTL based on automata. However, the  construction of the automaton corresponding to a given LTL-speciÄÅ¹Âcation u proceeds by induction on u, thus in a bottomÃ¢Â€Â“up manner. Hence it is not an extension of the classical automataÃ¢Â€Â“  theoretic approach, and more important, it requires the construction of the full automaton, so  optimisations such as on-the-ÄÅ¹Â‚y checking cannot be applied. A further drawback is its high  complexity. While an exponential blow-up is unavoidable for nested until-formulas, the procedure  has also an exponential blow-up for every negation. Since nested until-formulas are rare in  speciÄÅ¹Âcations but negations are typical for specifying unwanted behaviour, this limits the practical  applicability of this procedure.  In this paper, we propose a decision procedure for LTL for traces directly extending the classical  approach [23]. Our procedure is based upon an extended subformula closure and independence  222  B. Bollig, M. Leucker / Data & Knowledge Engineering 44 (2003) 219Ã¢Â€Â“238  rewriting of formulas of LTL. We employ this to construct a tableau-style alternating BÃ¢Â‚Å¹  uchi  automaton (ABA) accepting the set of linearisations of traces satisfying the speciÄÅ¹Âcation at hand.  In this sense, our procedure ÄÅ¹Âlls the missing gap for global trace logics by extending the classical  approach to this last remaining case. Our procedure corresponds exactly to the version given in  [23] when restricted to an empty independence relation. Furthermore, our automata can be  constructed on-the-ÄÅ¹Â‚y, which is crucial. Last but not least, for the fragment of LTL without untilformulas, our procedure is exponential.  In [14], it was shown that word languages deÄÅ¹Ânable by LTL-formulas over words correspond to  the languages of linear ABA. We prove that our construction yields a linear BÃ¢Â‚Å¹  uchi automaton as  well. Furthermore, we show that our linear BÃ¢Â‚Å¹  uchi automata accept trace-consistent languages.  Conversely, we show that the class of trace-consistent languages deÄÅ¹Ânable by linear ABA coincides with the class of languages that are deÄÅ¹Ânable by LTL-formulas over Mazurkiewicz traces for  a given dependency relation. In other words, LTL-deÄÅ¹Ânable trace languages correspond to languages deÄÅ¹Ânable by trace-consistent linear ABA.  The results of this paper will also appear in an extended version in [13].  In the next section, we recall Mazurkiewicz traces and some related notions that will play a  crucial r^  ole for our present purposes. In Section 3, we introduce the basic object of our study,  LTL, and interpret it directly over the domain of Mazurkiewicz traces. Following this, we give in  Section 4 a brief account of ABA underlying our decision procedure to be presented in Section 5.  There we supply a proof of correctness of our construction before giving a few concluding remarks in Section 6.  2. Mazurkiewicz traces  A (Mazurkiewicz) trace alphabet is a pair Ä‚Â°R; IÄ‚Â, where R, the alphabet, is a ÄÅ¹Ânite set and  I  R  R is an irreÄÅ¹Â‚exive and symmetric independence relation. Usually, R consists of the actions  performed by a distributed system while I captures a static notion of causal independence between  actions. We deÄÅ¹Âne D Ã‚Åº Ä‚Â°R  RÄ‚Â  I to be the dependency relation, which is then reÄÅ¹Â‚exive and  symmetric.  For the rest of the section, we ÄÅ¹Âx a trace alphabet Ä‚Â°R; IÄ‚Â. We will use aIb to denote that the  actions a and b are independent, i.e., that Ä‚Â°a; bÄ‚Â 2 I, and use similar notation for Ä‚Â°a; bÄ‚Â 2 D. We  extend the notion to sets of actions X , Y  R, and let XIY denote the fact that each pair of actions  a 2 X and b 2 Y is independent. Moreover, XDY will denote that X is dependent on Y, i.e., that  there exists a pair of actions a 2 X and b 2 Y with a and b dependent. For convenience, we will  write fagIY as aIY etc.  For the purpose of interpreting LTL over traces, we will adopt the viewpoint that traces are  restricted labelled partial orders of events and hence have an explicit representation of causality  and concurrency.  Let T Ã‚Åº Ä‚Â°E; 6 ; kÄ‚Â be a R-labelled poset. In other words, Ä‚Â°E; 6 Ä‚Â is a poset and k : E ! R is a  labelling function. k can be extended to subsets of E in the straightforward manner. For e 2 E, we  deÄÅ¹Âne # e Ã‚Åº fx 2 Ejx 6 eg and " e Ã‚Åº fx 2 Eje 6 xg. We let U be the covering relation given by xUy  iÄÅ¹Â€ x < y and for all z 2 E, x 6 z 6 y implies x Ã‚Åº z or z Ã‚Åº y.  B. Bollig, M. Leucker / Data & Knowledge Engineering 44 (2003) 219Ã¢Â€Â“238  223  A (Mazurkiewicz) trace over Ä‚Â°R; IÄ‚Â is a R-labelled poset T Ã‚Åº Ä‚Â°E; 6 ; kÄ‚Â satisfying:  Ã¢Â€Ë˜ # e is a ÄÅ¹Ânite set for each e 2 E.  Ã¢Â€Ë˜ For every e, e0 2 E, eUe0 implies kÄ‚Â°eÄ‚ÂDkÄ‚Â°e0 Ä‚Â.  Ã¢Â€Ë˜ For every e, e0 2 E, kÄ‚Â°eÄ‚ÂDkÄ‚Â°e0 Ä‚Â implies e 6 e0 or e0 6 e.  We shall let TRÄ‚Â°R; IÄ‚Â denote the class of traces over Ä‚Â°R; IÄ‚Â. As usual, a trace language L is a  subset of traces, i.e., L  TRÄ‚Â°R; IÄ‚Â. Throughout the paper we will not distinguish between isomorphic elements in TRÄ‚Â°R; IÄ‚Â. We will refer to members of E as events.  Let T Ã‚Åº Ä‚Â°E; 6 ; kÄ‚Â be a trace over Ä‚Â°R; IÄ‚Â. The ÄÅ¹Ânite preÄÅ¹Âxes of T, to be called conÄÅ¹Âgurations, will  play a crucial r^  ole in  S what follows. A conÄÅ¹Âguration of T is a ÄÅ¹Ânite subset of events c  E with  # c Ã‚Åº c where # c Ã‚Åº e2c # e. The set of conÄÅ¹Âgurations of T will be denoted CT . Trivially, ; 2 CT  for any trace T. CT can be equipped with a natural transition relation !T  CT  R  CT given  a  by: c !T c0 iÄÅ¹Â€ there exists an e 2 E such that kÄ‚Â°eÄ‚Â Ã‚Åº a, e 62 c and c0 Ã‚Åº c [ feg. ConÄÅ¹Âgurations of CT  are the trace-theoretic analogues of ÄÅ¹Ânite preÄÅ¹Âxes of strings. As will become apparent in Section 3,  the formulas of LTL are to be interpreted at conÄÅ¹Âgurations of traces.  In its original formulation [15], Mazurkiewicz introduced traces as certain equivalence classes of  strings, and this correspondence turns out to be essential to our developments here. To bring this  out, let R be the set of ÄÅ¹Ânite strings over R and Rx be the set of (countably) inÄÅ¹Ânite strings  generated by R with x Ã‚Åº f0; 1; 2; . . .g. We set R1 Ã‚Åº R [ Rx and denote the empty word by e. We  let w, w0 range over Rx and u, v with or without primes range over R . Finally, we take prf(w) to be  the set of ÄÅ¹Ânite preÄÅ¹Âxes of w and let alphÄ‚Â°wÄ‚Â denote the set of actions occurring in w.  Next, let T Ã‚Åº Ä‚Â°E; 6 ; kÄ‚Â 2 TRÄ‚Â°R; IÄ‚Â. Then w 2 R1 is a linearisation of T iÄÅ¹Â€ there exists a map q:  prfÄ‚Â°wÄ‚Â ! CT , such that the following conditions are met:  Ã¢Â€Ë˜ qÄ‚Â°eÄ‚Â Ã‚Åº ;.  a  Ã¢Â€Ë˜ qÄ‚Â°vÄ‚Â !T qÄ‚Â°vaÄ‚Â for each va 2 prfÄ‚Â°wÄ‚Â.  Ã¢Â€Ë˜ For every e 2 E, there exists some u 2 prfÄ‚Â°wÄ‚Â such that e 2 qÄ‚Â°uÄ‚Â.  The function q will be called a run map of the linearisation w. Note that the run map of a  linearisation is unique. In what follows, we shall take linÄ‚Â°T Ä‚Â to be the set of linearisations of the  trace T.  A set p  R is called a D-clique iÄÅ¹Â€ p  p  D. The equivalence relation  R1  R1 induced by  I is given by: w  w0 iÄÅ¹Â€ wp Ã‚Åº w0 p for every D-clique p. Here and elsewhere, if X  R, wX is the  sequence obtained by erasing from w all occurrences of letters in R  X . We take Ã‚Ëw to denote  the -equivalence class of w 2 R1 .  It is not hard to show that elements of TRÄ‚Â°R; IÄ‚Â and -equivalence classes are two representations of the same object: A labelled partial-order T 2 TRÄ‚Â°R; IÄ‚Â is represented by linÄ‚Â°T Ä‚Â and vice  versa (see [4] for a proof of this fact and a more thorough account of traces). We exploit this  duality of representation and let Tw denote the trace corresponding to Ã‚Ëw . Moreover, for each  v 2 prfÄ‚Â°wÄ‚Â we will use cv to denote the conÄÅ¹Âguration of CTw given by qÄ‚Â°vÄ‚Â.  To illustrate these concepts, consider the trace alphabet Ä‚Â°R; IÄ‚Â with R Ã‚Åº fa; b; dg and  I Ã‚Åº fÄ‚Â°a; bÄ‚Â; Ä‚Â°b; aÄ‚Âg. An example trace T over Ä‚Â°R; IÄ‚Â is depicted in Fig. 1 with smaller elements (with  respect to 6 ) appearing below larger elements. Furthermore, it can easily be veriÄÅ¹Âed that  224  B. Bollig, M. Leucker / Data & Knowledge Engineering 44 (2003) 219Ã¢Â€Â“238  Fig. 1. A trace over Ä‚Â°R; IÄ‚Â.  abdbabd 2 linÄ‚Â°T Ä‚Â so T Ã‚Åº Tabdbabd , but adabbbd 62 linÄ‚Â°T Ä‚Â. The conÄÅ¹Âguration c 2 CT consists of the  ÄÅ¹Ârst two aÃ¢Â€Â™s, ÄÅ¹Ârst d, ÄÅ¹Ârst two bÃ¢Â€Â™s and is also denoted by cabdab , which is identical to cbadab as  abdab  badab.  We transfer considering traces as equivalence classes to the level of languages and call a  word language L  Rx trace-consistent if for all words w, w0 2 Rx with w  w0 , it holds w 2 L iÄÅ¹Â€  w0 2 L.  3. LTL for Mazurkiewicz traces  In this section, we bring out the syntax and semantics of the linear time temporal logic LTL,  which will be our basic object of study. It was originally introduced for strings by Pnueli [17]. It  was later equipped with a trace semantics [20] and proved expressively equivalent to ÄÅ¹Ârst-order  logic for traces by Diekert and Gastin [3], and this is the version we will consider here.  The formulas of LTL are parameterised by a trace alphabet Ä‚Â°R; IÄ‚Â and are deÄÅ¹Âned inductively as  follows:  LTLÄ‚Â°R; IÄ‚Â ::Ã‚Åº ttj:uju _ wjhaiujuUw;  a 2 R:  Formulas of LTLÄ‚Â°R; IÄ‚Â are interpreted over conÄÅ¹Âgurations of traces over Ä‚Â°R; IÄ‚Â. More precisely,  given a trace T 2 TRÄ‚Â°R; IÄ‚Â, a conÄÅ¹Âguration c 2 CT , and a formula u 2 LTLÄ‚Â°R; IÄ‚Â, the notion of T ,  c  u is deÄÅ¹Âned inductively via:  Ã¢Â€Ë˜  Ã¢Â€Ë˜  Ã¢Â€Ë˜  Ã¢Â€Ë˜  Ã¢Â€Ë˜  T ; c  tt.  T ; c  :u iÄÅ¹Â€ T ; c 2 u.  T ; c  u _ w iÄÅ¹Â€ T ; c  u or T ; c  w.  a  T ; c  haiu iÄÅ¹Â€ there exists a c0 2 CT such that c !T c0 and T ; c0  u.  T ; c  uUw iÄÅ¹Â€ there exists a c0 2 CT with c  c0 such that T ; c0  w and all c00 2 CT with  c  c00  c0 satisfy u.  We will freely use the standard abbreviations such as e.g., ff Ã‚Åº :tt, u ^ w Ã‚Åº :Ä‚Â°:u _ :wÄ‚Â.  Furthermore, we sometimes abbreviate T ,;  u by T  u. All models of a formula u 2 LTLÄ‚Â°R; IÄ‚Â  constitute a subset of TRÄ‚Â°R; IÄ‚Â, thus a language. It is denoted by LÄ‚Â°uÄ‚Â and is called the language  B. Bollig, M. Leucker / Data & Knowledge Engineering 44 (2003) 219Ã¢Â€Â“238  225  deÄÅ¹Âned by u. Furthermore, every formula deÄÅ¹Ânes an x-language viz the set fw 2 linÄ‚Â°T Ä‚ÂjT  ug,  which is also indicated by LÄ‚Â°uÄ‚Â.  A simple example of a formula of LTL is u Ã‚Åº haihbiw. Note that for the trace of Fig. 1 it holds  that T  u if and only if T ,cab  w. Moreover, u is equivalent to u0 Ã‚Åº hbihaiw over this particular  trace alphabet because aIb, i.e., the models of u and u0 and coincide. Such considerations will play  a prominent r^  ole when we deÄÅ¹Âne the decision procedure in Section 5.  For bringing out the decision procedure itself, it will be convenient to assume that the syntax of  LTL is augmented with an indexed until operator UUZ w where Z  R and U Ã‚Åº fuY11 ; . . . ; uYnn g is a  ÄÅ¹Ânite set of indexed formulas with Yi  R. Formally, it will have the following semantics:  Ã¢Â€Ë˜ T ; c  UUZ w iÄÅ¹Â€ there exists a c0 2 CT with c  c0 such that T ; c0  w and kÄ‚Â°c0  cÄ‚ÂIZ, and, for  each 1 6 i 6 n and every c00 with c  c00  c0 and kÄ‚Â°c00  cÄ‚ÂIYi , it holds c00  ui .  Hence, a trace satisÄÅ¹Âes the formula UUZ w in the conÄÅ¹Âguration c iÄÅ¹Â€ there is a future conÄÅ¹Âguration c0 satisfying w and all the actions from c to c0 are independent from the actions in Z.  Furthermore, the conÄÅ¹Âgurations between c and c0 which can be reached from c by performing  actions independent of Yi all satisfy ui .  Note that uUw can be identiÄÅ¹Âed with fu; gU; w and we will not always make this distinction  explicit. It is not hard to see that UUZ w is expressible within FO, so this indexed modality is  derivable within LTL itself.  We remark that, in case of the empty independence relation, LTLÄ‚Â°R; IÄ‚Â and LTL interpreted  over words (denoted by LTLÄ‚Â°RÄ‚Â) coincide in the expected manner. Thus, we identify LTL over  words with LTLÄ‚Â°RÄ‚Â, especially in the proof of Theorem 13, and save the work for introducing  LTL over words formally.  4. Alternating BÃ¢Â‚Å¹  uchi automata  Alternating automata extend non-deterministic automata by universal choices. The transition  function denotes no longer a set of possible next states but a (positive) Boolean combination. In  this section, we recall the notion of alternating automata along the lines of [23] where ABA are  used for model checking LTL over strings. However, we modiÄÅ¹Âed the deÄÅ¹Ânition of a run to reÄÅ¹Â‚ect  the ideas presented in [14].  For a ÄÅ¹Ânite set X of variables, let BÄ‚Å¾ Ä‚Â°X Ä‚Â be the set of positive Boolean formulas over X, i.e., the  smallest set such that  Ã¢Â€Ë˜ X  BÄ‚Å¾ Ä‚Â°X Ä‚Â  Ã¢Â€Ë˜ tt, ff 2 BÄ‚Å¾ Ä‚Â°X Ä‚Â  Ã¢Â€Ë˜ u, w 2 BÄ‚Å¾ Ä‚Â°X Ä‚Â ) u ^ w 2 BÄ‚Å¾ Ä‚Â°X Ä‚Â, u _ w 2 BÄ‚Å¾ Ä‚Â°X Ä‚Â.  In the following, we assume for every positive Boolean formula that it is in disjunctive normal  form and that it is reduced with respect to idempotence and commutation. Hence, for a set X with  jX j  jX j elements, the size of BÄ‚Å¾ Ä‚Â°X Ä‚Â is bounded by 22 . This can easily be seen by considering the  formulas as sets of sets.  226  B. Bollig, M. Leucker / Data & Knowledge Engineering 44 (2003) 219Ã¢Â€Â“238  We say that a set Y  X satisÄÅ¹Âes (or is a model of) a formula u 2 BÄ‚Å¾ Ä‚Â°X Ä‚Â iÄÅ¹Â€ u evaluates to tt  when the variables in Y are assigned to tt and the members of X n Y are assigned to ff. A model is  called minimal if none of its proper subsets is a model. For example, fq1 ; q3 g as well as fq2 ; q3 g are  minimal models of the formula Ä‚Â°q1 _ q2 Ä‚Â ^ q3 .  Later in our construction, logical formulas will take over the r^  ole of states. Therefore, we  should formally distinguish between disjunctions of formulas and disjunctions of states. However,  to simplify our presentation, we identify these disjunctions when the context makes clear which  one is meant. In particular, given a formula u in disjunctive normal form, u Ã‚Åº _ ^ uij where no  uij is a (top level) disjunction or conjunction, we identify u with the positive Boolean combination  of states uij . To avoid confusion, we sometimes write stÄ‚Â°uÄ‚Â to denote fuij j _ ^uij g.  An ABA over an alphabet R is a tuple A Ã‚Åº Ä‚Â°Q; R; d; q0 ; F Ä‚Â such that Q is a ÄÅ¹Ânite non-empty set  of states, q0 2 Q is an initial state, F  Q is a set of accepting states and d : Q  R ! BÄ‚Å¾ Ä‚Â°QÄ‚Â is a  transition function.  Because of universal quantiÄÅ¹Âcation, a run over an inÄÅ¹Ânite string is no longer a sequence but a  labelled directed acyclic graph. A nodeÃ¢Â€Â™s label reÄÅ¹Â‚ects one of the current states of the automaton,  and the edges reÄÅ¹Â‚ect transitions of the automaton with respect to the input string. Hence, this  graph should have a unique Ã¢Â€Â˜Ã¢Â€Â˜rootÃ¢Â€Â™Ã¢Â€Â™ labelled with q0 . Furthermore, it has to be divisible into  Ã¢Â€Â˜Ã¢Â€Â˜levelsÃ¢Â€Â™Ã¢Â€Â™ i 2 N corresponding to the ith input letter. Every node except the root must have a  Ã¢Â€Â˜Ã¢Â€Â˜predecessorÃ¢Â€Â™Ã¢Â€Â™. For a node v, the labels of nodes of level i Ä‚Å¾ 1 connected with v should further be a  model for the transition in state lÄ‚Â°vÄ‚Â reading the ith letter. More precisely:  A run over an inÄÅ¹Ânite string w Ã‚Åº a0 a1 . . . 2 Rx is a Q-labelled directed acyclic graph Ä‚Â°V ; EÄ‚Â such  that there exist labellings l : V ! Q and h : V ! N which satisfy the following properties.  Ã¢Â€Ë˜  Ã¢Â€Ë˜  Ã¢Â€Ë˜  Ã¢Â€Ë˜  Ã¢Â€Ë˜  h1 Ä‚Â°0Ä‚Â  S Ã‚Åº fvg with lÄ‚Â°vÄ‚Â Ã‚Åº q0 .  E  i2N Ä‚Â°h1 Ä‚Â°iÄ‚Â  h1 Ä‚Â°i Ä‚Å¾ 1Ä‚ÂÄ‚Â.  For every v0 2 V with hÄ‚Â°v0 Ä‚Â P 1, fv 2 V jÄ‚Â°v; v0 Ä‚Â 2 Eg 6Ã‚Åº ;.  For every v; v0 2 V , v 6Ã‚Åº v0 , lÄ‚Â°vÄ‚Â Ã‚Åº lÄ‚Â°v0 Ä‚Â implies hÄ‚Â°vÄ‚Â 6Ã‚Åº hÄ‚Â°v0 Ä‚Â.  For every v 2 V , flÄ‚Â°v0 Ä‚ÂjÄ‚Â°v; v0 Ä‚Â 2 Eg is a minimal model of dÄ‚Â°lÄ‚Â°vÄ‚Â; ahÄ‚Â°vÄ‚Â Ä‚Â.  A run Ä‚Â°V ; EÄ‚Â is accepting if every maximal ÄÅ¹Ânite path ends in a node v 2 V with dÄ‚Â°lÄ‚Â°vÄ‚Â; ahÄ‚Â°vÄ‚Â Ä‚Â Ã‚Åº tt  and every maximal inÄÅ¹Ânite path, wrt the labelling l, visits at least one ÄÅ¹Ânal state inÄÅ¹Ânitely often.  The language LÄ‚Â°AÄ‚Â of an automaton A is determined by all strings for which an accepting run of  A exists.  Let us deÄÅ¹Âne a subclass of alternating automata corresponding to LTL formulas over words, as  shown in [14]. The transition graph of an ABA A Ã‚Åº Ä‚Â°Q; R; d; q0 ; F Ä‚Â is the graph Ä‚Â°Q; EÄ‚Â such that  Ä‚Â°q; q0 Ä‚Â 2 E iÄÅ¹Â€ there is an action a such that for dÄ‚Â°q; aÄ‚Â Ã‚Åº _ ^ qij , the state q0 is one of the qij . 2 The  automaton is called linear iÄÅ¹Â€ its transition graph has only trivial cycles.  Finally, we call an ABA A trace-consistent if its language LÄ‚Â°AÄ‚Â is trace-consistent. We will  show that linear trace-consistent automata correspond to LTL formulas over Mazurkiewicz traces.  Obviously, every BÃ¢Â‚Å¹  uchi automaton can be turned into an equivalent (wrt the accepted language) ABA. Vice versa, for every ABA, an equivalent BÃ¢Â‚Å¹  uchi automaton can be constructed with  2  Silently considering tt and ff as states here.  B. Bollig, M. Leucker / Data & Knowledge Engineering 44 (2003) 219Ã¢Â€Â“238  227  an exponential blow-up. The construction is described for example in [23]. Hence, it is easy to see  that the emptiness problem for ABAs is exponential in its number of states.  5. A decision procedure for LTL  We have now set the scene to bring out our decision procedure for LTL. Our procedure  generalises the classical approach by constructing an ABA Au accepting the set of linearisations  of traces satisfying a given formula u. The states of this automaton are derived from an extended  subformula closure, which we ÄÅ¹Ârst deÄÅ¹Âne. Following this, we deÄÅ¹Âne a notion of independencerewriting of such formulas, and this will eventually become the transition relation of Au . We pin  down the details of our construction and give a proof of correctness. Then we consider the  complexity of our decision procedure and point out the correspondence between linear traceconsistent alternating automata and LTL over Mazurkiewicz traces.  5.1. The construction  In essence, we will construct an automaton Au that accepts a string w 2 Rx whenever the  corresponding trace Tw satisÄÅ¹Âes u. To appreciate the developments to come, we commence with a  small example. Consider the example formula u Ã‚Åº haihbiw of Section 3. Suppose that w is of the  form abv for some v 2 Rx . It is then not hard to see that Tw , ;  u if and only if Tw ; ca  hbiw.  Consider now instead w0 Ã‚Åº bav. Since the underlying domain is traces, Tw0 might still satisfy u  even though the ÄÅ¹Ârst action is a b and not an a, because aIb. In fact, Tw0 , ;  u exactly when  Tw0 ; cb  haiw. In this sense, the proof obligation at the empty conÄÅ¹Âguration, Ã¢Â€Â˜Ã¢Â€Â˜haihbiwÃ¢Â€Â™Ã¢Â€Â™, has been  transformed by b to the proof obligation Ã¢Â€Â˜Ã¢Â€Â˜haiwÃ¢Â€Â™Ã¢Â€Â™ at cb ; the a-action still has to be witnessed, but  the present b has been matched. (Note by the way that either both or none of w and w0 should be  accepted, because w  w0 and hence Tw Ã‚Åº Tw0 .)  In eÄÅ¹Â€ect, our automaton proceeds in this way by Ã¢Â€Â˜Ã¢Â€Â˜independence-rewritingÃ¢Â€Â™Ã¢Â€Â™ the proof obligations by the actions read. The state space thus consists of all subformulas together with formulas  obtained by transformations as described above. We will call this set the extended closure of u.  DeÄÅ¹Ânition 1. Let g be a formula of LTL. We take ecl(g) to be the least set that satisÄÅ¹Âes the following:  Ã¢Â€Ë˜  Ã¢Â€Ë˜  Ã¢Â€Ë˜  Ã¢Â€Ë˜  g itself is contained in its closure.  For u _ w 2 eclÄ‚Â°gÄ‚Â, it also contains the closure of u and of w.  For haiu 2 eclÄ‚Â°gÄ‚Â, it also contains the closure of u as well as haiu0 for every u0 2 eclÄ‚Â°uÄ‚Â.  For u 2 eclÄ‚Â°gÄ‚Â, it also contains :u 2 eclÄ‚Â°gÄ‚Â. We identify ::u with u. Hence, eclÄ‚Â°gÄ‚Â is closed  under negation.  Ã¢Â€Ë˜ For uUw 2 eclÄ‚Â°gÄ‚Â, the closure contains eclÄ‚Â°uÄ‚Â as well as eclÄ‚Â°wÄ‚Â. Furthermore, for all Z  R, all  w0 2 eclÄ‚Â°wÄ‚Â, and all U  fu0Y ju0 2 eclÄ‚Â°uÄ‚Â; Y  Rg the closure contains UU Z w0 .  Ã¢Â€Ë˜ The closure is closed under positive Boolean combinations, i.e., BÄ‚Å¾ Ä‚Â°eclÄ‚Â°gÄ‚ÂÄ‚Â  eclÄ‚Â°gÄ‚Â.  Intuitively, the extended closure of a formula u contains all formulas which may be obtained by  substituting a subformula w of u by w0 where w0 is a positive Boolean combination of formulas  228  B. Bollig, M. Leucker / Data & Knowledge Engineering 44 (2003) 219Ã¢Â€Â“238  derived from w by applying this rule. This is because our automaton will be deÄÅ¹Âned in the way  that before it is considering a formula u it may consider a subformula w of u, transforming this  into a positive Boolean combination of new formulas w0 . This result is processed in the way that w  is substituted by w0 within u.  We assume that all positive Boolean formulas are in disjunctive normal form and moreover  that they are reduced wrt idempotence and commutation. With these assumptions we can prove  the following crucial result.  Proposition 2. eclÄ‚Â°gÄ‚Â is a finite set for each formula g of LTL.  Proof. The proof proceeds by a standard induction. The claim is obvious for atomic formulas. For  g Ã‚Åº haiu, the extended closure of g contains the extended closure of u and for every element u0 of  eclÄ‚Â°uÄ‚Â also haiu0 . Thus, we get jeclÄ‚Â°uÄ‚Âj ! 2 elements. Since the extended closure contains for every  element also a negated one, we get another factor 2. Now, positive Boolean combination yields  jeclÄ‚Â°uÄ‚Âj!2!2  . For g Ã‚Åº fuY11 ; . . . ; uYnn gUZ w,  a double exponential blow-up. Altogether, we have jeclÄ‚Â°gÄ‚Âj 6 22  it can be veriÄÅ¹Âed that jeclÄ‚Â°gÄ‚Âj is bounded by   P    n  22  2  2  iÃ‚Åº1  Ä‚Â°jeclÄ‚Â°ui Ä‚Âj!2jRj Ä‚Â  jeclÄ‚Â°wÄ‚Âj  !2jRj !22  !2  :  The three factors are upper bounds for the derivatives of f! ! !g, UZ , and w, resp., and the powers  bound their positive Boolean combination.   We will refer to formulas of this set as extended formulas. Furthermore, we will say that a  formula is a diamond-formula in case it is of the form haiu for some extended formula u and some  a 2 R. In a similar vein, we let the until-formulas consist of those of the form UUZ w with U being a  ÄÅ¹Ânite set of extended formulas, w a single extended formula and Z  R.  For extended formulas, we will make use of the important notion of its dual, which is obtained  as usual by applying de MorganÃ¢Â€Â™s laws to push negations inwards as far as possible.  DeÄÅ¹Ânition 3. The dual of an (extended) formula is given inductively as follows:  Ã¢Â€Ë˜  Ã¢Â€Ë˜  Ã¢Â€Ë˜  Ã¢Â€Ë˜  Ã¢Â€Ë˜  Ã¢Â€Ë˜  tt Ã‚Åº ff, ff Ã‚Åº tt.  :u Ã‚Åº u.  u _ w Ã‚Åº u ^ w, u ^ w Ã‚Åº u _ w.  haiu Ã‚Åº :haiu.  uUw Ã‚Åº :Ä‚Â°uUwÄ‚Â.  UUZ w Ã‚Åº :Ä‚Â°UUZ wÄ‚Â.  We are now set to introduce the operator k  k , which will constitute the transition relation of  the alternating automaton. Essentially, kuka is to be thought of as the independence-rewriting of  u by the action a.  It follows from the intuition conveyed earlier that it should be the case that khaiuka is u. Then,  for the case where aIb, khbiuka Ã‚Åº hbiu0 where u0 Ã‚Åº kuka . Of course, whenever aDb and the actions  B. Bollig, M. Leucker / Data & Knowledge Engineering 44 (2003) 219Ã¢Â€Â“238  229  are not identical, then khbiuka must be ff because b cannot be a next action. DeÄÅ¹Ânition 4 formally  captures this intuition.  DeÄÅ¹Ânition 4. For each extended formula u and each action a, the operator kuka yields a formula  of BÄ‚Å¾ Ä‚Â°eclÄ‚Â°uÄ‚ÂÄ‚Â and is deÄÅ¹Âned inductively via:  kttka Ã‚Åº tt:  ku _ wka Ã‚Åº kuka _ kwka :  k:uka Ã‚Åº kuka :  8  <u  khbiuka Ã‚Åº hbikuka  :  ff  if a Ã‚Åº b  if aIb  if aDb; a 6Ã‚Åº b:  Note that since eclÄ‚Â°gÄ‚Â is closed under positive Boolean combination, we have eclÄ‚Â°gÄ‚Â Ã‚Åº  BÄ‚Å¾ Ä‚Â°eclÄ‚Â°gÄ‚ÂÄ‚Â.  We now only need to specify the case of kUUZ wka . This turns out to be inherently more  complex, and before providing the precise deÄÅ¹Ânition, we carefully analyse the semantics of the  indexed until modality in Fig. 2. For this purpose, consider some trace T be given and suppose  c; c0 2 CT such that c  c0 . Furthermore, let c00 be a conÄÅ¹Âguration between c and c0 (Fig. 2(i)).  Suppose, we can augment c by an a-labelled event e to obtain a successor conÄÅ¹Âguration c000 of c,  a  i.e., c!c000 . Then c000  c00  c0 or c000 6 c00 but c000  c0 or c000 6 c0 , as shown in Fig. 2(a)Ã¢Â€Â“(c) resp. In  case (b), it is obvious that kÄ‚Â°c00  cÄ‚ÂIa and for case (c), we have kÄ‚Â°c0  cÄ‚ÂIa (as well as kÄ‚Â°c00  cÄ‚ÂIa).  The situation shown in Fig. 2 can, in other words, be described in the following manner: The  action a is  (a) neither in the future of c00 nor of c0 (case (a)),  (b) in the future of c00 (case (b)), or  (c) in the future of c00 as well as of c0 (case (c)).  Consider a formula uUw, which is to be checked in the conÄÅ¹Âguration c. In case (c), we have to  employ a for verifying w as well as u. Note that for case (c), we get two subcases depending upon  whether c0 Ã‚Åº c or c0 # c. While w is not relevant to the ÄÅ¹Ârst case, u is required to hold in the  Fig. 2. ConÄÅ¹Âguration and actions.  230  B. Bollig, M. Leucker / Data & Knowledge Engineering 44 (2003) 219Ã¢Â€Â“238  conÄÅ¹Âgurations between c and c0 . Note that these conÄÅ¹Âgurations are reached by actions independent of a.  For case (a), we have to employ a for verifying u in conÄÅ¹Âguration c but not for c00 . In case (b),  we have to prove u considering a in the conÄÅ¹Âguration c00 , which might be equal to c as well as  diÄÅ¹Â€erent from c. Note that in the latter case, every event of c00  c is independent of a.  Consequently, we deÄÅ¹Âne the rewriting operator for a formula UUZ w as follows.  DeÄÅ¹Ânition 5 (extends DeÄÅ¹Ânition 4). Let  n  o  W1 Ã‚Åº kwka W2 Ã‚Åº kukYa [fag juY 2 U UZ[fag kwka :  Moreover, we set W0 Ã‚Åº W1 _ W2 . Let  n  o  kUka Ã‚Åº kukaY [fag juY 2 U [ uY juY 2 U; aIY  and  U1 Ã‚Åº ^uY 2U kuka  U2 Ã‚Åº kUka UZ w  and U0 Ã‚Åº U1 ^ U2 . Then we deÄÅ¹Âne  kUUZ wka Ã‚Åº  W0  W0 _ U0  if aDZ;  else aIZ:  Note that W0 captures case (c) in which an action a is employed for verifying w under the assumption that c0 Ã‚Åº c Ä‚Â°W1 Ä‚Â or not (W2 ). U0 covers the idea that a is not in the future of c0 but is  employed for verifying the obligations in U.  It is not hard to verify that k  k is well-deÄÅ¹Âned. However, to show the correctness of our  construction, the following proposition is essential. Suppose that we have given one linearisation  of a trace and one formula and we want to check the formula wrt the trace obtained from the  linearisation. According to the following proposition it is possible to consider the word action by  action and to modify the formula according to the rewriting operator.  Proposition 6. Let g be any formula of LTLÄ‚Â°R; IÄ‚Â. Then for all w 2 Rx and for all v 2 R , a 2 R,  w0 2 Rx with vaw0  w  Tw ; cv  g if and only if Tw ; cva  kgka :  Proof. The proof proceeds by induction on the formula g. We only show the most important cases  as the other cases follow in a similar manner. The cases where g Ã‚Åº tt or g Ã‚Åº ff are trivial.  Suppose g Ã‚Åº u _ w. Then Tw ; cv  u _ w means by deÄÅ¹Ânition that Tw ; cv  u or Tw ; cv  w. By  induction, this is equivalent to Tw ; cva  kuka or Tw ; cva  kwka , which is equivalent to Tw ; cva   ku _ wka by deÄÅ¹Ânition of the rewrite operator.  Suppose g Ã‚Åº :u. By deÄÅ¹Ânition, Tw ; cv  :u iÄÅ¹Â€ not Tw ; cv  u. Induction yields Tw ; cva 2 kuka ,  which means Tw ; cva  :kuka . The dual of a formula is obviously logically equivalent to the negation of the formula so that the previous statement is equivalent to Tw ; cva  kuka .  B. Bollig, M. Leucker / Data & Knowledge Engineering 44 (2003) 219Ã¢Â€Â“238  231  Suppose g Ã‚Åº hbiu. By deÄÅ¹Ânition, Tw ; cv  hbiu if and only if there is a conÄÅ¹Âguration c0 such that  b  cv ! c0 Ã‚Åº cvb and Tw ; c0  u. We consider three diÄÅ¹Â€erent cases:  Ã¢Â€Ë˜ b Ã‚Åº a: then c0 Ã‚Åº cva . Hence Tw ; cva  u.  b  a  Ã¢Â€Ë˜ bÃ‚Åº  6 a, bDa: then cv ! c0 and cv ! cva . However, then w is not a linearisation of the trace, which  is a contradiction.  Ã¢Â€Ë˜ bIa: Tw ; cvb  u is by induction equivalent to Tw ; cvba  kuka . Since aIb, this means Tw ; cvab   kuka , which is equivalent to Tw ; cva  hbikuka .  Putting together all the cases we get that Tw ; cv  hbiu if and only if Tw ; cva  khbiuka .  The most involved case is g Ã‚Åº UUZ w. Let U Ã‚Åº fuY11 ; . . . ; uYNN g. Recall that Tw ; cv   fuY11 ; . . . ; uYNN gUZ w if and only if  9x 2 R ; y 2 Rx ; aw0  xy; xIZ; such that Tw ; cvx  w; and  8i 2 f1; . . . ; N g; 8x1 ; x2 2 R with x1 x2  x; x1 IYi ; x2 6Ã‚Åº e; it holds  Tw ; cvx1  ui :  We consider here only the case where aIÄ‚Â°Yi [ ZÄ‚Â. The other cases follow similarly. Let us ÄÅ¹Ârst  discuss the implication from left to right: we consider the following cases for x:  Ã¢Â€Ë˜ x Ã‚Åº e: then Tw ; cvx  w means Tw ; cv  w, which implies by induction Tw ; cva  kwka . This shows  Ä‚Â°W1 Ä‚Â.  Ã¢Â€Ë˜ x 6Ã‚Åº e, a 62 alphÄ‚Â°xÄ‚Â: We consider the cases for w and ui simultaneously.  )  I:H :  )  )  )  aIx  Tw ; cvx  w  Tw ; cvxa  kwka  Tw ; cvax  kwka  9x 2 R ; xIÄ‚Â°Z [ fagÄ‚Â  Tw ; cvax  kwka  )  I:H :  )  )  )  aIx1  Tw ; cvx1  ui  Tw ; cvx1 a  kui ka  Tw ; cvax1  kui ka  8x1 ; x2 2 R ; x1 x2  x; x1 IÄ‚Â°Yi [ fagÄ‚Â  x2 6Ã‚Åº e; Tw ; cvax1  kui ka  Hence, Tw ; cva  fkukaY [fag juY 2 UgUZ[fag kwka , which shows (W2 ).  Ã¢Â€Ë˜ x 6Ã‚Åº e, a 2 alphÄ‚Â°xÄ‚Â: We easily see that x  ax0 and a, x0 IZ and Tw ; cvax0  w. We will show Ä‚Â°U1 Ä‚Â  and Ä‚Â°U2 Ä‚Â. Let us consider x1 . If x1 Ã‚Åº e then Tw ; cv  ui implies by induction Tw ; cva  kui ka . If  x1 6Ã‚Åº e and a 62 alphÄ‚Â°x1 Ä‚Â, we see that aIx1 and x1 IYi . Hence, x1 IÄ‚Â°Yi [ fagÄ‚Â. Now, Tw ; cvx1  ui  yields by induction Tw ; cvx1 a  kui ka proving Tw ; cvax1  kui ka since aIx1 . For the case x1 6Ã‚Åº e  but a 2 alphÄ‚Â°x1 Ä‚Â, we see that x1  ax01 and Tw ; cvax01  ui . Summing up the cases for x1 , we get  Tw ; cva  kUka UZ w, which shows Ä‚Â°U2 Ä‚Â, and Tw ; cva  kuka for all uY 2 U, which shows Ä‚Â°U1 Ä‚Â.  Altogether, we showed that W0 or U0 hold in the until case proving the Ã¢Â€Â˜Ã¢Â€Â˜ifÃ¢Â€Â™Ã¢Â€Â™-part. Now, let us  consider the implication from right to left: suppose Tw ; cva  kUUZ wka , i.e.,  Tw ; cva  W1 _ W2 _ U0 :  232  B. Bollig, M. Leucker / Data & Knowledge Engineering 44 (2003) 219Ã¢Â€Â“238  We discuss the disjunction by drawing the conclusions of each formula  Ã¢Â€Ë˜ Tw ; cva  kwka : this implies by induction that Tw ; cv  w. Hence, Tw ; cv  UUZ w.  Y [fag  juY 2 UgUZ[fag kwka : Then there exist x; y, xIÄ‚Â°Z [ fagÄ‚Â, w  vaxy such that  Ã¢Â€Ë˜ Tw ; cva  fkuka  Tw ; cvax  kwka . Since xIa also Tw ; cvxa  kwka , which yields by induction Tw ; cvx  w. We further  know that for every proper preÄÅ¹Âx (modulo ) x1 of x with x1 IÄ‚Â°Y [ fagÄ‚Â, we have Tw ; cvax1   kuka . Then Tw ; cvx1 a  kuka and, by induction, Tw ; cvx1  u. Hence, Tw ; cv  UUZ w.  Ã¢Â€Ë˜ Tw ; cva  ^uY 2U kuka ^ kUka UZ w: We ÄÅ¹Ârst obtain by induction that Tw ; cv  u for every uY 2 U.  Let us consider  Tw ; cva  Ä‚Â°fkukYa [fag juY 2 Ug [ fuY juY 2 U; aIY gÄ‚ÂUZ w:  It implies that there is an x0 , independent of Z, such that Tw ; cvax0  w. Since we are in the case of  aIZ, we conclude that there is an x, xIZ(x  ax0 ) such that Tw ; cvx  w. Now, consider x1 x2  x,  x2 6Ã‚Åº e. For every x1 IÄ‚Â°Y [ fagÄ‚Â, x1 a preÄÅ¹Âx of x0 , we know Tw ; cvax1  kuka and, by induction,  Tw ; cvx1  u. For x0 Ã‚Åº e, we already know Tw ; cv  u. For x1 IY and x1 Da, we obtain x1  ax01 , x01 IY ,  since cva is a valid conÄÅ¹Âguration. By Tw ; cvax01  u we deduce Tw ; cvx1  u. Altogether, this shows  Tw ; cv  UUZ w.  This concludes the proof.   We can now ÄÅ¹Ânally bring the deÄÅ¹Ânition of the ABA Au corresponding to a formula u 2  LTLÄ‚Â°R; IÄ‚Â as follows.  DeÄÅ¹Ânition 7. Given a formula u 2 LTLÄ‚Â°R; IÄ‚Â, the ABA Au is the tuple Ä‚Â°Q; R; d; q0 ; F Ä‚Â where  Ã¢Â€Ë˜  Ã¢Â€Ë˜  Ã¢Â€Ë˜  Ã¢Â€Ë˜  Q Ã‚Åº eclÄ‚Â°uÄ‚Â is the set of states.  dÄ‚Â°q; aÄ‚Â Ã‚Åº kqka is the transition function.  q0 Ã‚Åº u is the initial state.  F Ã‚Åº f:wj:w 2 eclÄ‚Â°uÄ‚Âg is the set of accepting states.  Note that we deÄÅ¹Âned the set of ÄÅ¹Ânal states to be all negated formulas. The intuitive idea is that  failing to prove a proposition inÄÅ¹Ânitely often suÄÅ¹Âƒces to assume that its negation is true. In the  work of Vardi [23], one could likewise take all negated formulas as ÄÅ¹Ânal states. Since in the case of  LTL over words, only until-formulas may occur inÄÅ¹Ânitely often, the set of ÄÅ¹Ânal states is there  restricted to negated until-formulas.  The correctness of the construction is summarised in the following theorem, which is the main  contribution of the paper.  Theorem 8. Let u be a formula of LTLÄ‚Â°R; IÄ‚Â and let its ABA be given as Au Ã‚Åº Ä‚Â°Q; R; d; q0 ; F Ä‚Â. Then  w 2 LÄ‚Â°Au Ä‚Â if and only if Tw ; ;  u  for every w 2 Rx . In other words, LÄ‚Â°Au Ä‚Â Ã‚Åº LÄ‚Â°uÄ‚Â.  B. Bollig, M. Leucker / Data & Knowledge Engineering 44 (2003) 219Ã¢Â€Â“238  233  Proof. For w 2 Rx , we have to show that Au has an accepting run on w iÄÅ¹Â€ Tw  u. Note that every  run has (at most) three types of paths:  Ã¢Â€Ë˜ ÄÅ¹Ânite paths ending in tt,  Ã¢Â€Ë˜ inÄÅ¹Ânite paths on which from some point on every node is labelled by an until- or diamondformula, or  Ã¢Â€Ë˜ inÄÅ¹Ânite paths on which from some point on every node is labelled by a negated until- or diamond- formula.  Let us give a sketch of the proof. For w 2 eclÄ‚Â°uÄ‚Â and w Ã‚Åº aw0 2 Rx , let dÄ‚Â°w; wÄ‚Â be the extension  of d deÄÅ¹Âned by dÄ‚Â°w; aw0 Ä‚Â Ã‚Åº dÄ‚Â°dÄ‚Â°w; aÄ‚Â; w0 Ä‚Â. By Proposition 6, dÄ‚Â°u; wÄ‚Â Ã‚Åº dÄ‚Â°dÄ‚Â°u; aÄ‚Â; w0 Ä‚Â Ã‚Åº dÄ‚Â°kuka ; w0 Ä‚Â  and Tw ; c  u iÄÅ¹Â€ Tw ; ca  kuka . Now, consider an accepting run of Au . Its ÄÅ¹Ânite paths end in tt,  thus all proof obligations are proved. Conversely, a run should be accepted only if the ÄÅ¹Ânite paths  end in tt, i.e., that all proof obligations are proved. Now, let us consider the inÄÅ¹Ânite paths of a run.  These can only occur by unwinding a (negated) until-formula inÄÅ¹Ânitely often or by reading actions  independent of the one given within a diamond-formula. This can be accepted iÄÅ¹Â€ the underlying  until-formula or diamond-formula is preceded by a negation. This is captured by the acceptance  condition for inÄÅ¹Ânite paths given by the ÄÅ¹Ânal states of the automaton.   5.2. State space  To simplify the presentation, we have deÄÅ¹Âned the state space of our automaton in a straightforward manner and presented a simple argument to show that it is ÄÅ¹Ânite. Thus, we indeed  obtained a decision procedure. Now, let us take a closer look to the states that are really needed  in our construction. In other words, let us consider the states that are reachable from the initial  state.  Given a formula u 2 LTLÄ‚Â°R; IÄ‚Â, a state w of Au , and a set Y  R, let reachY Ä‚Â°wÄ‚Â denote  the set of states reachable from w in Au by words whose actions are independent of Y. More  precisely,  reachY Ä‚Â°wÄ‚Â Ã‚Åº fw0 j9w 2 R ; wIY : w0 2 stÄ‚Â°dÄ‚Â°w; wÄ‚ÂÄ‚Âg;  where d is the extension of d deÄÅ¹Âned in the obvious manner.  Proposition 9. Given u 2 LTLÄ‚Â°R; IÄ‚Â, we get upper bounds for the number of states reachable from a  state of Au wrt Y inductively as follows:  Ã¢Â€Ë˜  Ã¢Â€Ë˜  Ã¢Â€Ë˜  Ã¢Â€Ë˜  Ã¢Â€Ë˜  jreachY Ä‚Â°ttÄ‚Âj Ã‚Åº 1  jreachY Ä‚Â°ffÄ‚Âj Ã‚Åº 1  jreachY Ä‚Â°:wÄ‚Âj Ã‚Åº jreachY Ä‚Â°wÄ‚Âj  jreachY Ä‚Â°w1 _ w2 Ä‚Âj 6 jreachY Ä‚Â°w1 Ä‚Âj Ä‚Å¾ jreachY Ä‚Â°w2 Ä‚Âj  jreachY Ä‚Â°w1 ^ w2 Ä‚Âj 6 jreachY Ä‚Â°w1 Ä‚Âj Ä‚Å¾ jreachY Ä‚Â°w2 Ä‚Âj  Ã¢Â€Ë˜ jreachY Ä‚Â°haiwÄ‚Âj 6  jreachY Ä‚Â°wÄ‚Âj Ä‚Å¾ jreachY [fag Ä‚Â°wÄ‚Âj Ä‚Å¾ 1  jreachY [fag Ä‚Â°wÄ‚Âj Ä‚Å¾ 1  if aIY  if aDY  234  Ã¢Â€Ë˜  B. Bollig, M. Leucker / Data & Knowledge Engineering 44 (2003) 219Ã¢Â€Â“238  jreachY Ä‚Â°fuY11 ; . . . ; uYnn gUZ wÄ‚Âj 6 22  Pn  iÃ‚Åº1  Ä‚Â°jreachY Ä‚Â°ui Ä‚Âj!2jRj Ä‚Â  ! 2jRj ! 22  jreachY Ä‚Â°wÄ‚Âj  :  Proof. The obvious cases are if the state formula is tt or ÄÅ¹Â€.  Since negation is shifted inwards by the dual operator , the states reachable from :w are the  same states as reachable from w, except that every state is preceded by :. Thus, the cardinality is  the same.  Given haiw, assume a to be independent of Y. Reading an action dependent on but diÄÅ¹Â€erent  from a (and independent of Y) yields the state ÄÅ¹Â€ and in our formula the 1. Reading a yields the  state w, thus, the states reachable from w are obviously reachable from haiw Ä‚Â°jreachY Ä‚Â°wÄ‚ÂjÄ‚Â. The  last possibility is reading an action b independent of a and Y. This yields formulas of the form  haiw0 where w0 is obtained by rewriting w by actions independent of Y and a. Since haiw0 distributes over disjunctions and conjunctions, we get the same number of states as obtained by  considering the states reachable from w by words independent of Y [ fag (jreachY [fag Ä‚Â°wÄ‚Âj).  The bound for until-formulas follows by a simple combinatorial argument. Before and after the  U within an until-formula, only positive Boolean combinations of derivations of respectively U  and w may occur, and the U is indexed with subsets of R.   Let us call the fragment of LTL deÄÅ¹Âned without until-formulas HennessyÃ¢Â€Â“Milner fragment.  Proposition 10. Given a formula w from the HennessyÃ¢Â€Â“Milner fragment of LTLÄ‚Â°R; IÄ‚Â, we obtain  reachY Ä‚Â°wÄ‚Â 6 jwjjRY j .  Proof. The proof follows a simple induction of which we pick out two cases:  Ã¢Â€Ë˜ Applying Proposition 9, the induction hypothesis, and the binomial formula,  jRY j  jreachY Ä‚Â°w1 _ w2 Ä‚Âj 6 jreachY Ä‚Â°w1 Ä‚Âj Ä‚Å¾ jreachY Ä‚Â°w2 Ä‚Âj 6 jw1 j  jRY j  Ä‚Å¾ jw2 j  3  6 Ä‚Â°jw1 j Ä‚Å¾ jw2 j Ä‚Å¾ 1Ä‚Â  jRY j  :  Ã¢Â€Ë˜ Assuming aIY ,  jreachY Ä‚Â°haiwÄ‚Âj 6 jreachY Ä‚Â°wÄ‚Âj Ä‚Å¾ jreachY [fag Ä‚Â°wÄ‚Âj Ä‚Å¾ 1 6 jwjjRY j Ä‚Å¾ jwjjRY j1 Ä‚Å¾ 1  6 Ä‚Â°jwj Ä‚Å¾ 1Ä‚ÂjRY j :    Due to the exponential blow-up the construction of an equivalent BÃ¢Â‚Å¹  uchi automaton for Au  causes, we conclude.  Theorem 11. Checking satisfiability of a formula from the HennessyÃ¢Â€Â“Milner fragment of LTLÄ‚Â°R; IÄ‚Â  can be done in exponential time.  5.3. LTL and linear automata  Now we characterise LTLÄ‚Â°R; IÄ‚Â as equivalent to that subclass of ABA that we called traceconsistent linear ABA, and we start observing the linearity of the above construction.  3  Ä‚Â°a Ä‚Å¾ bÄ‚Ân Ã‚Åº     n ni i  a b.  iÃ‚Åº0  i  Pn  B. Bollig, M. Leucker / Data & Knowledge Engineering 44 (2003) 219Ã¢Â€Â“238  235  Proposition 12. Given u 2 LTLÄ‚Â°R; IÄ‚Â, Au is linear.  Proof. We have to show that the transition function only admits trivial cycles. Therefore we deÄÅ¹Âne  a well-founded strict ordering relation 4 & on the states of our automaton and show that kwka  yields a Boolean combination of strictly smaller states or w.  For a formula g 2 LTLÄ‚Â°R; IÄ‚Â, & eclÄ‚Â°gÄ‚Â  eclÄ‚Â°gÄ‚Â is inductively deÄÅ¹Âned by  Ã¢Â€Ë˜  Ã¢Â€Ë˜  Ã¢Â€Ë˜  Ã¢Â€Ë˜  Ã¢Â€Ë˜  u & haiu,  haiu & haiw if u & w,  u & :w if u & w,  wY11 & wY22 if w1 ' w2 and Y1 ( Y2 and one of the orderings is strict, i.e., w1 & w2 or Y1 )Y2 ,  _ ^ uij & _ ^ wij if fuij g ) fwij g where ) is the (strict) (multi-)set ordering induced by &, i.e.,  M1 ) M2 iÄÅ¹Â€ there exist a set X and an element m 2 M2 with m0 & m for all m0 2 X such that  M1 Ã‚Åº Ä‚Â°M2  fmgÄ‚Â [ X . In other words, a set M1 is smaller than M2 if an element of M2 is replaced by a set of smaller elements resulting in M1 .  Ã¢Â€Ë˜ w0 & UUZ w if w0 & w,  Ã¢Â€Ë˜ _ ^ uij & UUZ w if fuRij g ) U,  Ã¢Â€Ë˜ U1 UZ1 w1 & U2 UZ2 w2 if U1 )U2 and Z1 ( Z2 and w1 ' w2 and one of the orderings is strict, i.e.,  U1 ) U2 or Z1 )Z2 or w1 & w2 , where ) is the reÄÅ¹Â‚exive closure of ),  and contains its transitive closure. Here, ' is the reÄÅ¹Â‚exive closure of &.  We easily verify that, given formulas u, w 2 eclÄ‚Â°gÄ‚Â, an action a 2 R, and a minimal model W of  kwka with u 2 W, it holds u ' w and furthermore that for arbitrary u; w 2 eclÄ‚Â°gÄ‚Â, u &Ä‚Å¾ w implies  u 6Ã‚Åº w. We conclude the linearity of our construction.   Theorem 13. Let A Ã‚Åº Ä‚Â°Q; R; d; q0 ; F Ä‚Â be a trace-consistent linear ABA. There is a formula u 2  LTLÄ‚Â°R; IÄ‚Â such that  Tw ; ;  u if and only if w 2 LÄ‚Â°AÄ‚Â  for every w 2 Rx . In other words, LÄ‚Â°uÄ‚Â Ã‚Åº LÄ‚Â°AÄ‚Â.  Before we are going to prove the previous theorem, let us mention two facts:  Proposition 14. Let A Ã‚Åº Ä‚Â°Q; R; d; q0 ; F Ä‚Â be a linear ABA. There is a formula u 2 LTLÄ‚Â°RÄ‚Â such that  LÄ‚Â°uÄ‚Â Ã‚Åº LÄ‚Â°AÄ‚Â.  Proposition 15. Let L  Rx and I  R  R be an independence relation. Then the following statements are equivalent.  1. L is trace-consistent wrt I and LTLÄ‚Â°RÄ‚Â-definable.  2. fTw jw 2 Lg is FOÄ‚Â°R; IÄ‚Â-definable.  3. fTw jw 2 Lg is LTLÄ‚Â°R; IÄ‚Â-definable.  4  That is, a transitive and acyclic relation.  236  B. Bollig, M. Leucker / Data & Knowledge Engineering 44 (2003) 219Ã¢Â€Â“238  Proposition 14 was independently shown by [18] and [14]. As aforementioned in the introduction, the equivalence of (1) and (2) traces back to [5], that one between (2) and (3) back to [3].  Now, we are ready to prove Theorem 13.  Proof. In accordance with Proposition 14, given a trace-consistent linear ABA A, there is a  formula w 2 LTLÄ‚Â°RÄ‚Â satisfying LÄ‚Â°wÄ‚Â Ã‚Åº LÄ‚Â°AÄ‚Â where LÄ‚Â°wÄ‚Â is likewise trace consistent. Employing the equivalences from Proposition 15, it immediately follows the existence of a formula  u 2 LTLÄ‚Â°R; IÄ‚Â with Tw ; ;  u if and only if w 2 LÄ‚Â°AÄ‚Â for every w 2 Rx .   Let us bring out two important consequences of the last theorem:  1. Given an LTL formula u over Mazurkiewicz traces, it is simple to construct a trace-consistent  LTL formula w over words deÄÅ¹Âning the same set of x-words. Just construct Au , and for Au , a  corresponding formula w according to the proof given in [14].  2. Partial-order reduction techniques work for LTL over Mazurkiewicz traces. Given an LTL formula u over Mazurkiewicz traces, consider its automaton Au . It is a linear trace-consistent  automaton over words. For this kind automata, several powerful partial-order reduction techniques have been developed, which will have the same success here [16]. Hence, specifying with  LTL over Mazurkiewicz traces promisesÃ¢Â€Â“Ã¢Â€Â“despite the bad worst-case runtime of its decision  procedureÃ¢Â€Â“Ã¢Â€Â“eÄÅ¹Âƒcient veriÄÅ¹Âcation tasks in practice.  Note that the ÄÅ¹Ârst item even implies that the languages deÄÅ¹Ânable by LTL-formulas over  Mazurkiewicz traces are FO-deÄÅ¹Ânable over Mazurkiewicz traces. Thus, we obtained one direction  of the expressive completeness proof given in [3].  6. Conclusion  We have exhibited a decision procedure demonstrating that the classical automataÃ¢Â€Â“theoretic  approach can be generalised to conÄÅ¹Âguration based temporal logics for traces such as LTL. In  particular, Theorem 8 asserts that it is possible to directly construct an ABA accepting the set of  linearisations of traces satisfying the formula at hand.  The main idea underlying this construction is to use a notion of independence-rewriting to an  extended subformula closure. It easily follows from [24] that this closure must be of nonelementary size and, moreover, that this is unavoidable for any decision procedure directly generalising the classical automataÃ¢Â€Â“theoretic approach.  Our approach clearly yields an optimal (non-elementary) decision procedure and shares this  similarity with [7]. We are sure that an actual implementation of our approach would compare  favourably due to the fact that the automata need not necessarily be constructed in full and especially because it avoids an exponential blow-up for negation.  We showed that trace-consistent linear automata correspond to LTL over Mazurkiewicz traces  wrt language deÄÅ¹Ânability, transferring a similar result shown in [14] from the setting of words to  the setting of traces. As a consequence, it is quite natural to construct trace-consistent linear  B. Bollig, M. Leucker / Data & Knowledge Engineering 44 (2003) 219Ã¢Â€Â“238  237  automata as a tool to answer the satisÄÅ¹Âability problem, and our approach exactly follows this  idea.  It is easy to adapt our decision procedure for the unary fragment of LTL, where the untilmodality is replaced by an eventually-modality with the obvious semantics. Unfortunately, it  remains an open question whether the decision procedure obtained in this way is optimal.  Acknowledgement  We would like to thank Jesper G. Henriksen for fruitful discussions and valuable comments on  this work.  References  [1] R. Alur, D. Peled, W. Penczek, Model checking of causality properties, in: Proceedings of the 10th Annual IEEE  Symposium on Logic in Computer Science (LICSÃ¢Â€Â™95), IEEE Computer Society Press, San Diego, California, 1995,  pp. 90Ã¢Â€Â“100.  [2] O. Bernholtz, M.Y. Vardi, P. Wolper, An automataÃ¢Â€Â“theoretic approach to branching-time model checking, in:  D.L. dill (Ed. ), Proceedings of the 6th International Conference on Computer-Aided VeriÄÅ¹Âcation (CAVÃ¢Â€Â™94), vol.  818 of Lecture Notes in Computer Science, Springer, 1994, pp. 142Ã¢Â€Â“155.  [3] V. Diekert, P. Gastin, LTL is expressively complete for Mazurkiewicz traces, in: Proceedings of International  Colloquim on Automata, Languages and Programming (ICALPÃ¢Â€Â™2000), vol. 1853 Lecture Notes in Computer  Science, Springer, 2000, pp. 211Ã¢Â€Â“222.  [4] V. Diekert, G. Rozenberg (Eds. ), The Book of Traces, World ScientiÄÅ¹Âc, Singapore, 1995.  [5] W. Ebinger, A. Muscholl, Logical deÄÅ¹Ânability on inÄÅ¹Ânite traces, Theor. Comput. Sci. 154 (1) (1996) 67Ã¢Â€Â“84.  [6] P. Gastin, R. Meyer, A. Petit, A (non-elementary) modular decision procedure for LTrL, in: MFCS: Symposium  on Mathematical Foundations of Computer Science, Lecture Notes in Computer Science, vol. 1450, 1998.  [7] P. Gastin, R. Meyer, A. Petit. A (non-elementary) modular decision procedure for LTrL. Technical report, LSV,  ENS de Cachan, 1998, extended version of MFCSÃ¢Â€Â™98.  [8] J.-C. Gregoire, G.J. Holzmann, D.A. Peled, (Eds. ), The Spin VeriÄÅ¹Âcation System, vol. 32 of DIMACS series,  American Mathematical Society, 1997, ISBN 0-8218-0680-7, p. 203.  [9] J.G. Henriksen, J.L. Jensen, M.E. JÄ‚Â¸rgensen, N. Klarlund, R. Paige, T. Rauhe, A. Sandholm, Mona: Monadic  second-order logic in practice, in: E. Brinksma, R. Cleaveland, K.G. Larsen, T. Margaria, B. SteÄÅ¹Â€an (Eds. ), Tools  and Algorithms for the Construction and Analysis of Systems, vol. 1019 of Lecture Notes in Computer Science,  Springer, 1995, pp. 89Ã¢Â€Â“110.  [10] H.W. Kamp. Tense Logic and the Theory of Linear Order, Ph.D. thesis, University of California, Los Angeles,  1968.  [11] O. Kupferman, M.Y. Vardi, An automataÃ¢Â€Â“theoretic approach to reasonings about inÄÅ¹Ânite-state systems, in: E.A.  Emerson, A.P. Sistla (Eds. ), Proceedings of the 12th International Conference on Computer-Aided VeriÄÅ¹Âcation  (CAVÃ¢Â€Â™00), vol. 1855 of Lecture Notes in Computer Science, Springer, 2000.  [12] O. Kupferman, M.Y. Vardi, P. Wolfer, An automataÃ¢Â€Â“theoretic approach to branching-time model checking,  J. ACM 47 (2) (2000) 312Ã¢Â€Â“360.  [13] M. Leucker, Logics for Mazurkiewicz traces. Ph.D. thesis, Lehrstuhl fÃ¢Â‚Å¹  ur Informatik II, RWTH Aachen, 2002. Also  appeared as Technical Report 2002-10, RWTH Aachen.  [14] C. LÃ¢Â‚Å¹  oding, W. Thomas, Altering automata and logics over inÄÅ¹Ânte words, in: Proceedings of the IFIP International  Conference on Theoretical Computer Science, IFIP TCS2000, vol. 1872 of Lecture Notes in Computer Science,  Springer, 2000, pp. 521Ã¢Â€Â“535.  [15] A. Mazurkiewicz, Concurrent program schemes and their interpretations, DAIMI Rep. PB 78, Aarhus, 1977.  238  B. Bollig, M. Leucker / Data & Knowledge Engineering 44 (2003) 219Ã¢Â€Â“238  [16] D. Peled, Ten years of partial order reduction, in: Proceedings of 10th International Conference on ComputerAideds VeriÄÅ¹Âcation (CAVÃ¢Â€Â™98), vol. 1427 of Lecture Notes in Computer Science, Springer, Vancouver, BC, Canada,  1998, pp. 17Ã¢Â€Â“28.  [17] A. Pneuli, The temporal logic of programs, in: Proceedings of the 18th IEEE Symposium on the Foundations of  Computer Science (FOCS-77), Providence, Rhode Island, October 31Ã¢Â€Â“November 2, 1977, IEEE Computer Society  Press.  [18] S. Rohde, Alternating automata and the temporal logic of ordinals, Ph.D. thesis, University of Illinois at UrbanaChampaign, 1997.  [19] P.S. Thiagarajan, A trace based extension of linear time temporal logic, in: Proceedings of the Ninth Annual IEEE  Symposium on Logic in Computer Science, Paris, France, 4Ã¢Â€Â“7 July, IEEE Computer Society Press, 1994, pp. 438Ã¢Â€Â“  447.  [20] P.S. Thiagarajan, I. Walukiewicz, An expressively complete linear time temporal logic for Mazurkiewicz traces. in:  Proceedings, Twelth Annual IEEE Symposium on Logic in Computer Science, Warsaw, Poland, 29 JuneÃ¢Â€Â“2 July,  IEEE Computer Society Press, 1997, pp. 183Ã¢Â€Â“194.  [21] A. Valmari, A stubborn attack on state explosion, in: E.M. Clarke, R.P. Kurshan (Eds. ), Proceedings of  Computer-Aided VeriÄÅ¹Âcation (CAVÃ¢Â€Â™90), vol. 531 of Lecture Notes in Computer Science, Springer, Berlin,  Germany, 1991, pp. 156Ã¢Â€Â“165.  [22] M.Y. Vardi, P. Wolper, An automataÃ¢Â€Â“theoretic approach to automatic program veriÄÅ¹Âcation, in: Symposium on  Logic in Computer Science (LICSÃ¢Â€Â™86), IEEE Computer Society Press, Washington, DC , USA, 1986, pp. 332Ã¢Â€Â“345.  [23] M.Y. Vardi, in: An AutomataÃ¢Â€Â“Theoretic Approach to Linear Temporal Logic, vol. 1043 of Lecture Notes in  Computer Science, Springer, New York, NY, USA, 1996, pp. 238Ã¢Â€Â“266.  [24] I. Walukiewicz, DiÄÅ¹Âƒcult conÄÅ¹ÂgurationsÃ¢Â€Â“Ã¢Â€Â“on the complexity of LTrL, in: K.G. Larsen, S. Skyum, G. Winskel  (Eds. ), Proceedings of 25th International Colloquium on Automata, Languages and Programming (ICALPÃ¢Â€Â™98),  vol. 1443 of Lecture Notes in Computer Science, 1998, pp. 140Ã¢Â€Â“151.  Benedikt Bollig received his M.Sc. degree (Dipl.-Inform.) in Computer Science in 2000 from the University of  Technology Aachen (RWTH Aachen). He is currently doing his Ph.D. degree in Computer Science at Lehrstuhl fÃ¢Â‚Å¹  ur Informatik II, RWTH Aachen. His research interests include model checking, Mazurkiewicz  traces, and message sequence charts.  Martin Leucker received his M.Sc. degree (Dipl.-Math.) in Mathematics in 1996 from the University of  Technology Aachen (RWTH Aachen). He got his Ph.D. degree (Dr. rer. nat.) at Lehrstuhl fÃ¢Â‚Å¹  ur Informatik II,  RWTH Aachen. In his thesis, he studied several logics for Mazurkiewicz traces. Currently, he is a postdoctoral researcher at the University of Pennsylvania, USA. 