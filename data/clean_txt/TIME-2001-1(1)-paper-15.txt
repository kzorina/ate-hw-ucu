Data & Knowledge Engineering 44 (2003) 219â238  www.elsevier.com/locate/datak  Deciding LTL over Mazurkiewicz traces  Benedikt Bollig a, Martin Leucker  b,*,1  a  b  Lehrstuhl fâŹur Informatik II, RWTH Aachen, 52074 Aachen, Germany  Department of Computer and Information Science, University of Pennsylvania, Philadelphia PA 19104, USA  Received 10 December 2001; accepted 3 July 2002  Abstract  Linear temporal logic (LTL) has become a well established tool for specifying the dynamic behaviour of  reactive systems with an interleaving semantics, and the automataâtheoretic approach has proven to be a  very useful mechanism for performing automatic veriďŹcation in this setting. Especially alternating automata turned out to be a powerful tool in constructing eďŹcient yet simple to understand decision procedures  and directly yield further on-the-ďŹy model checking procedures. In this paper, we exhibit a decision procedure for LTL over Mazurkiewicz traces that generalises the classical automataâtheoretic approach to a  LTL interpreted no longer over sequences but certain partial orders. SpeciďŹcally, we construct a (linear)  alternating BâŹ  uchi automaton (ABA) accepting the set of linearisations of traces satisfying the formula at  hand. The salient point of our technique is to apply a notion of independence-rewriting to formulas of the  logic. Furthermore, we show that the class of linear and trace-consistent ABA corresponds exactly to LTL  formulas over Mazurkiewicz traces, lifting a similar result from LâŹ  oding and Thomas formulated in the  framework of LTL over words.   2002 Elsevier Science B.V. All rights reserved.  Keywords: LTL; Model checking; Mazurkiewicz traces; Alternating automata  *  Corresponding author.  E-mail addresses: bollig@informatik.rwth-aachen.de (B. Bollig), leucker@cis.upenn.edu (M. Leucker).  1  Part of this work was done during the second authorâs stay at BRICS and RWTH Aachen. He is grateful for the  hospitality and the overall support.  0169-023X/03/$ - see front matter  2002 Elsevier Science B.V. All rights reserved.  PII: S 0 1 6 9 - 0 2 3 X ( 0 2 ) 0 0 1 3 6 - 2  220  B. Bollig, M. Leucker / Data & Knowledge Engineering 44 (2003) 219â238  1. Introduction  Linear time temporal logic (LTL) as proposed by Pnueli [17] has become a well established tool  for specifying the dynamic behaviour of distributed systems. The traditional approach towards  automatic program veriďŹcation is model checking speciďŹcations in LTL. A basic feature of LTL  has been that its formulas are interpreted over sequences. Typically, such a sequence will model a  computation of a system: a sequence of states visited by the system or a sequence of actions  executed by the system during the course of the computation.  The automataâtheoretic approach of Vardi and Wolper [22] for satisďŹability checking has  proven to be very useful and eďŹcient for performing the automatic program veriďŹcation. In its  purest form, this amounts to the construction of a BâŹ  uchi automaton accepting precisely the set of  sequences that satisďŹes the speciďŹcation expressed as an assertion of LTL. In the last years, a shift  towards the employment of alternating automata for deďŹning decision procedures took place.  Alternating automata provide simple, eďŹcient, and easy to understand decision procedures. They  have proven to be useful for deďŹning satisďŹability algorithms for LTL over words [23], branching  time logics [2,12] over ďŹnite transition systems, and the l-calculus over (inďŹnite) preďŹx-recognisable graphs [11]. The idea is that the states of the automaton are constructed essentially from the  subformula closure of the speciďŹcation formula, and the automaton operates in a tableau-like  fashion. The satisďŹability problem is then solved by checking whether the constructed automaton  accepts any strings.  This approach forms the conceptual basis of many veriďŹcation algorithms. Several tools (e.g.,  SPIN [8]) being employed in industry are built upon this translation from formulas to automata.  To improve performance, however, a number of substantial optimisations must be incorporated.  One observation is that the state space of the product automaton needs seldomly to be fully  constructed. Often the answer to the veriďŹcation problem can be established by investigating only  a subset of states, and this subset might be considerably smaller than the entire state space. This is  the main idea underlying the so-called on-the-ďŹy veriďŹcation techniques. To support on-the-ďŹy  checking, an automaton corresponding to a formula should be deďŹned in a topâdown manner.  This means that, given a formula u and one of its subformulas w, a part of the automaton Au  should be constructible without constructing Aw , where Ag denotes the automaton accepting the  models of g. In this way, the automaton for a given formula and an underlying transition system  may only be constructed partly viz if the model-checking or satisďŹability question can already be  answered by considering this part.  In many applications, the computations of a distributed system will constitute interleavings of the occurrences of causally independent actions. Consequently, the computations can  be naturally grouped together into equivalence classes where two computations are equated  in case they are two diďŹerent interleavings of the same partially ordered stretch of behaviour. It  turns out that many of the properties expressed as LTL-formulas happen to have the so called  ââall-or-noneââ property. Either all members of an equivalence class of computations will have  the desired property or none will do (ââleads to deadlockââ is one such property). For verifying such properties, one has to check them for just one member of each equivalence class. This  is the insight underlying many of the partial-order based veriďŹcation methods (e.g., [16,21]).  As may be guessed, the importance of these methods lies in the fact that via these methods  B. Bollig, M. Leucker / Data & Knowledge Engineering 44 (2003) 219â238  221  the computational resources required for the veriďŹcation task can often be dramatically reduced.  Often, the equivalence classes of computations generated by a distributed system constitute objects called Mazurkiewicz traces [4,15]. They can be canonically represented as restricted  labelled partial orders. This opens up an alternative way of exploiting the non-sequential  nature of the computations of a distributed system and the attendant partial-order based  methods. It consists of developing LTLs that can be interpreted directly over Mazurkiewicz  traces. In these logics, every speciďŹcation is guaranteed to have the ââall-or-noneââ property and  hence can be subjected to the partial-order based reduction methods during the veriďŹcation  process.  A number of LTLs to be interpreted over Mazurkiewicz traces directly (e.g., [1,19,20]) has been  proposed starting with TrPTL [19]. There are several possible routes towards extending LTLs to  traces. TrPTL is based on locations, where one reasons explicitly about a distribution of computing agents cooperating through some communication structure given as an alphabet distribution. Another option [1] is to view events as the partial-order computation points in time, and  base the speciďŹcations upon the relationship between individual events. Together, these paradigms  constitute the local trace logics. In contrast, in the global view of computations, conďŹgurations are  seen as instantaneous snapshots of the system at hand. In this sense, a conďŹguration is a global  view capturing a collection of simultaneous local views.  The âârightââ temporal logic for traces should be equal in expressive power to ďŹrst-order logic for  traces (FO). It follows from [5] that such a logic would capture exactly those properties of LTL  that have the ââall-or-noneââ property and hence are amenable to partial-order veriďŹcation.  However, none of the local logics are known to be expressively equivalent to FO. This led Thiagarajan and Walukiewicz to deďŹne the conďŹguration based LTrL [20], which they indeed prove  equivalent to FO. LTrL was later reďŹned [3] to a straightforward formulation of LTL for traces  essentially extending Kampâs Theorem [10] to the setting of traces.  While both the event based and location based logics have elegant (exponential-time) decision  procedures smoothly extending the classical automataâtheoretic approach to the setting of traces,  no such smooth extension exists for global logics such as LTL. The essence of this anomaly is the  complications that arise as a consequence of the fact that the satisďŹability problem for LTL has a  non-elementary lower bound [24]. However, experience [9] has shown that decision procedures  can still be useful in practice despite discouraging lower bounds.  Gastin et al [6,7] do give a direct decision procedure for LTL based on automata. However, the  construction of the automaton corresponding to a given LTL-speciďŹcation u proceeds by induction on u, thus in a bottomâup manner. Hence it is not an extension of the classical automataâ  theoretic approach, and more important, it requires the construction of the full automaton, so  optimisations such as on-the-ďŹy checking cannot be applied. A further drawback is its high  complexity. While an exponential blow-up is unavoidable for nested until-formulas, the procedure  has also an exponential blow-up for every negation. Since nested until-formulas are rare in  speciďŹcations but negations are typical for specifying unwanted behaviour, this limits the practical  applicability of this procedure.  In this paper, we propose a decision procedure for LTL for traces directly extending the classical  approach [23]. Our procedure is based upon an extended subformula closure and independence  222  B. Bollig, M. Leucker / Data & Knowledge Engineering 44 (2003) 219â238  rewriting of formulas of LTL. We employ this to construct a tableau-style alternating BâŹ  uchi  automaton (ABA) accepting the set of linearisations of traces satisfying the speciďŹcation at hand.  In this sense, our procedure ďŹlls the missing gap for global trace logics by extending the classical  approach to this last remaining case. Our procedure corresponds exactly to the version given in  [23] when restricted to an empty independence relation. Furthermore, our automata can be  constructed on-the-ďŹy, which is crucial. Last but not least, for the fragment of LTL without untilformulas, our procedure is exponential.  In [14], it was shown that word languages deďŹnable by LTL-formulas over words correspond to  the languages of linear ABA. We prove that our construction yields a linear BâŹ  uchi automaton as  well. Furthermore, we show that our linear BâŹ  uchi automata accept trace-consistent languages.  Conversely, we show that the class of trace-consistent languages deďŹnable by linear ABA coincides with the class of languages that are deďŹnable by LTL-formulas over Mazurkiewicz traces for  a given dependency relation. In other words, LTL-deďŹnable trace languages correspond to languages deďŹnable by trace-consistent linear ABA.  The results of this paper will also appear in an extended version in [13].  In the next section, we recall Mazurkiewicz traces and some related notions that will play a  crucial r^  ole for our present purposes. In Section 3, we introduce the basic object of our study,  LTL, and interpret it directly over the domain of Mazurkiewicz traces. Following this, we give in  Section 4 a brief account of ABA underlying our decision procedure to be presented in Section 5.  There we supply a proof of correctness of our construction before giving a few concluding remarks in Section 6.  2. Mazurkiewicz traces  A (Mazurkiewicz) trace alphabet is a pair Ă°R; IĂ, where R, the alphabet, is a ďŹnite set and  I  R  R is an irreďŹexive and symmetric independence relation. Usually, R consists of the actions  performed by a distributed system while I captures a static notion of causal independence between  actions. We deďŹne D Âź Ă°R  RĂ  I to be the dependency relation, which is then reďŹexive and  symmetric.  For the rest of the section, we ďŹx a trace alphabet Ă°R; IĂ. We will use aIb to denote that the  actions a and b are independent, i.e., that Ă°a; bĂ 2 I, and use similar notation for Ă°a; bĂ 2 D. We  extend the notion to sets of actions X , Y  R, and let XIY denote the fact that each pair of actions  a 2 X and b 2 Y is independent. Moreover, XDY will denote that X is dependent on Y, i.e., that  there exists a pair of actions a 2 X and b 2 Y with a and b dependent. For convenience, we will  write fagIY as aIY etc.  For the purpose of interpreting LTL over traces, we will adopt the viewpoint that traces are  restricted labelled partial orders of events and hence have an explicit representation of causality  and concurrency.  Let T Âź Ă°E; 6 ; kĂ be a R-labelled poset. In other words, Ă°E; 6 Ă is a poset and k : E ! R is a  labelling function. k can be extended to subsets of E in the straightforward manner. For e 2 E, we  deďŹne # e Âź fx 2 Ejx 6 eg and " e Âź fx 2 Eje 6 xg. We let U be the covering relation given by xUy  iďŹ x < y and for all z 2 E, x 6 z 6 y implies x Âź z or z Âź y.  B. Bollig, M. Leucker / Data & Knowledge Engineering 44 (2003) 219â238  223  A (Mazurkiewicz) trace over Ă°R; IĂ is a R-labelled poset T Âź Ă°E; 6 ; kĂ satisfying:  â˘ # e is a ďŹnite set for each e 2 E.  â˘ For every e, e0 2 E, eUe0 implies kĂ°eĂDkĂ°e0 Ă.  â˘ For every e, e0 2 E, kĂ°eĂDkĂ°e0 Ă implies e 6 e0 or e0 6 e.  We shall let TRĂ°R; IĂ denote the class of traces over Ă°R; IĂ. As usual, a trace language L is a  subset of traces, i.e., L  TRĂ°R; IĂ. Throughout the paper we will not distinguish between isomorphic elements in TRĂ°R; IĂ. We will refer to members of E as events.  Let T Âź Ă°E; 6 ; kĂ be a trace over Ă°R; IĂ. The ďŹnite preďŹxes of T, to be called conďŹgurations, will  play a crucial r^  ole in  S what follows. A conďŹguration of T is a ďŹnite subset of events c  E with  # c Âź c where # c Âź e2c # e. The set of conďŹgurations of T will be denoted CT . Trivially, ; 2 CT  for any trace T. CT can be equipped with a natural transition relation !T  CT  R  CT given  a  by: c !T c0 iďŹ there exists an e 2 E such that kĂ°eĂ Âź a, e 62 c and c0 Âź c [ feg. ConďŹgurations of CT  are the trace-theoretic analogues of ďŹnite preďŹxes of strings. As will become apparent in Section 3,  the formulas of LTL are to be interpreted at conďŹgurations of traces.  In its original formulation [15], Mazurkiewicz introduced traces as certain equivalence classes of  strings, and this correspondence turns out to be essential to our developments here. To bring this  out, let R be the set of ďŹnite strings over R and Rx be the set of (countably) inďŹnite strings  generated by R with x Âź f0; 1; 2; . . .g. We set R1 Âź R [ Rx and denote the empty word by e. We  let w, w0 range over Rx and u, v with or without primes range over R . Finally, we take prf(w) to be  the set of ďŹnite preďŹxes of w and let alphĂ°wĂ denote the set of actions occurring in w.  Next, let T Âź Ă°E; 6 ; kĂ 2 TRĂ°R; IĂ. Then w 2 R1 is a linearisation of T iďŹ there exists a map q:  prfĂ°wĂ ! CT , such that the following conditions are met:  â˘ qĂ°eĂ Âź ;.  a  â˘ qĂ°vĂ !T qĂ°vaĂ for each va 2 prfĂ°wĂ.  â˘ For every e 2 E, there exists some u 2 prfĂ°wĂ such that e 2 qĂ°uĂ.  The function q will be called a run map of the linearisation w. Note that the run map of a  linearisation is unique. In what follows, we shall take linĂ°T Ă to be the set of linearisations of the  trace T.  A set p  R is called a D-clique iďŹ p  p  D. The equivalence relation  R1  R1 induced by  I is given by: w  w0 iďŹ wp Âź w0 p for every D-clique p. Here and elsewhere, if X  R, wX is the  sequence obtained by erasing from w all occurrences of letters in R  X . We take Â˝w to denote  the -equivalence class of w 2 R1 .  It is not hard to show that elements of TRĂ°R; IĂ and -equivalence classes are two representations of the same object: A labelled partial-order T 2 TRĂ°R; IĂ is represented by linĂ°T Ă and vice  versa (see [4] for a proof of this fact and a more thorough account of traces). We exploit this  duality of representation and let Tw denote the trace corresponding to Â˝w . Moreover, for each  v 2 prfĂ°wĂ we will use cv to denote the conďŹguration of CTw given by qĂ°vĂ.  To illustrate these concepts, consider the trace alphabet Ă°R; IĂ with R Âź fa; b; dg and  I Âź fĂ°a; bĂ; Ă°b; aĂg. An example trace T over Ă°R; IĂ is depicted in Fig. 1 with smaller elements (with  respect to 6 ) appearing below larger elements. Furthermore, it can easily be veriďŹed that  224  B. Bollig, M. Leucker / Data & Knowledge Engineering 44 (2003) 219â238  Fig. 1. A trace over Ă°R; IĂ.  abdbabd 2 linĂ°T Ă so T Âź Tabdbabd , but adabbbd 62 linĂ°T Ă. The conďŹguration c 2 CT consists of the  ďŹrst two aâs, ďŹrst d, ďŹrst two bâs and is also denoted by cabdab , which is identical to cbadab as  abdab  badab.  We transfer considering traces as equivalence classes to the level of languages and call a  word language L  Rx trace-consistent if for all words w, w0 2 Rx with w  w0 , it holds w 2 L iďŹ  w0 2 L.  3. LTL for Mazurkiewicz traces  In this section, we bring out the syntax and semantics of the linear time temporal logic LTL,  which will be our basic object of study. It was originally introduced for strings by Pnueli [17]. It  was later equipped with a trace semantics [20] and proved expressively equivalent to ďŹrst-order  logic for traces by Diekert and Gastin [3], and this is the version we will consider here.  The formulas of LTL are parameterised by a trace alphabet Ă°R; IĂ and are deďŹned inductively as  follows:  LTLĂ°R; IĂ ::Âź ttj:uju _ wjhaiujuUw;  a 2 R:  Formulas of LTLĂ°R; IĂ are interpreted over conďŹgurations of traces over Ă°R; IĂ. More precisely,  given a trace T 2 TRĂ°R; IĂ, a conďŹguration c 2 CT , and a formula u 2 LTLĂ°R; IĂ, the notion of T ,  c  u is deďŹned inductively via:  â˘  â˘  â˘  â˘  â˘  T ; c  tt.  T ; c  :u iďŹ T ; c 2 u.  T ; c  u _ w iďŹ T ; c  u or T ; c  w.  a  T ; c  haiu iďŹ there exists a c0 2 CT such that c !T c0 and T ; c0  u.  T ; c  uUw iďŹ there exists a c0 2 CT with c  c0 such that T ; c0  w and all c00 2 CT with  c  c00  c0 satisfy u.  We will freely use the standard abbreviations such as e.g., ff Âź :tt, u ^ w Âź :Ă°:u _ :wĂ.  Furthermore, we sometimes abbreviate T ,;  u by T  u. All models of a formula u 2 LTLĂ°R; IĂ  constitute a subset of TRĂ°R; IĂ, thus a language. It is denoted by LĂ°uĂ and is called the language  B. Bollig, M. Leucker / Data & Knowledge Engineering 44 (2003) 219â238  225  deďŹned by u. Furthermore, every formula deďŹnes an x-language viz the set fw 2 linĂ°T ĂjT  ug,  which is also indicated by LĂ°uĂ.  A simple example of a formula of LTL is u Âź haihbiw. Note that for the trace of Fig. 1 it holds  that T  u if and only if T ,cab  w. Moreover, u is equivalent to u0 Âź hbihaiw over this particular  trace alphabet because aIb, i.e., the models of u and u0 and coincide. Such considerations will play  a prominent r^  ole when we deďŹne the decision procedure in Section 5.  For bringing out the decision procedure itself, it will be convenient to assume that the syntax of  LTL is augmented with an indexed until operator UUZ w where Z  R and U Âź fuY11 ; . . . ; uYnn g is a  ďŹnite set of indexed formulas with Yi  R. Formally, it will have the following semantics:  â˘ T ; c  UUZ w iďŹ there exists a c0 2 CT with c  c0 such that T ; c0  w and kĂ°c0  cĂIZ, and, for  each 1 6 i 6 n and every c00 with c  c00  c0 and kĂ°c00  cĂIYi , it holds c00  ui .  Hence, a trace satisďŹes the formula UUZ w in the conďŹguration c iďŹ there is a future conďŹguration c0 satisfying w and all the actions from c to c0 are independent from the actions in Z.  Furthermore, the conďŹgurations between c and c0 which can be reached from c by performing  actions independent of Yi all satisfy ui .  Note that uUw can be identiďŹed with fu; gU; w and we will not always make this distinction  explicit. It is not hard to see that UUZ w is expressible within FO, so this indexed modality is  derivable within LTL itself.  We remark that, in case of the empty independence relation, LTLĂ°R; IĂ and LTL interpreted  over words (denoted by LTLĂ°RĂ) coincide in the expected manner. Thus, we identify LTL over  words with LTLĂ°RĂ, especially in the proof of Theorem 13, and save the work for introducing  LTL over words formally.  4. Alternating BâŹ  uchi automata  Alternating automata extend non-deterministic automata by universal choices. The transition  function denotes no longer a set of possible next states but a (positive) Boolean combination. In  this section, we recall the notion of alternating automata along the lines of [23] where ABA are  used for model checking LTL over strings. However, we modiďŹed the deďŹnition of a run to reďŹect  the ideas presented in [14].  For a ďŹnite set X of variables, let BĂž Ă°X Ă be the set of positive Boolean formulas over X, i.e., the  smallest set such that  â˘ X  BĂž Ă°X Ă  â˘ tt, ff 2 BĂž Ă°X Ă  â˘ u, w 2 BĂž Ă°X Ă ) u ^ w 2 BĂž Ă°X Ă, u _ w 2 BĂž Ă°X Ă.  In the following, we assume for every positive Boolean formula that it is in disjunctive normal  form and that it is reduced with respect to idempotence and commutation. Hence, for a set X with  jX j  jX j elements, the size of BĂž Ă°X Ă is bounded by 22 . This can easily be seen by considering the  formulas as sets of sets.  226  B. Bollig, M. Leucker / Data & Knowledge Engineering 44 (2003) 219â238  We say that a set Y  X satisďŹes (or is a model of) a formula u 2 BĂž Ă°X Ă iďŹ u evaluates to tt  when the variables in Y are assigned to tt and the members of X n Y are assigned to ff. A model is  called minimal if none of its proper subsets is a model. For example, fq1 ; q3 g as well as fq2 ; q3 g are  minimal models of the formula Ă°q1 _ q2 Ă ^ q3 .  Later in our construction, logical formulas will take over the r^  ole of states. Therefore, we  should formally distinguish between disjunctions of formulas and disjunctions of states. However,  to simplify our presentation, we identify these disjunctions when the context makes clear which  one is meant. In particular, given a formula u in disjunctive normal form, u Âź _ ^ uij where no  uij is a (top level) disjunction or conjunction, we identify u with the positive Boolean combination  of states uij . To avoid confusion, we sometimes write stĂ°uĂ to denote fuij j _ ^uij g.  An ABA over an alphabet R is a tuple A Âź Ă°Q; R; d; q0 ; F Ă such that Q is a ďŹnite non-empty set  of states, q0 2 Q is an initial state, F  Q is a set of accepting states and d : Q  R ! BĂž Ă°QĂ is a  transition function.  Because of universal quantiďŹcation, a run over an inďŹnite string is no longer a sequence but a  labelled directed acyclic graph. A nodeâs label reďŹects one of the current states of the automaton,  and the edges reďŹect transitions of the automaton with respect to the input string. Hence, this  graph should have a unique âârootââ labelled with q0 . Furthermore, it has to be divisible into  ââlevelsââ i 2 N corresponding to the ith input letter. Every node except the root must have a  ââpredecessorââ. For a node v, the labels of nodes of level i Ăž 1 connected with v should further be a  model for the transition in state lĂ°vĂ reading the ith letter. More precisely:  A run over an inďŹnite string w Âź a0 a1 . . . 2 Rx is a Q-labelled directed acyclic graph Ă°V ; EĂ such  that there exist labellings l : V ! Q and h : V ! N which satisfy the following properties.  â˘  â˘  â˘  â˘  â˘  h1 Ă°0Ă  S Âź fvg with lĂ°vĂ Âź q0 .  E  i2N Ă°h1 Ă°iĂ  h1 Ă°i Ăž 1ĂĂ.  For every v0 2 V with hĂ°v0 Ă P 1, fv 2 V jĂ°v; v0 Ă 2 Eg 6Âź ;.  For every v; v0 2 V , v 6Âź v0 , lĂ°vĂ Âź lĂ°v0 Ă implies hĂ°vĂ 6Âź hĂ°v0 Ă.  For every v 2 V , flĂ°v0 ĂjĂ°v; v0 Ă 2 Eg is a minimal model of dĂ°lĂ°vĂ; ahĂ°vĂ Ă.  A run Ă°V ; EĂ is accepting if every maximal ďŹnite path ends in a node v 2 V with dĂ°lĂ°vĂ; ahĂ°vĂ Ă Âź tt  and every maximal inďŹnite path, wrt the labelling l, visits at least one ďŹnal state inďŹnitely often.  The language LĂ°AĂ of an automaton A is determined by all strings for which an accepting run of  A exists.  Let us deďŹne a subclass of alternating automata corresponding to LTL formulas over words, as  shown in [14]. The transition graph of an ABA A Âź Ă°Q; R; d; q0 ; F Ă is the graph Ă°Q; EĂ such that  Ă°q; q0 Ă 2 E iďŹ there is an action a such that for dĂ°q; aĂ Âź _ ^ qij , the state q0 is one of the qij . 2 The  automaton is called linear iďŹ its transition graph has only trivial cycles.  Finally, we call an ABA A trace-consistent if its language LĂ°AĂ is trace-consistent. We will  show that linear trace-consistent automata correspond to LTL formulas over Mazurkiewicz traces.  Obviously, every BâŹ  uchi automaton can be turned into an equivalent (wrt the accepted language) ABA. Vice versa, for every ABA, an equivalent BâŹ  uchi automaton can be constructed with  2  Silently considering tt and ff as states here.  B. Bollig, M. Leucker / Data & Knowledge Engineering 44 (2003) 219â238  227  an exponential blow-up. The construction is described for example in [23]. Hence, it is easy to see  that the emptiness problem for ABAs is exponential in its number of states.  5. A decision procedure for LTL  We have now set the scene to bring out our decision procedure for LTL. Our procedure  generalises the classical approach by constructing an ABA Au accepting the set of linearisations  of traces satisfying a given formula u. The states of this automaton are derived from an extended  subformula closure, which we ďŹrst deďŹne. Following this, we deďŹne a notion of independencerewriting of such formulas, and this will eventually become the transition relation of Au . We pin  down the details of our construction and give a proof of correctness. Then we consider the  complexity of our decision procedure and point out the correspondence between linear traceconsistent alternating automata and LTL over Mazurkiewicz traces.  5.1. The construction  In essence, we will construct an automaton Au that accepts a string w 2 Rx whenever the  corresponding trace Tw satisďŹes u. To appreciate the developments to come, we commence with a  small example. Consider the example formula u Âź haihbiw of Section 3. Suppose that w is of the  form abv for some v 2 Rx . It is then not hard to see that Tw , ;  u if and only if Tw ; ca  hbiw.  Consider now instead w0 Âź bav. Since the underlying domain is traces, Tw0 might still satisfy u  even though the ďŹrst action is a b and not an a, because aIb. In fact, Tw0 , ;  u exactly when  Tw0 ; cb  haiw. In this sense, the proof obligation at the empty conďŹguration, ââhaihbiwââ, has been  transformed by b to the proof obligation ââhaiwââ at cb ; the a-action still has to be witnessed, but  the present b has been matched. (Note by the way that either both or none of w and w0 should be  accepted, because w  w0 and hence Tw Âź Tw0 .)  In eďŹect, our automaton proceeds in this way by ââindependence-rewritingââ the proof obligations by the actions read. The state space thus consists of all subformulas together with formulas  obtained by transformations as described above. We will call this set the extended closure of u.  DeďŹnition 1. Let g be a formula of LTL. We take ecl(g) to be the least set that satisďŹes the following:  â˘  â˘  â˘  â˘  g itself is contained in its closure.  For u _ w 2 eclĂ°gĂ, it also contains the closure of u and of w.  For haiu 2 eclĂ°gĂ, it also contains the closure of u as well as haiu0 for every u0 2 eclĂ°uĂ.  For u 2 eclĂ°gĂ, it also contains :u 2 eclĂ°gĂ. We identify ::u with u. Hence, eclĂ°gĂ is closed  under negation.  â˘ For uUw 2 eclĂ°gĂ, the closure contains eclĂ°uĂ as well as eclĂ°wĂ. Furthermore, for all Z  R, all  w0 2 eclĂ°wĂ, and all U  fu0Y ju0 2 eclĂ°uĂ; Y  Rg the closure contains UU Z w0 .  â˘ The closure is closed under positive Boolean combinations, i.e., BĂž Ă°eclĂ°gĂĂ  eclĂ°gĂ.  Intuitively, the extended closure of a formula u contains all formulas which may be obtained by  substituting a subformula w of u by w0 where w0 is a positive Boolean combination of formulas  228  B. Bollig, M. Leucker / Data & Knowledge Engineering 44 (2003) 219â238  derived from w by applying this rule. This is because our automaton will be deďŹned in the way  that before it is considering a formula u it may consider a subformula w of u, transforming this  into a positive Boolean combination of new formulas w0 . This result is processed in the way that w  is substituted by w0 within u.  We assume that all positive Boolean formulas are in disjunctive normal form and moreover  that they are reduced wrt idempotence and commutation. With these assumptions we can prove  the following crucial result.  Proposition 2. eclĂ°gĂ is a finite set for each formula g of LTL.  Proof. The proof proceeds by a standard induction. The claim is obvious for atomic formulas. For  g Âź haiu, the extended closure of g contains the extended closure of u and for every element u0 of  eclĂ°uĂ also haiu0 . Thus, we get jeclĂ°uĂj ! 2 elements. Since the extended closure contains for every  element also a negated one, we get another factor 2. Now, positive Boolean combination yields  jeclĂ°uĂj!2!2  . For g Âź fuY11 ; . . . ; uYnn gUZ w,  a double exponential blow-up. Altogether, we have jeclĂ°gĂj 6 22  it can be veriďŹed that jeclĂ°gĂj is bounded by   P    n  22  2  2  iÂź1  Ă°jeclĂ°ui Ăj!2jRj Ă  jeclĂ°wĂj  !2jRj !22  !2  :  The three factors are upper bounds for the derivatives of f! ! !g, UZ , and w, resp., and the powers  bound their positive Boolean combination.   We will refer to formulas of this set as extended formulas. Furthermore, we will say that a  formula is a diamond-formula in case it is of the form haiu for some extended formula u and some  a 2 R. In a similar vein, we let the until-formulas consist of those of the form UUZ w with U being a  ďŹnite set of extended formulas, w a single extended formula and Z  R.  For extended formulas, we will make use of the important notion of its dual, which is obtained  as usual by applying de Morganâs laws to push negations inwards as far as possible.  DeďŹnition 3. The dual of an (extended) formula is given inductively as follows:  â˘  â˘  â˘  â˘  â˘  â˘  tt Âź ff, ff Âź tt.  :u Âź u.  u _ w Âź u ^ w, u ^ w Âź u _ w.  haiu Âź :haiu.  uUw Âź :Ă°uUwĂ.  UUZ w Âź :Ă°UUZ wĂ.  We are now set to introduce the operator k  k , which will constitute the transition relation of  the alternating automaton. Essentially, kuka is to be thought of as the independence-rewriting of  u by the action a.  It follows from the intuition conveyed earlier that it should be the case that khaiuka is u. Then,  for the case where aIb, khbiuka Âź hbiu0 where u0 Âź kuka . Of course, whenever aDb and the actions  B. Bollig, M. Leucker / Data & Knowledge Engineering 44 (2003) 219â238  229  are not identical, then khbiuka must be ff because b cannot be a next action. DeďŹnition 4 formally  captures this intuition.  DeďŹnition 4. For each extended formula u and each action a, the operator kuka yields a formula  of BĂž Ă°eclĂ°uĂĂ and is deďŹned inductively via:  kttka Âź tt:  ku _ wka Âź kuka _ kwka :  k:uka Âź kuka :  8  <u  khbiuka Âź hbikuka  :  ff  if a Âź b  if aIb  if aDb; a 6Âź b:  Note that since eclĂ°gĂ is closed under positive Boolean combination, we have eclĂ°gĂ Âź  BĂž Ă°eclĂ°gĂĂ.  We now only need to specify the case of kUUZ wka . This turns out to be inherently more  complex, and before providing the precise deďŹnition, we carefully analyse the semantics of the  indexed until modality in Fig. 2. For this purpose, consider some trace T be given and suppose  c; c0 2 CT such that c  c0 . Furthermore, let c00 be a conďŹguration between c and c0 (Fig. 2(i)).  Suppose, we can augment c by an a-labelled event e to obtain a successor conďŹguration c000 of c,  a  i.e., c!c000 . Then c000  c00  c0 or c000 6 c00 but c000  c0 or c000 6 c0 , as shown in Fig. 2(a)â(c) resp. In  case (b), it is obvious that kĂ°c00  cĂIa and for case (c), we have kĂ°c0  cĂIa (as well as kĂ°c00  cĂIa).  The situation shown in Fig. 2 can, in other words, be described in the following manner: The  action a is  (a) neither in the future of c00 nor of c0 (case (a)),  (b) in the future of c00 (case (b)), or  (c) in the future of c00 as well as of c0 (case (c)).  Consider a formula uUw, which is to be checked in the conďŹguration c. In case (c), we have to  employ a for verifying w as well as u. Note that for case (c), we get two subcases depending upon  whether c0 Âź c or c0 # c. While w is not relevant to the ďŹrst case, u is required to hold in the  Fig. 2. ConďŹguration and actions.  230  B. Bollig, M. Leucker / Data & Knowledge Engineering 44 (2003) 219â238  conďŹgurations between c and c0 . Note that these conďŹgurations are reached by actions independent of a.  For case (a), we have to employ a for verifying u in conďŹguration c but not for c00 . In case (b),  we have to prove u considering a in the conďŹguration c00 , which might be equal to c as well as  diďŹerent from c. Note that in the latter case, every event of c00  c is independent of a.  Consequently, we deďŹne the rewriting operator for a formula UUZ w as follows.  DeďŹnition 5 (extends DeďŹnition 4). Let  n  o  W1 Âź kwka W2 Âź kukYa [fag juY 2 U UZ[fag kwka :  Moreover, we set W0 Âź W1 _ W2 . Let  n  o  kUka Âź kukaY [fag juY 2 U [ uY juY 2 U; aIY  and  U1 Âź ^uY 2U kuka  U2 Âź kUka UZ w  and U0 Âź U1 ^ U2 . Then we deďŹne  kUUZ wka Âź  W0  W0 _ U0  if aDZ;  else aIZ:  Note that W0 captures case (c) in which an action a is employed for verifying w under the assumption that c0 Âź c Ă°W1 Ă or not (W2 ). U0 covers the idea that a is not in the future of c0 but is  employed for verifying the obligations in U.  It is not hard to verify that k  k is well-deďŹned. However, to show the correctness of our  construction, the following proposition is essential. Suppose that we have given one linearisation  of a trace and one formula and we want to check the formula wrt the trace obtained from the  linearisation. According to the following proposition it is possible to consider the word action by  action and to modify the formula according to the rewriting operator.  Proposition 6. Let g be any formula of LTLĂ°R; IĂ. Then for all w 2 Rx and for all v 2 R , a 2 R,  w0 2 Rx with vaw0  w  Tw ; cv  g if and only if Tw ; cva  kgka :  Proof. The proof proceeds by induction on the formula g. We only show the most important cases  as the other cases follow in a similar manner. The cases where g Âź tt or g Âź ff are trivial.  Suppose g Âź u _ w. Then Tw ; cv  u _ w means by deďŹnition that Tw ; cv  u or Tw ; cv  w. By  induction, this is equivalent to Tw ; cva  kuka or Tw ; cva  kwka , which is equivalent to Tw ; cva   ku _ wka by deďŹnition of the rewrite operator.  Suppose g Âź :u. By deďŹnition, Tw ; cv  :u iďŹ not Tw ; cv  u. Induction yields Tw ; cva 2 kuka ,  which means Tw ; cva  :kuka . The dual of a formula is obviously logically equivalent to the negation of the formula so that the previous statement is equivalent to Tw ; cva  kuka .  B. Bollig, M. Leucker / Data & Knowledge Engineering 44 (2003) 219â238  231  Suppose g Âź hbiu. By deďŹnition, Tw ; cv  hbiu if and only if there is a conďŹguration c0 such that  b  cv ! c0 Âź cvb and Tw ; c0  u. We consider three diďŹerent cases:  â˘ b Âź a: then c0 Âź cva . Hence Tw ; cva  u.  b  a  â˘ bÂź  6 a, bDa: then cv ! c0 and cv ! cva . However, then w is not a linearisation of the trace, which  is a contradiction.  â˘ bIa: Tw ; cvb  u is by induction equivalent to Tw ; cvba  kuka . Since aIb, this means Tw ; cvab   kuka , which is equivalent to Tw ; cva  hbikuka .  Putting together all the cases we get that Tw ; cv  hbiu if and only if Tw ; cva  khbiuka .  The most involved case is g Âź UUZ w. Let U Âź fuY11 ; . . . ; uYNN g. Recall that Tw ; cv   fuY11 ; . . . ; uYNN gUZ w if and only if  9x 2 R ; y 2 Rx ; aw0  xy; xIZ; such that Tw ; cvx  w; and  8i 2 f1; . . . ; N g; 8x1 ; x2 2 R with x1 x2  x; x1 IYi ; x2 6Âź e; it holds  Tw ; cvx1  ui :  We consider here only the case where aIĂ°Yi [ ZĂ. The other cases follow similarly. Let us ďŹrst  discuss the implication from left to right: we consider the following cases for x:  â˘ x Âź e: then Tw ; cvx  w means Tw ; cv  w, which implies by induction Tw ; cva  kwka . This shows  Ă°W1 Ă.  â˘ x 6Âź e, a 62 alphĂ°xĂ: We consider the cases for w and ui simultaneously.  )  I:H :  )  )  )  aIx  Tw ; cvx  w  Tw ; cvxa  kwka  Tw ; cvax  kwka  9x 2 R ; xIĂ°Z [ fagĂ  Tw ; cvax  kwka  )  I:H :  )  )  )  aIx1  Tw ; cvx1  ui  Tw ; cvx1 a  kui ka  Tw ; cvax1  kui ka  8x1 ; x2 2 R ; x1 x2  x; x1 IĂ°Yi [ fagĂ  x2 6Âź e; Tw ; cvax1  kui ka  Hence, Tw ; cva  fkukaY [fag juY 2 UgUZ[fag kwka , which shows (W2 ).  â˘ x 6Âź e, a 2 alphĂ°xĂ: We easily see that x  ax0 and a, x0 IZ and Tw ; cvax0  w. We will show Ă°U1 Ă  and Ă°U2 Ă. Let us consider x1 . If x1 Âź e then Tw ; cv  ui implies by induction Tw ; cva  kui ka . If  x1 6Âź e and a 62 alphĂ°x1 Ă, we see that aIx1 and x1 IYi . Hence, x1 IĂ°Yi [ fagĂ. Now, Tw ; cvx1  ui  yields by induction Tw ; cvx1 a  kui ka proving Tw ; cvax1  kui ka since aIx1 . For the case x1 6Âź e  but a 2 alphĂ°x1 Ă, we see that x1  ax01 and Tw ; cvax01  ui . Summing up the cases for x1 , we get  Tw ; cva  kUka UZ w, which shows Ă°U2 Ă, and Tw ; cva  kuka for all uY 2 U, which shows Ă°U1 Ă.  Altogether, we showed that W0 or U0 hold in the until case proving the ââifââ-part. Now, let us  consider the implication from right to left: suppose Tw ; cva  kUUZ wka , i.e.,  Tw ; cva  W1 _ W2 _ U0 :  232  B. Bollig, M. Leucker / Data & Knowledge Engineering 44 (2003) 219â238  We discuss the disjunction by drawing the conclusions of each formula  â˘ Tw ; cva  kwka : this implies by induction that Tw ; cv  w. Hence, Tw ; cv  UUZ w.  Y [fag  juY 2 UgUZ[fag kwka : Then there exist x; y, xIĂ°Z [ fagĂ, w  vaxy such that  â˘ Tw ; cva  fkuka  Tw ; cvax  kwka . Since xIa also Tw ; cvxa  kwka , which yields by induction Tw ; cvx  w. We further  know that for every proper preďŹx (modulo ) x1 of x with x1 IĂ°Y [ fagĂ, we have Tw ; cvax1   kuka . Then Tw ; cvx1 a  kuka and, by induction, Tw ; cvx1  u. Hence, Tw ; cv  UUZ w.  â˘ Tw ; cva  ^uY 2U kuka ^ kUka UZ w: We ďŹrst obtain by induction that Tw ; cv  u for every uY 2 U.  Let us consider  Tw ; cva  Ă°fkukYa [fag juY 2 Ug [ fuY juY 2 U; aIY gĂUZ w:  It implies that there is an x0 , independent of Z, such that Tw ; cvax0  w. Since we are in the case of  aIZ, we conclude that there is an x, xIZ(x  ax0 ) such that Tw ; cvx  w. Now, consider x1 x2  x,  x2 6Âź e. For every x1 IĂ°Y [ fagĂ, x1 a preďŹx of x0 , we know Tw ; cvax1  kuka and, by induction,  Tw ; cvx1  u. For x0 Âź e, we already know Tw ; cv  u. For x1 IY and x1 Da, we obtain x1  ax01 , x01 IY ,  since cva is a valid conďŹguration. By Tw ; cvax01  u we deduce Tw ; cvx1  u. Altogether, this shows  Tw ; cv  UUZ w.  This concludes the proof.   We can now ďŹnally bring the deďŹnition of the ABA Au corresponding to a formula u 2  LTLĂ°R; IĂ as follows.  DeďŹnition 7. Given a formula u 2 LTLĂ°R; IĂ, the ABA Au is the tuple Ă°Q; R; d; q0 ; F Ă where  â˘  â˘  â˘  â˘  Q Âź eclĂ°uĂ is the set of states.  dĂ°q; aĂ Âź kqka is the transition function.  q0 Âź u is the initial state.  F Âź f:wj:w 2 eclĂ°uĂg is the set of accepting states.  Note that we deďŹned the set of ďŹnal states to be all negated formulas. The intuitive idea is that  failing to prove a proposition inďŹnitely often suďŹces to assume that its negation is true. In the  work of Vardi [23], one could likewise take all negated formulas as ďŹnal states. Since in the case of  LTL over words, only until-formulas may occur inďŹnitely often, the set of ďŹnal states is there  restricted to negated until-formulas.  The correctness of the construction is summarised in the following theorem, which is the main  contribution of the paper.  Theorem 8. Let u be a formula of LTLĂ°R; IĂ and let its ABA be given as Au Âź Ă°Q; R; d; q0 ; F Ă. Then  w 2 LĂ°Au Ă if and only if Tw ; ;  u  for every w 2 Rx . In other words, LĂ°Au Ă Âź LĂ°uĂ.  B. Bollig, M. Leucker / Data & Knowledge Engineering 44 (2003) 219â238  233  Proof. For w 2 Rx , we have to show that Au has an accepting run on w iďŹ Tw  u. Note that every  run has (at most) three types of paths:  â˘ ďŹnite paths ending in tt,  â˘ inďŹnite paths on which from some point on every node is labelled by an until- or diamondformula, or  â˘ inďŹnite paths on which from some point on every node is labelled by a negated until- or diamond- formula.  Let us give a sketch of the proof. For w 2 eclĂ°uĂ and w Âź aw0 2 Rx , let dĂ°w; wĂ be the extension  of d deďŹned by dĂ°w; aw0 Ă Âź dĂ°dĂ°w; aĂ; w0 Ă. By Proposition 6, dĂ°u; wĂ Âź dĂ°dĂ°u; aĂ; w0 Ă Âź dĂ°kuka ; w0 Ă  and Tw ; c  u iďŹ Tw ; ca  kuka . Now, consider an accepting run of Au . Its ďŹnite paths end in tt,  thus all proof obligations are proved. Conversely, a run should be accepted only if the ďŹnite paths  end in tt, i.e., that all proof obligations are proved. Now, let us consider the inďŹnite paths of a run.  These can only occur by unwinding a (negated) until-formula inďŹnitely often or by reading actions  independent of the one given within a diamond-formula. This can be accepted iďŹ the underlying  until-formula or diamond-formula is preceded by a negation. This is captured by the acceptance  condition for inďŹnite paths given by the ďŹnal states of the automaton.   5.2. State space  To simplify the presentation, we have deďŹned the state space of our automaton in a straightforward manner and presented a simple argument to show that it is ďŹnite. Thus, we indeed  obtained a decision procedure. Now, let us take a closer look to the states that are really needed  in our construction. In other words, let us consider the states that are reachable from the initial  state.  Given a formula u 2 LTLĂ°R; IĂ, a state w of Au , and a set Y  R, let reachY Ă°wĂ denote  the set of states reachable from w in Au by words whose actions are independent of Y. More  precisely,  reachY Ă°wĂ Âź fw0 j9w 2 R ; wIY : w0 2 stĂ°dĂ°w; wĂĂg;  where d is the extension of d deďŹned in the obvious manner.  Proposition 9. Given u 2 LTLĂ°R; IĂ, we get upper bounds for the number of states reachable from a  state of Au wrt Y inductively as follows:  â˘  â˘  â˘  â˘  â˘  jreachY Ă°ttĂj Âź 1  jreachY Ă°ffĂj Âź 1  jreachY Ă°:wĂj Âź jreachY Ă°wĂj  jreachY Ă°w1 _ w2 Ăj 6 jreachY Ă°w1 Ăj Ăž jreachY Ă°w2 Ăj  jreachY Ă°w1 ^ w2 Ăj 6 jreachY Ă°w1 Ăj Ăž jreachY Ă°w2 Ăj  â˘ jreachY Ă°haiwĂj 6  jreachY Ă°wĂj Ăž jreachY [fag Ă°wĂj Ăž 1  jreachY [fag Ă°wĂj Ăž 1  if aIY  if aDY  234  â˘  B. Bollig, M. Leucker / Data & Knowledge Engineering 44 (2003) 219â238  jreachY Ă°fuY11 ; . . . ; uYnn gUZ wĂj 6 22  Pn  iÂź1  Ă°jreachY Ă°ui Ăj!2jRj Ă  ! 2jRj ! 22  jreachY Ă°wĂj  :  Proof. The obvious cases are if the state formula is tt or ďŹ.  Since negation is shifted inwards by the dual operator , the states reachable from :w are the  same states as reachable from w, except that every state is preceded by :. Thus, the cardinality is  the same.  Given haiw, assume a to be independent of Y. Reading an action dependent on but diďŹerent  from a (and independent of Y) yields the state ďŹ and in our formula the 1. Reading a yields the  state w, thus, the states reachable from w are obviously reachable from haiw Ă°jreachY Ă°wĂjĂ. The  last possibility is reading an action b independent of a and Y. This yields formulas of the form  haiw0 where w0 is obtained by rewriting w by actions independent of Y and a. Since haiw0 distributes over disjunctions and conjunctions, we get the same number of states as obtained by  considering the states reachable from w by words independent of Y [ fag (jreachY [fag Ă°wĂj).  The bound for until-formulas follows by a simple combinatorial argument. Before and after the  U within an until-formula, only positive Boolean combinations of derivations of respectively U  and w may occur, and the U is indexed with subsets of R.   Let us call the fragment of LTL deďŹned without until-formulas HennessyâMilner fragment.  Proposition 10. Given a formula w from the HennessyâMilner fragment of LTLĂ°R; IĂ, we obtain  reachY Ă°wĂ 6 jwjjRY j .  Proof. The proof follows a simple induction of which we pick out two cases:  â˘ Applying Proposition 9, the induction hypothesis, and the binomial formula,  jRY j  jreachY Ă°w1 _ w2 Ăj 6 jreachY Ă°w1 Ăj Ăž jreachY Ă°w2 Ăj 6 jw1 j  jRY j  Ăž jw2 j  3  6 Ă°jw1 j Ăž jw2 j Ăž 1Ă  jRY j  :  â˘ Assuming aIY ,  jreachY Ă°haiwĂj 6 jreachY Ă°wĂj Ăž jreachY [fag Ă°wĂj Ăž 1 6 jwjjRY j Ăž jwjjRY j1 Ăž 1  6 Ă°jwj Ăž 1ĂjRY j :    Due to the exponential blow-up the construction of an equivalent BâŹ  uchi automaton for Au  causes, we conclude.  Theorem 11. Checking satisfiability of a formula from the HennessyâMilner fragment of LTLĂ°R; IĂ  can be done in exponential time.  5.3. LTL and linear automata  Now we characterise LTLĂ°R; IĂ as equivalent to that subclass of ABA that we called traceconsistent linear ABA, and we start observing the linearity of the above construction.  3  Ă°a Ăž bĂn Âź     n ni i  a b.  iÂź0  i  Pn  B. Bollig, M. Leucker / Data & Knowledge Engineering 44 (2003) 219â238  235  Proposition 12. Given u 2 LTLĂ°R; IĂ, Au is linear.  Proof. We have to show that the transition function only admits trivial cycles. Therefore we deďŹne  a well-founded strict ordering relation 4 & on the states of our automaton and show that kwka  yields a Boolean combination of strictly smaller states or w.  For a formula g 2 LTLĂ°R; IĂ, & eclĂ°gĂ  eclĂ°gĂ is inductively deďŹned by  â˘  â˘  â˘  â˘  â˘  u & haiu,  haiu & haiw if u & w,  u & :w if u & w,  wY11 & wY22 if w1 ' w2 and Y1 ( Y2 and one of the orderings is strict, i.e., w1 & w2 or Y1 )Y2 ,  _ ^ uij & _ ^ wij if fuij g ) fwij g where ) is the (strict) (multi-)set ordering induced by &, i.e.,  M1 ) M2 iďŹ there exist a set X and an element m 2 M2 with m0 & m for all m0 2 X such that  M1 Âź Ă°M2  fmgĂ [ X . In other words, a set M1 is smaller than M2 if an element of M2 is replaced by a set of smaller elements resulting in M1 .  â˘ w0 & UUZ w if w0 & w,  â˘ _ ^ uij & UUZ w if fuRij g ) U,  â˘ U1 UZ1 w1 & U2 UZ2 w2 if U1 )U2 and Z1 ( Z2 and w1 ' w2 and one of the orderings is strict, i.e.,  U1 ) U2 or Z1 )Z2 or w1 & w2 , where ) is the reďŹexive closure of ),  and contains its transitive closure. Here, ' is the reďŹexive closure of &.  We easily verify that, given formulas u, w 2 eclĂ°gĂ, an action a 2 R, and a minimal model W of  kwka with u 2 W, it holds u ' w and furthermore that for arbitrary u; w 2 eclĂ°gĂ, u &Ăž w implies  u 6Âź w. We conclude the linearity of our construction.   Theorem 13. Let A Âź Ă°Q; R; d; q0 ; F Ă be a trace-consistent linear ABA. There is a formula u 2  LTLĂ°R; IĂ such that  Tw ; ;  u if and only if w 2 LĂ°AĂ  for every w 2 Rx . In other words, LĂ°uĂ Âź LĂ°AĂ.  Before we are going to prove the previous theorem, let us mention two facts:  Proposition 14. Let A Âź Ă°Q; R; d; q0 ; F Ă be a linear ABA. There is a formula u 2 LTLĂ°RĂ such that  LĂ°uĂ Âź LĂ°AĂ.  Proposition 15. Let L  Rx and I  R  R be an independence relation. Then the following statements are equivalent.  1. L is trace-consistent wrt I and LTLĂ°RĂ-definable.  2. fTw jw 2 Lg is FOĂ°R; IĂ-definable.  3. fTw jw 2 Lg is LTLĂ°R; IĂ-definable.  4  That is, a transitive and acyclic relation.  236  B. Bollig, M. Leucker / Data & Knowledge Engineering 44 (2003) 219â238  Proposition 14 was independently shown by [18] and [14]. As aforementioned in the introduction, the equivalence of (1) and (2) traces back to [5], that one between (2) and (3) back to [3].  Now, we are ready to prove Theorem 13.  Proof. In accordance with Proposition 14, given a trace-consistent linear ABA A, there is a  formula w 2 LTLĂ°RĂ satisfying LĂ°wĂ Âź LĂ°AĂ where LĂ°wĂ is likewise trace consistent. Employing the equivalences from Proposition 15, it immediately follows the existence of a formula  u 2 LTLĂ°R; IĂ with Tw ; ;  u if and only if w 2 LĂ°AĂ for every w 2 Rx .   Let us bring out two important consequences of the last theorem:  1. Given an LTL formula u over Mazurkiewicz traces, it is simple to construct a trace-consistent  LTL formula w over words deďŹning the same set of x-words. Just construct Au , and for Au , a  corresponding formula w according to the proof given in [14].  2. Partial-order reduction techniques work for LTL over Mazurkiewicz traces. Given an LTL formula u over Mazurkiewicz traces, consider its automaton Au . It is a linear trace-consistent  automaton over words. For this kind automata, several powerful partial-order reduction techniques have been developed, which will have the same success here [16]. Hence, specifying with  LTL over Mazurkiewicz traces promisesââdespite the bad worst-case runtime of its decision  procedureââeďŹcient veriďŹcation tasks in practice.  Note that the ďŹrst item even implies that the languages deďŹnable by LTL-formulas over  Mazurkiewicz traces are FO-deďŹnable over Mazurkiewicz traces. Thus, we obtained one direction  of the expressive completeness proof given in [3].  6. Conclusion  We have exhibited a decision procedure demonstrating that the classical automataâtheoretic  approach can be generalised to conďŹguration based temporal logics for traces such as LTL. In  particular, Theorem 8 asserts that it is possible to directly construct an ABA accepting the set of  linearisations of traces satisfying the formula at hand.  The main idea underlying this construction is to use a notion of independence-rewriting to an  extended subformula closure. It easily follows from [24] that this closure must be of nonelementary size and, moreover, that this is unavoidable for any decision procedure directly generalising the classical automataâtheoretic approach.  Our approach clearly yields an optimal (non-elementary) decision procedure and shares this  similarity with [7]. We are sure that an actual implementation of our approach would compare  favourably due to the fact that the automata need not necessarily be constructed in full and especially because it avoids an exponential blow-up for negation.  We showed that trace-consistent linear automata correspond to LTL over Mazurkiewicz traces  wrt language deďŹnability, transferring a similar result shown in [14] from the setting of words to  the setting of traces. As a consequence, it is quite natural to construct trace-consistent linear  B. Bollig, M. Leucker / Data & Knowledge Engineering 44 (2003) 219â238  237  automata as a tool to answer the satisďŹability problem, and our approach exactly follows this  idea.  It is easy to adapt our decision procedure for the unary fragment of LTL, where the untilmodality is replaced by an eventually-modality with the obvious semantics. Unfortunately, it  remains an open question whether the decision procedure obtained in this way is optimal.  Acknowledgement  We would like to thank Jesper G. Henriksen for fruitful discussions and valuable comments on  this work.  References  [1] R. Alur, D. Peled, W. Penczek, Model checking of causality properties, in: Proceedings of the 10th Annual IEEE  Symposium on Logic in Computer Science (LICSâ95), IEEE Computer Society Press, San Diego, California, 1995,  pp. 90â100.  [2] O. Bernholtz, M.Y. Vardi, P. Wolper, An automataâtheoretic approach to branching-time model checking, in:  D.L. dill (Ed. ), Proceedings of the 6th International Conference on Computer-Aided VeriďŹcation (CAVâ94), vol.  818 of Lecture Notes in Computer Science, Springer, 1994, pp. 142â155.  [3] V. Diekert, P. Gastin, LTL is expressively complete for Mazurkiewicz traces, in: Proceedings of International  Colloquim on Automata, Languages and Programming (ICALPâ2000), vol. 1853 Lecture Notes in Computer  Science, Springer, 2000, pp. 211â222.  [4] V. Diekert, G. Rozenberg (Eds. ), The Book of Traces, World ScientiďŹc, Singapore, 1995.  [5] W. Ebinger, A. Muscholl, Logical deďŹnability on inďŹnite traces, Theor. Comput. Sci. 154 (1) (1996) 67â84.  [6] P. Gastin, R. Meyer, A. Petit, A (non-elementary) modular decision procedure for LTrL, in: MFCS: Symposium  on Mathematical Foundations of Computer Science, Lecture Notes in Computer Science, vol. 1450, 1998.  [7] P. Gastin, R. Meyer, A. Petit. A (non-elementary) modular decision procedure for LTrL. Technical report, LSV,  ENS de Cachan, 1998, extended version of MFCSâ98.  [8] J.-C. Gregoire, G.J. Holzmann, D.A. Peled, (Eds. ), The Spin VeriďŹcation System, vol. 32 of DIMACS series,  American Mathematical Society, 1997, ISBN 0-8218-0680-7, p. 203.  [9] J.G. Henriksen, J.L. Jensen, M.E. JĂ¸rgensen, N. Klarlund, R. Paige, T. Rauhe, A. Sandholm, Mona: Monadic  second-order logic in practice, in: E. Brinksma, R. Cleaveland, K.G. Larsen, T. Margaria, B. SteďŹan (Eds. ), Tools  and Algorithms for the Construction and Analysis of Systems, vol. 1019 of Lecture Notes in Computer Science,  Springer, 1995, pp. 89â110.  [10] H.W. Kamp. Tense Logic and the Theory of Linear Order, Ph.D. thesis, University of California, Los Angeles,  1968.  [11] O. Kupferman, M.Y. Vardi, An automataâtheoretic approach to reasonings about inďŹnite-state systems, in: E.A.  Emerson, A.P. Sistla (Eds. ), Proceedings of the 12th International Conference on Computer-Aided VeriďŹcation  (CAVâ00), vol. 1855 of Lecture Notes in Computer Science, Springer, 2000.  [12] O. Kupferman, M.Y. Vardi, P. Wolfer, An automataâtheoretic approach to branching-time model checking,  J. ACM 47 (2) (2000) 312â360.  [13] M. Leucker, Logics for Mazurkiewicz traces. Ph.D. thesis, Lehrstuhl fâŹ  ur Informatik II, RWTH Aachen, 2002. Also  appeared as Technical Report 2002-10, RWTH Aachen.  [14] C. LâŹ  oding, W. Thomas, Altering automata and logics over inďŹnte words, in: Proceedings of the IFIP International  Conference on Theoretical Computer Science, IFIP TCS2000, vol. 1872 of Lecture Notes in Computer Science,  Springer, 2000, pp. 521â535.  [15] A. Mazurkiewicz, Concurrent program schemes and their interpretations, DAIMI Rep. PB 78, Aarhus, 1977.  238  B. Bollig, M. Leucker / Data & Knowledge Engineering 44 (2003) 219â238  [16] D. Peled, Ten years of partial order reduction, in: Proceedings of 10th International Conference on ComputerAideds VeriďŹcation (CAVâ98), vol. 1427 of Lecture Notes in Computer Science, Springer, Vancouver, BC, Canada,  1998, pp. 17â28.  [17] A. Pneuli, The temporal logic of programs, in: Proceedings of the 18th IEEE Symposium on the Foundations of  Computer Science (FOCS-77), Providence, Rhode Island, October 31âNovember 2, 1977, IEEE Computer Society  Press.  [18] S. Rohde, Alternating automata and the temporal logic of ordinals, Ph.D. thesis, University of Illinois at UrbanaChampaign, 1997.  [19] P.S. Thiagarajan, A trace based extension of linear time temporal logic, in: Proceedings of the Ninth Annual IEEE  Symposium on Logic in Computer Science, Paris, France, 4â7 July, IEEE Computer Society Press, 1994, pp. 438â  447.  [20] P.S. Thiagarajan, I. Walukiewicz, An expressively complete linear time temporal logic for Mazurkiewicz traces. in:  Proceedings, Twelth Annual IEEE Symposium on Logic in Computer Science, Warsaw, Poland, 29 Juneâ2 July,  IEEE Computer Society Press, 1997, pp. 183â194.  [21] A. Valmari, A stubborn attack on state explosion, in: E.M. Clarke, R.P. Kurshan (Eds. ), Proceedings of  Computer-Aided VeriďŹcation (CAVâ90), vol. 531 of Lecture Notes in Computer Science, Springer, Berlin,  Germany, 1991, pp. 156â165.  [22] M.Y. Vardi, P. Wolper, An automataâtheoretic approach to automatic program veriďŹcation, in: Symposium on  Logic in Computer Science (LICSâ86), IEEE Computer Society Press, Washington, DC , USA, 1986, pp. 332â345.  [23] M.Y. Vardi, in: An AutomataâTheoretic Approach to Linear Temporal Logic, vol. 1043 of Lecture Notes in  Computer Science, Springer, New York, NY, USA, 1996, pp. 238â266.  [24] I. Walukiewicz, DiďŹcult conďŹgurationsââon the complexity of LTrL, in: K.G. Larsen, S. Skyum, G. Winskel  (Eds. ), Proceedings of 25th International Colloquium on Automata, Languages and Programming (ICALPâ98),  vol. 1443 of Lecture Notes in Computer Science, 1998, pp. 140â151.  Benedikt Bollig received his M.Sc. degree (Dipl.-Inform.) in Computer Science in 2000 from the University of  Technology Aachen (RWTH Aachen). He is currently doing his Ph.D. degree in Computer Science at Lehrstuhl fâŹ  ur Informatik II, RWTH Aachen. His research interests include model checking, Mazurkiewicz  traces, and message sequence charts.  Martin Leucker received his M.Sc. degree (Dipl.-Math.) in Mathematics in 1996 from the University of  Technology Aachen (RWTH Aachen). He got his Ph.D. degree (Dr. rer. nat.) at Lehrstuhl fâŹ  ur Informatik II,  RWTH Aachen. In his thesis, he studied several logics for Mazurkiewicz traces. Currently, he is a postdoctoral researcher at the University of Pennsylvania, USA. 