Reasoning with Ã¢Â€Â˜And ThenÃ¢Â€Â™ and Ã¢Â€Â˜WhileÃ¢Â€Â™Ã¢ÂˆÂ—  (Extended Abstract)  Suman Roy  Honeywell Technology Solutions Lab. (HTSL)  151/1, Doraisanipalya, Bannerghatta Road, Bangalore 560 076, India  suman.roy@honeywell.com  Guido Sciavicco  Department of Information and Communications Engineering  University of Murcia  Murcia E-30100 - Campus de Espinardo, Spain  guido@um.es  Abstract  Interval-based temporal logics are natural frameworks for  modeling a number of problems from various areas of computer science such as artiÄÅ¹Âcial intelligence, natural language processing, temporal databases and formal speciÄÅ¹Âcation. Quite a few interval-based temporal logics became popular in recent years, such as VenemaÃ¢Â€Â™s CDT logic,  Halpern and ShohamÃ¢Â€Â™s HS logic, MoszkowskiÃ¢Â€Â™s ITL and its  propositional version, and Goranko, Montanari, and SciaviccoÃ¢Â€Â™s PNL. In this work we introduce a new propositional interval-based temporal logic called CW, which can  be considered an extension of the propositional fragment of  MoszkowskiÃ¢Â€Â™s ITL evaluated over different (parallel) lines,  and which is particularly adapt for expressing natural language sentences. We study the logic CW and develop a  (non-terminating) sound and complete deduction system  based on tableaux for it.  1 Introduction  Modal logics of time, both at the propositional and the ÄÅ¹Ârstorder level, have found a wide variety of applications in  computer science. Such formalisms constitute a natural  framework for reasoning about action and change, temporal  qualitative reasoning, planning, and natural language processing; moreover, temporal logics have been successfully  used in the areas of speciÄÅ¹Âcation and automatic veriÄÅ¹Âcation  Ã¢ÂˆÂ— This work does not necessarily reÄÅ¹Â‚ect the research policies of HTSL,  nor does it discourage such kind of work among its employees  of programs, and temporal (and spatio-temporal) databases.  But, while temporal logics based on points have been deeply  studied, interval-based ones have received less attention in  the literature. One reason of such a disparity is that interval temporal logics exhibit, in general, a bad computational  behavior, due to their high expressive power and versatility;  moreover, from the classical point of view, interval-based  temporal languages correspond to fragments of ÄÅ¹Ârst-order  languages with binary predicates, while point-based ones  correspond to fragments with unary predicates.  Earlier work on propositional interval-based temporal logics include VenemasÃ¢Â€Â™s CDT [Ven91, GMSS06], Goranko,  Montanari, and Sciavicco Propositional Neighborhood  Logics [GMS03b], MoszkowskiÃ¢Â€Â™s PITL [Mos83], later  studied by Bowman and Thompson [BT03], Rosner and  PnueliÃ¢Â€Â™s point-based temporal logic DUXC with chop (also  know as and then) [RP86], Barua, Roy and ZhouÃ¢Â€Â™s ÄÅ¹Ârstorder Neighborhood Logic [BRZ00], and DutertreÃ¢Â€Â™s ÄÅ¹Ârstorder generalization of PITL [Dut95].  In both PITL and CDT the language includes the binary  interval operator chop. Given two intervals [d0 , d1 ] and  [d1 , d2 ] over a linearly ordered set, the chop operator allows one to express properties of both the two intervals  and the interval [d0 , d2 ] (the sequencing of the two intervals) at the same time. As noticed in [Ven91] by Venema,  and in [LR00], the chop operator presents interesting applications and analogies with natural language expressions.  In [LR00] a new temporal operator called while has been  introduced, and denoted by ||; it allows one to consider  different Ã¢Â€Â˜parallelÃ¢Â€Â™ lines of evaluation of the same interval.  For example, the formula p||q is interpreted as p while q,  where p and q are two propositional letters interpreted over  14th International Symposium on Temporal Representation and Reasoning (TIME'07  0-7695-2836-8/07 $20.00 Ã‚Å  2007  intervals. In this paper, we concentrate on the combined  logic CW (Chop-While), which is a propositional intervalbased temporal logic with different lines of evaluation, and  featuring the operators C, ||, and the modal constant ÄÂ€ for  point-intervals. CW is interpreted over a sequence of parallel time lines, each one of which can be viewed as a copy  of the same linearly ordered set. As we shall see, the logic  CW allows one to express natural languages sentences in a  very easy way, and thus it facilitates immediate applications  in understanding and reasoning about natural languages.  2 Syntax and Semantics of Chop-While  In this section we study a new interval logic called ChopWhile (CW) which can be viewed as the generalization of  C [Mos83, RS07, BT03, Dut95] to different (parallel) lines.  This logic, with a slightly different semantics, has been  originally introduced in [LR00].  ÄÂ†  ÄÂ•  Figure 1. A pictorial representation of the formula (ÄÂ†ÄÂˆ)||ÄÂ•  dik = djk . We also deÄÅ¹Âne the relation P Ã¢ÂŠÂ‚ I(D) Ä‚Â— I(D)  deÄÅ¹Âned as P ([dih , djh ], [dik , djk ]) if and only if h = k.  Thus, a CW-model can be viewed as a tuple MCW =  I(D), A, P, ÃÂ , VCW . The intuitive picture of the chop  operator is shown in Figure 1. The truth of a given CWformula ÄÂ† is given by the following clauses:  Ã¢Â€Ë˜ MCW , [dik , djk ]  ÄÂ€ iff for  [dih , djh ] Ã¢ÂˆÂˆ ÃÂ ;  The language of CW features a set of propositional letters  AP = {p, q, . . . }, the classical operators Ã‚Å¹, Ã¢ÂˆÂ¨ (the remaining ones can be considered as abbreviations), and the binary  modalities C, ||, in addition to the modal constant ÄÂ€. Wellformed formulas can be obtained by the following abstract  grammar:  each Dh Ã¢ÂˆÂˆ D,  Ã¢Â€Ë˜ MCW , [dik , djk ]  p iff p Ã¢ÂˆÂˆ VCW ([dik , djk ]);  Ã¢Â€Ë˜ MCW , [dik , djk ]  Ã‚Å¹ÄÂˆ iff it is not the case that  MCW , [dik , djk ]  ÄÂˆ;  Ã¢Â€Ë˜ MCW , [dik , djk ]  ÄÂˆ Ã¢ÂˆÂ¨ ÄÂ• iff MCW , [dik , djk ]  ÄÂˆ or  MCW , [dik , djk ]  ÄÂ•;  ÄÂ† = ÄÂ€ | p | Ã‚Å¹ÄÂ† | ÄÂ† Ã¢ÂˆÂ¨ ÄÂˆ | ÄÂ†CÄÂˆ | ÄÂ†||ÄÂˆ,  Ã¢Â€Ë˜ MCW , [dik , djk ]  ÄÂ†||ÄÂˆ iff MCW , [dik , djk ]   ÄÂ† and there exists some Dh Ã¢ÂˆÂˆ D such that  P ([dik , djk ], [dih , djh ]) and MCW , [dih , djh ]  ÄÂˆ;  where p Ã¢ÂˆÂˆ AP.  The models of CW are given in terms of parallel evaluation lines. We consider a set of linearly ordered set  D1 , <, D2 , <, . . . , Dn , <. We call CW-structure the  set D = {D1 , D2 , . . . , Dn }. The linearly ordered sets  are pairwise isomorphic, and theirs elements are denoted  here by di1 , dj1 , . . . Ã¢ÂˆÂˆ D1 , . . ., din , djn , . . . Ã¢ÂˆÂˆ Dn , and  so on; thus, for example, the element d34 is the third element of the fourth domain. For a given Dk , consider  the set of all intervals   that can be built on it, denote it by,  I(Dk ); let I(D) = nh=1 I(Dh ). A CW-model is a tuple  MCW = D, I(D), VCW , where VCW is a valuation function such that, for each linearly ordered set Dk Ã¢ÂˆÂˆ D and  interval [dik , djk ], it assigns a truth value to each propositional variable p Ã¢ÂˆÂˆ AP . In terms of classical modal  logic, we can deÄÅ¹Âne Kripke-style models of CW as follows. Let A be the relation A Ã¢ÂŠÂ† I(D) Ä‚Â— I(D) Ä‚Â— I(D),  where D Ã¢ÂˆÂˆ D is deÄÅ¹Âned in such a way that for all intervals [dik , djk ], [dik , djk ], [dik , djk ] Ã¢ÂˆÂˆ I(D), the triple  ([dik , djk ], [dik , djk ], [dik , djk ]) Ã¢ÂˆÂˆ A if and only if dik =  dik , djk = djk , and djk = dik (this is exactly VenemaÃ¢Â€Â™s  chop relation [Ven91]), and let ÃÂ  Ã¢ÂŠÂ† I(D) be a predicate  deÄÅ¹Âned in such a way that [dik , djk ] Ã¢ÂˆÂˆ ÃÂ  if and only if  ÄÂˆ  Ã¢Â€Ë˜ MCW , [dik , djk ]    ÄÂ†CÄÂˆ iff there are two  intervals [dlk , dmk ] and [dlk , dmk ] such that  A([dlk , dmk ], [dlk , dmk ], [dik , djk ]),  M, [dlk , dmk ]   ÄÂ†, and M, [dlk , dmk ]  ÄÂˆ.  Notice that, since intervals should behave the same way  over all parallel lines, whenever we encounter a ÄÂ€ over  some interval [dik , djk ], all the intervals which are parallel to it (including [dik , djk ] itself) must be point-intervals.  The concepts of satisÄÅ¹Âability, validity in a model, and validity are deÄÅ¹Âned in the usual way.  In the language of CW, we can deÄÅ¹Âne the during operator 3ÄÂ† as C(ÄÂ† Ã¢ÂˆÂ¨ ( ||ÄÂ†))C , which says that ÄÂ† holds  somewhere within an interval, its dual operator (throughout) 2ÄÂ† = Ã‚Å¹3Ã‚Å¹ÄÂ†, and the dual of the parallel operator:  p ||i q = p Ã¢ÂˆÂ§ Ã‚Å¹( ||Ã‚Å¹q), which means that p is true on the  current line and q is true on any other line, if any.  It is simple to see that the satisÄÅ¹Âability problem for CW is  not decidable. Indeed, in [Lod00] it has been shown that  14th International Symposium on Temporal Representation and Reasoning (TIME'07  0-7695-2836-8/07 $20.00 Ã‚Å  2007  CharacterÃ¢Â€Â™s name  Cornelia  CharacterÃ¢Â€Â™s reasoning  (J Ã¢ÂˆÂ§ S Ã¢ÂˆÂ§ CO Ã¢ÂˆÂ§ (J.drunk C S.shot.at CJ.hysterical)) C(J Ã¢ÂˆÂ§ CO Ã¢ÂˆÂ§ Ã‚Å¹S Ã¢ÂˆÂ§ (J.hysterical  C J.sedated))||(S Ã¢ÂˆÂ§ S.hurt)) C(S Ã¢ÂˆÂ§ CO Ã¢ÂˆÂ§ Ã‚Å¹J Ã¢ÂˆÂ§ ((S.hurt C S.bullet C S.sedated)  ||(J Ã¢ÂˆÂ§ J.sedated)) C((Ã‚Å¹CO Ã¢ÂˆÂ§ S Ã¢ÂˆÂ§ S.sedated)||(Ã‚Å¹CO Ã¢ÂˆÂ§ J Ã¢ÂˆÂ§ J.sedated)) Ã¢Â†Â’  2((J Ã¢ÂˆÂ§ CO) Ã¢ÂˆÂ¨ (J Ã¢ÂˆÂ§ J.sedated)) Ã¢ÂˆÂ§ 2((S Ã¢ÂˆÂ§ CO) Ã¢ÂˆÂ¨ (S Ã¢ÂˆÂ§ (S.hurt Ã¢ÂˆÂ¨ S.sedated)))  Poirot  (JÃ¢ÂˆÂ§SÃ¢ÂˆÂ§COÃ¢ÂˆÂ§(J.drunk C S.shot.at C J.hysterical)) C((JÃ¢ÂˆÂ§COÃ¢ÂˆÂ§Ã‚Å¹SÃ¢ÂˆÂ§(J.hysterical C  J.sedated))||i (SÃ¢ÂˆÂ§(Ã‚Å¹S.hurt C S.murder C S.shoots.leg C S.hurt)) C((SÃ¢ÂˆÂ§COÃ¢ÂˆÂ§Ã‚Å¹JÃ¢ÂˆÂ§  (S.hurt C S.bullet C S.sedated))||i (J Ã¢ÂˆÂ§ J.sedated))C ((Ã‚Å¹CO Ã¢ÂˆÂ§ S Ã¢ÂˆÂ§ S.sedated)||i  (Ã‚Å¹CO Ã¢ÂˆÂ§ J Ã¢ÂˆÂ§ J.sedated))))  Figure 2. Cornelia and PoirotÃ¢Â€Â™s reasoning put in a logical formula.  the logic C (with chop and ÄÂ€ only) is not decidable over  dense linearly ordered sets. When C is interpreted in the  class of all linearly ordered sets, the denseness property can  be deÄÅ¹Âned by a valid formula, and, since it is possible to  express in C (a sort of) universal modality, it is easy to show  that the satisÄÅ¹Âability problem for C is not decidable. Thus,  we have that also the satisÄÅ¹Âability problem for CW is not  decidable.  2.1  Using CW  In this section, we show how CW can be used to formalize a  natural language expression by using a non-trivial example.  the assumption that he was hurt, he could not do  the murder. But if he was not shot, he could do  it. During the second interval that Cornelia was  with Simon, the doctor removed the bullet from  his leg, he must have been shot by then. That is  still consistent if JackieÃ¢Â€Â™s shot did not hit him, his  fall was faked, and while he was alone, he did the  murder and then shot himself at the leg.  The logic CW is powerful enough to express both CorneliaÃ¢Â€Â™s version of the facts (ÄÂ†Cornelia ), and PoirotÃ¢Â€Â™s reasoning (ÄÂ†P oirot ), as shown in Figure 2 above. Clearly, if  the Poirot is right, it must be the case that the following  formula is valid:  ÄÂ†Cornelia Ã¢Â†Â’ ÄÂ†P oirot .  Example 1 We borrow the next example from [LR00].  In the Agatha Christie novel Death on the  Nile [Chr56], the two main suspects are Simon,  husband of the murdered woman, and Jackie, his  ex-girlfriend. On the evening of the murder, Cornelia, a witness, is with Simon and Jackie. Jackie  gets drunk and shoots at Simon. He falls down.  Simon asks Cornelia to bring a doctor, and to take  the hysterical Jackie with her. Cornelia does so.  The doctor gives Jackie a sedative and she goes  to sleep. Cornelia brings the doctor where Simon  is. The doctor pulls out the bullet from SimonÃ¢Â€Â™s  leg and gives him sedative, he goes to sleep. By  the morning the murder has taken place. Cornelia reasons: while she was with Jackie (and not  with Simon), he was shot and hurt, and later in  the night, Simon was sedated, otherwise she was  always with Simon. While she was with Simon  (and not with Jackie), he was sedated, otherwise  she was always with Jackie. So both Jackie and  Simon have alibis. Hercule Poirot, the detective,  notices that Simon was alone for the interval that  Cornelia and Jackie went for the doctor. Under  3 Automatic Entailment in CW: a Tableaux  Method  In this section we propose a tableau method for the logic  CW. The method can be seen as an adaptation of the one  used for PNL logics [GMS03a].  3.1  Basic DeÄÅ¹Ânitions  We assume the reader is familiar with the standard notions  of ÄÅ¹Ânite tree, root of a tree, successor of a node n, leaf node  (i.e., a node with no successors), and path of nodes. During  the construction of a tableaux for a given formula, we will  consider a single branch (unless otherwise speciÄÅ¹Âed). We  deÄÅ¹Âne the height of a node n as the maximum length (number of edges) of a path from n to a leaf. The expression n Ã¢Â‰ÅŸ  n (resp. n  n ) means that, for two nodes n, n belonging  to the same branch, that the height of n is less than (resp.  less than or equal to) the height of n .  We consider a collection C1 , <, C2 , <, . . . , Cn , < of  linearly ordered sets, and denote C = {C1 , C2 , . . . , Cn }.  14th International Symposium on Temporal Representation and Reasoning (TIME'07  0-7695-2836-8/07 $20.00 Ã‚Å  2007  ÄÂ†  Ã‚Å¹Ã‚Å¹ÄÂˆ  ÄÂˆ0 Ã¢ÂˆÂ§ ÄÂˆ1  Ã‚Å¹(ÄÂˆ0 Ã¢ÂˆÂ§ ÄÂˆ1 )  Ã‚Å¹(ÄÂˆ0 CÄÂˆ1 )  Ã‚Å¹(ÄÂˆ0 ||ÄÂˆ1 )  ÄÂˆ0 CÄÂˆ1  (ÄÂˆ0 ||ÄÂˆ1 )  Expansion rule for the node n and the branch B  expand the branch to B Ã‚Ë‡ n0 , with ÄÂ(n0 ) = ((ÄÂˆ, [cik , cjk ]), CB , u)  expand the branch to B Ã‚Ë‡ n0 Ã‚Ë‡n1 , with ÄÂ(n0 ) = ((ÄÂˆ0 , [cik , cjk ]), CB , u) and ÄÂ(n1 ) =  ((ÄÂˆ1 , [cik , cjk ]), CB , u)  expand the branch to B Ã‚Ë‡ n0 |n1 , with ÄÂ(n0 ) = ((Ã‚Å¹ÄÂˆ0 , [cik , cjk ]), CB , u) and ÄÂ(n1 ) =  ((Ã‚Å¹ÄÂˆ1 , [cik , cjk ]), CB , u)  take the least chk Ã¢ÂˆÂˆ Ck (chk Ã¢ÂˆÂˆ [cik , cjk ]) which has not been yet used to expand the node n  on B, and expand the branch to B Ã‚Ë‡ n0 |n1 , with ÄÂ(n0 ) = ((Ã‚Å¹ÄÂˆ0 , [cik , chk ]), CB , u) and ÄÂ(n1 )  = ((Ã‚Å¹ÄÂˆ1 , [chk , cjk ]), CB , u)  take some evaluation line Cl Ã¢ÂˆÂˆ C (Cl = Ck ) such that the interval [cil , cjl ] has not been yet used to  expand the node n on B, and expand the branch to B Ã‚Ë‡ n0 |n1 , with ÄÂ(n0 ) = ((Ã‚Å¹ÄÂˆ0 , [cik , cjk ]), CB , u)  and ÄÂ(n1 ) = ((Ã‚Å¹ÄÂˆ1 , [cil , cjl ]), CB , u)  expand the branch to B Ã‚Ë‡ (ni Ã‚Ë‡ mi )| . . . |(nj Ã‚Ë‡ mj )|(ni Ã‚Ë‡ mi )| . . . |(njÃ¢ÂˆÂ’1 Ã‚Ë‡ mjÃ¢ÂˆÂ’1 ), where: (i) for all chk Ã¢ÂˆÂˆ  [cik , cjk ], ÄÂ(nk ) = ((ÄÂˆ0 , [cik , chk ]), CB , u) and ÄÂ(mk ) = ((ÄÂˆ1 , [chk , cjk ]), CB , u), and (ii) for all i Ã¢Â‰Â¤  l Ã¢Â‰Â¤ j Ã¢ÂˆÂ’ 1, let C  be the set if linearly ordered sets obtained by inserting a new element c between clz and  cl+1z (for all 1 Ã¢Â‰Â¤ z Ã¢Â‰Â¤ k), ÄÂ(nk ) = ((ÄÂˆ0 , [cik , c]), C  , u), and ÄÂ(mk ) = ((ÄÂˆ1 , [c, cjk ]), C  , u);  expand the branch to B Ã‚Ë‡ n0 Ã‚Ë‡ (n1 | . . . |nnÃ¢ÂˆÂ’1 |n ), where: (i) for all 1 Ã¢Â‰Â¤ l Ã¢Â‰Â¤ n, l =  k, ÄÂ(nl ) = ((ÄÂˆ1 , [cil , cjl ]), CB , u), (ii) ÄÂ(n0 ) = ((ÄÂˆ0 , [cik , cjk ]), CB , u), and (iii) ÄÂ(n ) =  ((ÄÂˆ1 , [cin+1 , cjn+1 ]), C  , u), where C  = CB Ã¢ÂˆÅ Cn+1 , and Cn+1 is any linear domain isomorphic to  C Ã¢ÂˆÂ— , where C Ã¢ÂˆÂ— Ã¢ÂˆÂˆ CB and |C Ã¢ÂˆÂ— | is maximal.  Table 1. Branch-expansion rules  Each one of the linearly ordered sets is composed of the  same elements (the sets Ci are pairwise isomorphic), which  are denoted here as ci1 , cj1 , . . . Ã¢ÂˆÂˆ C1 , ci2 , cj2 , . . . Ã¢ÂˆÂˆ C2 ,  and so on.  DeÄÅ¹Ânition 2 Let n be a node in a branch B of a tree T .  Ã¢Â€Ë˜ An annotated formula is a pair (ÄÂ†, [cik , cjk ]), where  ÄÂ† Ã¢ÂˆÂˆ CW and cik , cjk Ã¢ÂˆÂˆ Ck , 1 Ã¢Â‰Â¤ k Ã¢Â‰Â¤ n, where |C| = n.  Ã¢Â€Ë˜ The annotation ÄÂ(n) is a triple ((ÄÂ†, [cik , cjk ]), C,  un,B1 , . . . , un,Bq ), where (ÄÂ†, [cik , cjk ]) is an annotated formula and for each 1 Ã¢Â‰Â¤ r Ã¢Â‰Â¤ q, un,Br Ã¢ÂˆÂˆ {0, 1}  is the expansion ÄÅ¹Â‚ag, i.e., it associates the values 0 or  1 with every branch Bi in T containing n.  Ã¢Â€Ë˜ n is said to be active if and only if its ÄÅ¹Â‚ag is 0 for at  least one branch B  to which n belongs.  Ã¢Â€Ë˜ An annotated tree is a tree in which every node has an  annotation ÄÂ(n).  For a node n and a branch Br containing it, the ÄÅ¹Â‚ag is 0  when the node has not been expanded yet over Br , and 1  otherwise, except for the universal cases Ã‚Å¹C and Ã‚Å¹||, in  which the ÄÅ¹Â‚ag always remains 0. For sake of simplicity, we  will often assume an interval [cik , cjk ], from the line Ck , to  consist of the elements cik < c(i+1)k < . . . < cjk . For any  branch B in a annotated tree, we denote by CB the ordered  set in the annotation of the leaf of B, and for any node n  in a annotated tree, we denote by ÃÅš(n) the formula in its  annotation. If B is a branch, then B Ã‚Ë‡ n denotes the result  of the expansion of B with the node n (addition of an edge  connecting the leaf of B to n). Similarly, B Ã‚Ë‡ n1 | . . . | nk  denotes the result of the expansion of B with k immediate  successor nodes n1 , . . . , nk (which produces k branches  extending B). A tableau for CW will be deÄÅ¹Âned as a distinguished annotated tree. It is worth noticing that C remains  ÄÅ¹Ânite throughout the construction of the tableau.  3.2  Tableaux and Expansion Rule  Now we are ready to deÄÅ¹Âne the tableaux for CW and the  expansion rule for them.  DeÄÅ¹Ânition 3 Given an annotated tree T , a branch B in T ,  and a node n Ã¢ÂˆÂˆ B such that ÄÂ(n) = ((ÄÂ†, [cik , cjk ]), C, u),  with un,B = 0, the branch-expansion rule for B and n is  deÄÅ¹Âned as in Table 1. In all the considered cases, un ,B =  0 for all new pairs (n , B  ) of nodes and branches, and u  switches from 0 to 1 in all cases except for Ã‚Å¹C and Ã‚Å¹||.  DeÄÅ¹Ânition 4 Let B a branch of a tableau T .  14th International Symposium on Temporal Representation and Reasoning (TIME'07  0-7695-2836-8/07 $20.00 Ã‚Å  2007  Ã¢Â€Ë˜ The branch-expansion rule is applicable to a node n  on B if the node is active on B and the application of  the rule generates at least one successor node with a  new annotated formula;  Ã¢Â€Ë˜ A branch B is closed if some of the following conditions holds: (i) there are two nodes n, n Ã¢ÂˆÂˆ B such  that ÄÂ(n) = ((ÄÂˆ, [cik , cjk ]), C, u) and ÄÂ(n ) = ((Ã‚Å¹ÄÂˆ,  [cik , cjk ]), C  , u ) for some formula ÄÂˆ and cik , cjk Ã¢ÂˆÂˆ  C Ã¢ÂˆÅ  C  ; (ii) there is a node n such that ÄÂ(n) =  ((ÄÂ€, [cik , cjk ]), C, u) and cik = cjk ; (iii) there is a node  n such that ÄÂ(n) = ((Ã‚Å¹ÄÂ€, [cik , cjk ]), C, u) and cik =  cjk ; (iv) there are two nodes n, n Ã¢ÂˆÂˆ B such that ÄÂ(n)  = ((ÄÂˆ, [cik , cjk ]), C, u) and ÄÂ(n ) = ((ÄÂˆ  , [cih , cjh ]),  C  , u ) for some formulas ÄÂˆ, ÄÂˆ  , and cik = cjk (resp.,  cik = cjk ) and cih = cjh (resp., cih = cjh ); otherwise,  the branch is open (Clearly, a tableau for CW is closed  if and only if every branch in it is closed, otherwise it  is open);  Ã¢Â€Ë˜ The branch-expansion strategy for a branch B in an  annotated tree T consists of applying the branchexpansion rule to a branch B only if it is open, and, in  such a case, applying it to the ÄÅ¹Ârst active node one encounters moving from the root to the leaf of B to which  the branch-expansion rule is applicable (if any);  Ã¢Â€Ë˜ An initial tableau for a given formula ÄÂ† Ã¢ÂˆÂˆ  CW is the ÄÅ¹Ânite annotated tree T composed of  an empty root and two nodes n0 and n1 such  that ÄÂ(n0 ) = ((ÄÂ†, [c01 , c01 ]), C, 0) and ÄÂ(n1 ) =  ((ÄÂ†, [c01 , c11 ]), C  , 0), where C = {C1 }, C1 = {c01 },  C  = {C1 }, C1 = {c01 , c11 }, and c01 < c11 . A tableau  for a given formula ÄÂ† Ã¢ÂˆÂˆ CW is any ÄÅ¹Ânite annotated  tree isomorphic to a ÄÅ¹Ânite annotated tree T obtained  by expanding the initial tableau for ÄÂ† through successive applications of the branch-expansion strategy to  the existing branches.  Theorem 5 If ÄÂ† Ã¢ÂˆÂˆ CW and a tableau T for ÄÂ† is closed, then  ÄÂ† is not satisÄÅ¹Âable. Moreover, if ÄÂ† is a valid CW-formula,  then there is a closed tableau for Ã‚Å¹ÄÂ†.  3.3  In order to formalize the above situation, we will use the  following proposition letters: the symbol w denotes that the  paper is on work, dr denotes that the paper is still a draft,  and f i that it is a ÄÅ¹Ânal version. As we see in Figure 3, there  is a closed tableau for the conjunction of the formulas that  formalize the statement in the example, showing that the  described situation is not consistent. For sake of simplicity,  we have omitted some of the branches, and we used rules  for ||i and 2 which do not appear in DeÄÅ¹Ânition 8, but can be  easily deducted from the semantics of the operators.  Acknowledgement: The authors would like to thank Kamal Lodaya for his many useful suggestions and comments  about this work (he has indeed worked on some of the ideas  in this paper), and Ian Hodkinson for pointing out an important mistake in the ÄÅ¹Ârst version of the paper. The ÄÅ¹Ârst  author is grateful to the management of HTSL for constant support and encouragement during this work. This  research has been partially founded by the Spanish MEC  project IDEATIO, no. TIN2006-15460-C04-01.  References  [BRZ00]  R. Barua, S. Roy, and C. Zhou. Completeness  of neighbourhood logic. Journal of Logic and  Computation, 10(2):271Ã¢Â€Â“295, 2000.  [BT03]  H. Bowman and S. Thompson. A decision procedure and complete axiomatization of ÄÅ¹Ânite  interval temporal logic with projection. Journal of Logic and Computation, 13(2):195Ã¢Â€Â“239,  2003.  [Chr56]  A. Christie. Death on the nile. Collins (London), 1956.  [Dut95]  B. Dutertre. Complete proof systems for ÄÅ¹Ârst  order interval temporal logic. In Proc. of  the 10th International Symposium on Logic in  Computer Science, pages 36Ã¢Â€Â“43, 1995.  An Example  Finally, we consider a simple example taken from the context of natural language, and we analyze it by means of the  tableaux-based method.  Example 6 Guido works in Murcia (Spain), and Suman  works in Bangalore (India). They have been working on  the same paper. It is always true that when a paper is on  work (draft), it is not a ÄÅ¹Ânal version. During a given period  of time, the Guido has been working on a draft version of  the paper, while Suman has been working on a draft and got  a ÄÅ¹Ânal version of the paper. Is this situation consistent?  [GMS03a] V. Goranko, A. Montanari, and G. Sciavicco.  A general tableau method for propositional interval temporal logic. In Proc. of TABLEAUX  2003: 12th Conference on Automated Reasoning with Analytic Tableaux and Related Methods, volume 2796 of LNAI, pages 102Ã¢Â€Â“116,  Rome, Italy, September 2003. Springer.  [GMS03b] V. Goranko, A. Montanari, and G. Sciavicco.  Propositional interval neighborhood temporal  logics. Journal of Universal Computer Science,  9(9):1137Ã¢Â€Â“1167, 2003.  14th International Symposium on Temporal Representation and Reasoning (TIME'07  0-7695-2836-8/07 $20.00 Ã‚Å  2007  ((2(w Ã¢Â†Â’ dr)||i 2(w Ã¢Â†Â’ dr), [c01 , c11 ]), {{c01 < c11 }}, 0)  ((2(dr Ã¢Â†Â’ f i)||i 2(dr Ã¢Â†Â’ f i), [c01 , c11 ]), {{c01 < c11 }}, 0)  ((w||w C f i), [c01 , c11 ]), {{c01 < c11 }}, 1)  (w, [c01 , c11 ]), {{c01 < c11 }}, 1)  ((w C f i, [c02 , c12 ]), {{c01 < c11 }, {c02 < c12 }}, 1)  ((w, [c02 , c22 ]), {{c01 < c21 < c11 }, {c02 < c22 < c12 }}, 1)  ((f i, [c22 , c12 ]), {{c01 < c21 < c11 }, {c02 < c22 < c12 }}, 1)  gggg  ggggg  ggggg  ((Ã‚Å¹w, [c22 , c12 ], {{c01 < c21 < c11 }, {c02 < c22 < c12 }}, 1)  Ä‚Â—  (dr, [c22 , c12 ], {{c01 < c21 < c11 }, {c02 < c22 < c12 }}, 1)  g  ggggg  g  g  g  g  gggg  ((Ã‚Å¹dr, [c22 , c12 ]), {{c01 < c21 < c11 }, {c02 < c22 < c12 }}, 1)  Ä‚Â— ((Ã‚Å¹f i, [c22 , c12 ]), {{c01 < c21 < c11 }, {c02 < c22 < c12 }}, 1)  Ä‚Â—  Figure 3. A closed tableau for Example 6.  [GMSS06] V. Goranko, A. Montanari, G. Sciavicco, and  P. Sala. A general tableau method for propositional interval temporal logics: theory and  implementation. Journal of Applied Logic,  4(3):305Ã¢Â€Â“330, 2006.  [Lod00]  [LR00]  [Mos83]  puter Science, Stanford University, Stanford,  CA, 1983.  [RP86]  K. Lodaya. Sharpening the undecidability of  interval temporal logic. In Proc. of 6th Asian  Computing Science Conference, volume 1961  of LNCS, pages 290Ã¢Â€Â“298. Springer, 2000.  R. Rosner and A. Pnueli. A choppy logic.  In First Annual IEEE Symposium on Logic In  Computer Science, pages 306Ã¢Â€Â“314. IEEE Computer Society Press, 1986.  [RS07]  K. Lodaya and S. Roy. Lines, a while, and  intervals. In Proc. of ESSLLI Workshop on  Many-Dimensional Logical Systems, Birmingham, pages 1Ã¢Â€Â“8, 2000.  S. Roy and G. Sciavicco. Completeness of  chop. In H.W. Guesguen, G. Ligozat, and  R.V. Rodriguez, editors, Proc. of the IJCAI-07  Workshop on Spatial and Temporal Reasoning,  pages 90Ã¢Â€Â“95, 2007.  [Ven91]  Y. Venema. A modal logic for chopping intervals. Journal of Logic and Computation,  1(4):453Ã¢Â€Â“476, 1991.  B. Moszkowski. Reasoning about digital circuits. Tech. rep. stan-cs-83-970, Dept. of Com-  14th International Symposium on Temporal Representation and Reasoning (TIME'07  0-7695-2836-8/07 $20.00 Ã‚Å  2007 