Reasoning with âAnd Thenâ and âWhileââ  (Extended Abstract)  Suman Roy  Honeywell Technology Solutions Lab. (HTSL)  151/1, Doraisanipalya, Bannerghatta Road, Bangalore 560 076, India  suman.roy@honeywell.com  Guido Sciavicco  Department of Information and Communications Engineering  University of Murcia  Murcia E-30100 - Campus de Espinardo, Spain  guido@um.es  Abstract  Interval-based temporal logics are natural frameworks for  modeling a number of problems from various areas of computer science such as artiďŹcial intelligence, natural language processing, temporal databases and formal speciďŹcation. Quite a few interval-based temporal logics became popular in recent years, such as Venemaâs CDT logic,  Halpern and Shohamâs HS logic, Moszkowskiâs ITL and its  propositional version, and Goranko, Montanari, and Sciaviccoâs PNL. In this work we introduce a new propositional interval-based temporal logic called CW, which can  be considered an extension of the propositional fragment of  Moszkowskiâs ITL evaluated over different (parallel) lines,  and which is particularly adapt for expressing natural language sentences. We study the logic CW and develop a  (non-terminating) sound and complete deduction system  based on tableaux for it.  1 Introduction  Modal logics of time, both at the propositional and the ďŹrstorder level, have found a wide variety of applications in  computer science. Such formalisms constitute a natural  framework for reasoning about action and change, temporal  qualitative reasoning, planning, and natural language processing; moreover, temporal logics have been successfully  used in the areas of speciďŹcation and automatic veriďŹcation  â This work does not necessarily reďŹect the research policies of HTSL,  nor does it discourage such kind of work among its employees  of programs, and temporal (and spatio-temporal) databases.  But, while temporal logics based on points have been deeply  studied, interval-based ones have received less attention in  the literature. One reason of such a disparity is that interval temporal logics exhibit, in general, a bad computational  behavior, due to their high expressive power and versatility;  moreover, from the classical point of view, interval-based  temporal languages correspond to fragments of ďŹrst-order  languages with binary predicates, while point-based ones  correspond to fragments with unary predicates.  Earlier work on propositional interval-based temporal logics include Venemasâs CDT [Ven91, GMSS06], Goranko,  Montanari, and Sciavicco Propositional Neighborhood  Logics [GMS03b], Moszkowskiâs PITL [Mos83], later  studied by Bowman and Thompson [BT03], Rosner and  Pnueliâs point-based temporal logic DUXC with chop (also  know as and then) [RP86], Barua, Roy and Zhouâs ďŹrstorder Neighborhood Logic [BRZ00], and Dutertreâs ďŹrstorder generalization of PITL [Dut95].  In both PITL and CDT the language includes the binary  interval operator chop. Given two intervals [d0 , d1 ] and  [d1 , d2 ] over a linearly ordered set, the chop operator allows one to express properties of both the two intervals  and the interval [d0 , d2 ] (the sequencing of the two intervals) at the same time. As noticed in [Ven91] by Venema,  and in [LR00], the chop operator presents interesting applications and analogies with natural language expressions.  In [LR00] a new temporal operator called while has been  introduced, and denoted by ||; it allows one to consider  different âparallelâ lines of evaluation of the same interval.  For example, the formula p||q is interpreted as p while q,  where p and q are two propositional letters interpreted over  14th International Symposium on Temporal Representation and Reasoning (TIME'07  0-7695-2836-8/07 $20.00 ÂŠ 2007  intervals. In this paper, we concentrate on the combined  logic CW (Chop-While), which is a propositional intervalbased temporal logic with different lines of evaluation, and  featuring the operators C, ||, and the modal constant Ď for  point-intervals. CW is interpreted over a sequence of parallel time lines, each one of which can be viewed as a copy  of the same linearly ordered set. As we shall see, the logic  CW allows one to express natural languages sentences in a  very easy way, and thus it facilitates immediate applications  in understanding and reasoning about natural languages.  2 Syntax and Semantics of Chop-While  In this section we study a new interval logic called ChopWhile (CW) which can be viewed as the generalization of  C [Mos83, RS07, BT03, Dut95] to different (parallel) lines.  This logic, with a slightly different semantics, has been  originally introduced in [LR00].  Ď  Ď  Figure 1. A pictorial representation of the formula (ĎĎ)||Ď  dik = djk . We also deďŹne the relation P â I(D) Ă I(D)  deďŹned as P ([dih , djh ], [dik , djk ]) if and only if h = k.  Thus, a CW-model can be viewed as a tuple MCW =  I(D), A, P, Î , VCW . The intuitive picture of the chop  operator is shown in Figure 1. The truth of a given CWformula Ď is given by the following clauses:  â˘ MCW , [dik , djk ]  Ď iff for  [dih , djh ] â Î ;  The language of CW features a set of propositional letters  AP = {p, q, . . . }, the classical operators ÂŹ, â¨ (the remaining ones can be considered as abbreviations), and the binary  modalities C, ||, in addition to the modal constant Ď. Wellformed formulas can be obtained by the following abstract  grammar:  each Dh â D,  â˘ MCW , [dik , djk ]  p iff p â VCW ([dik , djk ]);  â˘ MCW , [dik , djk ]  ÂŹĎ iff it is not the case that  MCW , [dik , djk ]  Ď;  â˘ MCW , [dik , djk ]  Ď â¨ Ď iff MCW , [dik , djk ]  Ď or  MCW , [dik , djk ]  Ď;  Ď = Ď | p | ÂŹĎ | Ď â¨ Ď | ĎCĎ | Ď||Ď,  â˘ MCW , [dik , djk ]  Ď||Ď iff MCW , [dik , djk ]   Ď and there exists some Dh â D such that  P ([dik , djk ], [dih , djh ]) and MCW , [dih , djh ]  Ď;  where p â AP.  The models of CW are given in terms of parallel evaluation lines. We consider a set of linearly ordered set  D1 , <, D2 , <, . . . , Dn , <. We call CW-structure the  set D = {D1 , D2 , . . . , Dn }. The linearly ordered sets  are pairwise isomorphic, and theirs elements are denoted  here by di1 , dj1 , . . . â D1 , . . ., din , djn , . . . â Dn , and  so on; thus, for example, the element d34 is the third element of the fourth domain. For a given Dk , consider  the set of all intervals   that can be built on it, denote it by,  I(Dk ); let I(D) = nh=1 I(Dh ). A CW-model is a tuple  MCW = D, I(D), VCW , where VCW is a valuation function such that, for each linearly ordered set Dk â D and  interval [dik , djk ], it assigns a truth value to each propositional variable p â AP . In terms of classical modal  logic, we can deďŹne Kripke-style models of CW as follows. Let A be the relation A â I(D) Ă I(D) Ă I(D),  where D â D is deďŹned in such a way that for all intervals [dik , djk ], [dik , djk ], [dik , djk ] â I(D), the triple  ([dik , djk ], [dik , djk ], [dik , djk ]) â A if and only if dik =  dik , djk = djk , and djk = dik (this is exactly Venemaâs  chop relation [Ven91]), and let Î  â I(D) be a predicate  deďŹned in such a way that [dik , djk ] â Î  if and only if  Ď  â˘ MCW , [dik , djk ]    ĎCĎ iff there are two  intervals [dlk , dmk ] and [dlk , dmk ] such that  A([dlk , dmk ], [dlk , dmk ], [dik , djk ]),  M, [dlk , dmk ]   Ď, and M, [dlk , dmk ]  Ď.  Notice that, since intervals should behave the same way  over all parallel lines, whenever we encounter a Ď over  some interval [dik , djk ], all the intervals which are parallel to it (including [dik , djk ] itself) must be point-intervals.  The concepts of satisďŹability, validity in a model, and validity are deďŹned in the usual way.  In the language of CW, we can deďŹne the during operator 3Ď as C(Ď â¨ ( ||Ď))C , which says that Ď holds  somewhere within an interval, its dual operator (throughout) 2Ď = ÂŹ3ÂŹĎ, and the dual of the parallel operator:  p ||i q = p â§ ÂŹ( ||ÂŹq), which means that p is true on the  current line and q is true on any other line, if any.  It is simple to see that the satisďŹability problem for CW is  not decidable. Indeed, in [Lod00] it has been shown that  14th International Symposium on Temporal Representation and Reasoning (TIME'07  0-7695-2836-8/07 $20.00 ÂŠ 2007  Characterâs name  Cornelia  Characterâs reasoning  (J â§ S â§ CO â§ (J.drunk C S.shot.at CJ.hysterical)) C(J â§ CO â§ ÂŹS â§ (J.hysterical  C J.sedated))||(S â§ S.hurt)) C(S â§ CO â§ ÂŹJ â§ ((S.hurt C S.bullet C S.sedated)  ||(J â§ J.sedated)) C((ÂŹCO â§ S â§ S.sedated)||(ÂŹCO â§ J â§ J.sedated)) â  2((J â§ CO) â¨ (J â§ J.sedated)) â§ 2((S â§ CO) â¨ (S â§ (S.hurt â¨ S.sedated)))  Poirot  (Jâ§Sâ§COâ§(J.drunk C S.shot.at C J.hysterical)) C((Jâ§COâ§ÂŹSâ§(J.hysterical C  J.sedated))||i (Sâ§(ÂŹS.hurt C S.murder C S.shoots.leg C S.hurt)) C((Sâ§COâ§ÂŹJâ§  (S.hurt C S.bullet C S.sedated))||i (J â§ J.sedated))C ((ÂŹCO â§ S â§ S.sedated)||i  (ÂŹCO â§ J â§ J.sedated))))  Figure 2. Cornelia and Poirotâs reasoning put in a logical formula.  the logic C (with chop and Ď only) is not decidable over  dense linearly ordered sets. When C is interpreted in the  class of all linearly ordered sets, the denseness property can  be deďŹned by a valid formula, and, since it is possible to  express in C (a sort of) universal modality, it is easy to show  that the satisďŹability problem for C is not decidable. Thus,  we have that also the satisďŹability problem for CW is not  decidable.  2.1  Using CW  In this section, we show how CW can be used to formalize a  natural language expression by using a non-trivial example.  the assumption that he was hurt, he could not do  the murder. But if he was not shot, he could do  it. During the second interval that Cornelia was  with Simon, the doctor removed the bullet from  his leg, he must have been shot by then. That is  still consistent if Jackieâs shot did not hit him, his  fall was faked, and while he was alone, he did the  murder and then shot himself at the leg.  The logic CW is powerful enough to express both Corneliaâs version of the facts (ĎCornelia ), and Poirotâs reasoning (ĎP oirot ), as shown in Figure 2 above. Clearly, if  the Poirot is right, it must be the case that the following  formula is valid:  ĎCornelia â ĎP oirot .  Example 1 We borrow the next example from [LR00].  In the Agatha Christie novel Death on the  Nile [Chr56], the two main suspects are Simon,  husband of the murdered woman, and Jackie, his  ex-girlfriend. On the evening of the murder, Cornelia, a witness, is with Simon and Jackie. Jackie  gets drunk and shoots at Simon. He falls down.  Simon asks Cornelia to bring a doctor, and to take  the hysterical Jackie with her. Cornelia does so.  The doctor gives Jackie a sedative and she goes  to sleep. Cornelia brings the doctor where Simon  is. The doctor pulls out the bullet from Simonâs  leg and gives him sedative, he goes to sleep. By  the morning the murder has taken place. Cornelia reasons: while she was with Jackie (and not  with Simon), he was shot and hurt, and later in  the night, Simon was sedated, otherwise she was  always with Simon. While she was with Simon  (and not with Jackie), he was sedated, otherwise  she was always with Jackie. So both Jackie and  Simon have alibis. Hercule Poirot, the detective,  notices that Simon was alone for the interval that  Cornelia and Jackie went for the doctor. Under  3 Automatic Entailment in CW: a Tableaux  Method  In this section we propose a tableau method for the logic  CW. The method can be seen as an adaptation of the one  used for PNL logics [GMS03a].  3.1  Basic DeďŹnitions  We assume the reader is familiar with the standard notions  of ďŹnite tree, root of a tree, successor of a node n, leaf node  (i.e., a node with no successors), and path of nodes. During  the construction of a tableaux for a given formula, we will  consider a single branch (unless otherwise speciďŹed). We  deďŹne the height of a node n as the maximum length (number of edges) of a path from n to a leaf. The expression n âş  n (resp. n  n ) means that, for two nodes n, n belonging  to the same branch, that the height of n is less than (resp.  less than or equal to) the height of n .  We consider a collection C1 , <, C2 , <, . . . , Cn , < of  linearly ordered sets, and denote C = {C1 , C2 , . . . , Cn }.  14th International Symposium on Temporal Representation and Reasoning (TIME'07  0-7695-2836-8/07 $20.00 ÂŠ 2007  Ď  ÂŹÂŹĎ  Ď0 â§ Ď1  ÂŹ(Ď0 â§ Ď1 )  ÂŹ(Ď0 CĎ1 )  ÂŹ(Ď0 ||Ď1 )  Ď0 CĎ1  (Ď0 ||Ď1 )  Expansion rule for the node n and the branch B  expand the branch to B Âˇ n0 , with Ď(n0 ) = ((Ď, [cik , cjk ]), CB , u)  expand the branch to B Âˇ n0 Âˇn1 , with Ď(n0 ) = ((Ď0 , [cik , cjk ]), CB , u) and Ď(n1 ) =  ((Ď1 , [cik , cjk ]), CB , u)  expand the branch to B Âˇ n0 |n1 , with Ď(n0 ) = ((ÂŹĎ0 , [cik , cjk ]), CB , u) and Ď(n1 ) =  ((ÂŹĎ1 , [cik , cjk ]), CB , u)  take the least chk â Ck (chk â [cik , cjk ]) which has not been yet used to expand the node n  on B, and expand the branch to B Âˇ n0 |n1 , with Ď(n0 ) = ((ÂŹĎ0 , [cik , chk ]), CB , u) and Ď(n1 )  = ((ÂŹĎ1 , [chk , cjk ]), CB , u)  take some evaluation line Cl â C (Cl = Ck ) such that the interval [cil , cjl ] has not been yet used to  expand the node n on B, and expand the branch to B Âˇ n0 |n1 , with Ď(n0 ) = ((ÂŹĎ0 , [cik , cjk ]), CB , u)  and Ď(n1 ) = ((ÂŹĎ1 , [cil , cjl ]), CB , u)  expand the branch to B Âˇ (ni Âˇ mi )| . . . |(nj Âˇ mj )|(ni Âˇ mi )| . . . |(njâ1 Âˇ mjâ1 ), where: (i) for all chk â  [cik , cjk ], Ď(nk ) = ((Ď0 , [cik , chk ]), CB , u) and Ď(mk ) = ((Ď1 , [chk , cjk ]), CB , u), and (ii) for all i â¤  l â¤ j â 1, let C  be the set if linearly ordered sets obtained by inserting a new element c between clz and  cl+1z (for all 1 â¤ z â¤ k), Ď(nk ) = ((Ď0 , [cik , c]), C  , u), and Ď(mk ) = ((Ď1 , [c, cjk ]), C  , u);  expand the branch to B Âˇ n0 Âˇ (n1 | . . . |nnâ1 |n ), where: (i) for all 1 â¤ l â¤ n, l =  k, Ď(nl ) = ((Ď1 , [cil , cjl ]), CB , u), (ii) Ď(n0 ) = ((Ď0 , [cik , cjk ]), CB , u), and (iii) Ď(n ) =  ((Ď1 , [cin+1 , cjn+1 ]), C  , u), where C  = CB âŞ Cn+1 , and Cn+1 is any linear domain isomorphic to  C â , where C â â CB and |C â | is maximal.  Table 1. Branch-expansion rules  Each one of the linearly ordered sets is composed of the  same elements (the sets Ci are pairwise isomorphic), which  are denoted here as ci1 , cj1 , . . . â C1 , ci2 , cj2 , . . . â C2 ,  and so on.  DeďŹnition 2 Let n be a node in a branch B of a tree T .  â˘ An annotated formula is a pair (Ď, [cik , cjk ]), where  Ď â CW and cik , cjk â Ck , 1 â¤ k â¤ n, where |C| = n.  â˘ The annotation Ď(n) is a triple ((Ď, [cik , cjk ]), C,  un,B1 , . . . , un,Bq ), where (Ď, [cik , cjk ]) is an annotated formula and for each 1 â¤ r â¤ q, un,Br â {0, 1}  is the expansion ďŹag, i.e., it associates the values 0 or  1 with every branch Bi in T containing n.  â˘ n is said to be active if and only if its ďŹag is 0 for at  least one branch B  to which n belongs.  â˘ An annotated tree is a tree in which every node has an  annotation Ď(n).  For a node n and a branch Br containing it, the ďŹag is 0  when the node has not been expanded yet over Br , and 1  otherwise, except for the universal cases ÂŹC and ÂŹ||, in  which the ďŹag always remains 0. For sake of simplicity, we  will often assume an interval [cik , cjk ], from the line Ck , to  consist of the elements cik < c(i+1)k < . . . < cjk . For any  branch B in a annotated tree, we denote by CB the ordered  set in the annotation of the leaf of B, and for any node n  in a annotated tree, we denote by ÎŚ(n) the formula in its  annotation. If B is a branch, then B Âˇ n denotes the result  of the expansion of B with the node n (addition of an edge  connecting the leaf of B to n). Similarly, B Âˇ n1 | . . . | nk  denotes the result of the expansion of B with k immediate  successor nodes n1 , . . . , nk (which produces k branches  extending B). A tableau for CW will be deďŹned as a distinguished annotated tree. It is worth noticing that C remains  ďŹnite throughout the construction of the tableau.  3.2  Tableaux and Expansion Rule  Now we are ready to deďŹne the tableaux for CW and the  expansion rule for them.  DeďŹnition 3 Given an annotated tree T , a branch B in T ,  and a node n â B such that Ď(n) = ((Ď, [cik , cjk ]), C, u),  with un,B = 0, the branch-expansion rule for B and n is  deďŹned as in Table 1. In all the considered cases, un ,B =  0 for all new pairs (n , B  ) of nodes and branches, and u  switches from 0 to 1 in all cases except for ÂŹC and ÂŹ||.  DeďŹnition 4 Let B a branch of a tableau T .  14th International Symposium on Temporal Representation and Reasoning (TIME'07  0-7695-2836-8/07 $20.00 ÂŠ 2007  â˘ The branch-expansion rule is applicable to a node n  on B if the node is active on B and the application of  the rule generates at least one successor node with a  new annotated formula;  â˘ A branch B is closed if some of the following conditions holds: (i) there are two nodes n, n â B such  that Ď(n) = ((Ď, [cik , cjk ]), C, u) and Ď(n ) = ((ÂŹĎ,  [cik , cjk ]), C  , u ) for some formula Ď and cik , cjk â  C âŠ C  ; (ii) there is a node n such that Ď(n) =  ((Ď, [cik , cjk ]), C, u) and cik = cjk ; (iii) there is a node  n such that Ď(n) = ((ÂŹĎ, [cik , cjk ]), C, u) and cik =  cjk ; (iv) there are two nodes n, n â B such that Ď(n)  = ((Ď, [cik , cjk ]), C, u) and Ď(n ) = ((Ď  , [cih , cjh ]),  C  , u ) for some formulas Ď, Ď  , and cik = cjk (resp.,  cik = cjk ) and cih = cjh (resp., cih = cjh ); otherwise,  the branch is open (Clearly, a tableau for CW is closed  if and only if every branch in it is closed, otherwise it  is open);  â˘ The branch-expansion strategy for a branch B in an  annotated tree T consists of applying the branchexpansion rule to a branch B only if it is open, and, in  such a case, applying it to the ďŹrst active node one encounters moving from the root to the leaf of B to which  the branch-expansion rule is applicable (if any);  â˘ An initial tableau for a given formula Ď â  CW is the ďŹnite annotated tree T composed of  an empty root and two nodes n0 and n1 such  that Ď(n0 ) = ((Ď, [c01 , c01 ]), C, 0) and Ď(n1 ) =  ((Ď, [c01 , c11 ]), C  , 0), where C = {C1 }, C1 = {c01 },  C  = {C1 }, C1 = {c01 , c11 }, and c01 < c11 . A tableau  for a given formula Ď â CW is any ďŹnite annotated  tree isomorphic to a ďŹnite annotated tree T obtained  by expanding the initial tableau for Ď through successive applications of the branch-expansion strategy to  the existing branches.  Theorem 5 If Ď â CW and a tableau T for Ď is closed, then  Ď is not satisďŹable. Moreover, if Ď is a valid CW-formula,  then there is a closed tableau for ÂŹĎ.  3.3  In order to formalize the above situation, we will use the  following proposition letters: the symbol w denotes that the  paper is on work, dr denotes that the paper is still a draft,  and f i that it is a ďŹnal version. As we see in Figure 3, there  is a closed tableau for the conjunction of the formulas that  formalize the statement in the example, showing that the  described situation is not consistent. For sake of simplicity,  we have omitted some of the branches, and we used rules  for ||i and 2 which do not appear in DeďŹnition 8, but can be  easily deducted from the semantics of the operators.  Acknowledgement: The authors would like to thank Kamal Lodaya for his many useful suggestions and comments  about this work (he has indeed worked on some of the ideas  in this paper), and Ian Hodkinson for pointing out an important mistake in the ďŹrst version of the paper. The ďŹrst  author is grateful to the management of HTSL for constant support and encouragement during this work. This  research has been partially founded by the Spanish MEC  project IDEATIO, no. TIN2006-15460-C04-01.  References  [BRZ00]  R. Barua, S. Roy, and C. Zhou. Completeness  of neighbourhood logic. Journal of Logic and  Computation, 10(2):271â295, 2000.  [BT03]  H. Bowman and S. Thompson. A decision procedure and complete axiomatization of ďŹnite  interval temporal logic with projection. Journal of Logic and Computation, 13(2):195â239,  2003.  [Chr56]  A. Christie. Death on the nile. Collins (London), 1956.  [Dut95]  B. Dutertre. Complete proof systems for ďŹrst  order interval temporal logic. In Proc. of  the 10th International Symposium on Logic in  Computer Science, pages 36â43, 1995.  An Example  Finally, we consider a simple example taken from the context of natural language, and we analyze it by means of the  tableaux-based method.  Example 6 Guido works in Murcia (Spain), and Suman  works in Bangalore (India). They have been working on  the same paper. It is always true that when a paper is on  work (draft), it is not a ďŹnal version. During a given period  of time, the Guido has been working on a draft version of  the paper, while Suman has been working on a draft and got  a ďŹnal version of the paper. Is this situation consistent?  [GMS03a] V. Goranko, A. Montanari, and G. Sciavicco.  A general tableau method for propositional interval temporal logic. In Proc. of TABLEAUX  2003: 12th Conference on Automated Reasoning with Analytic Tableaux and Related Methods, volume 2796 of LNAI, pages 102â116,  Rome, Italy, September 2003. Springer.  [GMS03b] V. Goranko, A. Montanari, and G. Sciavicco.  Propositional interval neighborhood temporal  logics. Journal of Universal Computer Science,  9(9):1137â1167, 2003.  14th International Symposium on Temporal Representation and Reasoning (TIME'07  0-7695-2836-8/07 $20.00 ÂŠ 2007  ((2(w â dr)||i 2(w â dr), [c01 , c11 ]), {{c01 < c11 }}, 0)  ((2(dr â f i)||i 2(dr â f i), [c01 , c11 ]), {{c01 < c11 }}, 0)  ((w||w C f i), [c01 , c11 ]), {{c01 < c11 }}, 1)  (w, [c01 , c11 ]), {{c01 < c11 }}, 1)  ((w C f i, [c02 , c12 ]), {{c01 < c11 }, {c02 < c12 }}, 1)  ((w, [c02 , c22 ]), {{c01 < c21 < c11 }, {c02 < c22 < c12 }}, 1)  ((f i, [c22 , c12 ]), {{c01 < c21 < c11 }, {c02 < c22 < c12 }}, 1)  gggg  ggggg  ggggg  ((ÂŹw, [c22 , c12 ], {{c01 < c21 < c11 }, {c02 < c22 < c12 }}, 1)  Ă  (dr, [c22 , c12 ], {{c01 < c21 < c11 }, {c02 < c22 < c12 }}, 1)  g  ggggg  g  g  g  g  gggg  ((ÂŹdr, [c22 , c12 ]), {{c01 < c21 < c11 }, {c02 < c22 < c12 }}, 1)  Ă ((ÂŹf i, [c22 , c12 ]), {{c01 < c21 < c11 }, {c02 < c22 < c12 }}, 1)  Ă  Figure 3. A closed tableau for Example 6.  [GMSS06] V. Goranko, A. Montanari, G. Sciavicco, and  P. Sala. A general tableau method for propositional interval temporal logics: theory and  implementation. Journal of Applied Logic,  4(3):305â330, 2006.  [Lod00]  [LR00]  [Mos83]  puter Science, Stanford University, Stanford,  CA, 1983.  [RP86]  K. Lodaya. Sharpening the undecidability of  interval temporal logic. In Proc. of 6th Asian  Computing Science Conference, volume 1961  of LNCS, pages 290â298. Springer, 2000.  R. Rosner and A. Pnueli. A choppy logic.  In First Annual IEEE Symposium on Logic In  Computer Science, pages 306â314. IEEE Computer Society Press, 1986.  [RS07]  K. Lodaya and S. Roy. Lines, a while, and  intervals. In Proc. of ESSLLI Workshop on  Many-Dimensional Logical Systems, Birmingham, pages 1â8, 2000.  S. Roy and G. Sciavicco. Completeness of  chop. In H.W. Guesguen, G. Ligozat, and  R.V. Rodriguez, editors, Proc. of the IJCAI-07  Workshop on Spatial and Temporal Reasoning,  pages 90â95, 2007.  [Ven91]  Y. Venema. A modal logic for chopping intervals. Journal of Logic and Computation,  1(4):453â476, 1991.  B. Moszkowski. Reasoning about digital circuits. Tech. rep. stan-cs-83-970, Dept. of Com-  14th International Symposium on Temporal Representation and Reasoning (TIME'07  0-7695-2836-8/07 $20.00 ÂŠ 2007 