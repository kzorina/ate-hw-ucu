Data & Knowledge Engineering 44 (2003) 143â164  www.elsevier.com/locate/datak  Optimizing temporal queries: eďŹcient handling of duplicates  Ivan T. Bowman, David Toman  *  Department of Computer Science, University of Waterloo, 200 University Ave. West, Waterloo, Ont., Canada N2L 3G1  Received 10 December 2001; accepted 3 July 2002  Abstract  Recent research in the area of temporal databases has proposed a number of query languages that vary  in their expressive power and the semantics they provide to users. These query languages represent a  spectrum of solutions to the tension between clean semantics and eďŹcient evaluation. Often, these query  languages are implemented by translating temporal queries into standard relational queries. However, the  compiled queries are often quite cumbersome and expensive to execute even using state-of-the-art relational  products. This paper presents an optimization technique that produces more eďŹcient translated SQL  queries by taking into account the properties of the encoding used for temporal attributes. For concreteness, this translation technique is presented in the context of SQL/TP; however, these techniques are also  applicable to other temporal query languages.   2002 Elsevier Science B.V. All rights reserved.  Keywords: Temporal query languages; Duplicate semantics for temporal queries; Compilation of temporal queries;  Query optimization; Query performance  1. Introduction  The last decade of research in the area of temporal databases has led to the development of  several temporal query languages based on extensions of existing relational languages, in particular of SQL [10,12â15]. These languages are based on the idea of timestamping tuples: associating them with a time instant at which the tuple is valid. These instants are usually drawn from  a linearly ordered universe that models time in the database. The semantics of queries are then  deďŹned in terms of the individual time instants [4].  *  Corresponding author. Tel. : +1-519-888-4567x444; fax: +1-519-885-1208.  E-mail address: david@uwaterloo.ca (D. Toman).  0169-023X/03/$ - see front matter  2002 Elsevier Science B.V. All rights reserved.  PII: S 0 1 6 9 - 0 2 3 X ( 0 2 ) 0 0 1 3 3 - 7  144  I.T. Bowman, D. Toman / Data & Knowledge Engineering 44 (2003) 143â164  Although query semantics is deďŹned in terms of time instants, the space requirements of explicitly storing tuples with individual instants is prohibitive: tuples would need to be repeated for  each instant at which they are valid. Instead, practical languages rely on a compact encoding of  sets of time instants (often referred to as periods of validity), for example by using intervals,  bitemporal elements, or other interval-based encoding. The chosen encoding is then used as the  concrete domain for the representation of values of temporal attributes.  Example 1. A software development company maintains a time reporting database that records  the projects and tasks that each developer worked on throughout the year. The relation used for  this reporting has the following signature:  AssignmentĂ°Day; Employee; Project; TaskĂ:  Fig. 1 contains an instance of this relation and a compact interval encoding of the instance.  Note that Ann was assigned to both tasks 1 and 2 of project âAâ during February.  Since the query semantics is deďŹned over time instants, one way to evaluate queries would be to  use a standard relational query language over the expanded, point-based instance. This approach  would allow queries to be written and executed with the well-understood semantics of relational  theory. However, this approach would require prohibitive time and space to answer queries since  the number of tuples to be processed could depend on the values of attributes in the compact  encoding. For example, a single interval-encoded tuple can be expanded into an arbitrary number  of tuples by adjusting the interval endpoints.  Since it is not feasible to execute queries against the point-based instance, queries are ultimately  evaluated over a compact encoding, independently of the query language used. The query evaluation is often based on translating the original query to a standard relational query that can be  Fig. 1. Time-reporting example database.  I.T. Bowman, D. Toman / Data & Knowledge Engineering 44 (2003) 143â164  145  executed over the encoding [15] or [12â14] (for snapshot and sequenced fragments). Translation  allows queries to be written with a well-understood relational language, and this translation yields  queries that can be executed in time and space that is at most polynomial in the size of the  compact encoding, regardless of the particular values in intervals. However, such compilationbased approaches often lead to very complex queries that are extremely diďŹcult to optimize (given  current state-of-the-art query optimizers).  The main obstacle here is the fact that the SQL query optimizer has no knowledge of the  properties of the encoding used for temporal attributes and therefore cannot take advantage of  rewrites valid under the semantics of the original temporal queries. This shortcoming stands out  especially when following the strict duplicate-preserving semantics of SQL.  Duplicates are not permitted in pure relational theory, but SQL permits them in order to allow  counting, and also to allow applications to indicate that the query processor does not need to  spend the time removing duplicates if they do not aďŹect the application. For these reasons, SQL  permits bags instead of sets, and deďŹnes the multiplicity of tuples expected from the various  operations.  Example 2. Let D be a temporal database which asserts that value a is in the relation R at all time  instants t P 0. Let D1 Âź hR : fĂ°a; Â˝0; 10Ă; Ă°a; Â˝11; 1Ăgi and D2 Âź hR : fĂ°a; Â˝0; 1Ăgi be two (semantically equivalent) compact encodings of D. Now consider the query ââgive me all the values in  the ďŹrst attribute of Rââ. Under the set semantics, the answer for both D1 and D2 is a single tuple  containing the value ââaââ. However, answering this query under a duplicate-preserving semantics  is much more complicated: we would have to produce a tuple a for every time instant associated  with aââthis is clearly not possible as the result would have to be inďŹnite.  For this reason, SQL/TP (cf. Section 2 or [15,16] for description of the language) prohibits  duplicate-preserving projections of temporal attributes.  Example 3. The commonly proposed solution for implementing the query from Example 2 that  simply projects out the interval attribute [12] (non-sequenced fragment) is also problematic: the  result of the above query diďŹers for D1 and D2 in the number of duplicate ââaââs returned (2 tuples  for D1 and 1 for D2 ). It has been argued however, that no well-behaved temporal query should  distinguish between equivalent temporal databases. While one might argue that the diďŹerence  between the instances D1 and D2 can be resolved using coalescing [2], it has been shown that, in  general, coalescing-based approaches are bound to fail [5,15].  The query translator may recognize contexts within the translated query where the answer is  not sensitive to the duplicates generated by a subquery. Consider the following example.  Example 4. If we are interested in the time reporting for employee Ann, we can write the query Q  using the schema of Fig. 1 as follows:  SELECT DISTINCT Day, Project  FROM Assignment  WHERE Employee Âź âAnnâ  146  I.T. Bowman, D. Toman / Data & Knowledge Engineering 44 (2003) 143â164  We can use query Q to build up larger queries. If we are interested only in knowing the projects  that Ann worked on, we can write query Q2 as:  SELECT DISTINCT Project  FROM Q  If the query translator is aware that Q is being evaluated in a context where duplicates do  not aďŹect the result (for example, because of the DISTINCT keyword in query Q2 ), then the  translator could simply project out the âTaskâ attribute of Q. The intermediate results of Q would  then be:  Day  Project  Jan 1âFeb 28  Feb 1âMar 31  A  A  This intermediate result contains duplicate tuples because of the overlapping time intervals; these  duplicates are then eliminated by the DISTINCT of query Q2 . If we were also interested in the  days when âAnnâ or âBobâ was assigned to each project, with duplicates for days they were both  assigned, we could write a query Q3 as:  (Q) UNION ALL (SELECT DISTINCT Day, Project  FROM Assignment  WHERE Employee Âź âBobâ)  In this case, we must eliminate the duplicate values resulting from the overlapping time intervals. The relational projection used in the Q2 context is not suďŹcient in this caseââwe need a  more sophisticated technique (implemented by coalescing in some languages and as normalization  in SQL/TP) to eliminate duplicates within the range-encoded time intervals.  The intermediate results of Q as found by the SQL/TP normalization procedure is the following:  Day  Project  Jan 1âJan 31  Feb 1âFeb 28  Mar 1âMar 31  A  A  A  In this example, the context of evaluation of a query can be used to choose a more eďŹcient  evaluation technique. In the Q2 context, Q can be evaluated eďŹciently using the relational duplicate-preserving project. In the Q3 context, we must use the more expensive normalization  procedure to eliminate duplicates in the range-encoded time intervals.  The above examples set up the scene for this paper: while we want to use a well behaved,  declarative language such as SQL/TP, we would also like to employ the simple (relational) projection that projects out the compact representation of sets of time instants (as in Example 3) and  I.T. Bowman, D. Toman / Data & Knowledge Engineering 44 (2003) 143â164  147  thus provides a vastly better performance (similarly to duplicate preserving vs. distinct projections  in SQL).  The problem of eďŹciently executing relational queries in the presence of duplicates has been  well investigated for non-temporal query languages, and formal descriptions of algebras for bag  queries have been developed which allow the issues of duplicates to be described precisely [7,9]. In  addition to formal descriptions, results on optimization allow moving group-by and duplicate  elimination operations to earlier or later contexts during execution plans in order to improve  execution cost [3,8,17]. These optimization results also allow duplicate elimination operations to  be avoided in cases where they do not aďŹect the results. However, these prior results do not immediately generalize to the problem of executing temporal queries containing duplicates, mainly  because SQL/TP supports inďŹnite abstract databases (as shown in Example 2). In particular,  solutions based on counting and aggregation to avoid problems with duplicate values in SQL/92  queries fail for SQL/TP queries as the counts would need to be inďŹnite (cf. Example 3). In addition, to recover answers required by SQLâs deďŹnition, an unfold [10] or expand [8] operation is  necessary to replicate a tuple based on an integer value stored in the database. This operation,  however, cannot be expressed in SQL itself.  The contributions of the paper are twofold:  (1) First, we identify contexts in a given query in which relaxed SQL/TP-to-SQL/92 translation  rules can be used. In addition we provide these additional compilation rules and show their  eďŹect on several examples.  (2) Second, and more importantly, the proposed approach provides a general paradigm for optimizing temporal queries (and in general, queries over non-trivial encodings of data) that  leads beyond the optimizations possible in standard SQL.  We demonstrate the approach on SQL/TP, the query language proposed by Toman [15,16].  However, we would like to stress that the proposed approach is applicable to other proposals, e.g.,  to IXRM [10] and to the SQL/TemporalâTSQL2âATSQL2 family [12â14].  The remainder of this paper is organized as follows. Section 2 provides an introduction to the  SQL/TP query language and the basic compilation technique used to translate SQL/TP queries  into SQL/92 (a more detailed description can be found in [15,16]). Section 3 describes the main  results of the paper: it deďŹnes the duplicate insensitive evaluation contexts. Section 4 shows patterns where these contexts can simplify the SQL/TP-to-SQL translation. Section 4.2 outlines the  modiďŹed compilation procedure from SQL/TP to standard SQL. Finally, Section 5 presents our  conclusions and discusses several open questions and directions for future research.  2. SQL/TP primer  The SQL/TP language operates on a point-based view of time. Temporal attributes are drawn  from a discrete, countably inďŹnite, linearly ordered set without endpoints. In addition to time, we  also use all of the standard data types provided by SQL such as strings, integers, ďŹoats, and so on.  Since we do not assign any a priori meaning to these data types, we refer to them as the uninterpreted constants.  148  I.T. Bowman, D. Toman / Data & Knowledge Engineering 44 (2003) 143â164  The relationship between the time instants and the uninterpreted constants is captured in a  ďŹnite set of temporal relations in a database. We distinguish between the abstract temporal  database, which is deďŹned in terms of time points, and the concrete temporal database, which is a  compact encoding of the abstract database.  DeďŹnition 5 (Abstract temporal database). A signature sigĂ°RĂ of a relational symbol R is a tuple  Ă°a1 : t1 ; . . . ; ak : tk Ă where ai are distinct attribute names, ti are the corresponding attribute types,  and k is the arity of R. Attributes of type time are temporal attributes, and the others are data  attributes.  A database schema is a ďŹnite set of relational symbols R1 ; . . . ; Rn paired with signatures  sigĂ°R1 Ă; . . . ; sigĂ°Rn Ă. A table R is a (possibly inďŹnite) bag of tuples that match the signature of R  deďŹned in the database schema. An abstract temporal database is a set of tables deďŹned by a  database schema.  In general, we do not restrict the cardinality of temporal tables: we allow inďŹnite tables as well.  However, we do require that the multiplicity of each distinct tuple is ďŹnite. Note, too, that there is  no restriction on the number of temporal attributes in a relation.  The abstract temporal database provides a natural data model for modeling and querying  temporal data based on timestamps. However, the storage cost for a naive representation of such  a database would be prohibitively large. In the case of inďŹnite tables, it is not even possible to  store the abstract temporal database. To address this issue, SQL/TP uses a compact encoding of  sets of time instants. The choice of intervals as the compact encoding deďŹnes a class of concrete  temporal databases.  DeďŹnition 6 (Concrete temporal database). Let R be a relational symbol with signature E. A  concrete signature corresponding to E is deďŹned as a tuple E of attributes that contains (1) a data  attribute A for every data attribute a in E, and (2) an interval attribute It for every temporal  attribute t in E. The attribute It holds the interval encoding of consecutive time instants. 1 A  concrete temporal database schema is a set of relational symbols and their concrete signatures  derived from their signatures in the abstract database schema. A concrete temporal database is a  set of ďŹnite relations deďŹned by a concrete database schema.  To capture the relationship between the abstract and concrete temporal databases, we deďŹne a  semantic map operator s t. The meaning of a single concrete tuple x Âź Ă°It ; a1 ; . . . ; ak Ă is a bag of  tuples sxt Âź fĂ°t; a1 ; . . . ; ak Ăjt 2 It g. Similarly, for concrete tuples with multiple abstract temporal  attributes we deďŹne the result of the s t operator to be the hypercube resulting from allowing  in the concrete tuple. This  each temporal attribute ti to range within its interval bounds deďŹned U  map is extended to a concrete relation R by taking the additive union t2R Â˝Â˝t of the meanings of  all concrete tuples t 2 R.  1  We assume the existence of an interval-valued data type in the target language; in the absence of such a data type we  use pairs of attributes to denote left and right endpoints of intervals instead.  I.T. Bowman, D. Toman / Data & Knowledge Engineering 44 (2003) 143â164  149  Fig. 2. Syntax of SQL/TP.  2.1. Syntax and semantics  The syntax of the SQL/TP query language is deďŹned by the grammar in Fig. 2, which has been  slightly simpliďŹed to omit details such as the precedence of query constructs. Here, hcexpi denotes a column expression (an aggregate function), hsexpi denotes a scalar expression,  hconditioni represents an atomic condition, and hsetopi is a multi-set operation. The  meaning of QĂ°DĂ is deďŹned by induction as follows:  (1) RĂ°DĂ denotes the relation stored in D named R.   Qk Ă°DĂ implements Cartesian product.  (2) Ă°FROM Q1 r1 ; . . . ; Qk rk ĂĂ°DĂ Âź Q1 Ă°DĂ   (3) Ă°Q WHERE uĂ Âź ru QĂ°DĂ is the restriction operation, where u is an atomic condition (free of  boolean connectives). For temporal attributes, the allowed conditions u are of the form  ai Ăž c 6 aj , c 6 ai , or ai 6 c, where ai and aj are temporal attributes and c is a constant.  (4) Ă°SELECT e1 AS i1 ; . . . ; ek AS ik QĂĂ°DĂ is the duplicate-preserving projection operation that  generates a bag of tuples with signature i1 ; . . . ; ik and one tuple Ă°e1 Ă°xĂ; . . . ; ek Ă°xĂĂ for each tuple  x 2 QĂ°DĂ.  (5) Ă°Q GROUP BY a1 ; . . . ; ak AGG f 1 Ă°b1 Ă AS i1 ; . . . ; f n Ă°bn Ă AS in ĂĂ°DĂ is the grouping operator,  where ai and bi are attribute names, and f i are aggregate functions. For temporal attributes,  the aggregate functions may be MIN, MAX, or COUNT. The aggregate functions may be omitted, in which case the operation has the eďŹect of removing duplicates (similarly to the SQL/92  SELECT DISTINCT).  (6) Ă°Q1 hSETOPiQ2 ĂĂ°DĂ Âź Q1 Ă°DĂ op Q2 Ă°DĂ are the set (bag) operators. The allowed operations op  are:  UNION (set union),  UNION ALL (additive union),  EXCEPT (set diďŹerence),  EXCEPT IN (âânot existsââ),  EXCEPT ALL (monus),  INTERSECT (set intersection),  INTERSECT IN (ââexistsââ), and  150  I.T. Bowman, D. Toman / Data & Knowledge Engineering 44 (2003) 143â164  INTERSECT ALL (duplicate-preserving intersection).  Compared to the original deďŹnition of SQL/TP [15,16], we introduce two additional multi-set  operations EXCEPT IN and INTERSECT IN. These two operations are the counterparts of SQLâs  NOT EXISTS and EXISTS constructs in the WHERE clause and their meaning is deďŹned as follows:  Ă°Q1 EXCEPT IN Q2 ĂĂ°DĂ Âź fjx 2 Q1 Ă°DĂ : x 62 Q2 Ă°DĂjg  Ă°Q1 INTERSECT IN Q2 ĂĂ°DĂ Âź fjx 2 Q1 Ă°DĂ : x 2 Q2 Ă°DĂjg  where fjx 2  jg denotes the formation of a bag of x values. Note that from the expressive power  point of view, the new operations do not add new capabilities to SQL/TP (as both of them can be  simulated by EXCEPT ALL and INTERSECT ALL with the help of additional joins). However,  they allow us to extend the inference technique described in Section 3 to a larger class of queries.  Further, these operations allow us to express a query that is semantically equivalent to an SQL/TP  query but which has a more eďŹcient implementation. The other set (bag) operators behave exactly  like their SQL/92 counterparts.  As in the standard SQL/TP, we guarantee closure of all of the above constructs by requiring  that the SELECT clause may not project out a temporal attribute encoded using intervals (as this  might violate the requirement of ďŹnite duplication; cf. Example 2) and the grouped-by and nongrouped attributes in the GROUP BYââAGG clause are mutually independent whenever aggregate  functions COUNT and SUM are used. addition, to guarantee that the result of a query is representable using the interval encoding, we require all attributes in the answer to a query to be  pairwise independent [15].  The particular restriction to bags with ďŹnite duplication only, and in turn the restriction placed  on the projection operation, is needed to guarantee meaningful semantics of bag operations.  Example 7. Consider the query  Ă°SELECT d FROM rĂ EXCEPT ALL Ă°SELECT d FROM r WHERE t > 10Ă  executed over a concrete relation rĂ°d; tĂ Âź fĂ°a; Â˝0; 1Ăg. Clearly, if a duplicate-preserving projection of temporal attributes (in this case t) was permitted, the two subqueries would both return  countably many tuples (a), and thus the number of duplicate tuples in the result of the query  (according to the usual rules for cardinal arithmetic) is not deďŹned.  2.2. Query compilation  Our ďŹnal goal is to translate SQL/TP queries to standard SQL and then submit the result to an  oďŹ-the-shelf database engine. To achieve this goal we have to resolve two problems. First, while  the top-level attributes of an SQL/TP query have to be independent, this restriction may not hold  for subqueries of the original query. To translate (sub-)queries with dependent attributes we use  conditional queries of the form Qfug where Q is an SQL translation of the original query (without  any references to individual time instants) and u is a formula that captures the remaining restrictions on temporal attributes. The translation itself is then realized by a function comp that  I.T. Bowman, D. Toman / Data & Knowledge Engineering 44 (2003) 143â164  151  maps SQL/TP queries to sets of conditional queries by induction on their structure, while  maintaining the following invariant:  ]  M  ruj sQj Ă°DĂt  QĂ°sDtĂ Âź scompĂ°QĂĂ°DĂt Âź  Qj fuj g2compĂ°QĂ  The SQL/TP language carefully models the set and the multi-set semantics of SQLââSQL/TP  queries are translated to generate exact multiplicities for all tuples as deďŹned by standard SQL  semantics. The compilation procedure thus proceeds inductively on the structure of the original  query Q by replacing subqueries by ââequivalentââ subqueries according to the above invariant  [15,16].  The second problem that arises during translation is that every temporal attribute t in an  SQL/TP query that refers to individual time instants in T has to be replaced with an attribute It  ranging over intervals, the elements of the concrete temporal sort. The challenge here lies in the  deďŹnition of relational operators that preserve semantics over the interval-based encoding.  Example 8. Let D be the following encoding of a temporal database:  D Âź hS1 : fĂ°a; Â˝0; 4Ă; Ă°b; Â˝0; 1Ă; Ă°b; Â˝7; 8Ăg; S2 : fĂ°a; Â˝4; 6Ă; Ă°b; Â˝1; 7Ăgi  If we compute the expression S Âź S1 EXCEPT S2 , then one possible encoding is given by  S : fĂ°a; Â˝0; 3Ă; Ă°b; Â˝0; 0Ă; Ă°b; Â˝8; 8Ăg  Relational database engines do not have the ability to generate the desired results using existing  relational techniques. For this purpose, we introduce a novel normalization technique. The idea  behind the technique is quite simple: we normalize the encoded input relations in a manner which  allows relational operations to treat intervals as atomic values. In this way, the ordinary relational  operations give the desired results for the encoded relations. Fig. 3 shows a graphical depiction of  the normalization operation applied to implement set diďŹerence for Example 8. The formal definitions are as follows:  Fig. 3. Set diďŹerence using normalization.  152  I.T. Bowman, D. Toman / Data & Knowledge Engineering 44 (2003) 143â164  DeďŹnition 9 (Time compatibility). Let fQ1 ; . . . ; Qk g be a set of SQL/92 queries with compatible  signatures and X a subset of their attributes. We call the queries Q1 ; . . . ; Qk X-compatible if,  whenever there are two concrete tuples t1 2 Qi Ă°DĂ and t2 2 Qj Ă°DĂ, then  spX Ă°t1 Ăt \ spX Ă°t2 Ăt 6Âź ; ) pX Ă°t1 Ă Âź pX Ă°t2 Ă  for all concrete temporal databases D and all 0 < i 6 j 6 k.  The deďŹnition of an X-compatible set of queries says that if the meanings of two concrete tuples  intersect then it is always the case that these two tuples coincide. This way we can guarantee the  intervals behave like points with respect to set/bag operations. If X contains all of the temporal  attributes of the queries, then we say that the queries are time compatible.  It is also easy to see that we can deďŹne a normalization operation that transforms an arbitrary  set of queries to an X-compatible set of s t-equivalent queries. Moreover, this operation can be  deďŹned using a ďŹrst-order query: 2  Lemma 10. Let fQ1 ; . . . ; Qk g be a set of SQL/92 queries with compatible signatures and X a subset  of their attributes. Then there are first-order queries NX Â˝Qi ; Q1 ; . . . ; Qk  such that  (1) sQi Ă°DĂt Âź sNX Â˝Qi ; Q1 ; . . . ; Qk Ă°DĂt for all concrete databases D,  (2) fNX Â˝Qi ; Q1 ; . . . ; Qk  : 0 < i 6 kg are X-compatible.  To deďŹne a time-compatible set of queries the above lemma is used for all temporal attributes in  the common signature.  2.3. Implementation of normalization operator  The normalization operation can be performed in OĂ°n log nĂ Ăž OĂ°mĂ where n is the combined  size of the inputs and m is the size of the output of the operator. For example, it can be implemented by merging sorted inputs. More eďŹcient implementations are possible in cases the optimizer knows properties of the inputs to the operator (e.g., that the inputs are already sorted).  However, the normalization operation is never better than OĂ°nĂ in the size of the input relations,  and removing it or replacing it by SQLâs duplicate-preserving projection always improves performance.  3. Duplicate insensitive contexts  For many queries, the requirement to match the precise multiplicity semantics imposes a signiďŹcant cost in the translated query. For some sub-expressions, this additional cost can be  eliminated because the translated expression is evaluated in a context that does not require precise  multiplicity semantics. More formally:  2  Similarly to coalescing; a native implementation of the normalization can often be made more eďŹcient.  I.T. Bowman, D. Toman / Data & Knowledge Engineering 44 (2003) 143â164  153  DeďŹnition 11 (Query equivalence). Let Q1 and Q2 be SQL/TP queries. We say that Q1 and Q2 are:  SET  â˘ set equivalent, Q1 Âź Q2 if fx : x 2 Q1 Ă°DĂg Âź fx : x 2 Q2 Ă°DĂg for all databases D;  BAG  â˘ bag equivalent, Q1 Âź Q2 , if Q1 Ă°DĂ Âź Q2 Ă°DĂ for all databases D; the Âź sign is used to denote bag  equality unless otherwise noted.  If two queries are set equivalent, they produce the same set of distinct tuples for any given  instance. However, the multiplicity of the tuples does not need to agree in the results of the two  queries. If, however, two queries are bag equivalent, they produce the same bag of tuples for any  given instance.  DeďŹnition 12 (Context). An expression CÂ˝  is a context (of signature r) if, for any SQL/TP query  Q with signature r, CÂ˝Q (denoting the syntactical substitution of Q for Â˝ ) is a valid SQL/TP  query. Here, the signature r represents the schema of attributes expected by the context, and we  say that the above queries Q are compatible with CÂ˝ . For simplicity we omit the context signatures whenever possible.  For example,  CÂ˝  Âź Ă°Â˝  WHERE Employee Âź âAnn0 Ă and  C 0 Â˝  Âź Ă°FROM Q1 r1 ; Â˝  r2 Ă  are contexts. The expression CÂ˝Assignment represents the expansion:  Ă°Assignment WHERE Employee Âź âAnn0 Ă  and the expression CÂ˝Ă°Assignment WHERE Project Âź âA0 Ă represents the expansion:  Ă°Ă°Assignment WHERE Project Âź âA0 Ă WHERE Employee Âź âAnn0 Ă:  If CÂ˝  and C 0 Â˝  are two contexts with signature r and r0 , respectively, then CÂ˝C 0 Â˝  is also a  context of signature r0 . Here, CÂ˝C 0 Â˝  stands for the composition of contexts. The above contexts  also deďŹne the composite context and the expansion  CÂ˝C 0 Â˝  Âź Ă°Ă°FROM Q1 r1 ; Â˝ r2 Ă WHERE Employee Âź âAnn0 Ă  CÂ˝C 0 Â˝Assignment Âź Ă°Ă°FROM Q1 r1 ; Assignment r2 Ă WHERE Employee Âź âAnn0 Ă;  respectively.  DeďŹnition 13 (Duplicate insensitive context). A context CÂ˝  is duplicate insensitive if  SET  BAG  Q1 Âź Q2 ) CÂ˝Q1  Âź CÂ˝Q2   for any pair of queries Q1 and Q2 compatible with CÂ˝ .  Example 14. Consider the context  CÂ˝  Âź Ă°Â˝  GROUP BY aĂ:  154  I.T. Bowman, D. Toman / Data & Knowledge Engineering 44 (2003) 143â164  This context is duplicate insensitive since the result of the expression contains one tuple in its  output for each distinct value a for any pair of Q1 set-equivalent to Q2 (both with the same signature containing the attribute a).  Lemma 15. It is undecidable whether or not an arbitrary context CÂ˝  is duplicate insensitive.  Proof. Consider the context CÂ˝  Âź Ă°FROMÂ˝ r; QsĂ where Q is a closed query. 3 Then CÂ˝  is duplicate insensitive if and only if Q is unsatisďŹable (empty). However, emptiness is not decidable [1],  so there cannot exist a decision algorithm for duplicate insensitivity.   DeďŹnition 16 (Set preserving context). A context CÂ˝  is set preserving if  SET  SET  Q1 Âź Q2 ) CÂ˝Q1  Âź CÂ˝Q2   for any pair of queries Q1 and Q2 compatible with CÂ˝ .  Example 17. Clearly, every context that is duplicate insensitive is also set preserving. In addition,  there are several contexts which are set preserving but which are not duplicate insensitive. Consider the context  CÂ˝  Âź Ă°Â˝  WHERE uĂ:  This context is set preserving since the result of the expression contains the same set of distinct  tuples in its output for any pair of set-equivalent queries Q1 and Q2 with signatures compatible  with CÂ˝ .  Lemma 18 (Set preserving contexts). The following contexts are set preserving:  FROM Q1 r1 ; . . . ; Â˝ ri ; . . . ; Qk rk ,  Â˝  WHERE u,  SELECT e1 AS i1 ; . . . ; ek AS ik Â˝ ,  Â˝  GROUP BY a1 ; . . . ; ak AGG f 1 AS i1 ; . . . ; f m AS im Ă°for f i 2 fMIN; MAXgĂ,  Â˝  hSETOPi Q2 ,  Q1 hSETOPi Â˝   where hSETOPi is one of the following:  â˘ UNION, UNION ALL,  â˘ INTERSECT, INTERSECT IN, INTERSECT ALL,  â˘ EXCEPT, EXCEPT IN.  Note that the EXCEPT ALL contexts are not set preserving in general, since the monus operation  produces diďŹerent sets as results depending on the multiplicities of the tuples in each input.  3  Unlike the SQL standard, SQL/TP allows closed queries with the expected semantics.  I.T. Bowman, D. Toman / Data & Knowledge Engineering 44 (2003) 143â164  155  Proof. By case analysis.  Case FROM: Consider the context  CF Â˝  Âź FROM Q r; Â˝  s  For any two compatible queries Q1 and Q2 , the results of the expansion CF Â˝Q1  is Q  Q1 and the  result of CF Â˝Q2  is Q  Q2 . For each tuple t 2 CF Â˝Q1 , there are tuples r 2 Q and s 2 Q1 such that  SET  t is the concatenation of r and s. If Q1 Âź Q2 , then s 2 Q2 as well, so t 2 CF Â˝Q2 . Therefore,  fs 2 CF Â˝Q1 g  fs 2 CF Â˝Q2 g. By a similar argument, fs 2 CF Â˝Q2 g  fs 2 CF Â˝Q1 g. Therefore,  SET  SET  Q1 Âź Q2 ) CF Â˝Q1  Âź CF Â˝Q2   and the context CF Â˝  is set preserving. The extension to a general Cartesian product of more than  two relations follows from the standard equivalence with a sequence of binary Cartesian products  and an inductive argument.  Case WHERE: The context  CW Â˝  Âź Â˝  WHERE u  produces the same set of distinct resulting tuples for any two set equivalent queries Q1 and Q2  compatible with the context. For any tuple t 2 CW Â˝Q1 , t 2 Q1 and hence t 2 Q2 and therefore  t 2 CW Â˝Q2 . Thus, the context CW Â˝  is set preserving.  Case SELECT: The context  CS Â˝  Âź SELECT e1 AS i1 ; . . . ; ek AS ik Â˝   is also set preserving. Let Q1 and Q2 be any two set equivalent queries compatible with CS Â˝ . If  tuple t 2 CS Â˝Q1 , then there is a tuple r 2 Q1 such that t is the projection of r. By set equivalence,  r 2 Q2 and therefore t 2 CS Â˝Q2 . This gives the result that CS Â˝  is a set preserving context.  Case GROUP BY: The context  CG Â˝  Âź Â˝  GROUP BY a1 ; . . . ; ak AGG f 1 AS i1 ; . . . ; f m AS im  is duplicate insensitive if either there are no aggregate functions, or they are drawn only from MIN  and MAX. In this case, the context is trivially set preserving since duplicate insensitivity is a  stronger condition.  Case hsetopi: The contexts  CP1 Â˝  Âź Â˝  hSETOPi Q2  CP2 Â˝  Âź Q1 hSETOPi Â˝   are set preserving for the set operations listed above. For these contexts, the presence of a distinct  tuple t in the results depends only on the existence of a single tuple t in one or both of the inputs  (depending on the particular hsetopi used). Thus, additional duplicates do not aďŹect the distinct  tuples generated in the result, although they do change the multiplicity.   Lemma 19 (Duplicate insensitive composition). Let C1 Â˝  be a duplicate insensitive context with  signature r1 , and C2 Â˝  a set-preserving context with signature r2 . Then the context defined by  composition of these two contexts, CÂ˝  Âź C1 Â˝C2 Â˝ , is duplicate insensitive.  156  I.T. Bowman, D. Toman / Data & Knowledge Engineering 44 (2003) 143â164  Proof. For any two queries Q1 , Q2 compatible with r2 , we have that  SET  SET  Q1 Âź Q2 ) C2 Â˝Q1  Âź C2 Â˝Q2   because C2 Â˝  is set preserving. Further, we have that  SET  BAG  C2 Â˝Q1  Âź C2 Â˝Q2  ) C1 Â˝C2 Â˝Q1  Âź C1 Â˝C2 Â˝Q2   since C1 is duplicate insensitive. Thus, for any two queries Q1 , Q2 compatible with r2 , we have  SET  BAG  Q1 Âź Q2 ) CÂ˝Q1  Âź CÂ˝Q2   and CÂ˝  is thus duplicate-insensitive.   3.1. Inference of duplicate insensitivity  Although there is no decision algorithm to ďŹnd precisely whether a given context is duplicate  insensitive, we can deďŹne syntax directed rules for ďŹnding several useful classes of duplicate insensitive contexts.  Lemma 20 (Duplicate insensitive contexts (i)). The contexts  Â˝  GROUP BY a1 ; . . . ; ak AGG f 1 AS i1 ; . . . ; f m AS im Ă°for f i 2 fMIN; MAXgĂ,  Â˝  INTERSECT Q; Â˝  EXCEPT Q; Â˝  UNION Q,  Q INTERSECT Â˝ ; Q EXCEPT Â˝ ; Q UNION Â˝   are duplicate insensitive.  Proof. All the above contexts CÂ˝  are set preserving (by Lemma 18); further, these contexts always generate duplicate-free results. For these contexts,  SET  SET  Q1 Âź Q2 ) CÂ˝Q1  Âź CÂ˝Q2   and further, since duplicates are eliminated in the output,  SET  BAG  CÂ˝Q1  Âź CÂ˝Q2  ) CÂ˝Q1  Âź CÂ˝Q2   Thus,  SET  BAG  Q1 Âź Q2 ) CÂ˝Q1  Âź CÂ˝Q2   and the contexts are duplicate insensitive as desired.   Lemma 21 (Duplicate insensitive contexts (ii)). The contexts  Q INTERSECT IN Â˝ ; and Q EXCEPT IN Â˝   are duplicate insensitive.  Proof. Let CÂ˝  Âź Ă°Q hopi Â˝ Ă be a context where hopi is INTERSECT IN or EXCEPT IN. Let Q1  SET  and Q2 be any two queries compatible with the signature of context CÂ˝  where Q1 Âź Q2 . For each  I.T. Bowman, D. Toman / Data & Knowledge Engineering 44 (2003) 143â164  157  tuple t 2 Q, either t 2 Q1 ^ t 2 Q2 or t 62 Q1 ^ t 62 Q2 . The decision to include t in the output of CÂ˝   depends only on the existence of a single witness in Q1 and Q2 , and diďŹerent multiplicities does  not aďŹect this decision. Further, all duplicates of t 2 Q are treated identically, so the multiplicity of  t in the result will either be zero or the same as the multiplicity in the original query. Therefore, we  see that for any pair of queries Q1 and Q2  SET  BAG  Q1 Âź Q2 ) CÂ˝Q1  Âź CÂ˝Q2 :  Thus the context CÂ˝  is duplicate insensitive.   Lemma 22 (Inference of duplicate insensitivity). If CÂ˝  is a duplicate-insensitive context, then the  contexts  CÂ˝FROM Q1 r1 ; . . . ; Â˝ ri ; . . . ; Qn rn ,  CÂ˝SELECT e1 AS i1 ; . . . ; en AS in Â˝ ,  CÂ˝Â˝  WHERE u,  CÂ˝Q INTERSECT ALL Â˝ ,  CÂ˝Â˝  INTERSECT ALL Q,  CÂ˝Â˝  INTERSECT IN Q,  CÂ˝Â˝  EXCEPT IN Q,  CÂ˝Q UNION ALL Â˝ , and  CÂ˝Â˝  UNION ALL Q  are also duplicate insensitive.  Proof. The inner contexts in all of the above cases are set preserving by Lemma 18. Since context CÂ˝  is duplicate insensitive, the composed context CÂ˝C 0 Â˝  is also duplicate insensitive by  Lemma 20.   4. Duplicate insensitive compilation  In this section we turn to the main goal of the paper: we show how the information about  duplicate insensitivity of query contexts can be used to improve the SQL/TP compilation to SQL  and in turn to generate more eďŹcient SQL queries. Our focus is the elimination of the normalization operator generated by the original approach [15] in the translations of the following two  SQL/TP constructs:  â˘ the aggregation/duplicate elimination operation and  â˘ a set/bag operation.  More formally, let Q1 and Q2 be two SQL/92 queries with a common concrete signature X corresponding to an SQL/TP signature x, perhaps resulting from translating parts of an SQL/TP  query. The original translation establishes the following:  158  I.T. Bowman, D. Toman / Data & Knowledge Engineering 44 (2003) 143â164  BAG  sQ1 Ă°DĂt GROUP BY y Âź sNY Â˝Q1 ; Q1  GROUP BY Y Ă°DĂt  BAG  sQ1 Ă°DĂt hSETOPi sQ2 Ă°DĂt Âź sNX Â˝Q1 ; Q1 ; Q2  hSETOPi NX Â˝Q2 ; Q1 ; Q2 Ă°DĂt  for y  x a set of grouping attributes and D an arbitrary concrete database.  It is easy to see that we cannot use optimization based on rewrites purely within SQL/TP and  therefore (modiďŹed) techniques for ââdistinctââ elimination used by standard SQL optimizers, e.g.,  [6,9,11], cannot be used: there is no SQL/TP expression that could replace the original one in a  duplicate-insensitive context and simplify the result of the translation.  In particular the (commonly suggested) expression SELECT x AS x Q is not a valid substitute  and, moreover, must be disallowed due to the problems outlined in Example 1. In addition, it is  also easy to see that translating an SQL/TP expression cannot generate SQLâs duplicate preserving  projection since such SQL/92 queries are not s t-generic over concrete temporal databases in  general (while all translations of SQL/TP queries are s t-generic).  Therefore, we consider modifying the SQL/TP-to-SQL translation instead. We proceed in two  steps. First we explore translation rules in which the normalization operator can be removed if we  weaken the requirement of bag equality to set equality for the results of the compiled queries.  Second, we integrate these new rules with an existing SQL/TP compilation procedure [15,16]  employing duplicate insensitivity inferred for query contexts present in the input query.  4.1. Relaxed compilation rules  In the following we use Q1 and Q2 to stand for two SQL/92 queries with a common concrete  signature X corresponding to a SQL/TP signature x. The following Lemmas treat the individual  cases.  First and most important is the case where the GROUP BY operation in SQL/TP is used for  projection. Here we want to use SQLâs vastly more eďŹcient duplicate-preserving projection. This  is, however, only possible in duplicate insensitive contexts:  Lemma 23 (Aggregation and duplicate elimination). Let D be an arbitrary concrete database and  y a subset of Q1 âs attributes. Then  SET  sQ1 Ă°DĂt GROUP BY y Âź sSELECT Y FROM Q1 Ă°DĂt  Proof. Let   a be an abstract tuple such that   a 2 sQ1 Ă°DĂt GROUP BY y . Then there must be a tuple  ab 2 sQ1 Ă°DĂt and consequently a concrete tuple AB 2 Q1 Ă°DĂ such that ab 2 sABt. Then, however,   2 SELECT Y FROM Q1 Ă°DĂ and thus    t. The proof of  A  a 2 sSELECT Y FROM Q1 Ă°DĂt since a 2 sA  the reverse inclusion is similar.   The right-hand side query is a pure SQL/92 query and does not involve the normalization  operator. Thus, we use this equation to generate a translation rule (cf. Section 4.2). Note also that  the query on the right-hand side is not bag-equivalent to any SQL/TP query. The following three  Lemmas provide similar results for the other operations that involve normalization:  I.T. Bowman, D. Toman / Data & Knowledge Engineering 44 (2003) 143â164  159  Lemma 24 (Union). Let D be an arbitrary concrete database. Then  SET  sQ1 Ă°DĂt UNION Â˝ALL sQ2 Ă°DĂt Âź sQ1 UNION ALL Q2 Ă°DĂt   2 sQ1 Ă°DĂt UNION Â˝ALL sQ2 Ă°DĂt. Then a must belong to the answer to Q1 or Q2 .  Proof. Let a   2 Q1 Ă°DĂ such that  W.l.o.g., we assume   a 2 sQ1 Ă°DĂt. Then, there must be a concrete tuple A        a 2 sAt. Since A 2 Q1 UNION ALL Q2 Ă°DĂ we have a 2 sQ1 UNION ALL Q2 Ă°DĂt. Again, the other  direction is similar.   In duplicate insensitive contexts the set/bag intersection can be turned into a join:  Lemma 25 (Intersection). Let D be an arbitrary concrete database. Then  SET  sQ1 Ă°DĂt INTERSECT Â˝ALLjIN sQ2 Ă°DĂt Âź sSELECT r: X \ s: X FROM Q1 r; Q2 s  WHERE r: X \ s: X 6Âź ;Ă°DĂt  where r: X \ s: X is a select list consisting of r: Xj AS Xj for data attributes and r:Ij \ s:Ij AS Ij for  temporal attributes. The select list expression r:Ij \ s:Ij AS Ij gives the interval encoding of the  overlap of the r:Ij and s:Ij intervals. Similarly, r: X \ s: X 6Âź ; is a conjunction of equalities for  matching data attributes and conditions of the form r:Ij \ s:Ij 6Âź ; for temporal attributes. This latter  condition identifies tuples r and s that have overlapping interval encodings of the Ij temporal attribute. This condition can, of course, be further expressed as a simple order condition involving  interval endpoints.   2 sQ1 Ă°DĂt INTERSECT Â˝ALLjINsQ2 Ă°DĂt then there must be concrete tuples A1 2  Proof. If a   1 t \ sA   2 t. These two tuples, however, satisfy the WHERE  a 2 sA  Q1 Ă°DĂ and A2 2 Q2 Ă°DĂ such that    representing the  clause on the right-hand side of the equation and therefore a concrete tuple A   2 is in the answer to the right-hand side query. Subsequently, a is in the   1 and A  intersection of A   2 t. Similarly, the other inclusion   t Âź sA   1 t \ sA  abstract answer to the right-hand side, since a 2 sA  holds.   Similarly, the set/not-exists-like set diďŹerence can be turned into an anti-join:  Lemma 26 (DiďŹerence). Let D be an arbitrary concrete database. Then  BAG  sQ1 Ă°DĂt EXCEPT Â˝IN sQ2 Ă°DĂt Âź sSELECT Â˝DISTINCT r: X  FROM NX Â˝Q1 ; Q1 ; Q2 r  WHERE NOT EXISTS Ă°SELECT  FROM Q2 s  WHERE r: X  s: X Ă Ă°DĂt  where r: X  s: X is a conjunction of equalities for data attributes (with matching names) and interval  inclusion conditions for temporal attributes, respectively.  160  I.T. Bowman, D. Toman / Data & Knowledge Engineering 44 (2003) 143â164  2   2 sQ1 Ă°DĂt EXCEPTÂ˝IN sQ2 Ă°DĂt. Then there must be a concrete tuple A  Proof. Let a   t such that    t (such a tuple must exist since the normalization  a 2 sA  a 2 sA  NX Â˝Q1 ; Q1 ; Q2  such that   operation preserves meaning of abstract relations and a 2 sQ1 Ă°DĂt). Moreover, there is no tuple   tuple satisďŹes the NOT EXISTS condition as,  B 2 Q2 Ă°DĂ such that   a 2 sBt. Then, however, the A   t \ sBt 6Âź ; implies sA   t  sBt.  due to the normalization operation applied on Q1 Ă°DĂ we have sA  The other direction is the same.   Note that in the case of set diďŹerence we can eliminate only the normalization operation  connected with the R operand. On the other hand, due to the (necessary) N operator applied on  Q1 , this translation preserves bag equality. 4  4.2. Enhancement of query compilation  As the last step of the development we incorporate the notion of duplicate insensitive contexts  and the simpliďŹed translation rule(s) developed in last section into the SQL/TP-to-SQL/92  translator. We use two mutually recursive functions compS and compB that are used in the duplicate insensitive (set) and duplicate sensitive (bag) contexts, respectively (comp stands for both  cases). We follow a convention that if Qj and uj appear in the translation, then they range over all  j such that Qj fuj g 2 compX Ă°QĂ where X (the appropriate bag- or set-based translation rule) is  determined by the context created by the operation for its arguments (cf. Lemmas 20â22). Fig. 4  summarizes the translation rules.  Theorem 27. Let Q be an SQL/TP query. Then for every concrete database D we have  BAG  D U  (1) QĂ°sDtĂ Âź scompB Ă°QĂĂ°DĂtÂź Qj fuj g2compB Ă°QĂ ruj sQj Ă°DĂt  SET  D S  (2) QĂ°sDtĂ Âź scompS Ă°QĂĂ°DĂtÂź Qj fuj g2compS Ă°QĂ ruj sQj Ă°DĂt  Proof. The compB translation rules have been shown to be correct in previous work [15]. Each of  the set-based translation rules compS is either an instance of an equality shown in Lemmas 23â26  or follows from Lemmas 20â22.   We illustrate the improved translation in the following examples. The ďŹrst example shows how  the translation handles nested ââdistinctââ queries.  Example 28. Decorrelation of SELECT DISTINCT and EXISTS-like queries; in SQL/TP syntax:  FROM  Q1q1;  Ă°Q2 GROUP BY tĂ q2  WHERE  q1:t Âź q2:t  GROUP BY q1:a  4  The set EXCEPT operator is paired with the SELECT DISTINCT right-hand side.  I.T. Bowman, D. Toman / Data & Knowledge Engineering 44 (2003) 143â164  Fig. 4. Complete SQL/TP translation rules.  161  162  I.T. Bowman, D. Toman / Data & Knowledge Engineering 44 (2003) 143â164  is translated to the SQL/92 query  SELECT  q1:a  FROM  Q1q1;  Ă°SELECT I t AS I t Q2Ă q2  WHERE  leftĂ°q1:I tĂ <Âź rightĂ°q2:I tĂ  AND  leftĂ°q2:I tĂ <Âź rightĂ°q1:I tĂ  GROUP BY  q1:a  where the left and right (perhaps user-deďŹned) functions allow us to access the left and right  endpoints of a given interval value, respectively. This query can be further ââďŹattenedââ using the  standard SQL rewriting rules. Without the ability to detect that the inner query operated in a  duplicate insensitive context, we would have to use the Nftg normalization procedure, and generate  a much more expensive query.  Similar examples can be made for other EXISTS-based queries which, in practice, cover a very  large number of cases. In the above example, we could, however, completely omit the inner  projection in the original query. The next example shows that this cannot be done in general:  Example 29. Duplicate elimination removal within a set operation:  Ă°Q1 GROUP BY a AS aĂ EXCEPT Ă°Q2 GROUP BY a AS aĂ  assuming a is a data attribute (but both Q1 and Q2 have additional temporal attributes in their  signatures), can still be compiled to  Ă°SELECT a AS a FROM Q1Ă EXCEPT Ă°SELECT a AS a FROM Q2Ă  5. Conclusion  We have presented a technique for optimizing the translation of SQL/TP to SQL/92. The  technique takes advantage of static determination of duplicate insensitive contexts in the original  query and uses more lax translation rules that produce much more eďŹcient SQL/92 queries as  results. These more eďŹcient queries cannot be achieved by a pure SQL/TP to SQL/TP translation,  nor by state-of-the-art commercial query optimizers from the SQL/92 queries resulting from the  translation. The proposed technique introduces a novel approach to optimizing queries that are  evaluated over an encoded database rather than over a standard relational representation. The  proposed technique is also applicable in the more general constraint databases, e.g., where  complex spatial objects are compactly encoded in a relational tables using a particular constraint  representation.  5.1. Future work  The technique presents a new approach to query optimization. While the current application of  the technique is limited to handling duplicates in SQL/TP, the approach is much more general and  can be summarized as follows: Given a declarative query language that is translated to another  I.T. Bowman, D. Toman / Data & Knowledge Engineering 44 (2003) 143â164  163  language to facilitate query evaluation over a particular encoding of data, can the translation  process take advantage of the fact that in certain query contexts we can use a translation that  produces more eďŹcient translations (but which are not equivalent to the original query in general)?  Acknowledgements  The authors gratefully acknowledge the Natural Sciences and Engineering Research Council of  Canada, the Communications and Information Technology of Ontario, and iAnywhere Solutions  (a Sybase company) for their support of this research.  References  [1] S. Abiteboul, R. Hull, V. Vianu, Foundations of Databases, Addison-Wesley, 1995.  [2] M. BâŹ  ohlen, R.T. Snodgrass, M.D. Soo, Coalescing in temporal databases, in: International Conference on Very  Large Data Bases, 1996, pp. 180â191.  [3] S. Chaudhuri, K. Shim, Including group-by in query optimization, in: International Conference on Very Large  Data Bases, 1994, pp. 354â366.  [4] J. Chomicki, Temporal query languages: A survey, in: D.M. Gabbay, H.J. Ohlbach (Eds. ), Temporal Logic, First  International Conference, Springer-Verlag, 1994, pp. 506â534, LNAI 827.  [5] J. Chomicki, D. Toman, Temporal logic in information systems, in: J. Chomicki, G. Saake (Eds. ), Logics for  Databases and Information Systems, Kluwer, 1998, pp. 31â70 (Chapter 3).  [6] P. Godfrey, J. Grant, J. Gryz, J. Minker, Integrity constraints: Semantics and applications, in: J. Chomicki,  G. Saake (Eds. ), Logics for Databases and Information Systems, Kluwer, 1998, pp. 265â306 (Chapter 9).  [7] S. Grumbach, T. Milo, Towards tractable algebras for bags, Journal of Computer and System Sciences 52 (3)  (1996) 570â588.  [8] A. Gupta, V. Harinarayan, D. Quass, Aggregate-query processing in data warehousing environments, in:  International Conference on Very Large Data Bases, 1995, pp. 358â369.  [9] V.L. Khizder, D. Toman, G. Weddell, Reasoning about duplicate elimination with description logic, in:  Computational Logic 2000, 2000, pp. 1017â1032.  [10] N.A. Lorentzos, The interval-extended relational model and its application to valid-time databases, in: A. Tansel,  J. CliďŹord, S. Gadia, S. Jajodia, A. Segev, R. Snodgrass (Eds. ), Temporal Databases: Theory, Design, and  Implementations, Benjamin/Cummings, 1993, pp. 67â91.  [11] P. Seshadri, H. Pirahesh, T.Y. CliďŹ Leung, Complex query decorrelation, in: 12th International Conference on  Data Engineering, 1996, pp. 450â458.  [12] R.T. Snodgrass, M.H. BâŹ  ohlen, C.S. Jensen, A. Steiner, Adding Valid Time to SQL/Temporal. ISO/IEC JTC1/  SC21/WG3 DBL MAD-146r2 21/11/96, (change proposal), International Organization for Standardization, 1996.  [13] R.T. Snodgrass, C.S. Jensen, M.H. BâŹ  ohlen, Evaluating and Enhancing the Completeness of TSQL2, Technical  Report TR 95-5, Computer Science Department, University of Arizona, 1995.  [14] R.T. Snodgrass, I. Ahn, G. Ariav, D. Batory, J. CliďŹord, C.E. Dyreson, R. Elmasri, F. Grandi, C.S. Jensen,  W. Kafer, N. Kline, K. Kulkarni, T.Y.C. Leung, N. Lorentzos, J.F. Roddick, A. Segev, M.D. Soo, S.A. Sripada,  TSQL2 language speciďŹcation, SIGMOD Record 23 (1) (1994) 65â86.  [15] D. Toman, Point-based temporal extensions of SQL, in: International Conference on Deductive and ObjectOriented Databases, 1997, pp. 103â121.  [16] D. Toman, Temporal extensions of SQL: A constraint approach, in: G. Kuper, L. Libkin, J. Paradaens (Eds. ),  Constraint Databases, Springer, 2000, pp. 31â70 (Chapter 8).  [17] W.P. Yan, P. Larson, Eager aggregation and lazy aggregation, in: International Conference on Very Large Data  Bases, 1995, pp. 345â357.  164  I.T. Bowman, D. Toman / Data & Knowledge Engineering 44 (2003) 143â164  Ivan T. Bowman is a Ph.D. student in the School of Computer Science at the University of Waterloo, and a  member of the Adaptive Server Anywhere query processing team at iAnywhere Solutions, a partially owned  subsidiary of Sybase Inc. He is also a member of the ACM SIGMOD, and his research interests include query  optimization and execution.  David Toman received his B.S. and M.S. degrees from the Masaryk University, Brno, Czech Republic in 1992,  and his Ph.D. fron Kansas State University in 1996, all in computer science. He is currently assistant professor  at the School of Computer Science, University of Waterloo, Canada. His research interests include temporal,  deductive, and constraint database systems, query optimization and compilation, query processing in embedded control programs, description logics, logic programming, and programming languages. 