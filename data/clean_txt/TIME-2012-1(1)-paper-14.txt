2012 19th International Symposium on Temporal Representation and Reasoning  An optimal tableau system for the logic of temporal neighborhood over the reals  Angelo Montanari  Department of Mathematics and Computer Science  University of Udine, Udine, Italy  angelo.montanari@uniud.it  border between decidability and undecidability cutting right  across the core of that family.  A prominent role in the family of ITLs is played by  Propositional Neighborhood Logic (PNL). It features two  modalities â¨đ´âŠ and â¨đ´âŠ that make it possible to access  intervals adjacent to the right (future) and to the left (past)  of the reference one, respectively. Representation theorems  and complete axiomatic systems for PNL with respect to  various classes of interval neighborhood frames have been  given by Goranko et al in [13]. Expressiveness issues have  been addressed in [6], [14]. Decidability and complexity  of the satisďŹability problem for PNL have been studied by  Bresolin et al in [6], where PNL decidability with respect  to the classes of all linearly-ordered domains, well-ordered  domains, and ďŹnite linearly-ordered domains, and the linear  order of â has been proved via a reduction to the satisďŹability problem for the two-variable fragment of ďŹrst-order logic  for binary relational structures over ordered domains [15].  Additional decidability results for PNL over the classes of  dense, discrete, and ďŹnite linear orders, as well as over the  linear orders of â¤ and â have been obtained in [7], [8]. In  all the considered (classes of) linear orders, the satisďŹability  problem for PNL turns out to be NEXPTIME-complete.  Optimal tableau systems for PNL over various classes of  linear orders, including â, â¤, and â, have been developed  in [7], [8], [10]. The only missing piece of information is that  about PNL over â. PNL is expressive enough to distinguish  between satisďŹability over different classes of linear orders.  In [8], Bresolin et al have shown that PNL can separate the  class of discrete (resp., dense) linear orders from that of all  linear orders. Additional separation results for speciďŹc linear  orders have been given in [14], where Della Monica et al  have proved that PNL is able to separate â¤ from â (easy) and  â from â (difďŹcult). As for the latter, they have shown that  if a PNL-formula is satisďŹable over â, then it is satisďŹable  over â as well, but the converse does not hold. In most  separation results, the past modality â¨đ´âŠ plays an essential  role. As an example, the future fragment of PNL, featuring  the modality â¨đ´âŠ only, is not able to distinguishing between  â and â. The relationships between â¤ and â and between  â and â are, however, quite different. In [14], the authors  give a log-space reduction from the satisďŹability problem for  PNL over â¤ to that over â, that is, the satisďŹability problem  AbstractâThe propositional logic of temporal neighborhood  (PNL) features two modalities that make it possible to access  intervals adjacent to the right and to the left of the current  one. PNL has been extensively studied in the last years.  In particular, decidability and complexity of its satisďŹability  problem have been systematically investigated, and optimal  decision procedures have been developed, for various (classes  of) linear orders, including â, â¤, and â. The only missing piece  is that for â. It is possible to show that PNL is expressive  enough to separate â and â. Unfortunately, there is no way to  reduce the satisďŹability problem for PNL over â to that over â.  In this paper, we ďŹrst prove the NEXPTIME-completeness of  the satisďŹability problem for PNL over â, and then we devise  an optimal tableau system for it.  Keywords-Interval Temporal Logics; Real Numbers; Decidability; Complexity; Tableaux Methods.  I NTRODUCTION  Interval temporal logics (ITLs) are a family of modal  logics for reasoning about relational interval structures over  linear orders, which are well suited for a number of applications [1] The 13 binary ordering relations between two intervals on a linear order form the set of the so-called Allenâs  interval relations [2]. Halpern and Shohamâs modal logic  of time intervals (HS) features a distinct unary modality  for each Allenâs relation and it is interpreted over frames  where intervals are primitive entities [3]. While formulas  of point-based temporal logics are evaluated at time points,  formulas of ITLs are evaluated at time intervals. This results  in a substantially higher expressive power and computational  complexity of ITLs as compared to point-based ones. Hence,  it does not come as a surprise that, while decidability is a  common feature of point-based temporal logics, undecidability dominates among HS and its fragments [3], [4], [5].  For a long time, such a situation has discouraged further  theoretical investigations on ITLs and prevented people from  systematically using them in practical applications. This  bleak picture started lightening up in the last few years when  various non-trivial decidable ITLs have been identiďŹed [6],  [7], [8], [9], [10], [11], [12]. (Un)decidability of an ITL  depends on two main factors: (i) the set of its modalities, and  (ii) the class of interval models (the linear order) over which  it is interpreted. Gradually, it became evident that the tradeoff between expressiveness and computational feasibility in  ITLs is rather subtle and sometimes unpredictable, with the  1530-1311/12 $26.00 ÂŠ 2012 IEEE  DOI 10.1109/TIME.2012.18  Pietro Sala  Department of Pharmacology  University of Verona, Verona, Italy  pietro.sala@univr.it  39  ...  đ, đ  đ đ đ  đ, â¨đ´âŠđ, â¨đ´âŠâ¨đ´âŠđ  â  2 đ đ đ  ... ...  đ, â¨đ´âŠđ, â¨đ´âŠâ¨đ´âŠđ  ÂŹđ, ÂŹđ, â¨đ´âŠđ, â¨đ´âŠđ  Figure 1.  A model for the PNL-formula đ over â.  for PNL over â¤ has been reduced to that for a suitable class  of PNL formulas over â. Unfortunately, there is no way to  reduce the satisďŹability problem for PNL over â to that over  â. To deďŹne such a reduction, we should be able to provide  a characterization of the class of â-models corresponding to  â-models in PNL, and we are not (a simple game-theoretic  argument can be used to prove it).  In this paper, we address the satisďŹability problem for  PNL over â. First, we deďŹne syntax and semantics of  PNL, and we brieďŹy discuss separability of â and â in  PNL. Then, we introduce the key notion of fulďŹlling labeled  interval structure. Next, we give a model-theoretic proof of  the decidability of PNL over â. Finally, an optimal tableau  system for PNL over â is developed.  â  M, [đđ , đđ ] âŠ đ1 â¨ đ2 (resp., ÂŹđ) iff M, [đđ , đđ ] âŠ đ1  or M, [đđ , đđ ] âŠ đ2 (resp., M, [đđ , đđ ] ââŠ đ);  â  M, [đđ , đđ ] âŠ â¨đ´âŠđ iff âđđ â đˇ such that đđ > đđ and  M, [đđ , đđ ] âŠ đ;  M, [đđ , đđ ] âŠ â¨đ´âŠđ iff âđđ â đˇ such that đđ < đđ and  M, [đđ , đđ ] âŠ đ.  â  We say that (i) đ is satisďŹable if there exist M and [đđ , đđ ]  such that M, [đđ , đđ ] âŠ đ and (ii) đ is valid, denoted âŁ= đ, if  it is true on every interval in every interval model. We do not  impose any constraint on the valuation function, thus placing  ourselves in the most general (and difďŹcult) interval setting.  As an example, given an interval [đđ , đđ ], it may happen that  đ â đ ([đđ , đđ ]) and đ ââ đ ([đâ˛đ , đâ˛đ ]) for all [đâ˛đ , đâ˛đ ] â [đđ , đđ ].  As already pointed pointed out, PNL is expressive enough  to separate different classes of linear orders as well as  speciďŹc ones. Here, we focus our attention on â and â.  On the one hand, it holds that, for any PNL-formula đ, if đ  is satisďŹable over â, then it is also satisďŹable over â [14].  Roughly speaking, given an â-model M = â¨đ(â), đ âŠ for  đ, a â-model Mâ˛ = â¨đ(â), đ â˛ âŠ for it can be obtained by  deďŹning a suitable (strictly monotonic) mapping from â to â  that mimicks the original valuation đ over â by a valuation  đ â˛ over â. The key observation is that it is always possible  to replace every đ â â â â by a suitable đâ˛ â â without  affecting the truth value of a PNL (sub)formula. On the other  hand, the opposite implication does not hold: there exist  PNL-formulas which are satisďŹable over â, but not over â  [14]. Let đ be the PNL-formula: đ â§ â¨đ´âŠâ¨đ´âŠđ â§ [đş]((đ â  â¨đ´âŠđ) â§ (đ â â¨đ´âŠđ) â§ (đ â [đ´]([đ´]đ â§ [đ´][đ´]đ)) â§ (đ â  [đ´]([đ´]đ â§ [đ´][đ´]đ)) â§ ÂŹ(đ â§ đ) â§ (ÂŹđ â§ ÂŹđ â â¨đ´âŠđ â§ â¨đ´âŠđ)),  where [đş] is the (PNL-deďŹnable) universal modality. đ is satisďŹable over â, but not over â. A â-model M = â¨đ(â), đ âŠ  for đ can be  â built by taking a ďŹctitious point đ â â â â,  say, đ = 2, and by forcing đ to be true over all (and  only) the intervals of rational numbers [đđ , đđ ] to the left of  đ and đ to be true over all (and only) the intervals of rational  numbers [đđ , đđ ] to the right of đ. It can be easily checked  that M satisďŹes đ. A graphical account of M is given in  Figure 1. The unsatisďŹability of đ over â can be proved by  a reductio ad absurdum. Intuitively, đ forces the existence of  an inďŹnite descending sequence of intervals where đ holds  and of an inďŹnite ascending ones where đ holds such that  both the inďŹmum of (the endpoints of) the ďŹrst sequence  and the supremum of (the endpoints of) the second one exist  and must coincide (Dedekind-completeness of â is exploited  T HE LOGIC OF TEMPORAL NEIGHBORHOOD  In this section, we introduce syntax and semantics of  PNL, and we provide a formula that separates â and â  in PNL. Let đˇ be a set of points and đť = â¨đˇ, <âŠ be  a linear order on it. An interval on đť is a pair [đđ , đđ ],  with đđ , đđ â đˇ and đđ < đđ (strict semantics)1 . The set of  all intervals over đť (interval structure) is denoted by đ(đť).  For every [đđ , đđ ], [đâ˛đ , đâ˛đ ] â đ(đť), we say that [đâ˛đ , đâ˛đ ] is  a right (resp., left) neighbor of [đđ , đđ ] iff đđ = đâ˛đ (resp.,  đâ˛đ = đđ ). The vocabulary of PNL consists of a set đđŤ  of proposition letters, the logical connectives ÂŹ and â¨, and  the modalities â¨đ´âŠ and â¨đ´âŠ. The other connectives and the  logical constants â¤ (true) and âĽ (false) are deďŹned as usual.  Moreover, [đ´] and [đ´] stand for the duals ÂŹâ¨đ´âŠÂŹ and ÂŹâ¨đ´âŠÂŹ  of â¨đ´âŠ and â¨đ´âŠ, respectively. Formulae of PNL, denoted  by đ, đ, . . ., are recursively deďŹned by the grammar: đ ::=  đ âŁ ÂŹđ âŁ đâ¨đ âŁ â¨đ´âŠđ âŁ â¨đ´âŠđ. We denote by âŁđâŁ the length of  đ (number of symbols in đ). A formula of the form â¨đ´âŠđ,  ÂŹâ¨đ´âŠđ, â¨đ´âŠđ, or ÂŹâ¨đ´âŠđ is called a temporal formula.  An interval model for a PNL formula đ is a pair M =  â¨đ(đť), đ âŠ, where đ : đ(đť) ââ 2đđŤ is a valuation function  assigning to every interval the set of proposition letters true  over it. Given an interval model M = â¨đ(đť), đ âŠ and an  interval [đđ , đđ ] â đ(đť), the semantics of PNL is deďŹned  recursively by the satisďŹability relation âŠ as follows:  â  ...  for đ â đđŤ, M, [đđ , đđ ] âŠ đ iff đ â đ ([đđ , đđ ]);  1 As an alternative, one may assume a non-strict semantics which admits  point intervals, that is, intervals of the form [đđ , đđ ]. All results in the paper  can be adapted to the case in which non-strict semantics is assumed.  40  here). Let đ be such a point. It is possible to show that there  is no way to consistently deďŹne the truth value of đ and đ  over intervals with đ as their left endpoint (đ excludes the  existence of an interval where both đ and đ hold).  The unsatisďŹability of đ over â can be interpreted as  a plus of â-models: structural properties of â exclude  pathological models like the above-described â-model satisfying đ. Hence, â-models can be viewed as the most  appropriate models for practical applications where density  is an essential ingredient of the temporal domain.  đ â â([đđ , đđ ]) and (ii) for each â¨đ´âŠđ â TF(đ) and every  [đđ , đđ ] â đ(đť), if â¨đ´âŠđ â â([đđ , đđ ]), then there exists  đđ < đđ such that đ â â([đđ , đđ ]). The next theorem proves  that for any PNL-formula đ and any linearly-ordered domain  đť, the satisďŹability of đ is equivalent to the existence of a  fulďŹlling LIS with an interval labeled by đ.  Theorem 1. A PNL-formula đ is satisďŹable over a linearlyordered domain đť iff there exists a fulďŹlling LIS L = â¨đ(đť),  ââŠ such that đ â â([đđ , đđ ]) for some [đđ , đđ ] â đ(đť).  The left-to-right implication is straightforward; the opposite  one is proved by induction on the structure of đ [8].  The statement of the theorem is parametric in đť: it holds  whatever linearly-ordered domain we take as đť. From now  on, we say that a fulďŹlling LIS L = â¨đ(đť), ââŠ satisďŹes đ iff  there exists [đđ , đđ ] â đ(đť) such that đ â â([đđ , đđ ]).  To reason about LISs, we associate with each point the set  of its temporal requests. Given L = â¨đ(đť), ââŠ and đđ â đˇ,  the set of future temporal requests of đđ is REQL  đ (đđ ) =  {â¨đ´âŠđ â TF(đ) : âđđ â đˇ(â¨đ´âŠđ â â([đđ , đđ ]))} âŞ {[đ´]đ â  TF(đ) : âđđ â đˇ([đ´]đ â â([đđ , đđ ]))}. Past temporal  requests are deďŹned in a similar way. The set of temporal  L  requests of đđ is REQL (đđ ) = REQL  đ (đđ ) âŞ REQđ (đđ ).  Given a PNL-formula đ and a LIS L, we deďŹne REQL =  {đ â REQđ âŁ đ = REQL (đ) for some đ â đˇ} and,  for each đ â đˇ, đš đ˘đĄđ˘đđL (đ) = {đ â REQL âŁ đ =  REQL (đâ˛ ) for some đâ˛ > đ} and đ đđ đĄL (đ) = {đ â  REQL âŁ đ = REQL (đâ˛ ) for some đâ˛ < đ}.  The general notion of fulďŹlling LIS can be applied to a  single point as follows. Given L = â¨đ(đť), ââŠ, đđ â đˇ, and  â¨đ´âŠđ â REQL  đ (đđ ), we say that â¨đ´âŠđ is fulďŹlled for đđ in  L if đ â â([đđ , đđ ]) for some đđ > đđ in đˇ. The same for  â¨đ´âŠđ â REQL  đ (đđ ). We say that đđ is fulďŹlled in L if all  L  â¨đ´âŠđ â REQL  đ (đđ ) and â¨đ´âŠđ â REQđ (đđ ) are fulďŹlled for  đđ in L. We also need to count the number of occurrences  of đ â REQđ in a (portion of a) LIS. Given L = â¨đ(đť), ââŠ,  đˇâ˛ â đˇ, and đ â REQđ , we say that đ occurs đ times  in đˇâ˛ if there exist exactly đ distinct points đđ1 , . . . , đđđ â  đˇâ˛ such that REQL (đđđ ) = đ, for each 1 â¤ đ â¤ đ. In  particular, given L = â¨đ(đť), ââŠ, đˇâ˛ â đˇ, and đđ â đˇâ˛ , we  say that REQL (đđ ) (resp., đđ ) is unique in đˇâ˛ if for every  đđ â đˇâ˛ , with đđ â= đđ , REQL (đđ ) â= REQL (đđ ).  F ULFILLING LABELED INTERVAL STRUCTURES  We introduce some basic notions and results. In particular,  we show that the satisďŹability of a PNL formula over a  linearly-ordered domain đť can be reduced to the existence  of a suitable labeling of the interval structure đ(đť).  Let đ be a PNL-formula to be checked for satisďŹability.  The closure CL(đ) of đ is the set of all sub-formulas of  đ and of their negations (we identify ÂŹÂŹđ with đ, ÂŹâ¨đ´âŠđ  with [đ´]ÂŹđ, and ÂŹâ¨đ´âŠđ with [đ´]ÂŹđ). Among the formulas  in CL(đ), a special role is played by the set of temporal  formulas TF(đ) = {â¨đ´âŠđ, [đ´]đ, â¨đ´âŠđ, [đ´]đ â CL(đ)}.  By induction on the structure of đ, one can prove that, for  every formula đ, âŁ CL(đ)âŁ â¤ 2ââŁđâŁ, and âŁ TF(đ)âŁ â¤ 2â(âŁđâŁâ  1). A maximal set of requests for đ is a set đ â TF(đ) such  that (i) for each â¨đ´âŠđ â TF(đ), â¨đ´âŠđ â đ iff [đ´]ÂŹđ ââ đ,  and (ii) for each â¨đ´âŠđ â TF(đ), â¨đ´âŠđ â đ iff [đ´]ÂŹđ ââ đ.  We denote by REQđ the set of all maximal sets of requests.  âŁ TF(đ)âŁ  âŁ REQđ âŁ is equal to 2 2 . We deďŹne a đ-atom (atom for  short) as a set đ´ â CL(đ) such that (i) for each đ â CL(đ),  đ â đ´ iff ÂŹđ ââ đ´, and (ii) for each đ1 â¨ đ2 â CL(đ),  đ1 â¨ đ2 â đ´ iff đ1 â đ´ or đ2 â đ´. Let đđ be the set  of all atoms. It holds that âŁđđ âŁ â¤ 2âŁđâŁ . We connect atoms  by a binary relation đżđđ such that for each pair of atoms  đ´1 , đ´2 â đđ , đ´1 đżđđ đ´2 iff (i) for each [đ´]đ â CL(đ), if  [đ´]đ â đ´1 , then đ â đ´2 , and (ii) for each [đ´]đ â CL(đ),  if [đ´]đ â đ´2 , then đ â đ´1 .  We now introduce a suitable labeling of interval structures  based on atoms that will play an important role in the following proofs. We deďŹne a đ-labeled interval structure (LIS)  as a pair L = â¨đ(đť), ââŠ, where đ(đť) is an interval structure  and â : đ(đť) â đđ is a labeling function such that, for  every pair of neighboring intervals [đđ , đđ ], [đđ , đđ ] â đ(đť),  â([đđ , đđ ]) đżđđ â([đđ , đđ ]). If we interpret â as a valuation  function, LISs can be viewed as candidate models for đ:  truth of formulas devoid of temporal operators follows from  the deďŹnition of atom, and universal temporal conditions,  imposed by [đ´] and [đ´] operators, are forced by the relation  đżđđ . To turn a LIS into a model for đ, we must also  guarantee the satisfaction of existential temporal conditions,  imposed by â¨đ´âŠ and â¨đ´âŠ operators. To this end, we introduce  the notion of fulďŹlling LIS. A LIS L = â¨đ(đť), ââŠ is fulďŹlling  iff (i) for each â¨đ´âŠđ â TF(đ) and every [đđ , đđ ] â đ(đť),  if â¨đ´âŠđ â â([đđ , đđ ]), then there exists đđ > đđ such that  D ECIDABILITY OF PNL OVER â  We now show that the satisďŹability problem for PNL over  â is decidable (NEXPTIME-complete).  DeďŹnition 1. Let đ be a PNL formula, đ´ be an atom, and  đ1 , đ2 â REQđ . The triple â¨đ1 , đ´, đ2 âŠ is an interval-tuple  iff (i) for each [đ´]đ â đ1 , đ â đ´; (ii) for each [đ´]đ â đ2 ,  đ â đ´; (iii) for each â¨đ´âŠđ â TF(đ), â¨đ´âŠđ â đ´ iff â¨đ´âŠđ â  đ2 ; (iv) for each â¨đ´âŠđ â TF(đ), â¨đ´âŠđ â đ´ iff â¨đ´âŠđ â đ1 ;  (v) for each đ â đ´, if â¨đ´âŠđ â TF(đ), then â¨đ´âŠđ â đ1 ; and  (vi) for each đ â đ´, if â¨đ´âŠđ â TF(đ), then â¨đ´âŠđ â đ2 .  41  Interval-tuples act as the basic building blocks in the construction of a (pseudo-)model for a PNL formula.  4)  5)  Proposition 1. Let L = â¨đ(â), ââŠ be a LIS for a PNL formula đ. For every đđ , đđ â â, the triple â¨REQL (đđ ), â([đđ ,  đđ ]), REQL (đđ )âŠ is an interval-tuple.  6)  Given a LIS L, we identify the interval-tuples that occur in  L, and, among them, those which are fulďŹlled in L.  DeďŹnition 2. Let L be a LIS and â¨đ, đ´, đâ˛ âŠ be an intervaltuple. We say that â¨đ, đ´, đâ˛ âŠ occurs in L if there exists  [đđ , đđ ] â đ(â) such that â([đđ , đđ ]) = đ´, REQL (đđ ) = đ,  and REQL (đđ ) = đâ˛ . If â¨đ, đ´, đâ˛ âŠ occurs in L and there  exists [đđ , đđ ] such that â([đđ , đđ ]) = đ´, REQL (đđ ) = đ,  REQL (đđ ) = đâ˛ , and both đđ and đđ are fulďŹlled in L,  then we say that â¨đ, đ´, đâ˛ âŠ is fulďŹlled in L (via [đđ , đđ ]).  7)  such that REQL (đ) = đ;  each point đ â đˇâą is fulďŹlled in L;  for all đ, đâ˛ â đˇâą , with đ < đâ˛ , there exists đâ˛â˛ â đˇ  such that đ < đâ˛â˛ < đâ˛ ;  for each đ â đˇ such that âinf (đ) = {đ1 , ..., đđ }  (â= â), âinf (đ) â đš đ˘đĄđ˘đđL (đ) and, for each 1  â¤ đ â¤ đ, there is đâ˛ such that REQL (đâ˛ ) = đđ  and đš đ˘đĄđ˘đđL (đâ˛ ) = đš đ˘đĄđ˘đđL (đ); if âââ = {đ1 ,  ..., đđ }, then for each 1 â¤ đ â¤ đ, there is đâ˛ such that  REQL (đâ˛ ) = đđ and đš đ˘đĄđ˘đđL (đâ˛ ) = đđđđđ(REQL );  the symmetric condition for âsup (đ) and â+â .  Even though all interval-tuples are fulďŹlled in an â-pseudomodel L for đ, L is not necessarily fulďŹlling, since there can  be multiple occurrences of the same interval-tuple associated  with different intervals. Thus, to turn L into a fulďŹlling LIS  (for đ) some additional effort is needed. The next deďŹnition  introduces an important ingredient of such a process.  We show now how to reduce the problem of checking the  existence of a fulďŹlling LIS for đ to that of checking the  existence of a ďŹnite pseudo-model of bounded size for it.  DeďŹnition 6. Let đ be a PNL formula, L = â¨đ(đť), ââŠ be a  LIS, and đ â đˇ be a fulďŹlled point in L. We say that:  đ  â a set đ¸đđ â đˇ is a future essential set for đ if (i) for  each â¨đ´âŠđ â REQL (đ), there is đâ˛ â đ¸đđđ such that  đ â â([đ, đâ˛ ]) (fulďŹlling condition) and (ii) for each  đâ˛ â đ¸đđđ there is â¨đ´âŠđ â REQL (đ) such that, for  each đâ˛â˛ â đ¸đđđ â {đâ˛ }, ÂŹđ â â([đ, đâ˛â˛ ]) (minimality);  đ  â a set đ¸đđ â đˇ is a past essential set for đ if it satisďŹes  the symmetric fulďŹlling and minimality conditions.  DeďŹnition 3. Let L = â¨đ(đť), ââŠ be a LIS, with đť being (a  restriction of) â. A function âąđđđ : REQL â đˇ âŞ {ââ}  (resp., âąđ đ˘đ : REQL â đˇ âŞ {+â}) is an inďŹmum  (resp., supremum) region function if, for each đ â REQL ,  âąđđđ (đ) = đ, with đ â= ââ (resp., âąđ đ˘đ (đ) = đ, with  đ â= +â), implies REQL (đâ˛ ) â= đ for every đâ˛ â đˇ, with  đâ˛ < đ (resp., đâ˛ > đ).  DeďŹnition 4. Let L = â¨đ(đť), ââŠ be a LIS, with đť being (a  restriction of) â, âąđđđ (resp., âąđ đ˘đ ) be an inďŹmum (resp.,  supremum) region function, and đ â đˇ. The set of sets  of requests that âąđđđ (resp., âąđ đ˘đ ) accumulates on đ is  âinf (đ) = {đ â REQL âŁ âąđđđ (đ) = đ â§ đ â= REQL (đ)}  (resp., âsup (đ) = {đ â REQL âŁ âąđ đ˘đ (đ) = đ â§ đ â=  REQL (đ)}). We put âââ = {đ â REQL âŁ âąđđđ (đ) =  ââ} (resp., â+â = {đ â REQL âŁ âąđ đ˘đ (đ) = +â}).  From DeďŹnition 6, it follows that for each đâ˛ â đ¸đđđ (resp.,  đâ˛ â đ¸đđđ ), there exists at least one formula đ that belongs  to â([đ, đâ˛ ]) (resp., â([đâ˛ , đ]) only, while we cannot exclude  the existence of formulas đ that belong to the labeling of  more than one interval [đ, đâ˛ ] (resp., [đâ˛ , đ]), with đâ˛ â đ¸đđđ  (resp., đâ˛ â đ¸đđđ ).  Lemma 1. Let đ be a PNL formula and L = â¨đ(â), ââŠ  be a fulďŹlling LIS that satisďŹes it. Then, there exists an  â-pseudo-model  Lâ =) â¨â¨đ(đť), ââŠ, âąđđđ , âąđ đ˘đ âŠ for đ with  ( 2ââŁđâŁ  +3â2âŁđâŁ â2  â (2 â âŁđâŁ + 1) + 2 â âŁđâŁ â 23ââŁđâŁ+1 .  âŁđˇâŁ â¤ 2  2  Let đťâą = {đ1 < ... < đđ } be the restriction of đť to the elements which are âsupremaâ or âinďŹmaâ of some đ â REQL ,  i.e., đťâą = â¨(đđđđđ(âąđđđ )âŞđđđđđ(âąđ đ˘đ ))âŠđˇ, <âŠ. For each  1 â¤ đ â¤ đ â 1 and đ â REQL , đ occurs in region đ if there  is đđ < đ < đđ+1 such that REQL (đ) = đ, and đ occurs  in region 0 (resp., đ) if there is đ < đ1 (resp., đ > đđ ) such  that REQL (đ) = đ. Given a PNL formula đ, an â-pseudomodel for đ is deďŹned as follows.  Lemma 2. Let đ be a PNL formula and Lâ = â¨â¨đ(đť), ââŠ,  âąđđđ , âąđ đ˘đ âŠ be an â-pseudo-model for it. Then, there exists  a fulďŹlling LIS L over â that satisďŹes đ.  Proof: First, we build a fulďŹlling LIS over â satisfying  đ; then, we turn it into a fulďŹlling LIS over â satisfying đ.  Building a fulďŹlling LIS Lâ˛ over â. The fulďŹlling LIS Lâ˛ =  â¨đ(â), ââ âŠ is obtained as the âlimitâ of an inďŹnite sequence  of â-pseudo-models L0 (= Lâ ), L1 , L2 , .... We show how to  transform Lđ into Lđ+1 , for every đ âĽ 0, by a 3-step process.  We make use of an auxiliary queue to collect points to be  checked for fulďŹllment. Formally, for any đ âĽ 0, let đđ be  the queue of all points đ â đˇđ that must be checked for  fulďŹllment. đ0 consists of all and only those đ â đˇ such  that đ is not fulďŹlled in Lâ .  DeďŹnition 5. Let đ be a PNL formula, L = â¨đ(đť), ââŠ  be a ďŹnite LIS for đ, âąđđđ and âąđ đ˘đ be respectively an  inďŹmum and a supremum region function, and đťâą = {đ1 <  ... < đđ } be the above-deďŹned suborder of đť. The triple  â¨L, âąđđđ , âąđ đ˘đ âŠ is an â-pseudo-model for đ if it satisďŹes  the following conditions:  1) there exists [đ, đâ˛ ] â đ(đť) such that đ â â([đ, đâ˛ ]);  2) each interval-tuple that occurs in L is fulďŹlled;  3) for each 0 â¤ đ â¤ đ and each đ â REQL that occurs  in region đ, there exists a fulďŹlled point đ in region đ  42  / đˇâą . It can be easily  between đ, đâ˛ belongs to đˇâą . Let đ â  shown that đ = REQLđ+1 (đ) is not unique (the proof is  by contradiction), and thus there is đ â đˇđ+1 , with đ â= đ  (assume đ < đ), such that REQLđ+1 (đ) = đ. We add a new  Ë  point đË to đˇđ+1 , with đ < đË < đâ˛ , and we force REQLđ+1 (đ)  to be equal to đ. To this end, for each đâ˛â˛ â đˇđ+1 , if đâ˛â˛ <  Ë = âđ+1 ([đâ˛â˛ , đ]), otherwise (đâ˛â˛ >  đ, we put âđ+1 ([đâ˛â˛ , đ])  â˛â˛  Ë we put âđ+1 ([đ,  Ë đ ]) = âđ+1 ([đ, đâ˛â˛ ]). Moreover, we put  đ),  Ë = âđ+1 ([đ, đ]). The case in which đ â đˇâą and  âđ+1 ([đ, đ])  / đˇâą is symmetric.  đâ˛ â  First, we observe that the above construction introduces  inďŹnitely many new points, but it does not remove any  point. The choice of a queue to manage points which are  not fulďŹlled guarantees that their defects are sooner or later  ďŹxed. We show now that the fulďŹlling LIS Lâ˛ for đ we  were looking for is the limit of this inďŹnite construction.  Let Lâ  đ be equal to Lđ devoid of the labeling of all intervals  consisting of a (non-unique) point in đđ and a unique point  in đˇđ â đđ . We deďŹne Lâ˛ as the inďŹnite union âŞđâĽ0 Lâ  đ . It  trivially holds that đˇđ â đˇđ+1 , for every đ âĽ 0. To prove  â  that ââ  đ â âđ+1 , for every đ âĽ 0, we observe that: (i) the  set of unique points never changes, that is, the set of unique  points in đˇ0 is equal to that in đˇđ , for every đ âĽ 0, (ii) the  labeling of intervals whose endpoints are both non-unique  (resp., unique) never changes, that is, it is ďŹxed once and for  all, and (iii) for each pair of points đ, đâ˛ â đˇđ âđđ such that đ  is non-unique and đâ˛ is unique, if đ < đâ˛ (resp., đâ˛ < đ), then  âđ ([đ, đâ˛ ]) = âđ ([đ, đâ˛ ]) (resp., âđ ([đâ˛ , đ]) = âđ ([đâ˛ , đ]))  for all đ âĽ đ, that is, the labeling of [đ, đâ˛ ] (resp., [đâ˛ , đ])  may possibly change when the non-unique point is removed  from the queue, but then it remains unchanged forever (nonunique points which are fulďŹlled from the beginning never  change âtheir labelingâ). Finally, to prove that all points are  fulďŹlled in âŞđâĽ0 Lâ  đ , it sufďŹces to observe that: (i) all unique  points are fulďŹlled in the restriction of L0 to đˇ0 â đ0 (and  thus in Lâ  0 ), and (ii) for every đ âĽ 0, all points in đˇđ â đđ  are fulďŹlled in Lâ  đ and the ďŹrst element of đđ may be not  â  fulďŹlled in Lđ (and thus in Lâ  đ ), but it is fulďŹlled in Lđ+1 .  Every point is indeed either directly inserted into đˇđ â đđ  or added to đđ (and thus it becomes the ďŹrst element of đđ  for some đ > đ) for some đ âĽ 0. To conclude, it sufďŹces to  observe that, by condition 1 of DeďŹnition 5, đ â â([đ, đâ˛ ])  for some [đ, đâ˛ ] â đ(đť), and such a condition is preserved  by the construction (from a given iteration on, the interval  over which đ holds does not change anymore). Hence, Lâ˛  is a fulďŹlling LIS for đ over â (it can be easily shown that  đˇâ˛ is isomorphic to â).  Step 1. First, we observe that đđ âŠ đˇâą = â, as points in  đˇâą are already fulďŹlled in Lâ (condition 4 of DeďŹnition 5)  and, as we will see, points which are fulďŹlled in Lđ remain  fulďŹlled in Lđ+1 . If đđ is empty, then we directly move to  step 2. Otherwise, we build Lđ+1 as follows. Let đ be the  element at the head of đđ . If đ is fulďŹlled, we remove it  from đđ and put Lđ+1 = Lđ (every point is not fulďŹlled  when added to the queue, but subsequent expansions of the  domain can make it fulďŹlled before the time at which it will  be taken into consideration). Otherwise, there exist a â¨đ´âŠor a â¨đ´âŠ-formula in đđ¸đLđ (đ) which are not fulďŹlled. Let  us consider the former case. By condition 3 of DeďŹnition  5, there exists đâ˛ (in the same region as đ) such that  REQLđ (đâ˛ ) = REQLđ (đ) and đâ˛ is fulďŹlled. We distinguish  two cases, namely, đâ˛ > đ and đâ˛ < đ, and we show how to  make đ fulďŹlling in both of them (details in the Appendix).  The case of a â¨đ´âŠ-formula in REQLđ (đ) is symmetric. Since  đ is fulďŹlled in the resulting structure Lđ+1 , it can be safely  removed from the queue. As the insertion of new points does  not affect the properties of âąinf and âąsup , we keep them  unchanged during the whole construction. It can be easily  shown that Lđ+1 is an â-pseudo-model for đ.  Step 2. This step acts on the â-pseudo-model generated by  step 1 to guarantee that, in the âlimitâ LIS Lâ˛ , for each đ â  đđđđđ(âąđđđ ) (resp., đđđđđ(âąđ đ˘đ )) and each đ â âđđđ (đ)  â˛  (resp., âđ đ˘đ (đ)), REQL (đâ˛ ) â= đ, for every đâ˛ < đ (resp.,  đâ˛ > đ), and for every đ > 0, there is đ â˛ < đâ˛ < đ + đ  (resp., đ â đ < đâ˛ < đ) such that REQL (đâ˛ ) = đ. For  each đ â đđđđđ(âąđđđ ), let âđđđ (đ) = {đ1 , ..., đđ } (if  âđđđ (đ) = â, the property trivially holds) and let đ be the  immediate successor of đ in (the current value of) đťđ+1  (we refer to the output of Step 1). We add đ new points  đ < đË1 < .. < đËđ < đ to đˇđ+1 , at positions đ+(đâđ)/(đ+  1), .., đ + đ â (đ â đ)/(đ + 1), and we force REQLđ+1 (đËđ ) to  be equal to đđ , for 1 â¤ đ â¤ đ. By condition 6 of DeďŹnition  5, for each 1 â¤ đ â¤ đ, there is đâ˛đ â đˇđ+1 such that  REQLđ+1 (đâ˛đ ) = đđ and FutureLđ+1 (đâ˛đ ) = FutureLđ+1 (đ),  and thus âđđđ (đ) â FutureLđ+1 (đâ˛đ ). Then, for each đ < đ <  đ, there is đâ˛â˛đ > đâ˛đ such that REQLđ+1 (đâ˛â˛đ ) = đđ . We put  â˛  âđ+1 ([đËđ , đËđ ]) = âđ+1 ([đâ˛đ , đâ˛â˛đ ]). Moreover, for every đ âĽ đ,  â˛  there is đâ˛â˛ > đâ˛đ such that REQLđ+1 (đâ˛â˛ ) = REQLđ+1 (đ ).  â˛  We put âđ+1 ([đËđ , đ ]) = âđ+1 ([đâ˛đ , đâ˛â˛ ]). Finally, by deďŹnition  â˛  of âąđđđ , đâ˛đ > đ, and thus, for every đ â¤ đ, we put  â˛  â˛  âđ+1 ([đ , đËđ ]) = âđ+1 ([đ , đâ˛đ ]). For each đ â âââ , we  proceed in the same way, the only difference being that new  points are inserted to the left of the least element of đˇđ+1 .  A completely symmetric set of operations must be peformed  for each đ â đđđđđ(âąđ đ˘đ ) and đ â âđ đ˘đ (đ), and for â+â .  Step 3. This step forces the âlimitâ LIS Lâ˛ to be dense by  simply adding a point in between any pair of consecutive  points. Let đ, đâ˛ be a pair of consecutive points in đˇđ+1 (we  refer to the output of Step 2). Since Lđ+1 is an â-pseudomodel for đ, by condition 5 of DeďŹnition 5, at most one  Turning Lâ˛ into a fulďŹlling LIS L over â. The fulďŹlling  LIS L = â¨đ(â), ââ âŠ for đ can be obtained from Lâ˛ as  follows. First, we put ââ ([đ, đâ˛ ]) = ââ ([đ, đâ˛ ]) for every  đ, đâ˛ â â. Next, we deďŹne a function âąâ : â â â â REQđ  such that for every đđ â â â â, âąâ (đđ ) = đ, for some  đ such that âąinf (đ) < đđ < âąsup (đ) (the existence of  43  đ is guaranteed by the construction of Lâ˛ , which forces  all sets of requests to accumulate on rational points - set  đˇâą ). For every đđ â â â â, we force REQL (đđ ) to  be equal to âąâ (đđ ). By construction, there exists a pair  of rational points đ < đđ < đâ˛ such that REQL (đ) =  REQL (đđ ) = REQL (đâ˛ ) (= R). Then, for every đ â â, we  put (i) ââ ([đ, đđ ]) = ââ ([đ, đ]) if đ < đ, (ii) ââ ([đ, đđ ]) =  ââ ([đ, đâ˛ ]) if đ < đ < đđ , (iii) ââ ([đđ , đ]) = ââ ([đ, đ]) if  đđ < đ < đâ˛ , and (iv) ââ ([đđ , đ]) = ââ ([đâ˛ , đ]) if đ > đâ˛ .  Moreover, we put ââ ([đ, đđ ]) = ââ ([đđ , đâ˛ ]) = ââ ([đ, đâ˛ ]).  From (đ) and (đđŁ), it immediately follows that đđ is fulďŹlled. To complete the construction, we must deďŹne the  labeling of intervals [đđ , đâ˛đ ] for đâ˛đ â â â â (intervals  of the form [đâ˛đ , đđ ], with đâ˛đ â â â â, are taken into  consideration in the labeling of đâ˛đ ). By deďŹnition of âąâ ,  there exist đ, đâ˛ â â, with đ < đđ and đâ˛đ < đâ˛ , such that  REQâ (đ) = REQâ (đđ ) and REQâ (đâ˛ ) = REQâ (đâ˛đ ). We  put ââ ([đđ , đâ˛đ ]) = ââ ([đ, đâ˛ ]). It is easy to check that L is  a fulďŹlling LIS for đ over â.  â¨[đ0 , đ1 ], đ´đ âŠ, where đťđľ = {đ0 < đ1 } and đ â đ´đ . Given  đ â đˇđľ and â¨đ´âŠđ â REQđľ (đ) (resp., â¨đ´âŠđ â REQđľ (đ)),  â¨đ´âŠđ (resp., â¨đ´âŠđ) is fulďŹlled in đľ for đ if there is a node  đâ˛ â đľ labeled by â¨[đ, đâ˛ ], đ´đâ˛ âŠ (resp., â¨[đâ˛ , đ], đ´đâ˛ âŠ) such  that đ â đ´đâ˛ . Given đ â đˇđľ , đ is fulďŹlled in đľ if each  â¨đ´âŠđ (resp., â¨đ´âŠđ) in REQđľ (đ) is fulďŹlled in đľ for đ.  Let đŻ be a tableau and đľ be a branch of đŻ , with đťđľ =  {đ0 < .. < đđ }. We denote by đľ â đ (resp., đľ â đ1 âŁ..âŁđâ ) the  expansion of đľ with an immediate successor node đ (resp.,  â immediate successor nodes đ1 , .., đâ ). To possibly expand  đľ, we apply one of the following expansion rules:  â¨đ´âŠ-rule. If there are đđ â đˇđľ and â¨đ´âŠđ â REQđľ (đđ )  such that â¨đ´âŠđ is not fulďŹlled in đľ for đđ , we proceed  as follows. If there is not an interval-tuple â¨REQđľ (đđ ),  đ´đ , đâŠ, with đ â đ´đ , we close đľ. If for every interval-tuple  đľ  (đ) is deďŹned  â¨REQđľ (đđ ), đ´đ , đâŠ, with đ â đ´đ , âąsup  đľ  â˛  â˛  and âąsup (đ) = đ for some đ â¤ đđ , we close đľ as well.  Otherwise, let â¨REQđľ (đđ ), đ´đ , đâŠ be the selected intervaltuple. Two cases must be considered:  Theorem 2. The satisďŹability problem for PNL over â is  decidable.  đľ  đľ  1) âąsup  (đ) = +â or âąsup  (đ) is not deďŹned. We choose  a new point đ and we expand đľ with â = đ â đ + 1  immediate successor nodes đ1 , . . . , đâ such that, for  each 1 â¤ đ < â, đťđľâđđ = đťđľ âŞ {đđ+đâ1 < đ < đđ+đ }  (for đ = â, we add đ > đđ to the linear order), đđ =  â¨[đđ , đ], đ´đ âŠ, with đ â đ´đ , REQđľâđđ (đ) = đ, and  REQđľâđđ (đâ˛ ) = REQđľ (đâ˛ ) for each đâ˛ â đˇđľ ;  The thesis follows from Lemma 1, Lemma 2, and Theorem  1. Theorem 2 allows us to reduce the problem of checking  whether a PNL formula đ is satisďŹable to that of checking  the existence of an â-pseudo-model for it of bounded size  (the bound is given by Lemma 1). A NEXPTIME decision  procedure for such a problem can be easily developed.  NEXPTIME-hardness can be proved as in [10].  đľ  2) there exists â > 0 such that âąsup  (đ) = đđ+â .  We choose a new point đ and we expand đľ with â  immediate successor nodes đ1 , . . . , đâ such that, for  each 1 â¤ đ â¤ â, đťđľâđđ = đťđľ âŞ {đđ+đâ1 < đ < đđ+đ }  đđ = â¨[đđ , đ], đ´đ âŠ, with đ â đ´đ , REQđľâđđ (đ) = đ,  and REQđľâđđ (đâ˛ ) = REQđľ (đâ˛ ) for each đâ˛ â đˇđľ .  A TABLEAU SYSTEM FOR PNL OVER â  In this section, we develop a tableau-based decision  procedure for PNL over â. First, we give the rules of the  tableau system; then, we describe expansion strategies and  blocking conditions; ďŹnally, we state termination, soundness,  and completeness. Optimality easily follows.  Let us introduce basic notation and deďŹnitions. A tableau  for a PNL formula đ is a special decorated tree đŻ . We  associate a ďŹnite linear order đťđľ = â¨đˇđľ , <âŠ and a request  function REQđľ : đˇđľ â REQđ with each branch đľ  of đŻ . We deďŹne an accumulation constraint as a triple  â¨đ, đđđđđđĄđđđ, đâŠ, where đ â REQđ , đđđđđđĄđđđ â {sup ,  inf }, and đ â đˇđľ âŞ {ââ, +â}. Each node đ in đľ is labeled either by a pair â¨[đđ , đđ ], đ´đ âŠ, when â¨REQđľ (đđ ), đ´đ ,  REQđľ (đđ )âŠ is an interval-tuple (expansion nodes), or by  an accumulation constraint (accumulation nodes). Accumuđľ  đľ  and âąsup  as  lation nodes in đľ deďŹne two functions âąinf  đľ  follows: for each đ â đđđđđ(REQđľ ), âąinf (đ) = đ (resp.,  đľ  âąsup  (đ) = đ) iff the accumulation node â¨đ, inf , đâŠ (resp.,  â¨đ, sup , đâŠ) belongs to đľ (during the construction of đľ,  đľ  đľ  and âąsup  are partial functions on đđđđđ(REQđľ )).  âąinf  đľ  đľ  Likewise, we deďŹne âđľ  inf , đˇâą đľ , Future , and Past .  The initial tableau for đ consists of a single expansion  node (and thus of a single branch đľ) labeled by the pair  â¨đ´âŠ-rule. Symmetric to the â¨đ´âŠ-rule.  Fill-in rule. If there are đđ , đđ â đˇđľ , with đđ < đđ , such  that no node in đľ is decorated with [đđ , đđ ] and there is an  interval-tuple â¨REQđľ (đđ ), đ´, REQđľ (đđ )âŠ, then we expand  đľ with a node đ = â¨[đđ , đđ ], đ´âŠ. If such an interval-tuple  does not exist, we close đľ.  Dense rule. If there are two consecutive points đđ , đđ+1 â  đˇđľ , with đđ , đđ+1 â đˇâą đľ , we proceed as follows. If there  is not an interval-tuple â¨REQđľ (đđ ), đ´, đâŠ for some đ â  REQđ and đ´ â đđ , we close đľ. If for each interval-tuple  đľ  (đ) = đâ˛ for some đâ˛ âĽ đđ+1 or  â¨REQđľ (đđ ), đ´, đâŠ, âąinf  đľ  â˛  âąsup (đ) = đ for some đâ˛ â¤ đđ , we close đľ. Otherwise, let  â¨REQđľ (đđ ), đ´, đâŠ be the selected interval-tuple. We choose  a new point đ and we expand đľ with a node đ, labeled by  â¨[đđ , đ], đ´âŠ, such that đťđľâđ = đťđľ âŞ {đđ < đ < đđ+1 },  REQđľâđ (đ) = đ, and REQđľâđ (đâ˛ ) = REQđľ (đâ˛ ) for every  đâ˛ â đˇ đľ .  đľ  Inf-rule. Let đ â đđđđđ(REQđľ ) be such that âąinf  is  undeďŹned, đđ be the least point in đˇđľ with REQđľ (đđ ) = đ,  and đ be a set of requests. We expand đľ with â = 2đ + 3  44  accumulation nodes đ0 , .., đââ1 , where đ0 = â¨đ, inf , âââŠ  and, for each 0 â¤ đ â¤ đ, đ2đ+2 = â¨đ, inf , đđ âŠ and đ2đ+1  = â¨đ, inf , đâŠ, where đđâ1 < đ < đđ (đ < đ0 for đ = 0)  is a new point. Moreover, for 0 â¤ đ â¤ đ, REQđľâđ2đ+2 (đâ˛ )  = REQđľ (đâ˛ ) for each đâ˛ â đˇđľ , and REQđľâđ2đ+1 (đ) = đ,  đťđľâđ2đ+1 = đťđľ âŞ {đđâ1 < đ < đđ } ({đ < đ0 } for đ = 0),  and REQđľâđ2đ+1 (đâ˛ ) = REQđľ (đâ˛ ) for each đâ˛ â đˇđľ .  đľ  is  Sup-rule. Let đ â đđđđđ(REQđľ ) be such that âąsup  undeďŹned, đđ be the greatest point in đˇđľ with REQđľ (đđ ) =  đ, and đ be a set of requests. We expand đľ with â =  2đâ2đ+3 accumulation nodes đ0 , .., đââ1 , where đ2đâ2đ+2  = â¨đ, sup , +ââŠ and, for each 0 â¤ đ â¤ đ â đ, đ2đ =  â¨đ, sup , đđ+đ âŠ and đ2đ+1 = â¨đ, sup , đâŠ, where đđ+đ < đ <  đđ+đ+1 (đđ < đ for đ = đ â đ) is a new point. Moreover, for  0 â¤ đ â¤ đ, REQđľâđ2đ (đâ˛ ) = REQđľ (đâ˛ ) for each đâ˛ â đˇđľ ,  and REQđľâđ2đ+1 (đ) = đ, đťđľâđ2đ+1 = đťđľ âŞ {đđ+đ < đ <  đđ+đ+1 } ({đđ < đ} for đ = đ â đ), and REQđľâđ2đ+1 (đâ˛ ) =  REQđľ (đâ˛ ) for each đâ˛ â đˇđľ .  Inf-chain rule. Let đ â đˇđľ be such that âđľ  inf (đ) =  {đ1 , . . . , đđ } (â= â) and 1 â¤ đ â¤ đ be such that for  each đâ˛ â đˇđľ , with REQđľ (đâ˛ ) = đđ , Futuređľ (đâ˛ ) â=  Futuređľ (đ). If there is not an interval-tuple of the form  â¨REQđľ (đ), đ´, đđ âŠ, for some đ´, we close đľ. Otherwise, let  â¨REQđľ (đ), đ´, đđ âŠ be such an interval-tuple and đ be the  immediate successor of đ in đťđľ . We choose a new point  đâ˛ and we expand đľ with a node đ = â¨[đ, đâ˛ ], đ´âŠ such that  REQđľâđ (đâ˛ ) = đđ , đťđľâđ = đťđľ âŞ {đ < đâ˛ < đ}, and  REQđľâđ (đâ˛â˛ ) = REQđľ (đâ˛â˛ ) for each đâ˛â˛ â đˇđľ .  Sup-chain rule. Symmetric to the inf-chain rule.  We start from an initial tableau for đ and we apply  the expansion rules to all the non-blocked and non-closed  branches đľ. The expansion strategy is deďŹned as follows:  1)  2)  3)  4)  5)  6)  7)  8)  apply the inf-rule until it generates no new node in đľ;  apply the sup-rule until it generates no new node in đľ;  apply the Fill-in rule until it generates no new node in đľ;  if there exist an active point đ â đˇđľ and â¨đ´âŠđ â REQđľ (đ)  such that â¨đ´âŠđ is not fulďŹlled in đľ for đ, then apply the  â¨đ´âŠ-rule on đ, and then go back to step 1;  if there exist an active point đ â đˇđľ and â¨đ´âŠđ â REQđľ (đ)  such that â¨đ´âŠđ is not fulďŹlled in đľ for đ, then apply the  â¨đ´âŠ-rule on đ, and then go back to step 1;  apply the inf-chain rule until it generates no new node in đľ;  apply the sup-chain rule until it generates no new node in đľ;  apply the Dense rule until it generates no new node in đľ.  A tableau đŻ for đ is ďŹnal iff each branch đľ of đŻ is closed  or blocked.  Theorem 3 (Termination). Let đŻ be a ďŹnal tableau for a  PNL formula  đľ) be a branch of đŻ . It holds that  ( 2âŁđâŁ đ and  2  +3â2âŁđâŁ â2  â (2âŁđâŁ + 1) + 2 â âŁđâŁ â 23ââŁđâŁ+1 ) â  âŁđľâŁ â¤ (  2  ( 2âŁđâŁ  )  âŁđâŁ  â2  â (2âŁđâŁ + 1) + 2 â âŁđâŁ â 23ââŁđâŁ+1 â 1)/2.  ( 2 +3â2  2  Theorem 4 (Soundness and completeness). Let đ be a PNL  formula. If đŻ is a ďŹnal tableau for đ that features one  blocked branch, then đ is satisďŹable over â and, conversely,  if đ is satisďŹable over â, then there exists a ďŹnal tableau  for đ with at least one blocked branch.  R EFERENCES  [1] V. Goranko, A. Montanari, and G. Sciavicco, âA road map  of interval temporal logics and duration calculi,â Journal of  Applied Non-Classical Logics, vol. 14, no. 1â2, pp. 9â54,  2004.  The application of any of the above rules results in the  replacement of the branch đľ with one or more new branches,  each one featuring a new node đ. However, while the ďŹllin rule decorates such a node with a new interval whose  endpoints already belong to đˇđľ , the other rules add a new  point which becomes the left or right endpoint of the interval  associated with the new node.  We say that đ â đˇđľ is active iff one of the following  three conditions occurs: (i) there is a node đ in đľ, with đ =  â¨đ, â, đâŠ for some đ â REQđ and â â {đđđ, đ đ˘đ}; (ii) there  is a node đ in đľ, with đ = â¨[đâ˛ , đâ˛â˛ ], đ´âŠ, such that either đâ˛ =  â˛ â˛â˛  đ or đâ˛â˛ = đ, and for each expansion node đâ˛ = â¨[đ , đ ], đ´â˛ âŠ,  â˛  â˛â˛  which is an ancestor of đ in đľ, â¨REQđľ (đ ), đ´â˛ , REQđľ (đ )âŠ  â˛  â˛â˛  â˛  â= â¨REQđľ (đ ), đ´, REQđľ (đ )âŠ; (iii) for each point đ , with  đľ  đľ  (REQđľ (đ)) < đâ˛ < âąsup  (REQđľ (đ)), inserted in đˇđľ  âąinf  đľ â˛  đľ  before đ, REQ (đ ) â= REQ (đ).  Let đľ be a non-closed branch. We say that đľ is complete  if for each đđ , đđ â đˇđľ , with đđ < đđ , there is a node đ in  đľ labeled by đ = â¨[đđ , đđ ], đ´âŠ, for some đ´. It can be easily  shown that if đľ is complete, then the pair â¨đ(đťđľ ), âđľ âŠ such  that, for each [đđ , đđ ] â đ(đťđľ ), âđľ ([đđ , đđ ]) = đ´ iff there  is a node đ in đľ labeled by â¨[đđ , đđ ], đ´âŠ is a LIS. We say  that đľ is blocked if đľ is complete and for each active point  đ â đľ, đ is fulďŹlled in đľ.  [2] J. Allen, âMaintaining knowledge about temporal intervals,â  Communications of the ACM, vol. 26, no. 11, pp. 832â843,  1983.  [3] J. Halpern and Y. Shoham, âA propositional modal logic of  time intervals,â Journal of the ACM, vol. 38, no. 4, pp. 935â  962, 1991.  [4] D. Bresolin, D. Della Monica, V. Goranko, A. Montanari,  and G. Sciavicco, âThe dark side of Interval Temporal Logic:  sharpening the undecidability border,â in Proc. of the 18th  TIME. IEEE, 2011, pp. 131â138.  [5] K. Lodaya, âSharpening the undecidability of interval temporal logic,â in Proc. of the 6th ASIAN, ser. LNCS, vol. 1961.  Springer, 2000, pp. 290â298.  [6] D. Bresolin, V. Goranko, A. Montanari, and G. Sciavicco,  âPropositional interval neighborhood logics: Expressiveness,  decidability, and undecidable extensions,â Annals of Pure and  Applied Logic, vol. 161, no. 3, pp. 289â304, 2009.  [7] D. Bresolin, A. Montanari, and P. Sala, âAn optimal tableaubased decision algorithm for Propositional Neighborhood  Logic,â in Proc. of the 24th STACS, ser. LNCS, vol. 4393.  Springer, 2007, pp. 549â560.  45  Ë = âđ ([đâ˛â˛ , đđ ]) (if đâ˛â˛ < đ)  Ë  as follows: we put âđ+1 ([đâ˛â˛ , đ])  â˛â˛  Ë đ ]) = âđ ([đđ , đâ˛â˛ ]) (if đâ˛â˛ > đ)  Ë for each đâ˛â˛ ,  and âđ+1 ([đ,  with đâ˛â˛ â= đ, đâ˛â˛ â= đâ˛ , and đâ˛â˛ â= đđ ; moreover, we put  Ë = âđ ([đâ˛ , đđ ]) and âđ+1 ([đâ˛ , đ])  Ë = âđ ([đ, đđ ]).  âđ+1 ([đ, đ])  Ë the request that đâ˛  In such a way, đ satisďŹes over [đ, đ]  satisďŹes over [đâ˛ , đđ ]. Moreover, đË satisďŹes the same past  Ë (resp., [đâ˛ , đ])  Ë  requests that đđ satisďŹes: đË satisďŹes over [đ, đ]  â˛  the request that đđ satisďŹes over [đ , đđ ] (resp., [đ, đđ ]) and it  satisďŹes the remaining past requests over intervals that start  at the same points where the intervals over which đđ satisďŹes  Ë =  them start. Finally, if đ > đđ , we put âđ+1 ([đđ , đ])  Ë  âđ ([đđ , đ]); âđ+1 ([đđ , đ]) = âđ ([đ, đđ ]) otherwise. The labeling remains unchanged for all the remaining pairs đđ , đđ  t, that is, âđ+1 ([đđ , đđ ]) = âđ ([đđ , đđ ]). Now, by deďŹnition of  âđ+1 , if đđ is fulďŹlled (in Lđ ), then đË is fulďŹlled (in Lđ+1 ),  while if đđ is not fulďŹlled (in Lđ ), being đË fulďŹlled or not (in  Ë If đË is  Lđ+1 ) depends on the labeling of the interval [đđ , đ].  not fulďŹlled (in Lđ+1 ), we insert it into đđ+1 . The case (đđđ)  is completely symmetric, and thus its description is omitted.  Case 2. Every đâ˛ > đ such that REQLđ (đâ˛ ) = REQLđ (đ)  (if any) is not fulďŹlled. By condition 3 of DeďŹnition 5, there  is đâ˛ < đ such that (i) REQLđ (đâ˛ ) = REQLđ (đ), (ii) đâ˛ is  / đˇâą (đâ˛ belongs  fulďŹlled, (iii) for each đâ˛ â¤ đâ˛â˛ â¤ đ, đâ˛â˛ â  to the same region as đ), and (iv) for each đâ˛ < đâ˛â˛ < đ, if  REQLđ (đâ˛â˛ ) = REQLđ (đ), then đâ˛â˛ is not fulďŹlled (đâ˛ is the  greatest fulďŹlling point with the same requests as đ). We ďŹrst  prove that PastLđ (đâ˛ ) = PastLđ (đ). The proof is by reductio  ad absurdum. Suppose that there is đâ˛ < đâ˛â˛ < đ such that  / PastLđ (đâ˛ ). Since Lđ is an â-pseudo-model,  REQLđ (đâ˛â˛ ) â  â˛  by condition 2 of DeďŹnition 5 there are đ, đ â đˇđ such  that â¨REQLđ (đâ˛â˛ ), âđ ([đâ˛â˛ , đ]), REQLđ (đ)âŠ is fulďŹlled in Lđ  â˛  â˛  via [đ, đ ]. By deďŹnition, both đ and đ are fulďŹlled; moreâ˛  over, REQLđ (đ) = REQLđ (đâ˛â˛ ), REQLđ (đ ) = REQLđ (đ),  â˛  â˛â˛  and âđ ([đ, đ ]) = âđ ([đ , đ]); ďŹnally, since REQLđ (đâ˛â˛ )  â˛  â  / PastLđ (đâ˛ ), đâ˛ < đ < đ . However, since by condiâ˛  tion (iv) đ is the greatest fulďŹlled element in đˇđ with  â˛  REQLđ (đâ˛ ) = REQLđ (đ), đ cannot be greater than đâ˛  Lđ â˛  (contradiction). Hence, Past (đ ) = PastLđ (đ). Now, let  â˛  đ¸đđđ = {đ1 , .., đđ }. For đ = 1, .., đ, we proceed as follows.  If đđ is unique, then đđ > đ, since PastLđ (đâ˛ ) = PastLđ (đ),  and thus Case 1a applies. If đđ is not unique and đđ > đ,  Case 1b applies. If đđ is not unique and đâ˛ < đđ < đ,  we insert a new point đË immediately after đ and we force  Ë to be equal to REQLđ (đđ ). For each đâ˛â˛ ,  REQLđ+1 (đ)  Ë we put âđ+1 ([đâ˛â˛ , đ])  Ë =  with đâ˛â˛ < đđ (resp., đâ˛â˛ > đ),  â˛â˛  â˛â˛  â˛â˛  Ë  âđ ([đ , đđ ]) (resp., âđ+1 ([đ, đ ]) = âđ ([đđ , đ ])). Since  PastLđ (đâ˛ ) = PastLđ (đ), for each đđ â¤ đâ˛â˛ < đ, there  is đâ˛â˛â˛ < đâ˛ such that REQLđ (đâ˛â˛â˛ ) = REQLđ (đâ˛â˛ ), and  Ë = âđ ([đâ˛â˛â˛ , đđ ]). Finally, we put  thus we put âđ+1 ([đâ˛â˛ , đ])  â˛  Ë  âđ+1 ([đ, đ]) = âđ ([đ , đđ ]). As in case 1, if đË is not fulďŹlled,  we insert it into đđ+1 .  [8] D. Bresolin, A. Montanari, P. Sala, and G. Sciavicco, âOptimal tableau systems for propositional neighborhood logic  over all, dense, and discrete linear orders,â in Proc. of the  20th TABLEAUX, ser. LNAI, vol. 6793. Springer, 2011, pp.  73â87.  [9] ââ, âWhatâs decidable about Halpern and Shohamâs interval  logic? The maximal fragment ABBL,â in Proc. of the 26th  LICS. IEEE Computer Society, 2011, pp. 387â396.  [10] D. Bresolin, A. Montanari, and G. Sciavicco, âAn optimal  decision procedure for Right Propositional Neighborhood  Logic,â Journal of Automated Reasoning, vol. 38, no. 1-3,  pp. 173â199, 2007.  [11] A. Montanari, G. Puppis, and P. Sala, âA decidable spatial  logic with cone-shaped cardinal directions,â in Proc. of the  18th CSL, ser. LNCS, vol. 5771. Springer, 2009, pp. 394â  408.  [12] ââ, âMaximal decidable fragments of Halpern and  Shohamâs modal logic of intervals,â in Proc. of the 37th  ICALP - Part II, ser. LNCS, vol. 6199, 2010, pp. 345â356.  [13] V. Goranko, A. Montanari, and G. Sciavicco, âPropositional  interval neighborhood temporal logics,â Journal of Universal  Computer Science, vol. 9, no. 9, pp. 1137â1167, 2003.  [14] D. Della Monica, A. Montanari, and P. Sala, âThe importance  of the past in interval temporal logics: the case of Propositional Neighborhood Logic,â in Festschrift of Marek Sergot,  ser. LNAI. Springer, 2012, vol. 7360, pp. 79â102.  [15] M. Otto, âTwo variable ďŹrst-order logic over ordered domains,â Journal of Symbolic Logic, vol. 66, no. 2, pp. 685â  702, 2001.  A PPENDIX  Proof of Lemma 2 (step 1).  Case 1. There exists đâ˛ > đ such that REQLđ (đâ˛ ) =  â˛  REQLđ (đ) and đâ˛ is fulďŹlled. Let đ¸đđđ = {đ1 , ..., đđ }. For  đ = 1, ..., đ, we proceed as follows:  Case 1.a. If đđ is unique, then we put âđ+1 ([đ, đđ ]) =  âđ ([đâ˛ , đđ ]). Such a replacement does not introduce new  defects for đđ . By contradiction, suppose that there is a  formula â¨đ´âŠđ â đđ¸đLđ (đđ ) that is fulďŹlled in Lđ by [đ, đđ ]  only. Since by condition 2 of DeďŹnition 5 â¨đđ¸đLđ (đ),  âđ ([đ, đđ ]), REQLđ (đđ )âŠ is fulďŹlled in Lđ , there is [đâ˛â˛ , đâ˛â˛â˛ ]  such that â¨đđ¸đLđ (đ), âđ ([đ, đđ ]), REQLđ (đđ )âŠ is fulďŹlled  in Lđ via [đâ˛â˛ , đâ˛â˛â˛ ]. Since đđ is unique, đâ˛â˛â˛ = đđ . However,  since đ is not fulďŹlled in Lđ , đâ˛â˛ â= đ. Hence, [đâ˛â˛ , đđ ], with  đâ˛â˛ â= đ, fulďŹlls â¨đ´âŠđ, thus contradicting the hypothesis that  changing the labeling of [đ, đđ ] causes a defect for đđ .  Case 1.b. If đđ is not unique, then there is đ â= đđ such that  REQLđ (đ) = REQLđ (đđ ). Three cases are possible: (i) đđ â=  âąinf (REQLđ (đđ )) and đđ â= âąsup (REQLđ (đđ )), (ii) đđ =  âąinf (REQLđ (đđ )), and (iii) đđ = âąsup (REQLđ (đđ )) (since  đđ is not unique, âąinf (REQLđ (đđ )) â= âąsup (REQLđ (đđ ))).  In cases (i) and (ii), we insert a new point đË immediately afË to be equal to REQLđ (đđ )  ter đđ and we force REQLđ+1 (đ)  46 