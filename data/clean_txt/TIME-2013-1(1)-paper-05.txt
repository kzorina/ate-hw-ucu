LTL Satisfiability Checking Revisited  Jianwen Li∗ , Lijun Zhang† , Geguang Pu∗ , Moshe Y. Vardi‡ and Jifeng He∗  ∗ Software  † State  Engineering, East China Normal University  Key Laboratory of Computer Science, Institute of Software, Chinese Academy of Sciences  ‡ Computer Science, Rice University  Abstract—We propose a novel algorithm for the satisfiability  problem for Linear Temporal Logic (LTL). Existing approaches  first transform the LTL formula into a Büchi automaton and  then perform an emptiness checking of the resulting automaton.  Instead, our approach works on-the-fly by inspecting the formula  directly, thus enabling finding a satisfying model quickly without  constructing the full automaton. This makes our algorithm  particularly fast for satisfiable formulas. We report on a prototype implementation, showing that our approach significantly  outperforms state-of-the-art tools.  I.  I NTRODUCTION  Model-checking tools are successfully used for checking  whether systems have desired properties [CGP99]. The application of model-checking tools to complex systems involves  a nontrivial step of creating a mathematical model of the  system and translating the desired properties into a formal  specification expressed by means of temporal assertions. When  the model does not satisfy a given assertion, model-checking  tools accompany this negative answer with a counterexample,  which points to an inconsistency between the system and the  desired behaviors.  The success of model checking led to the emergence of  assertion-based design, where one starts the design process by  formalizing designer intent by means of temporal assertions  [FKL04]. Since at that early stage of the design process model  checking cannot be employed, there is a need for techniques  that would debug these assertions, as it is quite likely that such  assertions contain errors [PSC+ 06]. A basic check is that of  satisfiability [SC85]: checking that each temporal assertion can  be satisfied and the full set of assertions be satisfied together.  (A stronger test is that of realizability [ALW89], but is out of  the scope of this paper.)  An in-depth empirical study of LTL satisfiability was  undertaken by Rozier and Vardi [RV07], [RV10]. A basic  observation underlying their work is that LTL satisfiability  checking can be reduced to model checking. Consider an LTL  formula ϕ over a set P rop of atomic propositions. If a model  M is universal, that is, it contains all possible traces over  P rop, then ϕ is satisfiable precisely when the model M does  not satisfy ¬ϕ. Thus, it is easy to add a satisfiability-checking  feature to LTL model-checking tools.  LTL model checkers can be classified as explicit or symbolic. Explicit model checkers, such as SPIN [Hol97] or SPOT  [DLP04], construct the state-space of the model explicitly  and search for a trace falsifying the assertion [CVWY92].  In contrast, symbolic model checkers, such as CadenceSMV  [McM99] or NuSMV [CCGR00], represent the model and  analyze it symbolically using binary decision diagrams (BDDs)  [BCM+ 92]. LTL model checkers follow the automata-theoretic  approach [VW86], in which the complemented LTL assertion  is explicitly or symbolically translated to a Büchi automaton,  which is then composed with the model under verification;  see also [Var07]. The model checker checks for nonemptiness,  by searching for a trace of the model that is accepted by the  automaton.  Rozier and Vardi [RV07], [RV10] carried out an extensive  experimental investigation of LTL satisfiability checking via a  reduction to model checking. By using large LTL formulas,  they offered challenging model-checking benchmarks to both  explicit and symbolic model checkers. For symbolic model  checking, they used CadenceSMV and NuSMV. For explicit  model checking, they used SPIN as the search engine, and  tested essentially all publicly available LTL translation tools.  They used a wide variety of benchmark formulas, either  generated randomly, as in [DGV99], or using scalable patterns.  Rozier and Vardi reached two major conclusions. First,  most LTL translation tools are research prototypes and cannot  be considered industrial quality tools. Among all the tools  tested, only SPOT can be considered an industrial quality  tool. Second, when it comes to LTL satisfiability checking, the  symbolic approach is clearly superior to the explicit approach.  Even SPOT, the best LTL translator in our experiments, was  rarely able to compete effectively against the symbolic tools.  The evidence marshalled by Rozier and Vardi for the  conclusion in favor of the symbolic approach is quite compelling, but a close examination shows that it applies only  to satisfiability checking via model checking. That is, if one  chooses to perform satisfiability checking via a reduction to  model checking, then the symbolic approach offers superior  performance. It is conceivable, however, that a direct explicit  approach to satisfiability checking would outperform the symbolic approach. In explicit model checking, it is possible to  perform the nonemptiness test on the fly, that is, by letting  the search algorithm drive the construction of the automaton  [CVWY92]. (In fact, the on-the-fly approach was proposed  also for model checking, but was not adopted by SPIN due to  its software architecture [Hol97]).  In this paper we revisit the LTL satisfiability problem  to examine the advantage of the on-the-fly approach. The  driving intuition is that the on-the-fly approach may be quite  advantageous in satisfiability checking, since it enables finding  a model quickly without constructing the full automaton.  Furthermore, the sole focus on satisfiability checking may  be amenable to various heuristics that are not applicable in  the context of model checking. We report here on a novel  LTL satisfiability checking tool, Aalta, and demonstrate that it  outperforms both SPOT and CadenceSMV.  To substantiate our results we also revisit the experimental  methodology of Rozier and Vardi. Their focus has been on  testing satisfiability of large LTL formulas, either scalable  patterns or random. But typical temporal assertions are rather  small [BAC98]. What makes the LTL satisfiability problem  hard is the fact that we need to check large conjunctions  of small temporal formulas. We describe here a new class  of challenging benchmarks, which are random conjunctions  of specification patterns from [BAC98]. Our conclusions on  the superiority of Aalta are based both on the benchmarks of  Rozier and Vardi and the newly introduced benchmarks.  The organization of the paper is as follows. We provide  preliminary material in Section II. In Section III we describe  the novel algorithm underlying Aalta. In Section IV we detail  our experimental methodology. We describe our experimental  results in Section V. Section VI discusses related work and  Section VII concludes the paper.  •  ξ |= ϕ1 U ϕ2 iff there exists i > 0 such that ξi |= ϕ2  and for all 0 6 j < i, ξj |= ϕ1 ;  •  ξ |= ϕ1 R ϕ2 iff either ξi |= ϕ2 for all i ≥ 0, or there  exists i ≥ 0 with ξi |= ϕ1 ∧ ϕ2 and ξj |= ϕ2 for all  0 ≤ j < i;  According to the semantics, it holds ϕRψ = ¬(¬ϕU ¬ϕ).  Definition 2 (Satisfiability): We say ϕ is satisfiable, denoted by SAT (ϕ), if there exists a consistent trace ξ such  that ξ |= ϕ.  In the remainder of this paper, if not stated explicitly, all  traces considered are assumed to be consistent.  Notation. We define some notation that we use throughout  this paper.  •  II.  P RELIMINARIES  A. Linear Temporal Logic  Let AP be a set of atomic properties. The syntax of LTL  formulas is defined by:  •  ϕ ::= tt | ff | a | ¬a | ϕ ∧ ϕ | ϕ ∨ ϕ | ϕU ϕ | ϕR ϕ | Xϕ  where a ∈ AP , ϕ is an LTL formula. We use the usual  abbreviations: F a = ttU a, and Ga = ffRa.  We say ϕ is a propositional formula if it does not contain  temporal operators X, U or R. We say ϕ is a literal if it is an  atomic proposition or its negation. We use L to denote the set  of literals. We use lower case letters a, b, c to denote literals,  α, β, γ to denote propositional formulas, and ϕ, ψ to denote  LTL formulas.  Note that, w.l.o.g., we are considering LTL formulas in  negation normal form (NNF) – all negations are pushed  down to literal level. LTL formulas are often interpreted over  (2AP )ω . Since we consider LTL in NNF forms, formulas are  interpreted on infinite literal sequences Σ := (2L )ω .  ω  A trace ξ = ω0 ω1 ω2 . . . is an infinite sequence over Σ .  For ξ and k ≥ 1 we use ξ k = ω0 ω1 . . . ωk−1 to denote the  prefix of ξ up to its k-th element, and ξk = ωk ωk+1 . . . to  denote the suffix of ξ from its (k + 1)-th element. Thus, ξ =  ξ k ξk . We use η, η0 . . . to denote finite sequences in Σ∗ . First,  we need the notion of consistent traces:  Definition 1 (Consistent Trace): We sayVa literal set A is  consistent iff for all a ∈ A we have that a 6≡ ff. A trace  ξ = ω0 ω1 . . . is consistent iff ωi is consistent for all i.  Let ω ∈ Σ be a consistent set of literals, and α a  propositional formula. We define ω |= α in the standard way:  if α is a literal then ω |= α iff α ∈ ω, ω |= α1 ∧ α2 iff  ω |= α1 and ω |= α2 , and ω |= α1 ∨ α2 iff ω |= α1 or  ω |= α2 . Moreover, ω |= tt and ω 6|= ff.  The semantics of temporal operators with respect to a  consistent trace ξ is given by:  •  ξ |= α iff ξ 1 |= α;  •  ξ |= X ϕ iff ξ1 |= ϕ;  For a formula ϕ, we use cl(ϕ) to denote the set of  subformulas of ϕ. We denote by APϕ the set of atoms  appearing in ϕ, by Lϕ the set of literals over APϕ ,  and by Σϕ the set of consistent literal sets over APϕ .  V  Let ϕ = i∈I ϕi such that the root operator of ϕi is  not a conjunctive. We define the set of conjuncts of ϕ  as CF (ϕ) := {ϕi | i ∈ I}. When ϕ does not include  a conjunctive as a root operator, CF (ϕ) includes only  ϕ itself. The set of disjuncts DF (ϕ) is defined in an  analogous way.  •  For a formula ϕ of the form ϕ1 U ϕ2 or ϕ1 Rϕ2 , let  left(ϕ) (right(ϕ)) be left (right) subformulas of ϕ.  •  For all propositional formula α appearing in the paper,  we always check first whether α is satisfiable. If not,  we shall replace α by ff.  B. Normal Form Expansion  Our algorithm will extend the given formula based on the  notion of normal form for LTL formulas defined as follows:  Definition 3 (Normal Form): The normal form of an LTL  formula ϕ, denoted as NF (ϕ), is a set defined as follows:  1)  2)  3)  4)  5)  6)  NF (ϕ) = {ϕ ∧ X(tt)} if ϕ 6≡ ff is a propositional  formula. If ϕ ≡ ff, we define NF (ff) = ∅;  NF (Xϕ) = {tt ∧ X(ψ) | ψ ∈ DF (ϕ)};  NF (ϕ1 U ϕ2 ) = NF (ϕ2 ) ∪ NF (ϕ1 ∧ X(ϕ1 U ϕ2 ));  NF (ϕ1 Rϕ2 ) = NF (ϕ1 ∧ϕ2 )∪NF (ϕ2 ∧X(ϕ1 Rϕ2 ));  NF (ϕ1 ∨ ϕ2 ) = NF (ϕ1 ) ∪ NF (ϕ2 );  NF (ϕ1 ∧ ϕ2 ) = {(α1 ∧ α2 ) ∧ X(ψ1 ∧ ψ2 ) | ∀i =  1 , 2 . αi ∧ X(ψi ) ∈ NF (ϕi )};  From the definition it is obvious that if α∧X(ψ) ∈ NF (ϕ),  then α is a conjunctive clause, namely a conjunction of literals.  For a formula ϕ, our algorithm will detect sucessor formulas based on the set NF (ϕ). First,  W we shall showWthat the  formula ϕ is logically equivalent  to NF (ϕ), here NF (ϕ)  W  represents the formula 1≤j≤k (αj ∧ Xϕj ) with αj ∧ Xϕj ∈  NF (ϕ) and k = |NF (ϕ)|. We note that the empty disjunction  (OR-ing over an empty set of operands) is defined as ff. Then,  we establish the equivalence property:  W  Lemma 1: For the formula ϕ, it holds ϕ ≡ NF (ϕ).  The lemma below states that along the expansion the set  of subformulas is decreasing (except the constant tt):  4)  5)  Lemma 2: If α ∧ Xψ ∈ NF (ϕ), then CF (ψ) ⊆ cl(ϕ) ∪  {tt}.  6)  III.  N EW S ATISFIABILITY C HECKING A LGORITHM  We first illustrate the main idea of our methodology. The  key of our on-the-fly-approach is the notion of obligation  set. As we show below, satisfying an obligation set gives  a sufficient condition for satisfying a given formula. For a  given formula, the obligation set contains several possible  obligations, each obligation consists of some literals that  characterize a possible way of satisfying the formula. We give  the flavor of this notion in term of a few examples:  •  for the formula aU b or W  aRb the obligation set is  {{b}}; for the formula 1≤i≤n ai U bi the obligation set is {{b1 }, {b2 }, . . . , {bn }}; for the formula  V  1≤i≤n ai U bi the obligation set is {{b1 , b2 , . . . , bn }}.  L  For V  a formula ϕ, if one of its obligations O ⊆ 2 is consistent,  i.e. a∈O a 6≡ ff, the trace ξ = Oω is consistent, and moreover,  it satisfies the corresponding formula. If there is no consistent  obligation, we construct a Transition System Tϕ for ϕ on-thefly. States consist of reachable formulas, and transitions are  obtained by unrolling the current formula according to the  normal form expansion. In our construction we need first to  tag the subformulas such that all the literals are identified by  their positions in until subformulas. We need the notion of  accepting SCCs:  Definition 4: For an SCC B of a transition system (here  it is viewed as a directed graph) we denote by L(B) the set  of all literals appearing in transitions between states in B. We  say B is accepting if L(B) is a superset of some obligation  O ∈ Olg(ψ) and ψ ∈ B.  We show that the formula is satisfiable if an accepting strongly  connected component (SCC) is found that contains a consistent  obligation. Summarizing, combining with the trivial on-the-fly  checking, our approach works as follows:  1)  2)  3)  If a consistent obligation is found in the processed  states so far, then the formula is satisfiable;  If an accepting SCC is found during the generation  of the transition system, then the formula is also  satisfiable.  In the worst case, the formula is unsatisfiable after  exploring on the whole transition system.  Now we present our approach in the following subsections.  A. Obligation Set  The key of our on-the-fly satisfiability algorithm is the  notion of obligation set, defined for the input formula ϕ:  Definition 5 (Obligation Set): For a formula ϕ, we define  its obligation set, denoted by Olg(ϕ), as follows:  1)  2)  3)  Olg(tt) = {∅} and Olg(ff) = {{ff}};  If ϕ is a literal, Olg(ϕ) = {{ϕ}};  If ϕ = Xψ, Olg(ϕ) = Olg(ψ);  If ϕ = ψ1 ∨ ψ2 , Olg(ϕ) = Olg(ψ1 ) ∪ Olg(ψ2 );  If ϕ = ψ1 ∧ψ2 , Olg(ϕ) = {O1 ∪O2 | O1 ∈ Olg(ψ1 )∧  O2 ∈ Olg(ψ2 )};  If ϕ = ψ1 U ψ2 or ψ1 Rψ2 , Olg(ϕ) = Olg(ψ2 );  For O ∈ Olg(ϕ), we refer to it as an obligation  V of ϕ.  Moreover, we say O is a consistent obligation iff a 6≡ ff  holds, where a ∈ O.  The obligation set Olg(ϕ) enumerates all obligations the  given formula ϕ is subject to. Each obligation O ∈ Olg(ϕ)  characterizes a possible way to resolve the obligations proposed by the formula, in the sense that a formula is satisfiable  if one of its obligation can be resolved accordingly. The  particular obligation {ff} can never be resolved.  The power of this characterization is best explained by the  following theorem:  Theorem 1: Assume O ∈ Olg(ϕ) is a consistent obligation. Then, Oω |= ϕ.  The theorem can be proven by simple structural induction  over ϕ. We illustrate the usefulness of the theorem by the  following example:  Example 1:  • Consider G(aRb). It has only one  obligation {b} which is consistent. Thus, the trace  {b}ω satisfies G(aRb).  •  Consider the formula ϕ := GF (a ∧ b) ∧ F (¬a): first,  the obligation {a, b, ¬a} is not consistent. Further, the  normal form NF (ϕ) contains ¬a ∧ X(GF (a ∧ b))).  Thus we can reach the formula GF (a ∧ b) along ¬a.  Moreover, GF (a ∧ b) has a consistent obligation set  O = {a, b}. Theorem 1 then provides a trace ξ with:  ξ := {¬a}Oω |= ϕ.  •  The opposite direction of Theorem 1 does not hold.  Consider for example the formula F (a) ∧ G(X¬a). It  has a single obligation {a, ¬a} which is not consistent.  However, {a}{¬a}ω is a satisfying trace. Consider  another formula F (a) ∧ G(¬a) which has the same  obligation. This formula is obviously not satisfiable.  Theorem 1 is indeed very useful: it returns an affirmative  answer as far as a consistent obligation is found for the current  candidate. This is often the case for satisfiable formulas. In the  following sections, we exploit this notion to derive an on-thefly algorithm for all formulas.  B. Tagging Input Formulas  First, from the discussions and definitions above, we observe that the obligation set ignores the left subformulas of  until and release operators. If Theorem 1 does not give an  affirmative answer, the left subformulas then play a role in our  construction. As a preparation for the general case, we need  first tag the atoms in the input formula in our approach such  that they can be differentiated. The example below illustrates  why tagging is useful in our construction:  Example 2: Consider ϕ := (a ∨ b)U (Ga), in which the  atom a appears twice. Without tagging, we can see there exists  a  b  a transition ϕ −  →ϕ→  − ϕ which forms a SCC B, and L(B) =  {a, b} is a superset of the obligation {a}. However, obviously,  the infinite path through this SCC can not satisfy ϕ.  On the other side, our algorithm first tags the formula to  ϕt = (a1 ∨ b)U (Ga2 ). Then the transition system for the  tagged formula will be constructed. The tagged SCC B has  label L(B) = {a1 , b} which is not a superset of the obligation  {a2 }. Thus B is not an accepting SCC, and the infinite path  a1  b  ϕ→  − ϕ can not satisfy ϕ.  through SCC ϕ −→  We need some notations to formalize the tagging process.  For a given input formula ϕ under consideration. For each  atom a appearing in ϕ, we enumerate all occurrences of a  by Sa := {a1 , a2 , . . . , an }, provided a appears n times in  ϕ. The easiest tagging function is the identity function, i.e.,  we consider all ai syntactically different, but semantically  equivalent. The complexity of our approach will depend on  the number of syntactically different atoms. This tagging is  inefficient: below we give an improved tagging function.  Given a formula ϕ we denote U (ϕ) the set of until  subformulas of ϕ. Then:  Definition 7 (LTL Transition System): Let ϕ be the input  formula and ϕt the tagged formula. The labeled transition  system Tϕ is a tuple hAct, Sϕ , →  − , ϕt i where:  1)  2)  3)  4)  ϕt is the initial state,  Act is the set of conjunctive formulas over Lϕt .  the transition relation →  − ⊆ Sϕ × Act × Sϕ is defined  α  by: ψ1 −  → ψ2 iff there exists α ∧ X(ψ2 ) ∈ NF (ψ1 );  Sϕ is the smallest set of formulas such that ψ1 ∈ Sϕ ,  α  and ψ1 −  → ψ2 implies ψ2 ∈ Sϕ .  Again, note that the transition system for ϕ is defined by  starting from the tagged formula ϕt . The set of states is the  set of formulas reachable from ϕt , with ϕt as the initial state.  Note between two states there can be more transitions. A state  ϕ has no outgoing transitions iff for all α ∧ Xψ ∈ NF (ϕ) and  α is equivalent to ff. In this case ϕ is not satisfiable. Now we  introduce the notion of accepting traces:  Definition 6 (Tagging Formula): Let a ∈ AP be an atom  appearing in ϕ. Then, the tagging function Fa : Sa → 2U (ϕ)  is defined as: ψ ∈ Fa (ai ) iff ai appears in right(ψ).  Definition 8: A run of Tϕ is a (finite or infinite) path r =  α0  α1  α2  ϕ −→  ψ1 −→  ψ2 −→  . . . in Tϕ . A trace ξ = ω0 ω1 . . . ∈ Σω  is accepted by the run r if ωi |= αi for all i.  We define the tagged formula ϕt as the formula obtained  by replacing ai by aFa (ai ) for each ai ∈ Sa .  For ω ∈ Σ, we write ϕ −  → ψ if there exists ϕ −  → ψ  such that ω |= α. For a finite sequence η = ω0 ω1 ..ωk , we  η  ωk  ω0  ω1  ω2  write ϕ −  → ψ iff ϕ −→  ψ1 −→  ψ2 −→  . . . −−→  ψk+1 = ψ.  ξ  More specially, we write ϕ −  → ϕ iff ξ can be written as ξ =  ηi  η0 η1 η2 . . . such that ηi is a finite sequence and ϕ −→ ϕ for  all i ≥ 0.  Thus, after tagging APϕt will contain more atoms. Note  that all these new copies are semantically equivalent to a, i.e.,  aFa (ai ) ≡ a for all aFa (ai ) . Given a tagging function Fa , two  copies ai , aj are syntactically equivalent iff Fa (ai ) = Fa (aj ).  More explicitly, a1 = a2 ⇔ Fa (a1 ) = Fa (a2 ).  As an example, consider ϕ = aU (a ∧ aU ¬a). Let  ψu = aU ¬a, and Sa = {a1 , a2 , a3 , a4 }. From Definition  6 we know Fa (a1 ) = ∅, Fa (a2 ) = Fa (a3 ) = {ϕ}, and  Fa (a4 ) = {ϕ, ϕu }. So the tagging function will introduce  three syntactically different copies of a, and we denote ϕt  by a1 U (a2 ∧ a2 U ¬a4 ). Here even a1 , a2 , a4 are syntactically  different, they are semantically equivalent. Thus it holds for  example a2 ∧ ¬a4 ≡ ff.  Note the size of subformulas may increase after tagging.  According to Definition 6, the following lemma is obvious:  Lemma 3 (Tagging Cost): Let ϕ be the input formula and  ϕt the formula obtained after tagging ϕ. Then, |cl(ϕt )| ≤  2m · |cl(ϕ)|, where m = |U (ϕ)|.  C. LTL Transition System  First, we note that for all formula ϕ, it holds ϕ ≡ ϕt . This  implies SAT (ϕ) iff SAT (ϕt ). As our approach will work with  the tagged formula ϕt , in the remaining of the paper:  •  •  Syntactically: for a given input formula ϕ, all atoms  are ranging over the tagged atoms appearing in ϕt ,  thus AP = APϕt , L = Lϕt and Σ = Σϕt = 2L .  Semantically: tagged atoms are equivalent to the original atom. Thus, the notion of consistent traces and  consistent obligations are defined by taking the semantical equivalences of tagged atoms into consideration.  For a given formula ϕ, we shall define below a labelled  transition system Tϕ for it:  ω  α  Lemma 2 implies the following properties of |Sϕ |:  Corollary 1: For any formula ϕ, it holds:  1)  2)  for all ψ ∈ Sϕ , it holds CF (ψ) ⊆ cl(ϕt ) ∪ {tt},  |Sϕ | ≤ 2n + 1 where n denotes the number of  subformulas of ϕt .  D. On-the-fly Satisfiability Algorithm  First, we introduce some notations:  •  For notational convenience, we fix λ as our input  formula in this section. Let Tλ be the transition system  for the tagged formula λt .  •  For all ϕ ∈ Sλ , we denote by STϕ the subsystem of  Tλ consisting all states reachable from ϕ.  Now we present our main theorem:  Theorem 2: Let ϕ ∈ Sλ . Then, SAT (ϕ) iff there exists a  SCC B of STϕ and a state ψ in B such that L(B) is a superset  of some obligation O ∈ Olg(ψ).  Sketch: The full proof is given in the appendix. We sketch  the proof idea here, which is best illustrated in Figure 1. Let  ξ = ω0 ω1 . . . be a (consistent) trace such that ξ |= ϕ. Then,  ω0  ω1  there is a run in STϕ accepting ξ, i.e., we have ϕ −→  ψ1 −→  n  . . .. After some prefix ξ , since there are only finitely many  states reachable, we will be able to partition the suffix into  η1 η2 . . . where all ηi are finite sequences, and all ηi lead from  ψ to ψ itself. Such formula ψ will be referred to as a looping  formula.  21  2    20  2m'  10   12  1    n  IV.  11   30  3m''  3  1m  31  32  Fig. 1.  A snapshot illustrating the relation ξ |= ϕ  Looping formulas arising from U and R operators must  b  be treated differently. For instance aRb →  − aRb resolves the  a  obligation {b}, however aU b −  → aU b does not. To characterize  this difference, we shall memorize atoms appearing along  the edges and check whether the obligation {b} is met.  Interestingly, R operators are easy to handle, but things get  more involved if the same atom appears on both sides of U  operators, such as aU a. Here we make use the fact that we  are working on the tagged formula, and our transition system  is labelled with tagged atoms. Thus we can efficiently check  whether appearing atoms correspond to those obligations for U  formulas or not. With these notions, the theorem can be proven  by the following idea: any edge label is a propositional formula  that is not ff, thus any run in the transition system induces a  consistent trace, which can be proven to satisfy the formula iff  the collected atoms along the trace can produce an obligation.  Thus, the formula is satisfiable if and only if we can find an  SCC B such that O ⊆ L(B).  The above theorem states that the satisfiability of an LTL  formula λ can be checked directly on the transition system Tλ .  Together with Theorem 1, we arrive at the following on-the-fly  algorithm, which we refer to as OF OA(λ):  1)  2)  3)  4)  We first tag the formula and get λt . Then we construct  Tλ , where we explore the states in an on-the-fly  manner, by performing nest depth-first [CVWY92],  Whenever a formula is found, we compute the obligation set. In case that it contains a consistent obligation  set, we return true because of Theorem 1,  If a SCC B is reached, ϕ ∈ B, and L(B) is a superset  of some obligation set O ∈ Olg(ϕ), we return true,  If all SCCs are explored, and all do not have the  property in step 3, we return false.  We discuss briefly the complexity of the proposed algorithm. First, we remark that the worst case senario happens if  all extended formulas do not contain any consistent sets, which  happens for instance for the formula GF (a) ∧ GF (¬a). Given  the input formula λ, we first construct λt . By Lemma 3, we  have |cl(λt )| ≤ 2m · |cl(λ)|, where m = |U (λ)| is the number  of until subformulas of λ. By Corollary 1, the number of states  is bounded by |Sϕ | ≤ 2n + 1, where n = 2m · |cl(λ)|. In  addition, for each reachable state ϕ, we compute the obligation  Olg(ϕ), which is exponential in the number of conjunctions  in ϕ, but linear in other operators.  E XPERIMENTAL M ETHODOLOGY  We have implemented our algorithms in a tool called  Aalta1 . We denote Theorem 1 as the obligation acceleration  technique (OA, for short). Similarly, we refer to the technique  that underlie Theorem 2 as the on-the-fly technique (OF, for  short). In the tool we have the following two configurations: (i)  OF: On-the-fly checking without OA, (ii) OFOA: On-the-fly  checking with OA (default).  1) Testing tools: In default Aaltais implelmented with the  on-the-fly plus obligation acceleration (OFOA) techniques. In  this paper we compare the performance of Aalta with two other  LTL satisfiability solvers: PANDA+CadenceSMV [RV11] and  SPOT [DLP04]. SPOT is considered as the best explicit LTLto-Büchi translator [RV07], [RV10]. Its most recent version  (1.0.2) has an integrated emptiness checking implementation  (with ”-e” flag) and it is considerably improved since the  benchmarking in [RV07], [RV10]. That benchmarking showed  the superiority of CadenceSMV for LTL satisfiability checking,  and this has been further improved in PANDA+CadenceSMV  [RV11]. Thus, we benchmarked all three tools. (Since PANDA  consists of 30 different symbolic encodings, we run all these  encodings in parallel and chose the best result among them.)  2) Platform: We conducted our benchmarking on the  SUG@R cluster in Rice University2 . SUG@R is an Intel Xeon  compute cluster. It contains 134 SunFire x4150 nodes from  Sun Microsystems. Each node has two quad-core Intel Xeon  processors running at 2.83GHz, yielding a system-wide total  of 1064 processor cores. In our experiments, each test is run  on a single core with a timeout of 10 minutes for each test  formula. The OS is Red Hat Enterprise 5 Linux, 2.6.18 kernel.  Times are measured using the Unix time command. All time  measurements are “end-to-end”; we measure the time starting  from formula input to the satisfiability-checking result (SAT  or UNSAT).  3) Input Formulas: We use here the benchmarks from  [RV07], [RV10], [RV11]. These include random, pattern and  counter formulas. We tested over 60,000 random formulas  and all eight kinds of pattern (lengths varying from 1 to  1000) and four counter formulas (lengths varying from 1 to  20). These benchmarks are suitable for testing satisfiability of  large formulas. Typical temporal assertions are, however, quite  small in practice [BAC98]. What makes the LTL satisfiability  problem hard is the fact that we need to check large conjunctions of small temporal formulas, as we need to check that  the conjunction of all input assertions is also satisfiable. We  introduce here a novel class of challenging LTL benchmarks,  which are random conjunctions of specification patterns from  [BAC98].  Random Conjunction Formulas: Formally, a random  conjunction  formula RC(n) has the form: RC(n) =  V  1≤i≤n Pi (v1 , v2 , . . . , vk ), where n is the number of conjuncts  elements and Pi (1 ≤ i ≤ m) is a randomly chosen property  pattern formula used frequently in practice [BAC98]. The  propositions {v1 , v2 , . . . , vk } used in these formulas are also  chosen randomly. More precisely, we generate the class of  random conjunction formulas in the following way:  1 www.lab205.org/aalta  2 http://www.rcsg.rice.edu/sugar/  20  Checking time (s)  Average Checking Time (s)  Best PANDA+CadenceSmv vs SPOT vs Aalta  checking for R pattern formulas  Average Best PANDA+CadenceSmv vs SPOT  vs Aalta checking time  100  Aalta  PANDA+CadenceSmv  SPOT  80  60  40  20  Aalta  PANDA + CadenceSmv  SPOT  15  10  5  0  0  0  50  100  150  0  200  50  Formula Length  Experimental results for random formulas with 3 variables.  Checking time (seconds)  Best PANDA+CadenceSmv vs SPOT vs Aalta  checking for S pattern formulas  5  Aalta  PANDA + CadenceSmv  SPOT  4  3  2  1  Fig. 3.  Average Checking time (seconds)  Fig. 2.  0  0  100  200  300  400  1)  2)  3)  Experimental results for S(n) =  V  1≤i≤n  Gpi .  We extract all pattern formulas3 .  For a formula in RC(n), we conjoin n pattern formulas selected randomly. In each pattern formula, we  instantiate the variables as random literals (positive or  negative) over a set of six atomic propositions.  In our experiments we generated 500 random formulas for each n.  4) Correctness: To test Aalta’s correctness, we assume that  the results from PANDA+CadenceSMV and SPOT are correct  and we compare the results Aalta’s. Aalta successfully passes  all the tests.  3 http://patterns.projects.cis.ksu.edu/documentation/patterns/ltl.shtml  Experimental results for R(n) =  V  n  i=1  250  (GF pi ∨ F Gpi+1 ).  Best PANDA+CadenceSmv vs SPOT vs Aalta  checking for random conjunction formulas  50  Aalta  PANDA + CadenceSmv  SPOT  40  30  20  10  0  500  0  Variable numbers  Fig. 4.  100  150  200  Variable numbers  Fig. 5.  2  4  6  8  10 12 14  Number of conjunctive elements  Experimental results for random conjunctive formulas.  V.  E XPERIMENTAL R ESULTS  In this section we analyze the experimental results. Generally speaking, our results demonstrate that Aalta outperforms  both SPOT and PANDA+CadenceSMV.  A. Aalta performs best for random formulas.  We first compare the three tools on random benchmarks.  We use here three atomic propositions and formula length of  up to 200. In total, we tested 20,000 formulas. Fig. 2 shows  performance results for the three tools, where for each length  we report average running time on 500 formulas. We can see  that Aalta outperforms the other tools on random formulas.  In fact, Aalta significantly outperforms the other tools; for  Average checking time for random formulas  from Aalta with OFOA and OF  Aalta with OFOA  Aalta with OF  Average checking time (s)  Average checking time (s)  20  Average checking time for random conjuncition  formulas from Aalta with OFOA and OF  20  Aalta with OFOA  Aalta with OF  15  10  5  15  10  5  0  0  50  100  150  formula length  0  200  Fig. 6. Experimental results for 3-variable random formulas from Aalta  with OFOA and OF.  60% of the formulas, Aalta returns in a few millisecond,  while SPOT and PANDA+CadenceSMV takes tens of seconds.  In fact, Aalta completes checking all 20,00 formulas in one  hour, where neither SPOT nor PANDA+CadenceSMV were  able to complete in 40 hours. The superiority of Aalta stems  from the fact that 95% of the test formulas turn out to be  satisfiable; furthermore, 80% of them are checked using the  obligation acceleration technique. Indeed, on unsatisfiable formulas PANDA+CadenceSMV is faster than Aalta, performing  nearly twice as fast as than Aalta. Overall, however, Aalta’s  heuristics for quick satisfiability testing do pay off.  B. Aalta performs best for most of the pattern formulas.  Our experiments show that Aalta performs best for all  pattern formulas except the S-pattern formula, where SPOT  performs best, For example, Fig. 3 displays the comparing  results for the R-pattern formulas, where SPOT scales exponentially with formula length, while PANDA+CadenceSMV  is quicker, and Aalta performs the best. Here it is clear that  SPOT pays the price for not performing the automaton nonemptiness test on the fly, as the automata scale exponentially.  In fact, even Aalta scales exponentially for R-pattern formulas  without the obligation acceleration technique.  For S-pattern formulas, the results are shown in Fig.  4. Here, all three tools scale polynomially, since automata  size scales linearly. SPOT performs better than Aalta, as its  automaton construction is faster.  0  2  4  6  8  10  formula length  12  14  Fig. 7. Experimental results for random conjunction formulas from  Aalta with OFOA and OF.  1)  2)  The number of cases that can be checked by the obligation acceleration technique is much smaller here.  For random conjunction, less than 20% cases can  be checked by the obligation acceleration, and only  about 30% can be checked by finding an accepting  SCC;  The fraction of unsatisfiable formulas is higher here;  about 50% of the formulas are satisfiable, so Aalta’s  advantage in quick satisfiability finding is reduced.  Checking satisfiability for random-conjunction formulas  emerges as a challenging problem, requiring further research.  It would be interesting to combine Aalta with the abstraction  technique of [CRST07].  D. The obligation acceleration enhances on-the-fly checking.  One of the effective heuristics of Aalta is the OA technique:  a consistent obligation implies satisfiability directly. Now we  compare here the results from Aalta implemented with the  OFOA and pure OF strategies in checking random and random  conjunction formulas. Fig. 6 and Fig. 7 indicate that OA  indeed plays a key role. For random formulas the OFOA  strategy performs much faster than the pure OF strategy.  Moreover, the OFOA strategy can be even exponentially better  for special cases, such as the R pattern formulas mentioned  above. Although the advantage declines for random conjunction formulas, the OFOA strategy is still twice as fast as the  OF strategy.  C. Aalta performs best for random conjunction formulas.  Checking satisfiability of random conjunction formulas is  quite challenging, but Aalta still performs best. The results  are shown in Fig. 5. The number of conjuncts extends only  to 15 (with average formula length of 100) and all tools  time out for larger formulas. The advantage of Aalta here  is less marked; it performs about twice as fast as SPOT and  PANDA+CadenceSMV.  VI.  R ELATED W ORK  The classical approach to LTL satisfiability checking is  by reduction to model checking. This can be implemented  using either explicit-state techniques or symbolic techniques.  Rozier and Vardi [RV07], [RV10] studied this approach and  benchmarked several tools. They concluded that the combination of SPIN [Hol97] and SPOT [DLP04] yields the best  performance for the explicit-state approach, but symbolic tools  such as CadenceSMV [McM99] or NuSMV [CCG+ 02] yield  better performance. In follow-up work [RV11], Rozier and  Vardi studied several symbolic encodings of automata for  LTL formulas and described a tool, PANDA, built on top of  CadenceSMV, which implements a portfolio approach, running  many symbolic encodings in parallel and selecting the best  performing one.  Several authors described direct approaches to LTL satisfiability checking, including Wolper [Wol85] and Schwendimann [Sch98]. Wolper’s algorithm uses multiple-pass incremental tableau procedure, while Schwendimann’s requires only  one pass. Although, theoretically, the multiple-pass algorithm  works in EXPTIME and the worst complexity of the onepass works in 2EXPTIME, Goranko, Kyrilov, and Shkatov  [VGS10] showed that, in practice, the one-pass procedure  is more efficient than the multiple-pass one. Yet another  approach to LTL satisfiability is based on temporal resolution [FDP01]. Cimati et al described a Boolean abstraction  technique for LTL satisfiability, which can be combined with  different satisfiability-checking techniques [CRST07]. De Wulf  et al [DDMR08] described a semi-symblic approach based on  anti-chains.  Schuppan and Darmawan [SD11] performed a comprehensive experimental evaluation of LTL satisfiability solvers. They  considered a wide range of solvers implementing three major  classes of algorithms, based on model checking, tableau, and  temporal resolution. They concluded that no solver dominates  or solves all instances, and recommend a portfolio approach,  similar to that of [RV11].  Our tool, Aalta, is closest in spirit to the model-checking  approach, but it combines automaton generation and nonemptiness checking in an on-the-fly approach. In this paper we  demonstrate its performance advantage over model-checkingbased tools. We leave comprehensive comparison in the style  of [SD11] to future work.  VII.  C ONCLUSIONS  In this paper, we proposed a novel on-the-fly satisfiability  checking approach for LTL formulas. Our approach exploits  the notion of obligation set, which provides efficient ways for  identifying many satisfiable formulas. We have implemented a  tool, Aalta, and run experiments using existing and new benchmarks. In most of the cases, Aalta significantly outperforms  existing model-checking-based LTL satisfiability solvers.  R EFERENCES  [ALW89]  M. Abadi, L. Lamport, and P. Wolper. Realizable and unrealizable  concurrent program specifications. In Proc. 25th Int. Colloq. on  Automata, Languages, and Programming, volume 372 of Lecture  Notes in Computer Science, pages 1–17. Springer, 1989.  [BAC98] M. Dwyer B, G.S. Avrunin, and J.C. Corbett. Property specification patterns for finite-state verification. In Proc. 2nd workshop  on Formal methods in software practice, pages 7–15. ACM, 1998.  [BCM+ 92] J.R. Burch, E.M. Clarke, K.L. McMillan, D.L. Dill, and L.J.  Hwang. Symbolic model checking: 1020 states and beyond.  Information and Computation, 98(2):142–170, 1992.  [CCG+ 02] A. Cimatti, E.M. Clarke, E. Giunchiglia, F. Giunchiglia, M. Pistore, M. Roveri, R. Sebastiani, and A. Tacchella. Nusmv 2: An  opensource tool for symbolic model checking. In Proc. 14th Int’l  Conf. on Computer Aided Verification, Lecture Notes in Computer  Science 2404, pages 359–364. Springer, 2002.  [CCGR00]  A. Cimatti, E.M. Clarke, F. Giunchiglia, and M. Roveri. NuSMV:  a new symbolic model checker. It’l J. on Software Tools for  Technology Transfer, 2(4):410–425, 2000.  [CGP99] E.M. Clarke, O. Grumberg, and D. Peled. Model Checking. MIT  Press, 1999.  [CRST07] A. Cimatti, M. Roveri, V. Schuppan, and S. Tonetta. Boolean  abstraction for temporal logic satisfiability. In Proc. 15th Int’l  Conf. on Computer Aided Verification, volume 4590 of Lecture  Notes in Computer Science, pages 532–546. Springer, 2007.  [CVWY92] C. Courcoubetis, M.Y. Vardi, P. Wolper, and M. Yannakakis.  Memory efficient algorithms for the verification of temporal  properties. Formal Methods in System Design, 1:275–288, 1992.  [DDMR08] M. De Wulf, L. Doyen, N. Maquet, and J.-F. Raskin. Antichains:  Alternative algorithms for ltl satisfiability and model-checking. In  Proc. 14th Int’l Conf. on Tools and Algorithms for the Construction and Analysis of Systems, volume 4963 of Lecture Notes in  Computer Science, pages 63–77. Springer, 2008.  [DGV99] N. Daniele, F. Guinchiglia, and M.Y. Vardi. Improved automata  generation for linear temporal logic. In Proc. 11th Int. Conf. on  Computer Aided Verification, volume 1633 of Lecture Notes in  Computer Science, pages 249–260. Springer, 1999.  [DLP04] A. Duret-Lutz and D. Poitrenaud. SPOT: An extensible model  checking library using transition-based generalized büchi automata. In Proc. 12th Int’l Workshop on Modeling, Analysis, and  Simulation of Computer and Telecommunication Systems, pages  76–83. IEEE Computer Society, 2004.  [FDP01] M. Fisher, C. Dixon, and M. Peim. Clausal temporal resolution.  ACM Trans. Comput. Log., 2(1):12–56, 2001.  [FKL04] H.D. Foster, A. Krolnik, and D.J. Lacey. Assertion-Based Design.  Springer, 2004.  [Hol97]  G.J. Holzmann. The model checker SPIN. IEEE Transactions on  Software Engineering, 23(5):279–295, 1997.  [McM99] K. McMillan. The SMV language. Technical report, Cadence  Berkeley Lab, 1999.  [PSC+ 06] I. Pill, S. Semprini, R. Cavada, M. Roveri, R. Bloem, and  A. Cimatti. Formal analysis of hardware requirements. In Proc.  43rd Design Automation Conference, pages 821–826. ACM, 2006.  [RV07]  K.Y. Rozier and M.Y. Vardi. LTL satisfiability checking. In Proc.  14th International SPIN Workshop, volume 4595 of Lecture Notes  in Computer Science, pages 149–167. Springer, 2007.  [RV10]  K.Y. Rozier and M.Y. Vardi. LTL satisfiability checking. Int’l J. on  Software Tools for Technology Transfer, 12(2):1230–137, 2010.  [RV11]  K.Y. Rozier and M.Y. Vardi. A multi-encoding approach for LTL  symbolic satisfiability checking. In Proc. 17th Int’l Symp. on  Formal Methods, volume 6664 of Lecture Notes in Computer  Science, pages 417–431. Springer, 2011.  [SC85]  A.P. Sistla and E.M. Clarke. The complexity of propositional  linear temporal logic. Journal of the ACM, 32:733–749, 1985.  [Sch98]  S. Schwendimann. A new one-pass tableau calculus for pltl. In  Proceedings of the International Conference on Automated Reasoning with Analytic Tableaux and Related Methods, TABLEAUX  ’98, pages 277–292. Springer-Verlag, 1998.  [SD11]  V. Schuppan and L. Darmawan. Evaluating ltl satisfiability solvers.  In Proceedings of the 9th international conference on Automated  technology for verification and analysis, AVTA’11, pages 397–  413. Springer-Verlag, 2011.  [Var07]  M.Y. Vardi. Automata-theoretic model checking revisited. In Proc.  8th Int. Conf. on Verification, Model Checking, and Abstract Interpretation, volume 4349 of Lecture Notes in Computer Science,  pages 137–150. Springer, 2007.  [VGS10] A. Kyrilov V. Goranko and D. Shkatov. Tableau tool for testing  satisfiability in ltl: Implementation and experimental analysis.  Electr. Notes Theor. Comput. Sci., 262:113–125, 2010.  [VW86]  M.Y. Vardi and P. Wolper. An automata-theoretic approach to  automatic program verification. In Proc. 1st IEEE Symp. on Logic  in Computer Science, pages 332–344, 1986.  [Wol85]  P. Wolper. The tableau method for temporal logic: An overview.  Logique et Analyse, 110–111:119–136, 1985.  A PPENDIX  In this appendix we provide all of the missing proofs in  the main paper.  A. Proofs of Lemma 1  C. Proof of Theorem 1  Proof: We prove by structural induction over ϕ. The basic  cases when ϕ is either tt, ff and or any literal are trivial. For  the induction step we consider:  •  If ϕ = Xψ then we have O ∈ Olg(ϕ) = Olg(ψ). By  inductive hypothesis we have Oω |= ψ. Thus, Oω |= ϕ  as well;  •  If ϕ = ϕ1 U ϕ2 then we have O ∈ Olg(ϕ2 ), according  to the definition of obligation set. By inductive hypothesis we have Oω |= ϕ2 . Moreover according to  LTL semantics we know Oω |= ϕ as well;  •  The case ϕ = ϕ1 Rϕ2 is similar to previous case;  •  If ϕ = ϕ1 ∨ ϕ2 , we have O ∈ Olg(ϕ1 ) or O ∈  Olg(ϕ2 ). Assume O ∈ Olg(ϕ2 ) without loss of  generality. By inductive hypothesis we have Oω |= ϕ2 ,  implying Oω |= ϕ as well;  •  If ϕ = ϕ1 ∧ ϕ2 then there exist O1 ∈ Olg(ϕ1 ) and  O2 ∈ Olg(ϕ2 ) such that O = O1 ∪ O2 . Since O is  consistent so both O1 and O2 must be consistent. By  inductive hypothesis we have O1ω |= ϕ1 and O2ω |= ϕ2 .  Again since O is consistent have Oω |= ϕ1 ∧ ϕ2 .  Proof: We prove it by structural induction over ϕ:  •  The case that ϕ is propositional formula or a next  formula is trivial by definition.  •  If ϕ = ϕ1 ∨ ϕ2 , then applying  induction  W  W hypothesis  we have ϕ ≡ ϕ1 ∨ ϕ2 ≡ W NF (ϕ1 ) ∨ NF (ϕ2 ) ≡  W  (NF (ϕ1 ) ∪ NF (ϕ2 )) ≡ NF (ϕ1 ∨ ϕ2 ).  •  If ϕ = ϕ1 ∧ ϕ2 , then applying  inductionWhypothesis  W  we have ϕ ≡ ϕ1 ∧ ϕ2 ≡ ( NF (ϕ1W  )) ∧ ( NF (ϕ2 )).  By inspection, this is equivalent to NF (ϕ1 ∧ ϕ2 ).  •  If ϕ = ϕ1 U ϕ2 , then by Definition 3 we know  NF (ϕ) = NF (ϕ2 ) ∪ NF (ϕ1 ∧ Xϕ), and that ϕ ≡  ϕ2 ∨ (ϕ1 ∧ Xϕ).  By induction hypothesis we have  W  that ϕ2 ≡  NF (ϕ2 ). Moreover,  we also proved  W  previously that ϕ1 ∧Xϕ ≡ NF (ϕ1 ∧Xϕ).  W Thus we  can prove that ϕ ≡ ϕ  W  W2 ∨ (ϕ1 ∧ Xϕ) ≡ NF (ϕ2 ) ∨  NF (ϕ1 ∧ Xϕ) ≡ NF (ϕ);  •  The case ϕ = ϕ1 Rϕ2 is similar to the case when ϕ  is a Until formula.  B. Proof of Lemma 2  Proof: First, CF (ψ) ⊆ cl(ϕ) by structural induction over  ϕ. The base cases ϕ = tt, ff and propositional formulas are  trivial. Otherwise:  1)  2)  3)  4)  5)  If ϕ = ϕ1 ∨ ϕ2 . Then NF (ϕ) = NF (ϕ1 ) ∪ NF (ϕ2 ).  So α ∧ Xψ ∈ NF (ϕi ) with i = 1 or i = 2. By  induction hypothesis we have CF (ψ) ⊆ cl(ϕi ) ⊆  cl(ϕ).  If ϕ = Xϕ1 . In this case we have NF (ϕ) = {tt ∧  Xϕ0 | ϕ0 ⊆ DF (ϕ1 )}. Since CF (ϕ0 ) ⊆ cl(ϕ1 ) ⊆  cl(ϕ), so we have CF (ψ) ⊆ cl(ϕ).  If ϕ = ϕ1 ∧ ϕ2 , then we know for every α ∧  Xψ ∈ NF (ϕ) there exists α1 ∧ Xψ1 ∈ NF (ϕ1 )  and α2 ∧ Xψ2 ∈ NF (ϕ2 ) such that α = α1 ∧ α2  and ψ = ψ1 ∧ ψ2 . Since by induction hypothesis we  know CF (ψ1 ) ⊆ cl(ϕ1 ) and CF (ψ2 ) ⊆ cl(ϕ2 ), so  CF (ψ) ⊆ cl(ϕ) holds.  If ϕ = ϕ1 U ϕ2 . We have two cases. Either we have  the right expansion α ∧ Xψ ∈ NF (ϕ2 ), in which  case CF (ψ) ⊆ cl(ϕ2 ) ⊆ cl(ϕ) follows directly by  induction hypothesis. For the left expansion case, we  have α ∧ Xψ ∈ NF (ϕ1 ∧ Xϕ), implying that there  exists α1 ∧ Xψ1 ∈ NF (ϕ1 ) such that ψ = ψ1 ∧ ϕ. So  CF (ψ) ⊆ cl(ϕ) follows by exploiting the induction  hypothesis that CF (ψ1 ) ⊆ cl(ϕ1 ) ⊆ cl(ϕ).  If ϕ = ϕ1 Rϕ2 , then we can prove similarly as the  case when ϕ = ϕ1 U ϕ2 .  D. Proof of Corollary 1  Proof: The first clause follows by a simple induction over  the path from ϕt to ψ. Note the constant 1 is due to the  possibility of producing tt along the expansion.  E. Proof of Theorem 2  This section is devoted to the proof of Theorem 2. We  organize the proof as follows. We first introduce the notion  of looping formulas and discuss their properties. We then  continue with the soundness and completeness proofs of the  theorem.  Assumption. Throughout the section, we have the following assumptions:  •  λ denotes the fixed input formula, Tλ is the transition  system for λ.  •  all traces are over Σω ⊆ 2Lλt , i.e., the set of consistent  literals over Lλt .  •  all formulas appearing in this section are taken from  the set of states Sλ , i.e., ϕ, ψ... ∈ Sλ . Thus, all  formulas in this appendix will be ranging over tagged  atoms appearing in λt .  1) Looping Formulas and Their Properties: We start with  a simple lemma about the relation between satisfiability and  the transitions:  Lemma 4: Let ξ ∈ Σω be a trace. Then, for all n ≥ 1,  ξn  there exists ψ such that ξ |= ϕ ⇔ ϕ −→ ψ ∧ ξn |= ψ.  Proof: Let ξ = ω0 ω1 . . .. We prove the lemma by  induction over the number n.  •  For the  W base case we let n = 1. Then: ξ |= ϕ ⇔  ξ |= NF (ϕ) ⇔ ∃α ∧ Xψ ∈ NF (ϕ) · ξ |= (α ∧ Xψ)  ξ1  ⇔ ∃α∧Xψ ∈ NF (ϕ)·ξ1 |= ψ∧ω0 |= α ⇔ ∃ψ·ϕ −→  ψ ∧ ξ1 |= ψ.  •  For the induction step, we assume the lemma holds  for all n = 1, 2, . . . , k and prove that it holds for  n = k + 1 as well. Applying the induction hypothesis  ξk  on k, we have: ξ |= ϕ ⇔ ϕ −→ ψ ∧ ξk |= ψ holds.  Further, for ξk |= ψ we apply the induction hypothesis  with respect to the base case and obtain ξk |= ψ ⇔  ξ1  k  ψ −→  ψ 0 ∧ ξk+1 |= ψ 0 , so we can conclude that ξ |=  The order ≺ is obviously a partial order. For a looping  formula ϕ, the set CF (ϕ) posses at least one minimal element  (w.r.t. the order ≺). Below we prove that all minimal elements  of the set expand either to tt or themselves.  η  Lemma 6: If ϕ −  → ϕ then for all minimal element ψ ∈  η  CF (ϕ) we have ψ −  → tt or ψ.  η  Proof: Let ψ be a minimal element in CF (ϕ). Since ϕ −  →  η  ϕ and ψ ∈ CF (ϕ), there must exist ψ 0 such that ψ −  → ψ 0 and  CF (ψ 0 ) ⊆ CF (ϕ) or ψ 0 = tt. If ψ 0 6= tt, then according  to Lemma 2 we know CF (ψ 0 ) ⊆ cl(ψ). However, cl(ψ) ∩  CF (ϕ) = {ψ} because of the minimality of ψ. Thus ψ 0 = ψ.  ξ k+1  ϕ ⇔ ϕ −−−→ ψ 0 ∧ ξk+1 |= ψ 0 . The proof is done.  Essentially, ξ |= ϕ is equivalent to that we can reach a  formula ψ along the prefix ξ n such that the suffix ξn satisfies  ψ. Thus, if ξ |= ϕ holds, then ξ will be accepted by a run in  STϕ .  Now we introduce the notion of looping formulas:  Definition 9 (Looping formula): We say ϕ is a looping  formula iff there exists a trace ξ ∈ Σω which can be written  as an infinite sequence ξ = η0 η1 η2 . . . such that ηi is a finite  ηi  ξ  sequence and ϕ −→ ϕ for all i ≥ 0. We write ϕ −  → ϕ in this  case, and say ϕ is a looping formula with respect to ξ.  The following corollary is a direct consequence of Lemma  4 and the fact that we have only finitely many formulas in Sϕ :  Corollary 2: If ξ |= ϕ, then there exists n ≥ 1 such that  ξn  ϕ −→ ψ and ξn |= ψ and ψ −→ ψ.  ξn  Proof: From Lemma 4 ξ |= ϕ implies there is an infinite  ω0  ω1  ω2  expansion path σ = ϕ −→  ψ1 −→  ψ2 −→  . . . such that  ξi |= ψi for all i ≥ 1. Since we have only finitely states, there  must exist a ψ reachable from ϕ such that it appears infinitely  often along this path. Obviously, this formula ψ is a looping  formula as required.  This corollary gives the hint that after a finite prefix we  can focus on the satisfiability of looping formulas. Now we  give a lemma stating a nice property for the release operator:  Definition 11: Let η = ω0 ω1 . . . ωn (n ≥ 0). Then, we  say the finite sequence η satisfies the formula ϕ, denoted by  η |=f ϕ, iff there exists O ∈ Olg(ϕ) such that O ⊆ η. Here  O ⊆ η is an abbreviation for O ⊆ ∪ni=0 ωi .  Please note that the relation is defined by checking syntactic inclusion. Thus, assuming the input formula is aU a, which  is a1 U a2 after tagging. According to the above definition,  {a1 } 6|=f a2 . The reader shall bear this in mind in the  remaining of this section.  Below we present some simple properties of the relation  |=f which will be useful later:  Lemma 7:  1) Assume η |=f ϕ, then η |=f ϕ ∨ ψ.  2) Assume η |=f ϕ and η |=f ψ, then η |=f ϕ ∧ ψ.  Proof: Let η = ω0 ω1 . . . ωn . We consider the first case:  η |=f ϕ implies that there exists O ∈ Olg(ϕ) such that O ⊆ η.  Since O ∈ Olg(ϕ) ⊆ Olg(ϕ∨ψ), we have η |=f ϕ∨ψ. For the  second case: η |=f ϕ implies that there exists O1 ∈ Olg(ϕ)  such that O1 ⊆ η. Similarly, η |=f ψ implies that there exists  O2 ∈ Olg(ψ) such that O2 ⊆ η. Since we have O1 ∪ O2 ∈  Olg(ϕ ∧ ψ) and O1 ∪ O2 ⊆ η, we have η |=f ϕ ∨ ψ.  The following lemma corresponds to Lemma 5 for until  formulas with respect to the finite satisfaction relation:  η  Lemma 8: Let ϕ = ϕ1 U ϕ2 and ϕ −  → ϕ. Then, η 6|=f ϕ.  η  → ϕ as  Proof: Let η = ω0 ω1 . . . ωn and we rewrite ϕ −  ω2  ωn  ω0  ϕ −→ ψ1 −→  . . . −−→  ϕ. Note it is apparent that ϕ −→  ω0  0  0  (ϕ ∧ ϕ1 ) with ϕ1 −→ ϕ1 . Thus, by induction one can show  ω0  ω1  that along the path ϕ −→  ψ1 −→  ψ2 . . . it holds ϕ ∈ CF (ψi )  for all i. Since the transition for conjunctive formula ψi is  obtained by combining transitions for each ψ 0 ∈ CF (ψi ), the  transition for the subformula ϕ ∈ CF (ψi ) must be from left  subformula ϕ1 , i.e., α ∧ Xψ ∈ NF (ϕ1 ∧ Xϕ). As a result, for  each i, the label ωi must be a superset of CF (αi ), and CF (αi )  contains the literals from ϕ1 . Moreover, the tagging function  has been used to classify the atoms. According to Definition  6 the atoms in ϕ1 and ϕ2 are never tagged the same – this is  because the atoms in ϕ2 will tag ϕ while those in ϕ1 will not.  So ϕ1 and ϕ2 still don’t have common atoms, thus CF (αi )  contains no obligation literals from ϕ2 ;  ω0  ξ  Lemma 5: If ϕ = ϕ1 Rϕ2 and ϕ −  → ϕ, then ξ |= ϕ.  ξ  2) Soundness Proof of Theorem 2: We first introduce the  relation |=f :  ξn  ξn  Proof: Since ϕ −  → ϕ, so we have ∃n · ϕ −→ ϕ ∧ ϕ −→ ϕ.  Let ηi = ωi ωi+1 . . . ωn (0 ≤ i ≤ n). Here all expansions for  the formula ϕ along the path must be from the right subformula  ξn  ϕ2 of ϕ, i.e., α ∧ Xψ ∈ NF (ϕ2 ∧ Xϕ). Since ϕ −→ ϕ, we  ηi  have that ∀0 ≤ i ≤ n · ϕ2 −→ tt, which implies ξj |= ϕ2 for  ξn  all 0 ≤ j ≤ n. Inductively for ϕ −→ ϕ we can get the same  property. So ∀j ≥ 0 we have ξ |= ϕ2 , implying ξ |= ϕ.  Finally, we shall introduce an order on formulas to identify  structural properties of looping formulas. We propose the  following order for formulas:  Definition 10 (Poset on Formulas): For formulas ϕ, ψ, we  write ϕ ≺ ψ iff ϕ ∈ cl(ψ).  According to the definition 5, the obligation literals of ϕ  are all from those of ϕ2 . Thus, from the definition of |=f  (Definition 11), we know η 6|=f ϕ.  The following lemma says that if there exists a partitioning  ξ = η1 η2 ... that makes ϕ expanding to itself by each ηi and  ηi |=f ϕ holds, then ξ |= ϕ.  Lemma 9: Given a looping formula ϕ and a trace ξ, let  ηi  ξ = η1 η2 . . . · if ∀i ≥ 1 · ϕ −→ ϕ ∧ ηi |=f ϕ, then ξ |= ϕ.  Proof: We enumerate  V the set CF (ϕ) = {ϕ1 , ϕ2 , . . . , ϕn },  and we shall prove ξ |= CF (ϕ). Let S0 denote the minimal  elements of CF (ϕ) with respect to the partial order ≺. Moreover, we define Si+1 = Si ∪{ψ 0 ∈ CF (ϕ) | ∃ψ ∈ Si .ψ ≺ ψ 0 }.  Obviously, there is a finite index k such that Sk = CF (ϕ).  We proceed with induction over the index:  1)  2)  •  If ϕ = ϕ1 ∧ ϕ2 , then ξ |= ϕ1 ∧ ξ |= ϕ2 . By induction  hypothesis we have ∃n1 · ξ n1 |=f ϕ1 and ∃n2 · ξ n2 |=f  ϕ2 hold. Observe that ξ n |=f ϕ implies ξ m |=f ϕ for  all m ≥ n. Now from Lemma 7 we have that ξ n |=f ϕ  with n := max(n1 , n2 ).  •  If ϕ = ϕ1 ∨ ϕ2 , then ξ |= ϕ1 ∨ ξ |= ϕ2 . By induction  hypothesis we have ∃n1 · ξ n1 |=f ϕ1 or ∃n2 · ξ n2 |=f  ϕ2 holds. Without loss of generality, assume ∃n1 ·  ξ n1 |=f ϕ1 . Lemma 7 implies then ξ n1 |=f ϕ1 ∨ ϕ2 .  •  If ϕ = ϕ1 U ϕ2 , ξ |= ϕ1 U ϕ2 implies that there exists  i ≥ 0 such that ξi |= ϕ2 . By induction hypothesis  we have ∃n · ξi n |=f ϕ2 hold, thus there exists an  obligation O ∈ Olg(ϕ2 ) such that O ⊆ ξi n . This  implies O ⊆ ξ i+n , thus ξ i+n |=f ϕ holds.  •  If ϕ = ϕ1 Rϕ2 , we observe first that ξ |= ϕ2 must  hold. By induction hypothesis we know ∃n·ξ n |=f ϕ2 .  According to Definition 11 we have that ξ n |=f ϕ  holds as well.  ηi  Basic step: Let ψ ∈ S0 . By Lemma 6 if ϕ −→ ϕ, then  ηi  ηi  ηi  ψ −→ tt or ψ −→ ψ. If ∃ηi · ψ −→ tt holds, ξ |= ψ  ηi  follows from Lemma 4. Otherwise we have ψ −→ ψ  for all i ≥ 1. According to LTL semantics ψ must be  either until or release formula. Applying Lemma 8 we  know that ψ cannot be an Until formula, and thus be a  Release formula. Then  V Lemma 5 implies that ξ |= ψ,  and therefore ξ |= S0 .  V  For induction step we assume ξ |= Sk . Consider  ηi  arbitrary ηi : let ψ ∈ Sk+1 \ Sk and assume ψ −→ ψ 0 .  ηi  0  Since ϕ −→ ϕ, we have CF (ψ ) ⊆ CF (ϕ). By the  construction of the set Si , CF (ψ 0 ) does not contain  any other elements in Sk+1 , thus we have CF (ψ 0 ) ⊆  {ψ} ∪ Sk . First we assume CF (ψ 0 ) ⊆ Sk . Then from  the induction hypothesis we know ηi+1 ηi+2 . . . |= ψ 0  so ηi ηi+1 . . . |= ψ (From Lemma 4), thus ξ |= ψ.  ηi  Now consider the case ψ ∈ CF (ψ 0 ):ψ −→ ψ implies  that ψ must be a Release formula. Then Lemma  5  V  implies again that ξ |= ψ, and therefore ξ |= Sk+1 .  ξ  Lemma 12: Let ϕ be a looping formula, and assume ϕ −  →  ϕ and ξ |= ϕ hold. Then there exists a partitioning ξ = η1 η2 . . .  ηi  and ∀i ≥ 0 · ϕ −→ ϕ ∧ ηi |=f ϕ holds.  ξ  Proof: Assume ϕ −  → ϕ ∧ ξ |= ϕ. We first prove that there  ξn  ξn  exist n such that ϕ −→ ϕ ∧ ξ n |=f ϕ ∧ (ϕ −→ ϕ ∧ ξn |= ϕ).  From Lemma 11 ξ |= ϕ implies that there exists k such that  ξ k |=f ϕ. Since ϕ is a looping formula with respect to ξ, we  ξn  ξn  can find the n ≥ k such that ϕ −→ ϕ and ϕ −→ ϕ hold.  For n ≥ k, ξ n |=f ϕ holds as well. Now we apply Lemma 4:  ξn  ξ |= ϕ implies that ϕ −→ ϕ and ξn |= ϕ.  ξn  Now we are ready to prove the soundness part of the  theorem:  Since ϕ −→ ϕ ∧ ξn |= ϕ, applying the arguments above  inductively yields the lemma.  ξ  Lemma 10 (Soundness): Let ϕ ∈ Sλ . Assume that there  exists a SCC B of STϕ such that ψ ∈ B and L(B) is a  superset of some obligation set O ∈ Olg(ψ). Then, SAT (ϕ).  ω  1  Proof: As B is a SCC, we have a path δ := ψ(ψ1 ) −→  ωk−1  ψ2 −→ . . . −−−→ ψ such that η visits all states in B and all  transitions between states in B (η = ω1 ω2 . . . ωk−1 ). Since all  states in STϕ are reachable from ϕ, there must exist a finite  η0  sequences η0 such that ϕ −→ ψ. We construct ξ := η0 η ω . By  assumption there exists O ∈ Olg(ψ) such that O ⊆ L(B) =  ∪k−1  i=1 ωi . So according to the definition of |=f we have η |=f ψ.  Thus from Lemma 9 we have ξ |= ϕ. So ϕ is satisfiable.  ω2  3) Completeness Proof of Theorem 2:  Lemma 11: ξ |= ϕ ⇒ ∃n · ξ n |=f ϕ.  Proof: We prove it by structural induction over the  formula ϕ. For the base case assume ϕ is tt or a literal,  ξ 1 |=f ϕ by definition. Moreover, ϕ can not be ff. Now we  consider the induction step:  •  If ϕ = Xψ, then ξ |= ϕ ⇒ ξ1 |= ψ. By induction  hypothesis we know ∃n·ξ1 n |=f ψ holds, so ξ n+1 |=f  ϕ holds.  The above lemma states that if ϕ −  → ϕ as well as ξ |= ϕ,  we can find a partitioning η1 η2 . . . that makes ϕ expend to  itself by each ηi and ηi |=f ϕ holds. Combining Lemma 6,  Lemma 7 and Corollary 1, we have our central theorem:  Lemma 13 (Completeness): Let ϕ ∈ Sλ . Then, SAT (ϕ)  implies that there exists a SCC B of STϕ and such that ψ ∈ B  and L(B) is a superset of some obligation set O ∈ Olg(ψ).  Proof: Since SAT (ϕ), let ξ such that ξ |= ϕ. Then by  ξn  Corollary 2 there exists n ≥ 0 and ψ ∈ Sϕ such that ϕ −→ ψ,  ξn  ψ −→ ψ and ξn |= ψ. Moreover, by Lemma 12, there exists  a partition ξn = η1 η2 . . . such that for every finite sequence  ηi  ηi we have ψ −→ ψ as well as ηi |=f ψ. As the state ψ  is visited infinitely often, there must be a SCC B such that  ψ ∈ B. According to the definition of |=f we know that there  η1  exists O ∈ Olg(ψ) such that O ⊆ η1 . Obviously, ψ −→ ψ  is contained in some SCC B, thus η ⊆ L(B), implying O ⊆  L(B). 