2011 Eighteenth International Symposium on Temporal Representation and Reasoning  On Tool Support for Duration Calculus on the basis of Presburger Arithmetic  Michael R. Hansen and Aske W. Brekling  Department of Informatics and Mathematical Modelling  Technical University of Denmark  Lyngby, Denmark  Email: mrh@imm.dtu.dk and aske@brekling.dk  can compare the interval length with a constant. A neighbourhood logic, in the sense of [31] and based on Restricted  DC [33], is shown decidable in [2].  In these decidable logics only very limited quantitative  aspects can be expressed and no tool supporting DC has,  as far as we know, reached a point where it is used on  a regular basis due to the very high complexities of the  decision problems (non-elementary in many cases) and to  the limited expressiveness concerning timing properties.  In recent work by FraĚnzle and Hansen [12], [13], an  approximation-based model-checking problem K |= Ď,  where K is a ďŹnite automaton and Ď belongs to an expressive  subset of discrete-time DC, is reduced to checking formulas  of Presburger arithmetic, i.e. ďŹrst-order logic of integers,  where addition is the only operation. The atomic formulas  in this approach can be arbitrary  constraints     on linear sums  of durations, e.g 3 P â 7 (Q â¨ R) + 5 ÂŹR âĽ 11, and  such atomic constraints can be freely combined using the  connectives of propositional DC. The validity and modelchecking problems for this subset is actually undecidable using standard semantics. However, by use of a so-called multiset semantics, the model-checking problem can be reduced  to checking Presburger formulas. The multiset semantics is  based on a kind of Parikh image of the runs of an automaton,  where the visiting frequencies of states are recorded, and it  gives an approximation in the sense that runs corresponding  to the same multiset cannot be distinguished. A similar idea  has been used to over-approximate reachability in Petri nets,  e.g. [7], [8].  The basic idea of the so-called marking algorithm for  generating Presburger formulas is the following: For every  pair of states i and j of the automaton K and for every  subformula Ď of Ď two Presburger formulas markT (i, j, Ď)  and markF (i, j, Ď) are generated, where markT (i, j, Ď)  describes multisets for runs from i to j in K for which  Ď is true and markF (i, j, Ď) describe multisets for which  Ď is false. Unfortunately, the generated formulas may be  exponential in the chop-depth of the DC formula. Even  worse, Fischer and Rabin [9] have established a double  exponential lower bound on the time required by any nondeterministic decision procedure for checking the truth of a  Presburger formulas, and Oppen [22] has established a triple  exponential upper bound for the worst-case running time of  AbstractâInterval Logics are often very expressive logics  for which decision and model-checking algorithms are hard or  even impossible to achieve, and this also applies for Duration  Calculus, which adds the notion of accumulated duration to  the Interval Temporal Logic introduced by Moszkowski et al  In this ongoing work, we report on our experiences with implementing the model-checking algorithm in [12], which reduces  model checking to checking formulas of Presburger arithmetic.  The model-checking algorithm generates Presburger formulas  that may have sizes being exponential in the chop depth of the  Duration Calculus formulas, so it is not clear whether this is  a feasible approach.  The decision procedure is partitioned into a frontend with reductions including âcheapâ, equation-based quantiďŹer eliminations, and a general quantiďŹer-elimination procedure, where we  have experimented with an implementation based on Cooperâs  algorithm and with the SMT solver Z3. The formula reductions  are facilitated using a new âguarded normal formâ. Applying  the frontend before a general quantiďŹer elimination procedure  gave signiďŹcant improvements for most of the experiments.  Keywords-Interval temporal logic; Duration calculus; model  checking; Presburger arithmetic;  I. I NTRODUCTION  A variety of quantitative aspects about real-time systems  are naturally expressed as properties of time intervals, and  indeed many interval logics have an adequate expressiveness.  In this paper we will focus on tool support for Duration  Calculus (abbreviated DC), [32], [34], which is an extension  of the Interval Temporal Logic introduced by Moszkowski  [21]. In DC one can express quantitative properties at a  high level of abstraction, through the notion of accumulated  durations of states. Unfortunately, fragments of Duration  Calculus are undecidable unless the notion of duration,  the use of negation and chop (the only modality of DC),  or the models considered are severely constrained, e.g.  [3], [10], [11], [16], [20], [23], [28]â[30], [33], [35] and,  indeed, undecidability is typically the case when interesting  quantitative properties are expressible in interval logics.  In [14] the decidability of Propositional Neighbourhood  Logic (PNL) is established, which is a fragment of the logic  introduced by Halpern and Shoham [15], but quantitative  aspects are not expressible in PNL. In recent work [4], the  decidability of metric PNL is shown, which have just a right  neighbourhood modality, together with atomic formulas that  1530-1311/11 $26.00 ÂŠ 2011 IEEE  DOI 10.1109/TIME.2011.26  115  Cooperâs algorithm. So the feasibility of this model-checking  approach for DC is far from obvious.  In this ongoing work, we report on experiences with  implementing the model-checking algorithm as well as a  tool for Presburger arithmetic. A ďŹrst prototype [17], [18]  validated the approach and showed that the approximations were good enough for some small examples. But  the marking algorithm was the bottleneck, as it ran out  of memory for rather small problems. To cope with this  space problem, a new marking algorithm was implemented  which just produces the necessary formulas. Furthermore,  the formulas are simpliďŹed during the marking phase. The  simpliďŹcations are performed on the basis of a new guarded  normal form, which also supports âcheapâ equation-based  quantiďŹer eliminations. As backend for checking formulas of  Presburger arithmetic we have used the SMT-solver Z3 [1],  [6] and an implementation which integrates simpliďŹcations  using the guarded normal form with Cooperâs algorithm [5]  and some reductions inspired by the Omega test [25] and  the work by Reddy and Loveland [26].  In the next section we give an introduction to DC and  the model-checking approach in [12]. In Section 3 we give  a short introduction to Presburger arithmetic, and present  the guarded normal form and some of the simpliďŹcations,  including some quantiďŹer-elimination techniques, which is  used for reducing the sizes of the generated formulas.  Experiments are presented and discussed in Section 4, and  the last section contains a summary.  in the last state of the trace and, therefore, the interpretation  is one shorter than the trace.    The duration of p for the above trace/interpretation is p =  4. The length of the trace is given by the duration of the state  expression 1, also abbreviated as . The length of the above  interpretation is 8.  A formula Ď  Ď is true for a trace iff it can be split into  a left and a right trace s.t. Ďholds of the   left part and Ď of   ÂŹp = 2 holds for t r  the right  part.  For  example,  p  =  2      since p = 2 holds for A B A B A and ÂŹp = 2 holds for  A B C D D. (Notice that no time is spent in the last state of  the trace.)  In [12], [13], an undecidable model-checking problem  K |= Ď is addressed for discrete-time DC. A ďŹnite run  (or trace) t r = s1 s2 Âˇ Âˇ Âˇ sn , where si is a state in K  induces an interpretation for the DC formulas by assuming  that one time unit is spend in each si and throughout that  time unit, the state variables associated with si are all 1.  Hence, one can easily deďŹne the concept that a DC formula  Ď holds for a trace t r, written t r |= Ď, as exempliďŹed  above. We say that K is a model for Ď, written K |= Ď,  if tr |= Ď, for every trace t r originating in some initial state  of K. This model-checking problem is addressed through  approximations described by a so-called counting semantics,  where approximations are based on two ideas:  â˘ Treat all traces between two states i and j uniformly.  â˘ Consider visiting frequencies of states of K using a  multiset m. For a state j, m(j) â N describes the  number of times state j is visited in the considered    traces. Observe that the value of a term like Si can  be calculated using the multiset by adding visiting  frequencies of states whose labelling make Si hold.  For a given Kripke structure K, states i and j, multiset  m, and formula Ď, the counting semantics is a function:  K[[Ď]] i j m â 2B with the following properties:  â˘ K[[Ď]] i j m = {true, false} iff there is no mconsistent trace from i to j,  â˘ K[[Ď]] i j m = {true} implies that Ď holds for every  m-consistent trace from i to j,  â˘ K[[Ď]] i j m = {false} implies that Ď is false for every  m-consistent trace from i to j, and  â˘ K[[Ď]] i j m = â otherwise.  An m-consistent trace t r satisďŹes that s occurs m(s) times  in t r, for every state s of K. Further details can be found in  [12]. Notice that the case K[[Ď]] i j m = â is a âdonât knowâ  situation, which can happen either when some traces from  i to j satisfy Ď while other traces from i to j falsify Ď, or  when the multiset semantics is too coarse grained to detect  that all traces from i to j satisfy Ď or to detect that all traces  from i to j falsify Ď. We shall return to that later.  The main idea of the model-checking algorithm is to  consider multisets symbolically: a multiset is represented  by a vector m = m[s1 ], . . . , m[sn ], of variables m[si ], for  II. M ODEL CHECKING FOR D URATION C ALCULUS  We start with an informal introduction to DC and the  model-checking algorithm of [12], where formulas Ď of DC  are generated by the grammar:  S ::=  Ď ::=  0 | 1 | P | ÂŹS | S1 â¨ S2 ,     | ÎŁni=1 ci Si  k | ÂŹĎ | Ď â§ Ď | Ď  Ď ,  where P ranges over states variables, k, ci are integers and   â {<, â¤, =, âĽ, >}. S is called a state expression.  We shall interpret formulas over ďŹnite traces generated  by a Kripke structure, i.e. a ďŹnite automaton, like the  one in Fig. 1, where states are labelled by sets of state  variables. For example, the following trace from A to D:  A  B  Figure 1.  p  C  p  D  Example automaton from [12]  t r = A B A B A B C D D generates a interpretation of the  state variable p:  ÂŹp p ÂŹp p ÂŹp p p ÂŹp  as p holds in the state B and C and p does not hold in A  and B. We shall assume that the automaton spends no time  116  every state si . The model-checking is a bottom-up marking  algorithm following the structure of the DC-formula, and  it generates for every subformula Ď, and states i, j â K  two Presburger formulas, denoted markT (i, j, Ď)(m) and  markF (i, j, Ď)(m), having m as free variables. These two  formulas have the properties:  m |= markT (i, j, Ď)(m)  m |= markF (i, j, Ď)(m)  minus 1 is needed because no time is spend the last time  the end state is visited. The model-checking problem (from  vertex A to D) is translated to  âm. (C(A, D)(m) â (2))  which asserts that every consistent trace from A to D must  satisfy the linear constraint (2). Since this formula is indeed  true, we know that every trace from A to D satisďŹes (1).  The full marking algorithm (except the deďŹnition of the  C-predicates) is given in Fig. 2. Most cases have simple  explanations, e.g. a multiset m is a counter example for  Ď â§ Ď if m is a counter example for Ď or a counter example  for Ď, which explains the false marking for conjunction.  Concerning Ď1  Ď2 , a multiset m is a counter example  if for every vertex k and every consistent split m1 , m2 of  m wrt. k, either m1 is a counter example for Ď1 or m2 is  a counter example for Ď2 (or both are counter examples).  This is actually a precise characterization of the traces  falsifying Ď1  Ď2 , provided that markF (i, k, Ď1 )(m) and  markF (k, j, Ď2 )(m) provide precise characterizations for the  traces falsifying Ď1 and Ď2 , respectively.  It is in the true marking for Ď1  Ď2 the approximations  of the multiset semantics become visible, by requiring that  there is a distinct state k which works as chop point. Since  we are considering universal path properties, this chop point  must work for all for possible splits of the multiset. This is  expressed using a universal quantiďŹer in the marking. We  shall in Section IV see an example where one vertex does  not sufďŹce as chop point, despite that every trace satisďŹes a  given formula Ď1  Ď2 . Since the model-checking problem  we start up with is undecidable, the approximations must  show up somewhere and here it is when chop occurs in  positive polarity.  â K[[Ď]] i j m = {true}  â K[[Ď]] i j m = {false}  The formulas markT (i, j, Ď)(m) and markF (i, j, Ď)(m)  are called the true and false markings, respectively, and they  are based on a Presburger formula C(i, j)(m) characterizing  the multisets for the traces bringing the automaton from state  i to state j. We introduce the general idea in terms of the  example in Fig. 1, where we would like to check whether  every run from A to D satisďŹes the formula:    <4â p<3  (1)  We introduce the following multiset variables: m =  mA , mB , mC , mD and the consistent traces from A to vertex  D is described by C(A, D)(m) =  âeAB , eBA , eBC , eCD , eDD :  = mA =  1 + eBA  eAB  eAB  eBC  =  =  mB  mC  =  =  eBA + eBC  eCD  eCD + eDD  = mD  =  eDD + 1  The idea is to introduce a variable for every edge (e.g. eAB  describes the frequency of visits to the edge from A to B),  and add equations expressing that the sum of all inďŹow to  a state is equal to the visiting frequency of that state which  is equal to the outďŹow of that state. The start state has an  extra inďŹow of 1 and the end state has an extra outďŹow of  1 to ensure a âďŹowâ from the start to the end. There are  extra conditions for certain loops to ensure that if a loop  has a positive visiting frequency, then some edge entering  that loop has a positive visiting frequency as well; but such  conditions are not needed in this example.  The construction of the consistency formulas C(i, j)(m),  see [12], we currently are using is based on the assumption  that every loop in K has a unique entry point, and in this  case the construction of C(i, j)(m) is simple and its size  is proportional to the size of K. If the unique entry-point  assumption does not hold, then one can use the linear-time  construction given in [27] for achieving a Presburger formula  for the Parikh image of a regular language. This construction  will, however, introduce extra quantiďŹers.  The DC formula (1) is translated to  III. P RESBURGER ARITHMETIC  Presburger arithmetic is the ďŹrst-order theory of natural  numbers (or integers) with addition, which was proved to  be decidable by M. Presburger in 1927. There are several  decision algorithms for PA, and one is Cooperâs algorithm  [5]. This algorithm is a quantiďŹer elimination algorithm,  which repeatedly removes quantiďŹers inside-out by replacing  an innermost quantiďŹed formula by an equivalent quantiďŹerfree formula. When the original formula has no free variables, its truth value can be computed in a straightforward  manner when all quantiďŹers have been eliminated. When  an existential quantiďŹer âx.Ď(x), where Ď(x) is quantiďŹer  free, is eliminated, Ď(x) is ďŹrst normalized to a negation  normal form formula Ď  (x) where < is the only comparison  operator occurring in Ď  (x) and x has the same coefďŹcient,  say Î´, in all constraints. Let Ď(x ) be Ď  [x /Î´x] â§ Î´|x ,  where Ď[t/ay] is the formula obtained from Ď by replacing  every occurrence of ay with t. We have âx.Ď(x) ââ  âx.Ď  (Î´x) ââ âx .Ď(x ). The existential quantiďŹer can  (2)  (ÎŁiâ{A,B,C,D} mi ) â 1 < 4 â mB + mC < 3    by replacing P with the sum of the multiset variables for  the states where P hold, and by replacing length with the  sum of all multiset variables minus 1. The adjustment with  117  markT (i, j, )(m)  markF (i, j, )    markT (i, j, ÎŁiâÎŠ ci Si < k)(m)    markF (i, j, ÎŁiâÎŠ ci Si < k)(m)  = C(i, j)(m)  = false  = C(i, j)(m) â§  = C(i, j)(m) â§      iâÎŠ ci  iâÎŠ ci    vâV,v|=Si  vâV,v|=Si  m[v] < k  m[v] âĽ k  markT (i, j, ÂŹĎ)(m)  = markF (i, j, Ď)(m)  markF (i, j, ÂŹĎ)(m)  = markT (i, jĎ)(m)  markT (i, j, Ď1 â§ Ď2 )(m)  markF (i, j, Ď1 â§ Ď2 )(m)  = markT (i, j, Ď1 )(m) â§ markT (i, j, Ď2 )(m)  = markF (i, j, Ď1 )(m) â¨ markF (i, j, Ď2 )(m)  and  â  markT (i, j, Ď1    Ď2 )(m) =  markF (i, j, Ď1    Ď2 )(m) =    kâV  â  âm1 , m2 : Îźikj (m, m1 , m2 )  â  â  â â§  â  âm1 , m2 : Îźikj (m, m1 , m2 ) â (markT (i, k, Ď1 )(m1 ) â§ markT (k, j, Ď2 )(m2 ))  C(i, j)(m)â§  kâV âm1 , m2 : Îźikj (m, m1 , m2 ) â (markF (i, k, Ď1 )(m1 ) â¨ markF (k, j, Ď2 )(m2 ))  where Îźikj (m, m1 , m2 ) = m = m1 + m2 â§ C(i, k)(m1 ) â§ C(k, j)(m2 ) expresses that m1 and m2 is a consistent split of  m for state k for traces from i to j in the Kripke structure.  Figure 2.  Marking algorithm (slightly rephrased from [12]) for a given Kripke structure K  now be replaced by a bounded disjunction as follows:    âx .Ď(x ) â  A. Guarded normal form  Inspecting the marking algorithm in Fig. 2, one can see  that the size of the generated formula is exponential in  the chop depth. It is therefore important that formulas are  simpliďŹed as much as possible. We are aiming at a normal  form where we can collect conjunctions of literals in order  to reduce the size of formulas by performing simpliďŹcations  including âcheapâ equation-based quantiďŹer eliminations.  We name this guarded normal form, and we consider it  ďŹrst in a propositional setting, with constants  (true) and  âĽ (false), variables p, q, r, conjunction P â§ Q, disjunctions  P â¨ Q and negation ÂŹP . Let L denote a literal, i.e. a  proposition of the form p or ÂŹp.  An implication guard is a proposition of the form:      Li â  Pj  Î´  â¨  i=1 Ď[/x < t, âĽ/t < x]  Î´     i=1  t<x in Ď(x ) Ď[t + i/x ]  (3)  where Î´  is the least common multiple of the divisors d in  divisibility constraints d|t(x). Here Ď[/x < t, âĽ/t < x]  is the formula obtained from Ď by substituting every occurrence of a constraint x < t in Ď with true and every  occurrence of a constraint t < x in Ď with false. Cooperâs  algorithm has the advantage that it just uses a non-expansive  negation normal form, but it is a major challenge to control  the growth of the constants Î´ and Î´  when eliminating nested  quantiďŹers using this algorithm.  i  The Omega test [25] is another quantiďŹer-elimination  method which is inspired by Fourier-Motzkinâs methods  for the reals. For a conjunction of upper- and lower-bound  constraints, U and L, respectively, it considers all possible  combinations of bx < t1 â L and ax > t2 â U when  eliminating x. This method is based on normalizing formulas  to disjunctive normal form, and, for example, in the case of  quantiďŹer alternations this may be undesirable. Furthermore,  Presburger arithmetic is incorporated in Z3 [1], [6], which  has shown to be a powerful tool for checking Presburger  formulas generated by our algorithm. Also automata-based  decision methods for Presburger arithmetic are available, see  for example [19].  j  and a conjunction guard is a proposition of the form:      Li â§  Pj  i  j  A guarded formula is a formula constructed from literals, ,  and âĽ by the use of guarded implications and conjunctions.  A conjunction of literals is called a guard. In the Presburger  setting, the literals are (possibly negated) equations, comparisons and divisibility constraints.  It is easy to express conjunction and disjunction by  guarded formulas using trivial guards. Furthermore, nega-  118  an equation nx = t in a guard can be used to eliminate x  elsewhere in the formula:    nx = t â§ i Li â j Pj    (11)  ââ nx = t â§ i Li [t/nx] â j Pj [t/nx]  tions propagate through guarded formulas:  P â§Q  P â¨Q  ÂŹ(  ÂŹ(  Li â  i Li â§  i    ââ  ââ  Pj )  j Pj )  j  ââ  ââ  Li â§ P â§ Q  iââ Li â P â¨ Q  iââ  Li â§ j ÂŹPj    i Li â  j ÂŹPj  i  nx = t â§  Li â§  Pj â§ L ââ L â§ i Li â§ j Pj        i Li â ( k Lk â  l Ql ) â¨  j Pj        ââ  L  â§  L  â  k k  i i  l Ql â¨  j Pj  i  j  Li â§ (  ââ  k  Lk â§ l Ql ) â§ j Pj    k Lk â§  i Li â§  l Ql â§  j  Pj  Li â§  ââ nx = t â§  A guarded formula F isin normal form if every implication guard i Li â j Pj in F satisďŹes that each  Pj is a conjunction guard, and every conjunction guard  i Li â§ j Qj in F satisďŹes that each Qj is an implication  guard.  Every propositional formula has a guarded normal form,  which can be obtained by using the equivalences:      (4)  i Li â  j Pj â¨ L ââ ÂŹL â§  i Li â  j Pj  i  i  j  i  Pj  Li [t/nx] â§  j  Pj [t/nx]  Such substitutions depend on the least common multiple of  n and the coefďŹcients of x in the formula, e.g.  ââ  3x + 5y > 2z[y + 2z/2x]  6x + 10y > 4z[y + 2z/2x]  ââ  3y + 6z + 10y > 4z ââ 13y > z  C. Simple quantiďŹer eliminations  Equations in guards are particular useful in connection  with quantiďŹer elimination due to the equivalences:      âx. (nx = t â§ Li â  Pj ) ââ   (13)  (5)  (6)  i  âx. (nx = t â§  ââ n|t â§  (7)  Notice that applications of these equivalences (from left to  right) have the effect of collecting literals in guards and  reducing the nesting of guarded formulas.  j  Li â§ j Pj )  L  i i [t/nx] â§  j Pj [t/nx]  i  ââ  âz.âx.2x = y + z â§ 4x + 3y â z = 1  âz.5y + z = 1 â§ 2|y + z  Reductions are natural to perform when literals are collected in guards by use of (4 â 7). We check for inconsistencies and for simpliďŹcations in the guards. An example  of an inconsistency check is the Omega methodâs check  for real shadows, which is one part of the Fourier-Moszkin  elimination for the ďŹrst-order theory of reals. The right-hand  side of the following implication is called the real shadow.  If this shadow is false, then no real number x satisďŹes  t1 â¤ axâ§bx â¤ t2 and hence there can be no integer solution:  ââ  2| â 4y + 1 ââ 2|1 ââ false  =â  bt1 â¤ at2  IV. I MPLEMENTATION AND E XPERIMENTS  We have implemented the model-checking algorithm in  Fig. 2 on the basis of the guarded normal form with  many simpliďŹcations including the equation-based quantiďŹer  eliminations shown in the previous section. The table with  markings generated with this algorithm was signiďŹcantly  smaller than that of [18] partly due to these simpliďŹcations,  and partly due to a more careful analysis of the Kripke  structure, which led to signiďŹcant simpliďŹcations on the  consistency predicates C(i, j) on the basis of a reachability analysis. In addition, we have implemented Cooperâs  algorithm to be used after the equation-based quantiďŹer  eliminations. For small examples, this worked well; but  for larger examples with many nested quantiďŹcations  the    expansions due to the the disjunctions t<x Ď[t + i/x ]  became the bottleneck. These disjunction must be treated in  a more symbolic manner (like  the way we treated bounded  Î´  disjunctions of the form i=1 F (i)) in order to be useful. In  the below experiments we have therefore, with good results,  used Z3 as backend. The experiments were conducted on  a Windows Server 2008 with Intel Xeon E5620 Processors  and 8GB of RAM.  We have so far just veriďŹed a few, rather small examples.  Each example has been tested using (1) the Z3-solver  (8)  Using this implication for all pairs of constraints matching  the left-hand side will generate a collection of new literals  and may expand the guard signiďŹcantly. In our implementation we just apply the rule when t1 and t2 are integers and  the truth value of the shadow can be computed directly.  The following equivalences used from left to right show  just two of the reductions which have shown to be useful  in our examples in order to keep the expansive parts of the  decision process manageable.  t > a â§ t > b ââ t > max{a, b}  t â 1 < a â§ a < t + 1 ââ a = t  (14)  The following example shows two applications of (14)  and simple reductions of divisibility constraints:  B. Reductions  t1 â¤ ax â§ bx â¤ t2  (12)  (9)  (10)  An advantage of collecting literals in guards is that  consistency can be checked and propagated. For example,  119  Example  3-seq  4-seq  5-seq  6-seq  Dia-1  Dia-2  NoGNF (KB)  /w Z3simp  808/ 3.026  1.952/7.084  3.865/14.010  6.739/25.058  10/ 26  10/ 26  EqQe (KB)  /w Z3simp  616/1.454  1.585/3.665  3.206/ 7.427  5.650/ 13.141  3/6  3/6  MarkingTime  /w Z3simp  0,6 /3,9 s  3,6 /12,9 s  4,6 /21,6 s  8,5 /44,2 s  EqQe  4,2  12,8  33,5  72,9  s  s  s  s  Z3Sat-NoGNF  /Z3simp  2,9 /1,8 s  12,9 /3,6 s  40,1 /6,3 s  122,5 /11,2 s  104ms  74ms  Z3Sat-EqQe  /Z3simp  1,5 /1,8 s  4,6/2,9 s  75,2/4,6  â  47ms  37ms  Commands used for Z3âs simpliďŹcations of formulas and SAT-solving  z3.exe /nw /smt2 ARITH_EXPAND_EQS=true STRONG_CONTEXT_SIMPLIFIER=true filename.smt  z3.exe /smt2 ELIM_QUANTIFIERS=true MODEL=true filename.smt  Figure 3.  Data from experiments  Bi  Ai  exclusively on a raw marking from the algorithm in Fig. 2  without the use of guarded normal form and equation-based  quantiďŹer eliminations, and (2) several combinations of  guarded normal form, equation-based quantiďŹer elimination  and a decision procedure based on Cooperâs algorithm.  The purpose of this is to compare results and to get a  conďŹdence in the correctness of the programs. The results of  the experiments are shown in Fig. 3. There are many ways in  which Z3 can be applied. We used Z3 with an input formula  in the SMT-lib format. The commands shown in Fig. 3 were  used to activate Z3âs simpliďŹcation of formulas and the SATsolving command. This use of Z3 seems to give us the best  results; but we certainly cannot exclude that there are better  ways to use Z3.  p  Ci  p  Di    (1) ( < 4 =â p < 3)    Properties:  (2) ( < 5 =â p < 3)  where Ď is deďŹned by ÂŹ(true  (ÂŹĎ)  true).  Figure 4.  Extended automaton from [12]  normalized formulas gives an improvement; however, for  sequences with 5 and 6 repetitions normalized formulas  were a disadvantage for Z3, and for 6 repetitions Z3 did  not complete within an hour. We have so far no explanation  why quantiďŹer eliminations and simpliďŹcations prior to using  Z3 did not help in these two cases. We have not met other  examples where this phenomenon occurred.  The experiments for the formula (1) were based on the  SAT-problem C(A1 , DN )(m) â§ ÂŹmarkF (A1 , DN , (1))(m)  which is not satisďŹable, i.e. the model-checking problem  holds. For the formula Fig. 4(2), the corresponding Presburger formula is satisďŹable and Z3 gives satisfying assignments slightly faster than for the corresponding unsat case.  Example 1  This example is based on an iterative version of the simple  automaton Mi shown in Fig. 4, with the veriďŹcation of the  two properties shown. Property (1) holds for every run in  the automaton, while property (2) does not hold as the run  Bi Ai Bi Ci Di gives a counter example.  By sequential composition of Mi , for i = 0, . . . , n, we use  this example to test the current limit of the approach. By an  N-sequence, we understand N automata M1 , M2 , . . . , MN ,  where there is an edge from Di to Ai+1 , for 1 â¤ i < N  and there are edges from Di to Aj , for 1 â¤ j â¤ i â¤ N .  This composition implies that from any state every other  state is reachable. Therefore, for every pair (i, j) of states  the consistency predicate C(i, j) must be computed. These  consistency predicates are used in connection with the two  chops occurring the deďŹnition of the -modality.  The experiments were conducted up to a 6-sequence and  the results are shown in Fig. 3. The ďŹrst two columns show  the sizes (in KB) of the generated formulas in the SMTlib format. The use of guarded normal form and equalitybased quantiďŹer elimination gives a signiďŹcant reduction on  the formulas sizes, which also applies for a succeeding Z3  simpliďŹcation. For sequences with up to 4 repetitions, using  Example 2  The counting semantics of chop is based on the ability to  ďŹnd, for a given multiset m, a state that works as a choppoint for all possible splits of m, cf. Fig. 2. This gives an  approximation in the sense that K[[Ď]] i j m may be â even  though every trace from i to j satisďŹes Ď.  This is illustrated with the formula (1) and the automaton  in Fig. 5. Every trace from A to D satisďŹes the formula  since it either ends with P or Q being true, but this is not  captured by the multiset semantics. The problem is that B  works as chop-point for the formula true   P  for just  the multisets which has visiting frequencies 1 and 0 for B  120  are propagated and we use (14) whenever it is possible.  Other equations and constraints should be propagated as  well. Experiments with a more aggressive guard propagation  approach has shown promising reductions in a propositional  setting.  B  P  A  D  V. S UMMARY  Q  It appear as a kind of âmission impossibleâ to base a  model-checking algorithm for Duration Calculus on checking formulas of Presburger Arithmetic, particularly, when the  formulas to be checked may have size that is exponential in  the chop depth of the original DC formula. To investigate  the feasibility of this approach we have implemented the  model-checking algorithm. A ďŹrst prototype implementation  in a Masterâs Thesis project [17], [18], validated the approach; but in this implementation the marking algorithm  was the bottleneck, as it ran out of memory for rather small  problems. To cope with that problem, a guarded normal  for formulas that supports âcheapâ equation-based quantiďŹer  eliminations and propagation of simpliďŹcations was developed and a new marking algorithm was implemented, which  produce a much smaller marking table.  So far we have just experimented with rather small  examples but the results obtained gave hope for eventually  achieving an efďŹcient veriďŹcation framework for several  reasons: (a) results were achieved fast for some of the bigger  examples we tried, (b) the guarded normal form can be  much more aggressively used for formula simpliďŹcations  using a guard propagation (which we have tried out in a  pure propositional setting with good results), (c) there are  a huge number of obvious optimizations to this prototype  implementation, and (d) a fragment of the model checking  problem reduces to linear SAT, see [12], and exploiting  this will give a huge improvement to using Presburger  arithmetic. In this ongoing work we are still in a phase  where seemingly simple optimizations and new reductions  often have signiďŹcant effect, and that experiments with the  implementation give many ideas for further improvements.  Z3 has shown to be a powerful backend.  C  (1) (true   P  ) â¨ (true   Q)  â      â  P â Q = â1  Properties:      â  â  P â Q=0 â  (2) true  â â¨      â¨  P â Q=1  Figure 5.  Automaton showing limitations  and C, respectively, since visits to C must be prevented for   P  to hold after the chop. A similar consideration applies  for the formula true   Q and the chop point C. For  example, the multiset m, where the visiting frequencies to  A, B, C and D are 1, 1, 2 and 1, respectively, is a case  where K[[Ď]] A D m = â.  The formula Fig. 5(2) also has chop in positive polarity;  but the multiset approximation is ďŹne grained enough and  the model checking will report that every trace from A to  D satisďŹes (2). In traces from A to D the difference of the  visiting frequencies to B and C is at most 1. It is easy to see  that state B works as chop point when the visiting frequency  of B is at least that of C, and C works as chop point when  the visiting frequency of C is at least that of B.  The veriďŹcation times are small and so are the sizes of  the generated formulas for this example; but they are shown  in Fig. 3 as they illustrate the tendencies we have seen in  most examples we have tried.  Discussion  We have used a unique representation for the atomic  formulas, which cancel out the least common divisor of the  coefďŹcients of the linear expressions. This often caused simpliďŹcations which were propagated by the guarded normal  form.  We are still at an initial stage of development and whenever we include new reductions in our approach, they have  big impact on the size of the formulas, of the time it takes to  eliminate quantiďŹers and of conducting satisďŹability check.  We are currently investigating different ways to incorporate more elements of the Omega test and   a more âlazyâ  treatment of the bounded disjunctions t<x Ď[t + i/x ]  into the guarded normal form reductions. Furthermore, we  can exploit the guarded normal form much better than we  are currently doing by âpropagating guardsâ more aggressively to subformulas. Until now only value assignments  ACKNOWLEDGMENT  This research has partially been funded by the SYSMODEL project (ARTEMIS JU 100035) and by the  IDEA4CPS project granted by the Danish Research Foundation for Basic Research. The authors would like to thank the  reviewers for their comments, corrections and suggestions,  which caused signiďŹcant improvements in the ďŹnal version.  Furthermore, we are grateful for discussions and comments  from Phan Anh Dung, Mikkel Koefoed Jakobsen, Marko  KaĚaĚramees and Jan Madsen.  R EFERENCES  [1] N. BjĂ¸rner, âLinear QuantiďŹer Elimination as an Abstract  Decision Procedure,â IJCAR 2010, LNAI 6173, Springer  2010, pp. 316-330.  121  [19] F. Klaedtke, âOn the Automata Size for Presburger Arithmetic,â ACM Transactions on Computational Logic 9(2) pp.  11:1â11:34, 2008.  [2] T. Bolander, J.U. Hansen, and M.R. Hansen, âDecidability of  a hybrid duration calculus,â ENTCS, 174(6):113â133, 2007.  [3] A. Bouajjani, Y. Lakhnech, and R. Robbana, âFrom duration  calculus to linear hybrid automata,â In CAVâ95, LNCS 939,  Springer 1995, pp. 196â210.  [20] R. Meyer, J. Faber, J. Hoenicke, and A. Rybalchenko, âModel  checking Duration Calculus: a practical approach,â Formal  Aspects of Computing 20(4-5), 2008, pp. 481â505.  [4] D. Bresolin, V. Goranko, A. Montanari, and G. Sciavicco,  âRight propositional neighborhood logic over natural numbers  with integer constraints for interval lengths,â In SEFM 2009,  pp. 240-249, 2009.  [21] B. Moszkowski, âA temporal logic for multi-level reasoning  about hardware,â IEEE Computer 18(2):10â19, 1985.  2pn  [22] D.C. Oppen, âA 22  Upper Bound on the Complexity of  Presburger Arithmetic,â Jour. Comput. Syst. Sci. 16(3): 323â  332, 1978.  [5] D.C. Cooper, âTheorem Proving in Arithmetic without  Multiplication,â Machine Intelligence, 1972, pp. 91-100.  [6] L. de Moura and N. BjĂ¸rner, âZ3: An EfďŹcient SMT Solver,â  In TACAS 2008, LNCS 4963, Springer 2008, pp. 337â340.  [23] P.K. Pandya, âSpecifying and deciding quantiďŹed discretetime duration calculus formulae using DCVALID,â In RTTOOLSâ2001. Aalborg, August 2001.  [7] J. Esparza, âPetri nets, commutative context-free grammars,  and basic parallel processes,â Fundamenta Informaticae 30:  23â41, 1997.  [24] P.K. Pandya, âModel Checking CTL*[DC],â In TACAS 2001,  LNCS 2031, Springer 2001, pp. 559â573.  [25] W. Pugh, âA practical algorithm for exact array dependence  analysis,â ACM Commun. 35(8), 1992, pp. 102-114.  [8] J. Esparza and S. Meltzer, âVeriďŹcation of Safety Properties  using Integer Programming: Beyond the State Equation,â  Formal Methods in System Design 16: 159â189, 2000.  [26] C.R. Reddy and D.W. Loveland, âPresburger Arithmetic with  Bounded QuantiďŹer Alternation,â ACM Symp. on Theory of  Computing, pages 320-325, ACM 1978.  [9] M.J. Fischer and M.O. Rabin, âSuper-Exponential Complexity of Presburger Arithmetic,â Proc. of the SIAM-AMS  Symposium in Applied Mathematics Vol. 7: 27-41, 1974.  [27] H. Seidl, T. Schwentick, A. Muscholl, and P. Habermehl,  âCounting for Free in Trees,â ICALP 2004, LNCS 3142,  2004, pp. 1136-1149.  [10] M. FraĚnzle, âModel-checking dense-time duration calculus,â  Formal Aspects of Computing 16(2):121â139, 2004.  [28] B. Sharma, P.K. Pandya, and S. Chakraborty, âBounded  Validity Checking of Interval Duration Logic,â TACAS 2005,  LNCS 3440, Springer 2005, pp. 302â316.  [11] M. FraĚnzle and M.R. Hansen, âDeciding an interval logic with  accumulated durations,â TACAS 2007, LNCS 4424, Springer  2007, pp. 201â215.  [29] Pham Hong Thai and Dang Van Hung, âVerifying Linear  Duration Constraints of Timed Automata,â ICTACâ2004,  LNCS 3407, Springer 2005, pp. 295â309.  [12] M. FraĚnzle and M.R. Hansen, âEfďŹcient model checking  for duration calculus,â International Journal of Software and  Informatics Vol.3, no.2-3, pp. 171-196, 2009.  [30] Miaomiao Zhang, Dang Van Hung, and Zhiming Liu, âVeriďŹcation of Linear Duration Invariants by Model Checking  CTL Properties,â ICTACâ2008, LNCS 5160, Springer 2008,  pp. 395â409.  [13] M. FraĚnzle and M.R. Hansen, âEfďŹcient model checking for  duration calculus based on branching-time approximations,â  In SEFM 2008, pp. 63â72, IEEE 2008.  [31] Zhou Chaochen and M.R. Hansen, âAn adequate ďŹrst order  logic of intervals,â In Compositionality: The SigniďŹcant  Difference, LNCS 1536. Springer 1996, pp. 584â608.  [14] V. Goranko, A. Montanari, and G. Sciavicco, âPropositional  interval neighborhood temporal logics,â Journal of Universal  Computer Science 9(9):1137-1167, 2003.  [32] Zhou Chaochen and M.R. Hansen, Duration Calculus â  A Formal Approach to Real-Time Systems, Monographs in  Theoretical Computer Science. Springer-Verlag, 2004.  [15] J. Halpern and Y. Shoham, âA propositional modal logic of  time intervals,â Journal of the ACM 38(4):935-962, 1991.  [33] Zhou Chaochen, M.R. Hansen, and P. Sestoft, âDecidability  and undecidability results for duration calculus,â STACS 93,  LNCS 665, Springer 1993, pp. 58â68.  [16] M.R. Hansen, âModel-checking discrete duration calculus,â  Formal Aspects of Computing 6(6A):826â845, 1994.  [17] W.P. Heise, M. FraĚnzle, and M.R. Hansen, âA prototype  model checker for Duration Calculus (Extended Abstract),â  NWPTâ09, DTU Informatics, Technical University of Denmark, 2009, pp. 26â29.  [34] Zhou Chaochen, C.A.R. Hoare, and A.P. Ravn, âA calculus  of durations,â Information Processing Letters 40(5):269â276,  1991.  [18] W.P. Heise, An efďŹcient model checker for Duration Calculus.  Masterâs Thesis, DTU Informatics, Technical University of  Denmark, 2010.  [35] Zhou Chaochen, Zhang Jingzhong, Yang Lu, and Li Xiaoshan. âLinear duration invariants,â In FTRTFTâ94, LNCS  863, Springer 1994, pp. 86â109.  122 