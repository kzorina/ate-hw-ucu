2011 Eighteenth International Symposium on Temporal Representation and Reasoning  On Tool Support for Duration Calculus on the basis of Presburger Arithmetic  Michael R. Hansen and Aske W. Brekling  Department of Informatics and Mathematical Modelling  Technical University of Denmark  Lyngby, Denmark  Email: mrh@imm.dtu.dk and aske@brekling.dk  can compare the interval length with a constant. A neighbourhood logic, in the sense of [31] and based on Restricted  DC [33], is shown decidable in [2].  In these decidable logics only very limited quantitative  aspects can be expressed and no tool supporting DC has,  as far as we know, reached a point where it is used on  a regular basis due to the very high complexities of the  decision problems (non-elementary in many cases) and to  the limited expressiveness concerning timing properties.  In recent work by FraÄšÂˆnzle and Hansen [12], [13], an  approximation-based model-checking problem K |= ÄÂ†,  where K is a ÄÅ¹Ânite automaton and ÄÂ† belongs to an expressive  subset of discrete-time DC, is reduced to checking formulas  of Presburger arithmetic, i.e. ÄÅ¹Ârst-order logic of integers,  where addition is the only operation. The atomic formulas  in this approach can be arbitrary  constraints     on linear sums  of durations, e.g 3 P Ã¢ÂˆÂ’ 7 (Q Ã¢ÂˆÂ¨ R) + 5 Ã‚Å¹R Ã¢Â‰Ä½ 11, and  such atomic constraints can be freely combined using the  connectives of propositional DC. The validity and modelchecking problems for this subset is actually undecidable using standard semantics. However, by use of a so-called multiset semantics, the model-checking problem can be reduced  to checking Presburger formulas. The multiset semantics is  based on a kind of Parikh image of the runs of an automaton,  where the visiting frequencies of states are recorded, and it  gives an approximation in the sense that runs corresponding  to the same multiset cannot be distinguished. A similar idea  has been used to over-approximate reachability in Petri nets,  e.g. [7], [8].  The basic idea of the so-called marking algorithm for  generating Presburger formulas is the following: For every  pair of states i and j of the automaton K and for every  subformula ÄÂˆ of ÄÂ† two Presburger formulas markT (i, j, ÄÂˆ)  and markF (i, j, ÄÂˆ) are generated, where markT (i, j, ÄÂˆ)  describes multisets for runs from i to j in K for which  ÄÂˆ is true and markF (i, j, ÄÂˆ) describe multisets for which  ÄÂˆ is false. Unfortunately, the generated formulas may be  exponential in the chop-depth of the DC formula. Even  worse, Fischer and Rabin [9] have established a double  exponential lower bound on the time required by any nondeterministic decision procedure for checking the truth of a  Presburger formulas, and Oppen [22] has established a triple  exponential upper bound for the worst-case running time of  AbstractÃ¢Â€Â”Interval Logics are often very expressive logics  for which decision and model-checking algorithms are hard or  even impossible to achieve, and this also applies for Duration  Calculus, which adds the notion of accumulated duration to  the Interval Temporal Logic introduced by Moszkowski et al  In this ongoing work, we report on our experiences with implementing the model-checking algorithm in [12], which reduces  model checking to checking formulas of Presburger arithmetic.  The model-checking algorithm generates Presburger formulas  that may have sizes being exponential in the chop depth of the  Duration Calculus formulas, so it is not clear whether this is  a feasible approach.  The decision procedure is partitioned into a frontend with reductions including Ã¢Â€ÂcheapÃ¢Â€Â, equation-based quantiÄÅ¹Âer eliminations, and a general quantiÄÅ¹Âer-elimination procedure, where we  have experimented with an implementation based on CooperÃ¢Â€Â™s  algorithm and with the SMT solver Z3. The formula reductions  are facilitated using a new Ã¢Â€Â™guarded normal formÃ¢Â€Â™. Applying  the frontend before a general quantiÄÅ¹Âer elimination procedure  gave signiÄÅ¹Âcant improvements for most of the experiments.  Keywords-Interval temporal logic; Duration calculus; model  checking; Presburger arithmetic;  I. I NTRODUCTION  A variety of quantitative aspects about real-time systems  are naturally expressed as properties of time intervals, and  indeed many interval logics have an adequate expressiveness.  In this paper we will focus on tool support for Duration  Calculus (abbreviated DC), [32], [34], which is an extension  of the Interval Temporal Logic introduced by Moszkowski  [21]. In DC one can express quantitative properties at a  high level of abstraction, through the notion of accumulated  durations of states. Unfortunately, fragments of Duration  Calculus are undecidable unless the notion of duration,  the use of negation and chop (the only modality of DC),  or the models considered are severely constrained, e.g.  [3], [10], [11], [16], [20], [23], [28]Ã¢Â€Â“[30], [33], [35] and,  indeed, undecidability is typically the case when interesting  quantitative properties are expressible in interval logics.  In [14] the decidability of Propositional Neighbourhood  Logic (PNL) is established, which is a fragment of the logic  introduced by Halpern and Shoham [15], but quantitative  aspects are not expressible in PNL. In recent work [4], the  decidability of metric PNL is shown, which have just a right  neighbourhood modality, together with atomic formulas that  1530-1311/11 $26.00 Ã‚Å  2011 IEEE  DOI 10.1109/TIME.2011.26  115  CooperÃ¢Â€Â™s algorithm. So the feasibility of this model-checking  approach for DC is far from obvious.  In this ongoing work, we report on experiences with  implementing the model-checking algorithm as well as a  tool for Presburger arithmetic. A ÄÅ¹Ârst prototype [17], [18]  validated the approach and showed that the approximations were good enough for some small examples. But  the marking algorithm was the bottleneck, as it ran out  of memory for rather small problems. To cope with this  space problem, a new marking algorithm was implemented  which just produces the necessary formulas. Furthermore,  the formulas are simpliÄÅ¹Âed during the marking phase. The  simpliÄÅ¹Âcations are performed on the basis of a new guarded  normal form, which also supports Ã¢Â€ÂcheapÃ¢Â€Â equation-based  quantiÄÅ¹Âer eliminations. As backend for checking formulas of  Presburger arithmetic we have used the SMT-solver Z3 [1],  [6] and an implementation which integrates simpliÄÅ¹Âcations  using the guarded normal form with CooperÃ¢Â€Â™s algorithm [5]  and some reductions inspired by the Omega test [25] and  the work by Reddy and Loveland [26].  In the next section we give an introduction to DC and  the model-checking approach in [12]. In Section 3 we give  a short introduction to Presburger arithmetic, and present  the guarded normal form and some of the simpliÄÅ¹Âcations,  including some quantiÄÅ¹Âer-elimination techniques, which is  used for reducing the sizes of the generated formulas.  Experiments are presented and discussed in Section 4, and  the last section contains a summary.  in the last state of the trace and, therefore, the interpretation  is one shorter than the trace.    The duration of p for the above trace/interpretation is p =  4. The length of the trace is given by the duration of the state  expression 1, also abbreviated as . The length of the above  interpretation is 8.  A formula ÄÂ†  ÄÂˆ is true for a trace iff it can be split into  a left and a right trace s.t. ÄÂ†holds of the   left part and ÄÂˆ of   Ã‚Å¹p = 2 holds for t r  the right  part.  For  example,  p  =  2      since p = 2 holds for A B A B A and Ã‚Å¹p = 2 holds for  A B C D D. (Notice that no time is spent in the last state of  the trace.)  In [12], [13], an undecidable model-checking problem  K |= ÄÂ† is addressed for discrete-time DC. A ÄÅ¹Ânite run  (or trace) t r = s1 s2 Ã‚Ë‡ Ã‚Ë‡ Ã‚Ë‡ sn , where si is a state in K  induces an interpretation for the DC formulas by assuming  that one time unit is spend in each si and throughout that  time unit, the state variables associated with si are all 1.  Hence, one can easily deÄÅ¹Âne the concept that a DC formula  ÄÂ† holds for a trace t r, written t r |= ÄÂ†, as exempliÄÅ¹Âed  above. We say that K is a model for ÄÂ†, written K |= ÄÂ†,  if tr |= ÄÂ†, for every trace t r originating in some initial state  of K. This model-checking problem is addressed through  approximations described by a so-called counting semantics,  where approximations are based on two ideas:  Ã¢Â€Ë˜ Treat all traces between two states i and j uniformly.  Ã¢Â€Ë˜ Consider visiting frequencies of states of K using a  multiset m. For a state j, m(j) Ã¢ÂˆÂˆ N describes the  number of times state j is visited in the considered    traces. Observe that the value of a term like Si can  be calculated using the multiset by adding visiting  frequencies of states whose labelling make Si hold.  For a given Kripke structure K, states i and j, multiset  m, and formula ÄÂ†, the counting semantics is a function:  K[[ÄÂ†]] i j m Ã¢ÂˆÂˆ 2B with the following properties:  Ã¢Â€Ë˜ K[[ÄÂ†]] i j m = {true, false} iff there is no mconsistent trace from i to j,  Ã¢Â€Ë˜ K[[ÄÂ†]] i j m = {true} implies that ÄÂ† holds for every  m-consistent trace from i to j,  Ã¢Â€Ë˜ K[[ÄÂ†]] i j m = {false} implies that ÄÂ† is false for every  m-consistent trace from i to j, and  Ã¢Â€Ë˜ K[[ÄÂ†]] i j m = Ã¢ÂˆÂ… otherwise.  An m-consistent trace t r satisÄÅ¹Âes that s occurs m(s) times  in t r, for every state s of K. Further details can be found in  [12]. Notice that the case K[[ÄÂ†]] i j m = Ã¢ÂˆÂ… is a Ã¢Â€ÂdonÃ¢Â€Â™t knowÃ¢Â€Â  situation, which can happen either when some traces from  i to j satisfy ÄÂ† while other traces from i to j falsify ÄÂ†, or  when the multiset semantics is too coarse grained to detect  that all traces from i to j satisfy ÄÂ† or to detect that all traces  from i to j falsify ÄÂ†. We shall return to that later.  The main idea of the model-checking algorithm is to  consider multisets symbolically: a multiset is represented  by a vector m = m[s1 ], . . . , m[sn ], of variables m[si ], for  II. M ODEL CHECKING FOR D URATION C ALCULUS  We start with an informal introduction to DC and the  model-checking algorithm of [12], where formulas ÄÂ† of DC  are generated by the grammar:  S ::=  ÄÂ† ::=  0 | 1 | P | Ã‚Å¹S | S1 Ã¢ÂˆÂ¨ S2 ,     | ÃÅni=1 ci Si  k | Ã‚Å¹ÄÂ† | ÄÂ† Ã¢ÂˆÂ§ ÄÂˆ | ÄÂ†  ÄÂˆ ,  where P ranges over states variables, k, ci are integers and   Ã¢ÂˆÂˆ {<, Ã¢Â‰Â¤, =, Ã¢Â‰Ä½, >}. S is called a state expression.  We shall interpret formulas over ÄÅ¹Ânite traces generated  by a Kripke structure, i.e. a ÄÅ¹Ânite automaton, like the  one in Fig. 1, where states are labelled by sets of state  variables. For example, the following trace from A to D:  A  B  Figure 1.  p  C  p  D  Example automaton from [12]  t r = A B A B A B C D D generates a interpretation of the  state variable p:  Ã‚Å¹p p Ã‚Å¹p p Ã‚Å¹p p p Ã‚Å¹p  as p holds in the state B and C and p does not hold in A  and B. We shall assume that the automaton spends no time  116  every state si . The model-checking is a bottom-up marking  algorithm following the structure of the DC-formula, and  it generates for every subformula ÄÂ†, and states i, j Ã¢ÂˆÂˆ K  two Presburger formulas, denoted markT (i, j, ÄÂ†)(m) and  markF (i, j, ÄÂ†)(m), having m as free variables. These two  formulas have the properties:  m |= markT (i, j, ÄÂ†)(m)  m |= markF (i, j, ÄÂ†)(m)  minus 1 is needed because no time is spend the last time  the end state is visited. The model-checking problem (from  vertex A to D) is translated to  Ã¢ÂˆÂ€m. (C(A, D)(m) Ã¢Â‡Â’ (2))  which asserts that every consistent trace from A to D must  satisfy the linear constraint (2). Since this formula is indeed  true, we know that every trace from A to D satisÄÅ¹Âes (1).  The full marking algorithm (except the deÄÅ¹Ânition of the  C-predicates) is given in Fig. 2. Most cases have simple  explanations, e.g. a multiset m is a counter example for  ÄÂ† Ã¢ÂˆÂ§ ÄÂˆ if m is a counter example for ÄÂ† or a counter example  for ÄÂˆ, which explains the false marking for conjunction.  Concerning ÄÂ†1  ÄÂ†2 , a multiset m is a counter example  if for every vertex k and every consistent split m1 , m2 of  m wrt. k, either m1 is a counter example for ÄÂ†1 or m2 is  a counter example for ÄÂ†2 (or both are counter examples).  This is actually a precise characterization of the traces  falsifying ÄÂ†1  ÄÂ†2 , provided that markF (i, k, ÄÂ†1 )(m) and  markF (k, j, ÄÂ†2 )(m) provide precise characterizations for the  traces falsifying ÄÂ†1 and ÄÂ†2 , respectively.  It is in the true marking for ÄÂ†1  ÄÂ†2 the approximations  of the multiset semantics become visible, by requiring that  there is a distinct state k which works as chop point. Since  we are considering universal path properties, this chop point  must work for all for possible splits of the multiset. This is  expressed using a universal quantiÄÅ¹Âer in the marking. We  shall in Section IV see an example where one vertex does  not sufÄÅ¹Âce as chop point, despite that every trace satisÄÅ¹Âes a  given formula ÄÂ†1  ÄÂ†2 . Since the model-checking problem  we start up with is undecidable, the approximations must  show up somewhere and here it is when chop occurs in  positive polarity.  Ã¢Â‡Â” K[[ÄÂ†]] i j m = {true}  Ã¢Â‡Â” K[[ÄÂ†]] i j m = {false}  The formulas markT (i, j, ÄÂ†)(m) and markF (i, j, ÄÂ†)(m)  are called the true and false markings, respectively, and they  are based on a Presburger formula C(i, j)(m) characterizing  the multisets for the traces bringing the automaton from state  i to state j. We introduce the general idea in terms of the  example in Fig. 1, where we would like to check whether  every run from A to D satisÄÅ¹Âes the formula:    <4Ã¢Â‡Â’ p<3  (1)  We introduce the following multiset variables: m =  mA , mB , mC , mD and the consistent traces from A to vertex  D is described by C(A, D)(m) =  Ã¢ÂˆÂƒeAB , eBA , eBC , eCD , eDD :  = mA =  1 + eBA  eAB  eAB  eBC  =  =  mB  mC  =  =  eBA + eBC  eCD  eCD + eDD  = mD  =  eDD + 1  The idea is to introduce a variable for every edge (e.g. eAB  describes the frequency of visits to the edge from A to B),  and add equations expressing that the sum of all inÄÅ¹Â‚ow to  a state is equal to the visiting frequency of that state which  is equal to the outÄÅ¹Â‚ow of that state. The start state has an  extra inÄÅ¹Â‚ow of 1 and the end state has an extra outÄÅ¹Â‚ow of  1 to ensure a Ã¢Â€ÂÄÅ¹Â‚owÃ¢Â€Â from the start to the end. There are  extra conditions for certain loops to ensure that if a loop  has a positive visiting frequency, then some edge entering  that loop has a positive visiting frequency as well; but such  conditions are not needed in this example.  The construction of the consistency formulas C(i, j)(m),  see [12], we currently are using is based on the assumption  that every loop in K has a unique entry point, and in this  case the construction of C(i, j)(m) is simple and its size  is proportional to the size of K. If the unique entry-point  assumption does not hold, then one can use the linear-time  construction given in [27] for achieving a Presburger formula  for the Parikh image of a regular language. This construction  will, however, introduce extra quantiÄÅ¹Âers.  The DC formula (1) is translated to  III. P RESBURGER ARITHMETIC  Presburger arithmetic is the ÄÅ¹Ârst-order theory of natural  numbers (or integers) with addition, which was proved to  be decidable by M. Presburger in 1927. There are several  decision algorithms for PA, and one is CooperÃ¢Â€Â™s algorithm  [5]. This algorithm is a quantiÄÅ¹Âer elimination algorithm,  which repeatedly removes quantiÄÅ¹Âers inside-out by replacing  an innermost quantiÄÅ¹Âed formula by an equivalent quantiÄÅ¹Âerfree formula. When the original formula has no free variables, its truth value can be computed in a straightforward  manner when all quantiÄÅ¹Âers have been eliminated. When  an existential quantiÄÅ¹Âer Ã¢ÂˆÂƒx.ÄÂˆ(x), where ÄÂˆ(x) is quantiÄÅ¹Âer  free, is eliminated, ÄÂˆ(x) is ÄÅ¹Ârst normalized to a negation  normal form formula ÄÂˆ  (x) where < is the only comparison  operator occurring in ÄÂˆ  (x) and x has the same coefÄÅ¹Âcient,  say ÃÂ´, in all constraints. Let ÄÂ†(x ) be ÄÂˆ  [x /ÃÂ´x] Ã¢ÂˆÂ§ ÃÂ´|x ,  where ÄÂ•[t/ay] is the formula obtained from ÄÂ• by replacing  every occurrence of ay with t. We have Ã¢ÂˆÂƒx.ÄÂˆ(x) Ã¢Â‡ÂÃ¢Â‡Â’  Ã¢ÂˆÂƒx.ÄÂˆ  (ÃÂ´x) Ã¢Â‡ÂÃ¢Â‡Â’ Ã¢ÂˆÂƒx .ÄÂ†(x ). The existential quantiÄÅ¹Âer can  (2)  (ÃÅiÃ¢ÂˆÂˆ{A,B,C,D} mi ) Ã¢ÂˆÂ’ 1 < 4 Ã¢Â‡Â’ mB + mC < 3    by replacing P with the sum of the multiset variables for  the states where P hold, and by replacing length with the  sum of all multiset variables minus 1. The adjustment with  117  markT (i, j, )(m)  markF (i, j, )    markT (i, j, ÃÅiÃ¢ÂˆÂˆÃÅ  ci Si < k)(m)    markF (i, j, ÃÅiÃ¢ÂˆÂˆÃÅ  ci Si < k)(m)  = C(i, j)(m)  = false  = C(i, j)(m) Ã¢ÂˆÂ§  = C(i, j)(m) Ã¢ÂˆÂ§      iÃ¢ÂˆÂˆÃÅ  ci  iÃ¢ÂˆÂˆÃÅ  ci    vÃ¢ÂˆÂˆV,v|=Si  vÃ¢ÂˆÂˆV,v|=Si  m[v] < k  m[v] Ã¢Â‰Ä½ k  markT (i, j, Ã‚Å¹ÄÂ†)(m)  = markF (i, j, ÄÂ†)(m)  markF (i, j, Ã‚Å¹ÄÂ†)(m)  = markT (i, jÄÂ†)(m)  markT (i, j, ÄÂ†1 Ã¢ÂˆÂ§ ÄÂ†2 )(m)  markF (i, j, ÄÂ†1 Ã¢ÂˆÂ§ ÄÂ†2 )(m)  = markT (i, j, ÄÂ†1 )(m) Ã¢ÂˆÂ§ markT (i, j, ÄÂ†2 )(m)  = markF (i, j, ÄÂ†1 )(m) Ã¢ÂˆÂ¨ markF (i, j, ÄÂ†2 )(m)  and  Ã¢ÂÂ›  markT (i, j, ÄÂ†1    ÄÂ†2 )(m) =  markF (i, j, ÄÂ†1    ÄÂ†2 )(m) =    kÃ¢ÂˆÂˆV  Ã¢ÂÂ  Ã¢ÂˆÂƒm1 , m2 : ÃÅºikj (m, m1 , m2 )  Ã¢ÂÂœ  Ã¢ÂÂŸ  Ã¢ÂÂ Ã¢ÂˆÂ§  Ã¢Â  Ã¢ÂˆÂ€m1 , m2 : ÃÅºikj (m, m1 , m2 ) Ã¢Â‡Â’ (markT (i, k, ÄÂ†1 )(m1 ) Ã¢ÂˆÂ§ markT (k, j, ÄÂ†2 )(m2 ))  C(i, j)(m)Ã¢ÂˆÂ§  kÃ¢ÂˆÂˆV Ã¢ÂˆÂ€m1 , m2 : ÃÅºikj (m, m1 , m2 ) Ã¢Â‡Â’ (markF (i, k, ÄÂ†1 )(m1 ) Ã¢ÂˆÂ¨ markF (k, j, ÄÂ†2 )(m2 ))  where ÃÅºikj (m, m1 , m2 ) = m = m1 + m2 Ã¢ÂˆÂ§ C(i, k)(m1 ) Ã¢ÂˆÂ§ C(k, j)(m2 ) expresses that m1 and m2 is a consistent split of  m for state k for traces from i to j in the Kripke structure.  Figure 2.  Marking algorithm (slightly rephrased from [12]) for a given Kripke structure K  now be replaced by a bounded disjunction as follows:    Ã¢ÂˆÂƒx .ÄÂ†(x ) Ã¢Â‡Â”  A. Guarded normal form  Inspecting the marking algorithm in Fig. 2, one can see  that the size of the generated formula is exponential in  the chop depth. It is therefore important that formulas are  simpliÄÅ¹Âed as much as possible. We are aiming at a normal  form where we can collect conjunctions of literals in order  to reduce the size of formulas by performing simpliÄÅ¹Âcations  including Ã¢Â€ÂcheapÃ¢Â€Â equation-based quantiÄÅ¹Âer eliminations.  We name this guarded normal form, and we consider it  ÄÅ¹Ârst in a propositional setting, with constants  (true) and  Ã¢ÂŠÄ½ (false), variables p, q, r, conjunction P Ã¢ÂˆÂ§ Q, disjunctions  P Ã¢ÂˆÂ¨ Q and negation Ã‚Å¹P . Let L denote a literal, i.e. a  proposition of the form p or Ã‚Å¹p.  An implication guard is a proposition of the form:      Li Ã¢Â‡Â’  Pj  ÃÂ´  Ã¢ÂˆÂ¨  i=1 ÄÂ†[/x < t, Ã¢ÂŠÄ½/t < x]  ÃÂ´     i=1  t<x in ÄÂ†(x ) ÄÂ†[t + i/x ]  (3)  where ÃÂ´  is the least common multiple of the divisors d in  divisibility constraints d|t(x). Here ÄÂ†[/x < t, Ã¢ÂŠÄ½/t < x]  is the formula obtained from ÄÂ† by substituting every occurrence of a constraint x < t in ÄÂ† with true and every  occurrence of a constraint t < x in ÄÂ† with false. CooperÃ¢Â€Â™s  algorithm has the advantage that it just uses a non-expansive  negation normal form, but it is a major challenge to control  the growth of the constants ÃÂ´ and ÃÂ´  when eliminating nested  quantiÄÅ¹Âers using this algorithm.  i  The Omega test [25] is another quantiÄÅ¹Âer-elimination  method which is inspired by Fourier-MotzkinÃ¢Â€Â™s methods  for the reals. For a conjunction of upper- and lower-bound  constraints, U and L, respectively, it considers all possible  combinations of bx < t1 Ã¢ÂˆÂˆ L and ax > t2 Ã¢ÂˆÂˆ U when  eliminating x. This method is based on normalizing formulas  to disjunctive normal form, and, for example, in the case of  quantiÄÅ¹Âer alternations this may be undesirable. Furthermore,  Presburger arithmetic is incorporated in Z3 [1], [6], which  has shown to be a powerful tool for checking Presburger  formulas generated by our algorithm. Also automata-based  decision methods for Presburger arithmetic are available, see  for example [19].  j  and a conjunction guard is a proposition of the form:      Li Ã¢ÂˆÂ§  Pj  i  j  A guarded formula is a formula constructed from literals, ,  and Ã¢ÂŠÄ½ by the use of guarded implications and conjunctions.  A conjunction of literals is called a guard. In the Presburger  setting, the literals are (possibly negated) equations, comparisons and divisibility constraints.  It is easy to express conjunction and disjunction by  guarded formulas using trivial guards. Furthermore, nega-  118  an equation nx = t in a guard can be used to eliminate x  elsewhere in the formula:    nx = t Ã¢ÂˆÂ§ i Li Ã¢Â‡Â’ j Pj    (11)  Ã¢Â‡ÂÃ¢Â‡Â’ nx = t Ã¢ÂˆÂ§ i Li [t/nx] Ã¢Â‡Â’ j Pj [t/nx]  tions propagate through guarded formulas:  P Ã¢ÂˆÂ§Q  P Ã¢ÂˆÂ¨Q  Ã‚Å¹(  Ã‚Å¹(  Li Ã¢Â‡Â’  i Li Ã¢ÂˆÂ§  i    Ã¢Â‡ÂÃ¢Â‡Â’  Ã¢Â‡ÂÃ¢Â‡Â’  Pj )  j Pj )  j  Ã¢Â‡ÂÃ¢Â‡Â’  Ã¢Â‡ÂÃ¢Â‡Â’  Li Ã¢ÂˆÂ§ P Ã¢ÂˆÂ§ Q  iÃ¢ÂˆÂˆÃ¢ÂˆÂ… Li Ã¢Â‡Â’ P Ã¢ÂˆÂ¨ Q  iÃ¢ÂˆÂˆÃ¢Âˆ  Li Ã¢ÂˆÂ§ j Ã‚Å¹Pj    i Li Ã¢Â‡Â’  j Ã‚Å¹Pj  i  nx = t Ã¢ÂˆÂ§  Li Ã¢ÂˆÂ§  Pj Ã¢ÂˆÂ§ L Ã¢Â‡ÂÃ¢Â‡Â’ L Ã¢ÂˆÂ§ i Li Ã¢ÂˆÂ§ j Pj        i Li Ã¢Â‡Â’ ( k Lk Ã¢Â‡Â’  l Ql ) Ã¢ÂˆÂ¨  j Pj        Ã¢Â‡ÂÃ¢Â‡Â’  L  Ã¢ÂˆÂ§  L  Ã¢Â‡Â’  k k  i i  l Ql Ã¢ÂˆÂ¨  j Pj  i  j  Li Ã¢ÂˆÂ§ (  Ã¢Â‡ÂÃ¢Â‡Â’  k  Lk Ã¢ÂˆÂ§ l Ql ) Ã¢ÂˆÂ§ j Pj    k Lk Ã¢ÂˆÂ§  i Li Ã¢ÂˆÂ§  l Ql Ã¢ÂˆÂ§  j  Pj  Li Ã¢ÂˆÂ§  Ã¢Â‡ÂÃ¢Â‡Â’ nx = t Ã¢ÂˆÂ§  A guarded formula F isin normal form if every implication guard i Li Ã¢Â‡Â’ j Pj in F satisÄÅ¹Âes that each  Pj is a conjunction guard, and every conjunction guard  i Li Ã¢ÂˆÂ§ j Qj in F satisÄÅ¹Âes that each Qj is an implication  guard.  Every propositional formula has a guarded normal form,  which can be obtained by using the equivalences:      (4)  i Li Ã¢Â‡Â’  j Pj Ã¢ÂˆÂ¨ L Ã¢Â‡ÂÃ¢Â‡Â’ Ã‚Å¹L Ã¢ÂˆÂ§  i Li Ã¢Â‡Â’  j Pj  i  i  j  i  Pj  Li [t/nx] Ã¢ÂˆÂ§  j  Pj [t/nx]  Such substitutions depend on the least common multiple of  n and the coefÄÅ¹Âcients of x in the formula, e.g.  Ã¢Â‡ÂÃ¢Â‡Â’  3x + 5y > 2z[y + 2z/2x]  6x + 10y > 4z[y + 2z/2x]  Ã¢Â‡ÂÃ¢Â‡Â’  3y + 6z + 10y > 4z Ã¢Â‡ÂÃ¢Â‡Â’ 13y > z  C. Simple quantiÄÅ¹Âer eliminations  Equations in guards are particular useful in connection  with quantiÄÅ¹Âer elimination due to the equivalences:      Ã¢ÂˆÂƒx. (nx = t Ã¢ÂˆÂ§ Li Ã¢Â‡Â’  Pj ) Ã¢Â‡ÂÃ¢Â‡Â’   (13)  (5)  (6)  i  Ã¢ÂˆÂƒx. (nx = t Ã¢ÂˆÂ§  Ã¢Â‡ÂÃ¢Â‡Â’ n|t Ã¢ÂˆÂ§  (7)  Notice that applications of these equivalences (from left to  right) have the effect of collecting literals in guards and  reducing the nesting of guarded formulas.  j  Li Ã¢ÂˆÂ§ j Pj )  L  i i [t/nx] Ã¢ÂˆÂ§  j Pj [t/nx]  i  Ã¢Â‡ÂÃ¢Â‡Â’  Ã¢ÂˆÂƒz.Ã¢ÂˆÂƒx.2x = y + z Ã¢ÂˆÂ§ 4x + 3y Ã¢ÂˆÂ’ z = 1  Ã¢ÂˆÂƒz.5y + z = 1 Ã¢ÂˆÂ§ 2|y + z  Reductions are natural to perform when literals are collected in guards by use of (4 Ã¢ÂˆÂ’ 7). We check for inconsistencies and for simpliÄÅ¹Âcations in the guards. An example  of an inconsistency check is the Omega methodÃ¢Â€Â™s check  for real shadows, which is one part of the Fourier-Moszkin  elimination for the ÄÅ¹Ârst-order theory of reals. The right-hand  side of the following implication is called the real shadow.  If this shadow is false, then no real number x satisÄÅ¹Âes  t1 Ã¢Â‰Â¤ axÃ¢ÂˆÂ§bx Ã¢Â‰Â¤ t2 and hence there can be no integer solution:  Ã¢Â‡ÂÃ¢Â‡Â’  2| Ã¢ÂˆÂ’ 4y + 1 Ã¢Â‡ÂÃ¢Â‡Â’ 2|1 Ã¢Â‡ÂÃ¢Â‡Â’ false  =Ã¢Â‡Â’  bt1 Ã¢Â‰Â¤ at2  IV. I MPLEMENTATION AND E XPERIMENTS  We have implemented the model-checking algorithm in  Fig. 2 on the basis of the guarded normal form with  many simpliÄÅ¹Âcations including the equation-based quantiÄÅ¹Âer  eliminations shown in the previous section. The table with  markings generated with this algorithm was signiÄÅ¹Âcantly  smaller than that of [18] partly due to these simpliÄÅ¹Âcations,  and partly due to a more careful analysis of the Kripke  structure, which led to signiÄÅ¹Âcant simpliÄÅ¹Âcations on the  consistency predicates C(i, j) on the basis of a reachability analysis. In addition, we have implemented CooperÃ¢Â€Â™s  algorithm to be used after the equation-based quantiÄÅ¹Âer  eliminations. For small examples, this worked well; but  for larger examples with many nested quantiÄÅ¹Âcations  the    expansions due to the the disjunctions t<x ÄÂ†[t + i/x ]  became the bottleneck. These disjunction must be treated in  a more symbolic manner (like  the way we treated bounded  ÃÂ´  disjunctions of the form i=1 F (i)) in order to be useful. In  the below experiments we have therefore, with good results,  used Z3 as backend. The experiments were conducted on  a Windows Server 2008 with Intel Xeon E5620 Processors  and 8GB of RAM.  We have so far just veriÄÅ¹Âed a few, rather small examples.  Each example has been tested using (1) the Z3-solver  (8)  Using this implication for all pairs of constraints matching  the left-hand side will generate a collection of new literals  and may expand the guard signiÄÅ¹Âcantly. In our implementation we just apply the rule when t1 and t2 are integers and  the truth value of the shadow can be computed directly.  The following equivalences used from left to right show  just two of the reductions which have shown to be useful  in our examples in order to keep the expansive parts of the  decision process manageable.  t > a Ã¢ÂˆÂ§ t > b Ã¢Â‡ÂÃ¢Â‡Â’ t > max{a, b}  t Ã¢ÂˆÂ’ 1 < a Ã¢ÂˆÂ§ a < t + 1 Ã¢Â‡ÂÃ¢Â‡Â’ a = t  (14)  The following example shows two applications of (14)  and simple reductions of divisibility constraints:  B. Reductions  t1 Ã¢Â‰Â¤ ax Ã¢ÂˆÂ§ bx Ã¢Â‰Â¤ t2  (12)  (9)  (10)  An advantage of collecting literals in guards is that  consistency can be checked and propagated. For example,  119  Example  3-seq  4-seq  5-seq  6-seq  Dia-1  Dia-2  NoGNF (KB)  /w Z3simp  808/ 3.026  1.952/7.084  3.865/14.010  6.739/25.058  10/ 26  10/ 26  EqQe (KB)  /w Z3simp  616/1.454  1.585/3.665  3.206/ 7.427  5.650/ 13.141  3/6  3/6  MarkingTime  /w Z3simp  0,6 /3,9 s  3,6 /12,9 s  4,6 /21,6 s  8,5 /44,2 s  EqQe  4,2  12,8  33,5  72,9  s  s  s  s  Z3Sat-NoGNF  /Z3simp  2,9 /1,8 s  12,9 /3,6 s  40,1 /6,3 s  122,5 /11,2 s  104ms  74ms  Z3Sat-EqQe  /Z3simp  1,5 /1,8 s  4,6/2,9 s  75,2/4,6  Ã¢Â€Â”  47ms  37ms  Commands used for Z3Ã¢Â€Â™s simpliÄÅ¹Âcations of formulas and SAT-solving  z3.exe /nw /smt2 ARITH_EXPAND_EQS=true STRONG_CONTEXT_SIMPLIFIER=true filename.smt  z3.exe /smt2 ELIM_QUANTIFIERS=true MODEL=true filename.smt  Figure 3.  Data from experiments  Bi  Ai  exclusively on a raw marking from the algorithm in Fig. 2  without the use of guarded normal form and equation-based  quantiÄÅ¹Âer eliminations, and (2) several combinations of  guarded normal form, equation-based quantiÄÅ¹Âer elimination  and a decision procedure based on CooperÃ¢Â€Â™s algorithm.  The purpose of this is to compare results and to get a  conÄÅ¹Âdence in the correctness of the programs. The results of  the experiments are shown in Fig. 3. There are many ways in  which Z3 can be applied. We used Z3 with an input formula  in the SMT-lib format. The commands shown in Fig. 3 were  used to activate Z3Ã¢Â€Â™s simpliÄÅ¹Âcation of formulas and the SATsolving command. This use of Z3 seems to give us the best  results; but we certainly cannot exclude that there are better  ways to use Z3.  p  Ci  p  Di    (1) ( < 4 =Ã¢Â‡Â’ p < 3)    Properties:  (2) ( < 5 =Ã¢Â‡Â’ p < 3)  where ÄÂ† is deÄÅ¹Âned by Ã‚Å¹(true  (Ã‚Å¹ÄÂ†)  true).  Figure 4.  Extended automaton from [12]  normalized formulas gives an improvement; however, for  sequences with 5 and 6 repetitions normalized formulas  were a disadvantage for Z3, and for 6 repetitions Z3 did  not complete within an hour. We have so far no explanation  why quantiÄÅ¹Âer eliminations and simpliÄÅ¹Âcations prior to using  Z3 did not help in these two cases. We have not met other  examples where this phenomenon occurred.  The experiments for the formula (1) were based on the  SAT-problem C(A1 , DN )(m) Ã¢ÂˆÂ§ Ã‚Å¹markF (A1 , DN , (1))(m)  which is not satisÄÅ¹Âable, i.e. the model-checking problem  holds. For the formula Fig. 4(2), the corresponding Presburger formula is satisÄÅ¹Âable and Z3 gives satisfying assignments slightly faster than for the corresponding unsat case.  Example 1  This example is based on an iterative version of the simple  automaton Mi shown in Fig. 4, with the veriÄÅ¹Âcation of the  two properties shown. Property (1) holds for every run in  the automaton, while property (2) does not hold as the run  Bi Ai Bi Ci Di gives a counter example.  By sequential composition of Mi , for i = 0, . . . , n, we use  this example to test the current limit of the approach. By an  N-sequence, we understand N automata M1 , M2 , . . . , MN ,  where there is an edge from Di to Ai+1 , for 1 Ã¢Â‰Â¤ i < N  and there are edges from Di to Aj , for 1 Ã¢Â‰Â¤ j Ã¢Â‰Â¤ i Ã¢Â‰Â¤ N .  This composition implies that from any state every other  state is reachable. Therefore, for every pair (i, j) of states  the consistency predicate C(i, j) must be computed. These  consistency predicates are used in connection with the two  chops occurring the deÄÅ¹Ânition of the -modality.  The experiments were conducted up to a 6-sequence and  the results are shown in Fig. 3. The ÄÅ¹Ârst two columns show  the sizes (in KB) of the generated formulas in the SMTlib format. The use of guarded normal form and equalitybased quantiÄÅ¹Âer elimination gives a signiÄÅ¹Âcant reduction on  the formulas sizes, which also applies for a succeeding Z3  simpliÄÅ¹Âcation. For sequences with up to 4 repetitions, using  Example 2  The counting semantics of chop is based on the ability to  ÄÅ¹Ând, for a given multiset m, a state that works as a choppoint for all possible splits of m, cf. Fig. 2. This gives an  approximation in the sense that K[[ÄÂ†]] i j m may be Ã¢ÂˆÂ… even  though every trace from i to j satisÄÅ¹Âes ÄÂ†.  This is illustrated with the formula (1) and the automaton  in Fig. 5. Every trace from A to D satisÄÅ¹Âes the formula  since it either ends with P or Q being true, but this is not  captured by the multiset semantics. The problem is that B  works as chop-point for the formula true   P  for just  the multisets which has visiting frequencies 1 and 0 for B  120  are propagated and we use (14) whenever it is possible.  Other equations and constraints should be propagated as  well. Experiments with a more aggressive guard propagation  approach has shown promising reductions in a propositional  setting.  B  P  A  D  V. S UMMARY  Q  It appear as a kind of Ã¢Â€Âmission impossibleÃ¢Â€Â to base a  model-checking algorithm for Duration Calculus on checking formulas of Presburger Arithmetic, particularly, when the  formulas to be checked may have size that is exponential in  the chop depth of the original DC formula. To investigate  the feasibility of this approach we have implemented the  model-checking algorithm. A ÄÅ¹Ârst prototype implementation  in a MasterÃ¢Â€Â™s Thesis project [17], [18], validated the approach; but in this implementation the marking algorithm  was the bottleneck, as it ran out of memory for rather small  problems. To cope with that problem, a guarded normal  for formulas that supports Ã¢Â€ÂcheapÃ¢Â€Â equation-based quantiÄÅ¹Âer  eliminations and propagation of simpliÄÅ¹Âcations was developed and a new marking algorithm was implemented, which  produce a much smaller marking table.  So far we have just experimented with rather small  examples but the results obtained gave hope for eventually  achieving an efÄÅ¹Âcient veriÄÅ¹Âcation framework for several  reasons: (a) results were achieved fast for some of the bigger  examples we tried, (b) the guarded normal form can be  much more aggressively used for formula simpliÄÅ¹Âcations  using a guard propagation (which we have tried out in a  pure propositional setting with good results), (c) there are  a huge number of obvious optimizations to this prototype  implementation, and (d) a fragment of the model checking  problem reduces to linear SAT, see [12], and exploiting  this will give a huge improvement to using Presburger  arithmetic. In this ongoing work we are still in a phase  where seemingly simple optimizations and new reductions  often have signiÄÅ¹Âcant effect, and that experiments with the  implementation give many ideas for further improvements.  Z3 has shown to be a powerful backend.  C  (1) (true   P  ) Ã¢ÂˆÂ¨ (true   Q)  Ã¢ÂÂ›      Ã¢ÂÂ  P Ã¢ÂˆÂ’ Q = Ã¢ÂˆÂ’1  Properties:      Ã¢ÂÂœ  Ã¢ÂÂŸ  P Ã¢ÂˆÂ’ Q=0 Ã¢Â  (2) true  Ã¢ÂÂ Ã¢ÂˆÂ¨      Ã¢ÂˆÂ¨  P Ã¢ÂˆÂ’ Q=1  Figure 5.  Automaton showing limitations  and C, respectively, since visits to C must be prevented for   P  to hold after the chop. A similar consideration applies  for the formula true   Q and the chop point C. For  example, the multiset m, where the visiting frequencies to  A, B, C and D are 1, 1, 2 and 1, respectively, is a case  where K[[ÄÂ†]] A D m = Ã¢ÂˆÂ….  The formula Fig. 5(2) also has chop in positive polarity;  but the multiset approximation is ÄÅ¹Âne grained enough and  the model checking will report that every trace from A to  D satisÄÅ¹Âes (2). In traces from A to D the difference of the  visiting frequencies to B and C is at most 1. It is easy to see  that state B works as chop point when the visiting frequency  of B is at least that of C, and C works as chop point when  the visiting frequency of C is at least that of B.  The veriÄÅ¹Âcation times are small and so are the sizes of  the generated formulas for this example; but they are shown  in Fig. 3 as they illustrate the tendencies we have seen in  most examples we have tried.  Discussion  We have used a unique representation for the atomic  formulas, which cancel out the least common divisor of the  coefÄÅ¹Âcients of the linear expressions. This often caused simpliÄÅ¹Âcations which were propagated by the guarded normal  form.  We are still at an initial stage of development and whenever we include new reductions in our approach, they have  big impact on the size of the formulas, of the time it takes to  eliminate quantiÄÅ¹Âers and of conducting satisÄÅ¹Âability check.  We are currently investigating different ways to incorporate more elements of the Omega test and   a more Ã¢Â€ÂlazyÃ¢Â€Â  treatment of the bounded disjunctions t<x ÄÂ†[t + i/x ]  into the guarded normal form reductions. Furthermore, we  can exploit the guarded normal form much better than we  are currently doing by Ã¢Â€Âpropagating guardsÃ¢Â€Â more aggressively to subformulas. Until now only value assignments  ACKNOWLEDGMENT  This research has partially been funded by the SYSMODEL project (ARTEMIS JU 100035) and by the  IDEA4CPS project granted by the Danish Research Foundation for Basic Research. The authors would like to thank the  reviewers for their comments, corrections and suggestions,  which caused signiÄÅ¹Âcant improvements in the ÄÅ¹Ânal version.  Furthermore, we are grateful for discussions and comments  from Phan Anh Dung, Mikkel Koefoed Jakobsen, Marko  KaÄšÂˆaÄšÂˆramees and Jan Madsen.  R EFERENCES  [1] N. BjÄ‚Â¸rner, Ã¢Â€ÂœLinear QuantiÄÅ¹Âer Elimination as an Abstract  Decision Procedure,Ã¢Â€Â IJCAR 2010, LNAI 6173, Springer  2010, pp. 316-330.  121  [19] F. Klaedtke, Ã¢Â€ÂœOn the Automata Size for Presburger Arithmetic,Ã¢Â€Â ACM Transactions on Computational Logic 9(2) pp.  11:1Ã¢Â€Â“11:34, 2008.  [2] T. Bolander, J.U. Hansen, and M.R. Hansen, Ã¢Â€ÂœDecidability of  a hybrid duration calculus,Ã¢Â€Â ENTCS, 174(6):113Ã¢Â€Â“133, 2007.  [3] A. Bouajjani, Y. Lakhnech, and R. Robbana, Ã¢Â€ÂœFrom duration  calculus to linear hybrid automata,Ã¢Â€Â In CAVÃ¢Â€Â™95, LNCS 939,  Springer 1995, pp. 196Ã¢Â€Â“210.  [20] R. Meyer, J. Faber, J. Hoenicke, and A. Rybalchenko, Ã¢Â€ÂœModel  checking Duration Calculus: a practical approach,Ã¢Â€Â Formal  Aspects of Computing 20(4-5), 2008, pp. 481Ã¢Â€Â“505.  [4] D. Bresolin, V. Goranko, A. Montanari, and G. Sciavicco,  Ã¢Â€ÂœRight propositional neighborhood logic over natural numbers  with integer constraints for interval lengths,Ã¢Â€Â In SEFM 2009,  pp. 240-249, 2009.  [21] B. Moszkowski, Ã¢Â€ÂœA temporal logic for multi-level reasoning  about hardware,Ã¢Â€Â IEEE Computer 18(2):10Ã¢Â€Â“19, 1985.  2pn  [22] D.C. Oppen, Ã¢Â€ÂœA 22  Upper Bound on the Complexity of  Presburger Arithmetic,Ã¢Â€Â Jour. Comput. Syst. Sci. 16(3): 323Ã¢Â€Â“  332, 1978.  [5] D.C. Cooper, Ã¢Â€ÂœTheorem Proving in Arithmetic without  Multiplication,Ã¢Â€Â Machine Intelligence, 1972, pp. 91-100.  [6] L. de Moura and N. BjÄ‚Â¸rner, Ã¢Â€ÂœZ3: An EfÄÅ¹Âcient SMT Solver,Ã¢Â€Â  In TACAS 2008, LNCS 4963, Springer 2008, pp. 337Ã¢Â€Â“340.  [23] P.K. Pandya, Ã¢Â€ÂœSpecifying and deciding quantiÄÅ¹Âed discretetime duration calculus formulae using DCVALID,Ã¢Â€Â In RTTOOLSÃ¢Â€Â˜2001. Aalborg, August 2001.  [7] J. Esparza, Ã¢Â€ÂœPetri nets, commutative context-free grammars,  and basic parallel processes,Ã¢Â€Â Fundamenta Informaticae 30:  23Ã¢Â€Â“41, 1997.  [24] P.K. Pandya, Ã¢Â€ÂœModel Checking CTL*[DC],Ã¢Â€Â In TACAS 2001,  LNCS 2031, Springer 2001, pp. 559Ã¢Â€Â“573.  [25] W. Pugh, Ã¢Â€ÂœA practical algorithm for exact array dependence  analysis,Ã¢Â€Â ACM Commun. 35(8), 1992, pp. 102-114.  [8] J. Esparza and S. Meltzer, Ã¢Â€ÂœVeriÄÅ¹Âcation of Safety Properties  using Integer Programming: Beyond the State Equation,Ã¢Â€Â  Formal Methods in System Design 16: 159Ã¢Â€Â“189, 2000.  [26] C.R. Reddy and D.W. Loveland, Ã¢Â€ÂœPresburger Arithmetic with  Bounded QuantiÄÅ¹Âer Alternation,Ã¢Â€Â ACM Symp. on Theory of  Computing, pages 320-325, ACM 1978.  [9] M.J. Fischer and M.O. Rabin, Ã¢Â€ÂœSuper-Exponential Complexity of Presburger Arithmetic,Ã¢Â€Â Proc. of the SIAM-AMS  Symposium in Applied Mathematics Vol. 7: 27-41, 1974.  [27] H. Seidl, T. Schwentick, A. Muscholl, and P. Habermehl,  Ã¢Â€ÂœCounting for Free in Trees,Ã¢Â€Â ICALP 2004, LNCS 3142,  2004, pp. 1136-1149.  [10] M. FraÄšÂˆnzle, Ã¢Â€ÂœModel-checking dense-time duration calculus,Ã¢Â€Â  Formal Aspects of Computing 16(2):121Ã¢Â€Â“139, 2004.  [28] B. Sharma, P.K. Pandya, and S. Chakraborty, Ã¢Â€ÂœBounded  Validity Checking of Interval Duration Logic,Ã¢Â€Â TACAS 2005,  LNCS 3440, Springer 2005, pp. 302Ã¢Â€Â“316.  [11] M. FraÄšÂˆnzle and M.R. Hansen, Ã¢Â€ÂœDeciding an interval logic with  accumulated durations,Ã¢Â€Â TACAS 2007, LNCS 4424, Springer  2007, pp. 201Ã¢Â€Â“215.  [29] Pham Hong Thai and Dang Van Hung, Ã¢Â€ÂœVerifying Linear  Duration Constraints of Timed Automata,Ã¢Â€Â ICTACÃ¢Â€Â™2004,  LNCS 3407, Springer 2005, pp. 295Ã¢Â€Â“309.  [12] M. FraÄšÂˆnzle and M.R. Hansen, Ã¢Â€ÂœEfÄÅ¹Âcient model checking  for duration calculus,Ã¢Â€Â International Journal of Software and  Informatics Vol.3, no.2-3, pp. 171-196, 2009.  [30] Miaomiao Zhang, Dang Van Hung, and Zhiming Liu, Ã¢Â€ÂœVeriÄÅ¹Âcation of Linear Duration Invariants by Model Checking  CTL Properties,Ã¢Â€Â ICTACÃ¢Â€Â™2008, LNCS 5160, Springer 2008,  pp. 395Ã¢Â€Â“409.  [13] M. FraÄšÂˆnzle and M.R. Hansen, Ã¢Â€ÂœEfÄÅ¹Âcient model checking for  duration calculus based on branching-time approximations,Ã¢Â€Â  In SEFM 2008, pp. 63Ã¢Â€Â“72, IEEE 2008.  [31] Zhou Chaochen and M.R. Hansen, Ã¢Â€ÂœAn adequate ÄÅ¹Ârst order  logic of intervals,Ã¢Â€Â In Compositionality: The SigniÄÅ¹Âcant  Difference, LNCS 1536. Springer 1996, pp. 584Ã¢Â€Â“608.  [14] V. Goranko, A. Montanari, and G. Sciavicco, Ã¢Â€ÂœPropositional  interval neighborhood temporal logics,Ã¢Â€Â Journal of Universal  Computer Science 9(9):1137-1167, 2003.  [32] Zhou Chaochen and M.R. Hansen, Duration Calculus Ã¢Â€Â”  A Formal Approach to Real-Time Systems, Monographs in  Theoretical Computer Science. Springer-Verlag, 2004.  [15] J. Halpern and Y. Shoham, Ã¢Â€ÂœA propositional modal logic of  time intervals,Ã¢Â€Â Journal of the ACM 38(4):935-962, 1991.  [33] Zhou Chaochen, M.R. Hansen, and P. Sestoft, Ã¢Â€ÂœDecidability  and undecidability results for duration calculus,Ã¢Â€Â STACS 93,  LNCS 665, Springer 1993, pp. 58Ã¢Â€Â“68.  [16] M.R. Hansen, Ã¢Â€ÂœModel-checking discrete duration calculus,Ã¢Â€Â  Formal Aspects of Computing 6(6A):826Ã¢Â€Â“845, 1994.  [17] W.P. Heise, M. FraÄšÂˆnzle, and M.R. Hansen, Ã¢Â€ÂœA prototype  model checker for Duration Calculus (Extended Abstract),Ã¢Â€Â  NWPTÃ¢Â€Â™09, DTU Informatics, Technical University of Denmark, 2009, pp. 26Ã¢Â€Â“29.  [34] Zhou Chaochen, C.A.R. Hoare, and A.P. Ravn, Ã¢Â€ÂœA calculus  of durations,Ã¢Â€Â Information Processing Letters 40(5):269Ã¢Â€Â“276,  1991.  [18] W.P. Heise, An efÄÅ¹Âcient model checker for Duration Calculus.  MasterÃ¢Â€Â™s Thesis, DTU Informatics, Technical University of  Denmark, 2010.  [35] Zhou Chaochen, Zhang Jingzhong, Yang Lu, and Li Xiaoshan. Ã¢Â€ÂœLinear duration invariants,Ã¢Â€Â In FTRTFTÃ¢Â€Â˜94, LNCS  863, Springer 1994, pp. 86Ã¢Â€Â“109.  122 