Positive and negative results on the decidability of the model-checking problem  for an epistemic extension of Timed CTL  Cătălin Dima∗  LACL, Université Paris Est – Université Paris 12, 61 av. du Général de Gaulle, 94010 Créteil, France  Abstract  agents may observe the exact current absolute time, while  perfect recall means that, based on the history of observations they can make on system states, agents are able to distinguish histories, and not only the current global state of  the system.  Our focus is on extending some results concerning an  epistemic variant of CTL without common knowledge. In  [5] we proved that model-checking formulas in such a logic  is nonelementary, and requires a subset construction on the  model. The question one would ask is then whether that  construction can be adapted to continuous time, provided  that timed automata cannot be determinized [2].  We show that, indeed, model-checking for this timed  version of epistemic CTL with synchrony and perfect recall is undecidable. Our result is even stronger: modelchecking for CTL with “simple” knowledge operators with  a continuous-time semantics is undecidable too, even without the freeze quantifiers from TCTL, and the result shows  that only one unobservable clock suffices for undecidability. This also means that undecidability holds even if the  agents are only able to observe time passage. The source of  this strong result comes more from the expressive power of  the models than from the logic itself, and is strongly related  to the impossibility to generalize the subset construction to  timed automata.  On the other hand, we show that if agents are able to  fully observe clock values – and this includes the observability of the values for the freeze clocks of TCTL – then  model-checking becomes decidable. The proof goes by  a straightforward adaptation of the classical algorithm for  TCTL model-checking [1], and is based on the fact that,  with full clock observability, the subset construction only  concerns the “untimed” part of the model.  Previous work on combining epistemic and continuous  time expressivity includes [19]. There, a continuous time  variant of CTLK is also presented, with a state-based semantics that includes state and clock observability, but not  history or absolute time observability. Therefore, the logic  in [19] has a decidable model-checking problem. However  our logic is more expressive, due to its perfect recall semantics.  We present TCTLK, a continuous-time variant of the  Computational Tree Logic with knowledge operators, generalizing both TCTL, the continuous-time variant of CTL,  and CTLK, the epistemic generalization of CTL. Formulas  are interpreted over timed automata, with a synchronous  and perfect recall semantics, and the observability relation  requires one to specify what clocks are visible for an agent.  We show that, in general, the model-checking problem  for TCTLK is undecidable, even if formulas do not use  any clocks – and hence CTLK has an undecidable modelchecking problem when interpreted over timed automata.  On the other hand, we show that, when each agent can see  all clock values, model-checking becomes decidable.  1  Introduction  Combinations of temporal and epistemic logics offer a  useful setting for the analysis of multi-agent systems. They  have been successfully utilized for model-checking protocols like the Alternating Bit Protocol [16], and the Chaum’s  Dining Cryptographers Protocol [18, 11], whose functioning is related to the participants’ knowledge of the system  state. Algorithms exist for the model-checking problem  [17, 12, 5] (to cite only a few) and several tools have been  designed for model-checking [13, 7].  In this paper we investigate a possibility to extend these  results to the continuous case. We present a logic, called  here TCTLK, which is based on an epistemic extension of  the Computational Tree Logic, with the addition of freeze  clock variables for expressing time. Here we consider a synchronous and perfect recall semantics [8, 9], given in terms  of timed automata [2]. The observability relations used for  defining the epistemic operators include the ability of agents  to observe truth values of some atomic propositions (and the  inability to observe some others), as well as their ability to  observe clock values, as a generalization of the ability to observe only time passage. Recall that synchrony means that  ∗ Partially  supported by the French ANR project SPREADS  1  The semantics of a timed automata will be given here in  a weakly-monotonic setting which draws some similarities  with the work of [15]. This avoids problems related to the  density of real numbers, that lead sometimes authors to consider a “nonstrict” variant of the until operator, as in [3]. We  introduce a weakly-monotonic presentation for both trajectories and runs. Trajectories are, in some sense, annotations  of timed words [2] with clock information, and, as such, are  a generalization of the concept of word in finite automata.  Runs are continuous presentations of behaviors of timed automata, embodying the possibility to have, in a model, some  finite control (locations) which is not captured by formulas.  The observability relation is then introduced using projection and equivalence on trajectories. Equivalence is needed  as there may be several trajectories representing the same  behavior, due to the possibility to have silent transitions in  a timed automaton. Also projection cannot be defined directly on runs, as it models “forgetting” some part of the  observable state of a system.  We also note that the decidability result would still hold  if we use a bounded asynchronous semantics. The idea is  that agents would only have the possibility to observe the  integer parts of the clock values, and of the differences between clocks, but not the exact clock values. The final section contains a brief discussion on this topic.  The rest of the paper is divided as follows: in Section  2 we lay the basis for the semantics of timed multi-agent  systems. Section 3 gives the undecidability result, while  Section 4 gives the decidability in the case of full observability of the clock values. A section with final remarks  concludes the paper. Due to space limitations the proofs are  only sketched; a technical report [6] can be consulted for  more detailed proofs.  2  A weakly-monotonic semantics for TCTLK  In this section we will give a weakly-monotonic semantics of timed automata, in terms of (continuous) trajectories.  A continuous trajectory is a description of a particular behavior of the automaton, describing at each time point the  location in which the automaton is at that time point, and  the values of all clocks. It is, in some sense, similar with  words for finite automata. We will present the “time domain” of a trajectory in a weakly-monotonic fashion [15],  in order to accomodate the possibility of a timed automaton  to take more than one transition at a given instant.  We will utilize throughout this paper a set X of nonnegative real-valued variables called clocks. A clock valuation is  a mapping v : X → R≥0 . For any clock valuation v and set  of clocks X ⊆ X , v[X := 0] denotes the clock valuation defined by v[X := 0](x) = 0 for x ∈ X and v[X := 0](x) = v(x)  for x 6∈ X. As always, ∞−α = ∞ for any α ∈ R.  Definition 1 A trajectory over X and a set of state symbols  Π is a pair T = (I, θ), where I is a (finite or infinite)  sequence of pairs of sets of state symbols and intervals    • I = Si , [αi−1 , αi ] 1≤i<η with η ∈ N∪{∞}, Si ⊆ Π,  αi−1 , αi ∈ R≥0 , αi−1 ≤ αi and α0 = 0.  and θ is a continuous mapping of clock intervals:  • θ = (θi )1≤i<η with θi : [αi−1 , αi ] × X → R≥0  subject to the following properties.  1. For all i < η and all t, t′ ∈ [αi−1 , αi ], t < t′ , and for  all x ∈ X , θi (t′ , x) = θ(t, x) + t′ − t.  2. For all i < η −1 there exists a (possibly empty) set of  clocks X ⊆ X such that θi+1 (αi , ·) = θi (αi , ·)[X := 0].  Remark 1 Note that for two successive elements of I,  (Si , [αi−1 , αi ]), (Si+1 , [αi , αi+1 ]), intervals are adjacent.  The weakly-monotonic  S time domain of a trajectory T =  (I, θ) is the set Iintv = 1≤i<η {i} × [αi−1 , αi ]. Elements  of Iintv will be called weakly-monotonic time points (or  w-points for short). Iintv can be totally-ordered as usual:  given (n, t), (n′ , t′ ) ∈ Iintv , we say that (n, t) precedes  (n′ , t′ ) and denote (n, t) ≺ (n′ , t′ ) if either n < n′ or  n = n′ and t < t′ .  Remark 2 Note that, for some 1 ≤ i < η, Iintv might  contain only one element of the form (i, α). The intuition  behind this is that the i-th state in the trajectory is transient,  the system must pass through this state but it rests there for  zero amount of time.  Given a trajectory T = (I, θ) and some w-point (n, β) ∈  Iintv , we define the suffix of T starting with (n, β), denoted  by T [(n, β)..] = I[(n, β)..], θ[(n, β)..]), as follows:    ′  1. I[(n, β)..] = Si+n−1 , [αi−1  , αi′ ] 1≤i<η′ with η ′ =  η − n + 1 and αi′ = αi+n−1 for all i with 1 ≤ i < η ′  2. θ[(n, β)..] = (θi′ )1≤i<η′ with θi′ (t, x) = θi+n−1 (t, x)  for all i with 1 ≤ i < η ′ .  In the same settings, we may define the prefix of T upto (n, β), denoted by T [0..(n, β)] =  I[0..(n, β)], θ[0..(n, β)]), as follows:    ′  1. I[0..(n, β)] = Si , [αi−1  , αi′ ] 1≤i<n+1 with αi′ = αi  for i < n, and αn′ = β.  2. θ[0..(n, β)] = (θi′ )1≤i≤n is defined by θi′ (t, x) =  θi (t, x) for all 1 ≤ i ≤ n, t ∈ [0, αi′ ].  Another useful operation is resetting some clock z at  some w-point (k, β): given a trajectory T = (I, θ) and  some w-point (k, β) ∈ Iintv , the trajectory T [z :=  0 at (k, β)] = (I ′ , θ′ ) is defined as follows:  ′  • I ′ = (Si′ , [αi−1  , αi′ ])1≤i<η′ where η ′ = η +1 and Si′ =  ′  Si for i ≤ k, Si = Si−1 for k < i < η ′ and αi′ = αi for  i < k, αk′ = β and αi′ = αi−1 for k < i < η ′ .  • θ′ = (θi′ )1≤i<η′ is defined by      θi (t, z), for i ≤ k and (i, t) ≺ (k, β)  ′  θi (t, z) = θi−1 (t, z), if k < i < η ′ , ∃j ≤ i−1, θj (t, z) = 0      θi−1 (t, z) − θi−1 (β, z), otherwise  and, for x 6= z, θi′ (t, x) = θi′ (t, x) for i ≤ k and  ′  (i, t) ≺ (k, β), and θi′ (t, x) = θi−1  (t, x) otherwise.  θj = θij )1≤i<ηj . Assume that T2 is stuttering-free. We  say that T2 represents T1 if there exists some surjective  increasing function ϕ : [1..η1 −1] → [1..η2 −1] satisfying  the following requirements:  2  .  • For all i < j < η1 , if ϕ(i) = ϕ(j) then Si1 = Sj1 = Sϕ(i)    2  • αϕ(i)  = max αj1 | ϕ(j) = ϕ(i) .  2  • For all i < η1 and t ∈ [αi−1 , αi ], θϕ(i)  (t, x) = θi1 (t, x).  We also say that two (arbitrary) trajectories T1 , T2 are  identical, denoted T1 ≡ T2 , if there exists a third stutteringfree trajectory T3 which represents both T1 and T2 .  Figure 1 shows some trajectory T and T [x := 0 at (2, 2)]:  x  A weakly-monotonic semantics of timed automata. A  simple constraint over X is a constraint of the form x ∈ I,  where I is an interval with nonnegative integer bounds. For  a simple constraint C and a clock valuation v, we denote as  usual v |= C if v satisfies the constraint C.  4  T  3  T [x := 0 at (2, 2)  2  T [x := 0 at (2, 2)  1  1  2  3  4  Time  Figure 1. Resetting clock x in T at (2,2).  A trajectory is initialized if all the clocks are set to zero  at the initial w-point, i.e.for all x ∈ X, α1 (0, x) = 0.  Trajectories and observability. In this subsection we  give the observability relation on trajectories, which represents the essence of the epistemic part of the logic. This  requires the definition of a projection operator on trajectories, which tells what are the clock values and state symbols  that are observable by some agent along some trajectory.  ′  Given a set of clocks X ′ ⊆ X , a set of states Π   ⊆ Π and  a trajectory T = (I, θ) where I = Si , [αi−1 , αi ] 1≤i<η and  θ = θi )1≤i<η , the projection of T defined by (Π′ , X ′ )  is the trajectory T Π′ ,X ′ = (I Π′ , θ X ′ ) with I Π′ = Si ∩    Π′ , [αi−1 , αi ] 1≤i<η and θ X ′ = θi′ )1≤i<η where θi′ (t, x) =  θi (t, x) for all i < η, t ∈ [αi−1 , αi ], and x ∈ X ′ .  Our presentation of trajectories has the problem that  some behavior can be presented by distinct trajectories: it is  what we call the “stuttering” phenomenon. A trajectory is  stuttering-free if either two consecutive intervals in I are labeled with distinct state symbols or if some clock is reset in  between the two intervals. Formally, a trajectory T = (I, θ)  is stuttering-free if for all i < η−1, if Si 6= Si+1 then there  exists x ∈ X with θi+1 (αi , x) = 0 6= θi (αi , x).  Stuttering-free trajectories represent “normal forms” for  behaviors of timed automata: consider two trajectories Tj =    j  (I j , θj ) (j = 1, 2), where I j = Sij , [αi−1  , αij ] 1≤i<η and  j  Definition 2 A timed automaton [2] is a tuple A =  (Q, X , Π, δ, λ, Q0 ) where Q is a finite set of locations, X  is a finite set of clocks, Π is a finite set of state labels,  λ : Q → 2Π is the state-labeling function, Q0 ⊆ Q is the  set of initial locations, and δ is a finite set of tuples called  transitions of the form (q, C, X, q ′ ), where q, q ′ ∈ Q, X ⊆ X ,  and C is a conjunction of simple constraints over X .  Our semantics of timed automata will be given in terms  of runs, which are behaviors of timed automata along trajectories. This is just an extension of the classical notion of  a run in a timed automaton, enhanced with the possiblity to  have “transient” locations (in which control stays for a zero  amount of time) and adapted such that each time point be  associated with the current location.  A run in a timed automaton A = (Q, X , Σ, δ, λ, Q0 ) is  then a pair R = (I, ρ), where  • I is a sequence of pairs of locations and intervals, I =  qi , [αi−1 , αi ] 1≤i<η , where η ∈ N ∪ {∞}, qi ∈ Q  and αi−1 , αi ∈ R≥0 with αi−1 ≤ αi , and α0 = 0.  • ρ = (ρi )1≤i<η with ρi : [αi−1 , αi ] × X → R≥0 .  subject to the following constraints:  1. For all 1 ≤ i < η and all t, t′ ∈ [αi−1 , αi ], t < t′ , and  for all x ∈ X , θi (t′ , x) = θ(t, x) + t′ − t.  2. For all 1 ≤ i < η − 1 there exists some transition  (qi , Ci , Xi , qi+1 ) ∈ δ for which ρi (αi , ·) |= Ci and  ρi+1 (αi , ·) = ρi (αi , ·)[Xi := 0].  We say that the run R is unbounded if η = ∞ or αη−1 = ∞.  At second item of the enumeration above, we say that the  transition (qi , Ci , Xi , qi+1 ) is associated with the w-point  (i, αi ) – and also associated with (i + 1, αi ), both being  w-points in Iintv for the run R.  Similarly to trajectories, prefix and postfix operators can  be defined on runs. Hence, given a run R = (I, ρ) and  some w-point (n, β) ∈ Iintv , the prefix of R upto (n, t)  is denoted R[0..(n, β)] = I[0..(n, β)], ρ[0..(n, β)]) and  the suffix of R starting with (n, t) is denoted R[(n, β)..] =  I[(n, β)..], ρ[(n, β)..]).  Reseting some clock along a run, R[z := 0 at (k, β)],  can also be defined as for trajectories. However the result  need not always be a run: it is a run only when there exists  a loop (qk , C, X, qk ) which can be associated with the wpoint (k, β) in the result R[z := 0 at (k, β)].    Given a run R = (I, ρ) with I = qi , [αi−1 , αi ] 1≤i<η ,  the trajectory generated by R is the   trajectory traj(R) =  (I ′ , ρ) where I = λ(qi ), [αi−1 , αi ] 1≤i<η .    A run R = (I, ρ) with I = qi , [αi−1 , αi ] 1≤i<η and  ρ = (ρi )1≤i<η is accepting if the first location q0 is an  initial location and the initial clock valuation is α1 (0, x) =  0 for all x ∈ X . A trajectory T is accepted if it is generated  by an accepting run. (Note that in our timed automata, all  locations are “accepting”.)  3  TCTLK defined  The logic we investigate here, called the Timed Computational Tree Logic with knowledge operators and with  synchronous and perfect recall semantics, denoted in the  following as TCTLK, has the following syntax:  φ ::= p | C | φ ∧ φ | ¬φ | φ AU φ | φ E U φ | z in φ | KA φ  where p ∈ Π, the set of atomic propositions, C is a simple  constraint over the set of clocks X , y is some clock in X ,  and A ∈ Ag a finite set of agents. The operator z in φ is  called the freeze operator. CTLK is the logic defined by  formulas not containing the freeze operator.  The semantics of TCTLK is given in terms of runs in  a multi-agent timed system, which is a timed automaton  endowed with some partial observability relations, one for  each agent A in a finite set of agents Ag. Each partial  observability relation models what is observable by some  agent A and is induced by a subset of symbols ΠA ⊆ Π and  a subset of clocks XA ⊆ X .  Definition 3 A timed system with agents in Ag is a tuple  M = (A, Z, (ΠA )A∈Ag , (XA )A∈Ag ) where A is a timed  automaton A = (Q, X , Π, δ, λ, Q0 ), Z ⊆ X is a subset of  clocks (called freeze clocks) and for all A ∈ Ag, ΠA ⊆ Π,  XA ⊆ X . It is also assumed that A contains, for each location q ∈ Q and each clock z ∈ Z, a loop (q, true, {z}, q).  Remark 3 Note that the last assumption in Definition 3 implies that for any run R in A and any w-point (k, β) in the  run, R[z := 0 at (k, β)] is also a run in A.  This assumption is related with the interpretation of  z in φ, requiring the freezed clock to be reset. The assumption does not represent a strong restriction: we may consider  that we are given a timed system M without the clocks Z,  and then we enhance M by appending clocks from Z, such  that the freeze quantifiers be interpretable.  For each agent A ∈ Ag, the observability relation  for A is the following: given two runs R1 and R2 in A,  and some w-point (k, β) occuring in both, we say that  R1 and R2 cannot be distinguished by A upto (k, β) if  traj(R1 )[0..(k, β)] Π ,X ≡ traj(R2 )[0..(k, β)] Π ,X .  A  A  A  A  The semantics of TCTLK formulas is given in terms of  tuples (M, R, k, β) consisting of an n-agent system M, an  unbounded run R = (I, ρ) in the underlying timed automaton of M and some w-point (k, β) ∈ Iintv . The rules defining the semantics of TCTLK formulas are the following:  • (M, R, k, β) |= p if p ∈ λ(q0 ), q0 being the first location in R.  • (M, R, k, β) |= C if v |= C where v is the clock valuation at (k, β) in R, v = ρk (β, ·) for R = (I, ρ).  • (M, R, k, β) |= φ1 ∧ φ2 if (M, R, k, β) |= φ1 and  (M, R, k, β) |= φ2 .  • (M, R, k, β) |= ¬φ if (M, R, k, β) 6|= φ.  • (M, R, k, β)  |=  0 at (k, β)], k, β) |= φ.  z in φ  if  (M, R[z  :=  • (M, R, k, β)  |=  KA φ if for any run  R′ and any w-point (k ′ , β) in R′ with  traj(R′ )[0..(k ′ , β)] Π ,X ≡ traj(R)[0..(k, β)] Π ,X  A  A  A  A  we have that (M, R′ , k ′ , β) |= φ.  • (M, R, k, β) |= φ1 E U φ2 if there exists some run  R′ = (I ′, ρ′ ) for which R[0..(k, β)] = R′ [0..(k, β)]  ′  and there exists a w-point (k ′,β ′ ) ∈ Iintv  with (k ′,β ′ )   ′ ′ ′  ′  (k, β), (M, R , k , β ) |= φ2 and for all (k ′′ , β ′′ ) ∈ Iintv  ′′  ′′  ′  ′  ′′  ′′  for which (k , β ) ≺ (k , β ), (k , β )  (k, β), we  have that (M, R′ , k ′′ , β ′′ ) |= φ1 .  • (M, R, k, β) |= φ1 AU φ2 if for any run R′ = (I ′, ρ′ )  for which R[0..(k, β)] = R′ [0..(k, β)], there exists  ′  a w-point (k ′ , β ′ ) ∈ Iintv  with (k ′, β ′ )  (k, β),  ′ ′ ′  ′  (M, R , k , β ) |= φ2 and for all (k ′′ , β ′′ ) ∈ Iintv  for  ′′  ′′  ′  ′  ′′  ′′  which (k , β ) ≺ (k , β ), (k , β )  (k, β) we have  that (M, R′ , k ′′ , β ′′ ) |= φ1 .  The usual abbreviations apply here too, in particular  E 3 φ = true E U φ  A3 φ = true AU φ  PA φ = ¬KA ¬φ  A2 φ = ¬ E 3 ¬φ  E 2 φ = ¬ A3 ¬φ  An example of a TCTLK formula is PA ϕ∧¬ϕ, with ϕ =  z in E 3(z ≤ 3 ∧ danger). This might model a situation  in which some sensor A might provoke a false alarm, as its  observable state would indicate that it’s possible that in less  than 3 time units the system goes into a dangerous state,  whereas this situation cannot occur in the current state.  4  Undecidability of model-checking  In this section we show that the model-checking problem  is undecidable for CTLK with the continuous-time semantics. For a given timed n-agent system M and a formula  φ, we denote M |= φ if for any accepting run R in the  underlying automaton, we have that (M, R, 0, 0) |= φ.  Definition 4 The model-checking problem for TCTLK  (CTLK) over continuous time domains is the following:  given a timed n-agent system M and a TCTLK (CTLK)  formula φ, does the property M |= φ hold?  Theorem 1 The model-checking problem for CTLK over  continuous time domains is undecidable.  Proof: We show that if some 2-counter machine has an  infinite computation, then that computation can be simulated with an instance of the model-checking problem. (We  utilize here 2-counter machines as programs utilizing only  incrementing, and decrementing instructions for one of the  two counters, or tests for zero.) Each configuration of the  2-counter program will be encoded into a unit-time interval of an accepted trajectory, with the value of each counter  being encoded as the number of positions within the interval where some specific atomic proposition holds. It is assumed that the respective atomic propositions holds only at  “sparse” points within any interval.  More specifically, each configuration (ℓ, ct1 , ct2 ) of the  2-counter program, where ℓ is the label of the current instruction, is coded as a unit-length part of a trajectory in  which ℓ holds as an atomic proposition. Also, during this  part of the trajectory, there are exactly ct1 point intervals  where a new atomic proposition pct1 holds, and exactly ct2  point intervals where pct2 holds.  We need to keep track, within each such unit interval,  of the last instruction executed before reaching program label ℓ. This is the role of a set of new propositional symbols pinstr for all the eight type of instructions that may  occur: p{ct1 ++} , p{ct2 ++} , p{ct1 −−} , p{ct2 −−} , p{if ct1 =0} ,  p{if ct1 6=0} , p{if ct2 =0} , and p{if ct2 6=0} . Note that we also  need to recall that the last step in the program was the negative branch of a test instruction – this is the rôle of the label  p{if ct1 6=0} .  Then each transition from a configuration (ℓ, ct1 , ct2 ) to  another configuration (ℓ′ , ct′1 , ct′2 ) is encoded as the concatenation of the trajectory which encodes the first config-  uration with the trajectory which encodes the second configuration. Moreover, the i-th position where pct1 holds in  the part of the trajectory corresponding to ℓ is separated by  exactly 1 time unit from the i-th position where pct1 holds  in the part of the trajectory corresponding to ℓ′ .  This unit separation property applies to instructions  which do not modify counter ct1 . It does not apply to  the last position when the transition from (ℓ, ct1 , ct2 ) to  (ℓ′ , ct′1 , ct′2 ) is the effect of the instruction ℓ : ct1++. In  this case, exactly one time unit before the last position of  pct1 in the trajectory corresponding to ℓ′ we must have a  position where pct1 is false. A similar property holds when  the instruction is ℓ : ct1 − −. In that case, exactly one time  unit after the last position of pct1 in the interval corresponding to ℓ we must have a position where pct1 is false.  The above coding is done partly in the timed automaton model, partly in the formula that is checked against the  model. The timed automaton simulates, along some trajectories, the control flow in the 2-counter program, and along  some other trajectories, the positions where pct1 and pct2  occur are copied from each unit interval to another. The use  of the temporal and epistemic operators allows us to iteratively construct an accepting trajectory which simulates, in  the sense described in the previous paragraphs, the halting  computation of the 2-counter program, if it exists.  The first task of the timed automaton is to simulate the  control flow, that is, the possible successions of states that  may occur if one ignores counter values. Namely, the timed  automaton stays for one time unit in states labeled with  some ℓ, then shifts to some other states labeled ℓ′ if and  only if, in the 2-counter program the control may flow from  instruction ℓ to instruction ℓ′ . In the case of test instructions  like ℓ : if ct1 = 0 then goto ℓ′ , the timed automaton simulates both the positive and the negative branch as follows:  • If, during the unit interval along which ℓ holds there is  no occurrence of pct1 , then the control goes (after one  time unit) to a state labeled ℓ′ .  • Otherwise, the control goes to a state labeled ℓ′′ , which  is the label of the instruction following ℓ in the 2counter program.  It should be noted that there may be several states labeled  ℓ: some might be labeled with pct1 , and some not, and similarly with all the other propositional symbols that are used  throughout the proof.  The simulation of control flow does not care about  counter values: the mechanism used for “copying” the  counter value from some unit interval to the next is different. It involves some branches in the timed automaton  which copy just a single occurrence of pct1 within some interval to the next interval, at exactly one time unit distance.  A similar trick needs to be used to specify that some position where pct2 is false occurs exactly one time unit after  a position where pct2 was false. This requires the use of  −−−, which, whenever  another new propositional symbol ←  p¬ct  2  occurring, signals that exactly one time unit before we had  pct2 false.  The previous tricks can be used for copying only one occurrence of a pct2 , resp only one point where pct2 is absent  from the location label. How to copy all the occurrences of  pct2 within an interval? It is here that the TCTLK formula  comes into play, and especially the epistemic operators. We  will consider an agent A that is able to observe the truth  value for pct2 and for all propositional symbols of the form  ℓ or pinstr , with ℓ being a label of some instruction in the  2-counter program, and instr being such an instruction. On  −− or  the other hand, A cannot observe the truth value for ←  pct  2  ←  −  −  −  p¬ct2 . We also assume that A cannot observe the value of  the clock z.  Suppose we have a trajectory T and a w-point (i, β)  in T such that T [0..(i, β)] simulates the behavior of the  2-counter program upto the moment when it just finished  instruction ℓ1 . We would like to say that, starting from  (i + 1, β) and during the next unit interval, the positions  where pct2 holds are the translations by one time unit of the  positions where pct2 held in the previous unit interval. The  following formula does this:    −−)∧  E 2 ℓ2 ∧ p{ct1 ++} ∧ pct2 → PA (←  pct  2    ℓ ∧p  ∧ ¬p → P (←  (1)  p−−−)  2  {ct1 ++}  ct2  A  ¬ct2  This formula says that there exists a trajectory (in the  timed automaton) that prolonges T starting with (i, β) and  such that at each position (j, γ) where pct2 holds and we are  at label ℓ2 and the last instruction did not modify ct2 , then  there must exist a trajectory T ′ which A cannot distinguish  −− occurs at (j, γ).  from T , and in which ←  pct  2  −−  Recall then that, by construction, the occurrence of ←  pct  2  at (j, γ) requires that, exactly one time unit before, pct2  must have been true in T ′ . And, on the other hand, T ′ and  T must be indistinguishable by A, hence all positions before (i, β) where pct2 holds in T ′ must also be positions  in T where pct2 holds. This is exactly what is needed to  conclude that for each point (j, γ) where pct2 holds in T ,  during unit interval starting at (i, β), then (j, γ) preceded,  at one time unit, by a position where pct2 holds.  The second part of the formula 1 specifies that all positions where pct2 is false are translations of positions where  pct2 are false in the unit interval right before (i, β). First,  consider the instruction {ct1 + +}, with the last position  where pct1 holds in the unit interval labeled ℓ2 not being  a one time unit translation of the last position where pct1  held in the previous unit interval. The idea is to have a  new propositional symbol plast  ct1 , visible for A, which signals that we have reached the last pct1 within the interval  −−− would be true,  where ℓ2 holds. Also, at the same time ←  p¬ct  1  signalling that exactly one time unit before pct1 was false.  The formula which ensures that the last occurrence of pct1  is “new” and all the other occurrences are copied is then    ←−−   E 2 ℓ2 ∧ p{ct1 ++} ∧ pct1 ∧ ¬plast  ct1 → PA (pct1 ) ∧    (2)  p−−−)  ℓ ∧p  ∧ (plast ∨ ¬p ) → P (←  2  {ct1 ++}  ct1  ct1  A  ¬ct1  Then, for the instruction {ct1 −−}, with the last position  where pct1 held in the previous unit interval being no longer  copied in the interval where ℓ2 holds, we utilize here symbol plast  ct1 that we have seen before and another new propo←−−  sitional symbol, plast  ct1 , not visible to A. The significance of  ←−−  last  pct1 is the same as above, while plast  ct1 signals that exactly  one time unit before we had a position where pct1 held. The  formula which ensures that the last occurrence of pct1 in the  previous unit interval is “lost” and all the other occurrences  are copied is then the following    ←last  −−   E 2 ℓ2 ∧ p{ct1 −−} ∧ (plast  ct1 ∨ pct1 ) → PA (pct1 ) ∧    → P (←  p−−−)  ℓ ∧p  ∧p  (3)  2  {ct1 −−}  ¬ct1  A  ¬ct1  cti  the subformula inside E 2  Then, if we denote φℓ,keep  1  in Formula 1, corresponding to instructions that keep uncti  the subforchanged the value of counter cti , and φℓ,inc  2  mula inside E 2 in Formula 2 corresponding to instructions  cti  for Formula  that increment cti , and similarly for φℓ,dec  3  3, the actual formula that we will check against the timed  automaton A is then  ^  ^  ^  cti   cti  cti  ∧ φℓ,dec  ∧ φℓ,incr  Φ = E 2 ¬end∧ φℓ,keep  3  2  1  cti  is taken for all instrucwhere the conjunction for φℓ,keep  1  tions labeled ℓ which are preceded by an instruction not  modifying counter cti , and similarly for all the other conjunctions, and also “end” is the “fictitious” label at the end  of the 2-counter program.  Then Φ is satisfied in the timed automaton constructed as  above if and only if the given 2-counter machine does not  have a halting computation.  Note that our formula utilizes a single agent. Moreover,  the essential ingredient for undecidability is that agent A  cannot observe the value for the clock z – observing or not  the other two clocks does not change the proof.  5  Model-checking with full observability of  clock values  In this section we show how the classical modelchecking algorithm for TCTL can be adapted to TCTLK  when all the agents can observe all clock values. By full  observability of clock values we mean that formulas of  TCTLK are interpreted over multi-agent systems M =  (A, Z, (ΠA )A∈Ag , (XA )A∈Ag ) in which XA = X for all  A ∈ Ag. In the sequel M is the largest constraint occurring  in the given timed automaton.  Given a timed automaton A = (Q, X , Π, δ, λ, Q0 ), an  X -region in A is a convex set of points r ⊆ Rn≥0 (n =  card (X )) characterized by a clock constraint of the form  ^  ^  ^      x ∈ ]M, ∞[  x−y ∈ Ixy ∧  (x ∈ Ix ) ∧  x∈Y  x,y∈Y  x∈X \Y  where Ix are non-negative integer-bound intervals whose  upper bound are at most M , and Ixy are integer-bound intervals whose both upper and lower bounds are in between  −M and M . Also Y ⊆ X is some set of clocks. The set of  regions in A is denoted RegA .  The region automaton forA is the tuple RA = Q ×  RegA , δR , S0 where S0 = (q0 , 0X ) | q0 ∈ Q0 with 0  being the region where all clocks are zero, and    δR = (q, r) → (q, r′ ) | r 6= r′ and ∃v ∈ r, v ′ ∈ r′  for which ∃t ∈ R≥0 with v ′ = v + t and  ∀t′ < t, v + t′ ∈ r ∪ r′ (time passage)  ∪ (q, r) → (q ′ , r′ ) | ∃v ∈ r, v ′ ∈ r′ , (q, C, X, q ′ ) ∈ δ    for which v |= C and v ′ = v[X := 0]  Here δR defines immediate transitions between states in the  region automaton. A run in RA is then simply a sequence  of transitions in δR agreeing on intermediary states.  A run R = (I, ρ) in A is simulated by a run σ =  (qi−1 , ri−1 ) → (qi , ri ) 1≤i≤n in RA if the following  properties hold:  • All the w-points in Iintv fall into some state of σ, i.e.  for any (k, β) ∈ Iintv there exists some i ≤ n such  that ρk (β, ·) ∈ ri and the k-th state in I is qi .  • If the w-point (k, β) falls into state (qi−1 , ri−1 ) and  the i-transition in σ is a time-passage transition, then  there exists some t ∈ R≥0 with (k, β + t) ∈ Iintv  which falls into state (qi−1 , ri ) (note that in this case  qi−1 = qi ).  • All discrete transitions in σ correspond to discrete transitions in R: for any interval [αi−1 , αi ] from I, if  (i − 1, αi ) falls into state (qj , rj ) then (i, αi ) falls into  state (qj+1 , rj+1 ) and the transition associated with  (i, αi ) is the same as the transition associated with the  (qj , rj ) → (qj+1 , rj+1 ).  Though the region automaton does not represent exactly  all runs in A, it has the following important property:  Proposition 1 Any run in A is associated with a run in RA ,  and the reverse holds too.  Theorem 2 The model-checking problem for TCTLK with  full observability of clock values is decidable.  Proof: The proof is a modification of the usual proof for  TCTL model-checking by inserting a procedure for treating  the case of subformulas of the type KA ψ. Recall that TCTL  model-checking works by iteratively labeling states in the  region automaton with subformulas of the given formula  φ. Here, for treating knowledge subformulas we need also  to split some states according to the classes of trajectories  along which the respective states can be reached, similar to  the discrete-time case [5].  So assume we are given a timed system M =  (A, Z, (ΠA )A∈Ag , (XA )A∈Ag ) and a formula φ that we  want to model-check on M. The technique is to transform the region automaton RA into another region automaton R′ which embodies the trajectories of A and in which  states may carry, besides region labels, additionnal labels  like new propositional symbols representing subformulas of  φ or pointers to states in RA which are “identically observable” as the current state.  Labeling some state (q, r) with a new propositional symbol pψ signals the fact that on any run R which “passes  through” (q, r), at each moment of this pass the subformula  ψ holds. That is,  (∗) For R = (I, ρ) and (i, t) ∈ Iintv with  ρi (t, ·) ∈ r and with the i-th state in I being q,  we have that (M, R, i, t) |= ψ.  Due to space limitations, we only recall the construction  for z in ψ: we label a state (q, r) with pz in ψ if and only if  the state (q, r[z := 0]) is labeled with pψ .  The last construction, for φ = KA ψ, no longer labels existing states, but needs to split the states of the given model  in order to be able to identify states that have indistinguishable history, as seen by agent A.  So, assume we start with a region automaton R = Q ×    RegA , δR , S0 where Q = Q×S, S being the extra labeling  information appended to each state. We also consider that  the labeling function λ in A is extended to the states of the  region automaton, so λ(q, s, r) = λ(q) ⊆ Π.  ′  We then construct   the following region automaton R =  ′  Q̃ × RegA , δR , S̃0 as follows:    Q̃ = (q, Q′ ) ⊆ Q×2Q | λ(q)∩ΠA = λ(q ′ )∩ΠA ∀q ′ ∈ Q′    S̃0 = (q0 , Q′0 , 0) | (q0 , 0) ∈ S0    ′  δR  = (q1 , Q′1 , r1 ) → (q2 , Q′2 , r2 ) | (q1 , r1 ) → (q2 , r2 ) ∈ δR    where Q′2 = q2′ ∈ Q | λ(q2′ ) ∩ ΠA = λ(q2 ) ∩ ΠA and  (q1′ , r1 ) → (q2′ , r2 ) ∈ δR .  Remark 4 Note that the projection of each state in R′ on  its first and third component gives a bijection between runs  in R and runs in R′ . Hence, any run in the initial timed  automaton is simulated by some run in R′ and vice-versa.  This property of projection also ensures the fact that the  state labeling with the new propositional variables pχ remains correct: for all runs in the given timed automaton  and all w-points (k, β) that fall in the state (q, Q′ , r), if  (q, Q′ , r) is labeled with pχ then (M, R, k, β) |= χ.  Then we label each state (q, Q′ , r) ∈ Q̃×RegA with KA pψ  if and only if all the states in Q′ are labeled with pψ . (Note  that q ∈ Q′ by construction.) The above remark ensures that  for any run R in A and any w-point (k, β) within R that fall  in the state (q, Q′ , r) we must have (M, R, k, β) |= KA ψ.  The final observation is that, though the construction  of R′ modifies the region automaton by modifying the locations component in each state, it can still be combined  with the previous procedures for treating temporal operators. These procedures can be applied to R′ since it is associated with the same trajectories as R. This is again a  consequence of the Remark 3. In fact, one may even think  of the procedure for obtaining R′ as a location-splitting procedure in the given timed automaton.  To end the proof, we only need to check, at the end of  the procedure, whether all the initial states in the resulting  region automaton are labeled with pφ .  The complexity of the above construction is nonelementary in the size of the given model. This complexity comes  from the fact that each epistemic operator induces an exponential blowup in the size of the model.  Note also that the main aspect allowing the modelchecking of TCTLK with full clock observability to be decidable is that we do not need to do subset construction on  clock regions.  6  Final remarks and conclusions  We have given an epistemic extension of TCTL, with a  synchronous and perfect recall semantics in which agents  may observe clock values. The model-checking problem is  undecidable for the new logic, but becomes decidable if any  agent may observe all clocks.  The decidability result still holds if we modify the semantics to a more realistic situation with “bounded asynchronous” observability. This would build on the idea that  agents are not able to observe the exact values of clocks,  but only whether these values fall in the same region, i.e.  satisfy the same clock constraints. If one properly defines  the observability relation in this case (which would imply  taking into account observability of intermediary clock values), then Theorem 2 would have the same proof.  Acknowledgments The author is indebted to Dimitar  Guelev for his suggestions for improving the presentation  and for his careful reading of the manuscript.  References  [1] R. Alur, C. Courcoubetis, and D. L. Dill. Model-checking in dense  real-time. Inf. Comput., 104(1):2–34, 1993.  [2] R. Alur and D. Dill. A theory of timed automata. Theoretical Computer Science, 126:183–235, 1994.  [3] C. Baier and J. P. Katoen. Principles of Model Checking. The MIT  Press, 2008.  [4] J. M. Davoren, V. Coulthard, N. Markey, and Th. Moor. Nondeterministic temporal logics for general flow systems. In Proceedings of HSCC 2004, volume 2993 of Lecture Notes in Computer Science, pages 280–295. Springer, 2004.  [5] C. Dima. Revisiting satisfiability and model-checking for CTLK  with synchrony and perfect recall. In Proceedings of CLIMA IX,  Lecture Notes in Artificial Intelligence, 2008. to appear.  [6] C. Dima. Positive and negative results on the decidability of the  model-checking problem for an epistemic extension of Timed CTL.  Technical report, LACL, Université Paris 12, 2009.  [7] P. Gammie and R. van der Meyden. MCK: Model checking the logic  of knowledge. In Proceedings of CAV’04, volume 3114 of Lecture  Notes in Computer Science, pages 479–483. Springer, 2004.  [8] J.Y. Halpern and M.Y. Vardi. The complexity of reasoning about  knowledge and time: Extended abstract. In Proceedings of STOC’86,  pages 304–315, 1986.  [9] J.Y. Halpern and M.Y. Vardi. The complexity of reasoning about  knowledge and time. I. Lower bounds. Journal of Computer System  Sciences, 38(1):195–237, 1989.  [10] T. A. Henzinger and V. S. Prabhu. Timed alternating-time temporal logic. In Proceedings of FORMATS’06, volume 4202 of Lecture  Notes in Computer Science, pages 1–17. Springer, 2006.  [11] M. Kacprzak, A. Lomuscio, A. Niewiadomski, W. Penczek, F. Raimondi, and M. Szreter. Comparing BDD and SAT based techniques  for model checking Chaum’s Dining Cryptographers Protocol. Fundamenta Informaticae, 72(1-3):215–234, 2006.  [12] A. Lomuscio and F. Raimondi. The complexity of model checking  concurrent programs against CTLK specifications. In Proceedings of  DALT’06, volume 4327 of Lecture Notes in Computer Science, pages  29–42. Springer, 2006.  [13] A. Lomuscio and F. Raimondi. MCMAS: A model checker for multiagent systems. In Proceedings of TACAS’06, volume 3920 of Lecture  Notes in Computer Science, pages 450–454. Springer, 2006.  [14] J. Ouaknine and J. Worrell. On metric temporal logic and faulty  turing machines. In Proceedings of FoSSaCS’06, volume 3921 of  Lecture Notes in Computer Science, pages 217–230. Springer, 2006.  [15] P. K. Pandya and Dang Van Hung. Duration calculus of weakly  monotonic time. In Proceedings of FTRTFT’98, volume 1486 of  Lecture Notes in Computer Science, pages 55–64. Springer, 1998.  [16] F. Raimondi and A. Lomuscio. Automatic verification of multi-agent  systems by model checking via ordered binary decision diagrams.  Journal of Applied Logic, 5(2):235–251, 2005.  [17] R. van der Meyden and N.V. Shilov. Model checking knowledge  and time in systems with perfect recall (extended abstract). In Proceedings of FSTTCS’99, volume 1738 of Lecture Notes in Computer  Science, pages 432–445, 1999.  [18] R. van der Meyden and K. Su. Symbolic model checking the knowledge of the dining cryptographers. In Proceedings of CSFW-17,  pages 280–. IEEE Computer Society, 2004.  [19] B. Wozna and A. Lomuscio. A logic for knowledge, correctness, and  real time. In Proceedings of CLIMA V, volume 3487 of Lecture Notes  in Computer Science, pages 1–15. Springer, 2005. 