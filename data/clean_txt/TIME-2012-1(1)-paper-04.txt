Efficient Regular Linear Temporal Logic using Dualization and Stratification  CeĚsar SaĚnchez  IMDEA Software Institute, Madrid, Spain  Institute for Applied Physics, CSIC, Spain  Email: Cesar.Sanchez@imdea.org  AbstractâWe study efficient translations of Regular Linear  Temporal Logic (RLTL) into automata on infinite words. RLTL  is a temporal logic that fuses Linear Temporal Logic (LTL)  with regular expressions, extending its expressive power to all  Ď-regular languages.  The first contribution of this paper is a novel bottom up  translation from RLTL into alternating parity automata of  linear size that requires only colors 0, 1 and 2. Moreover, the  resulting automata enjoy the stratified internal structure of  hesitant automata. Our translation is defined inductively for  every operator, and does not require an upfront transformation  of the expression into a normal form. Our construction builds  at every step two automata: one equivalent to the formula  and another to its complement. Inspired by this construction,  our second contribution is to extend RLTL with new operators,  including universal sequential composition, that enrich the logic  with duality laws and negation normal forms.  The third contribution is a ranking translation of the  resulting alternating automata into non-deterministic BuĚchi  automata. To provide this efficient translation we introduce  the notion of stratified rankings, and show how the translation  is optimal for the LTL fragment of the logic.  Keywords-temporal logic; formal verification; formal methods;  I. I NTRODUCTION  We study the problem of formal temporal verification of  reactive systems, which starts from a specification of the  intended behavior in some temporal logic. In this paper we  study the logic RLTL [1], [2] that extends LTL [3], [4] with  regular expressions.  The automata-theoretic approach to model checking reduces this verification problem to automata constructions  and automata decision problems. The verification process  begins by translating the negation of the formula into an  equivalent automaton on infinite words. This automaton  accepts all the traces that violate the specification. Then,  the automaton is composed synchronously with the system  description. Finally, a non-emptiness check reveals whether  the system admits some counterexample trace.  Modernly, specifications are translated into alternating  automata because their richer structure enables a direct  This work was funded in part by the EU project FET IST-231620 HATS,  MICINN project TIN-2008-05624 DOVES, CAM project S2009TIC-1465  PROMETIDOS, and by the COST Action IC0901 Rich ModelToolkit-An  Infrastructure for Reliable Computer Systems.  JuliaĚn Samborski-Forlese  IMDEA Software Institute, Madrid, Spain  Email: Julian.SF@imdea.org  translation from temporal logics, postponing a potentially  exponential blow-up. Another advantage of alternation is the  easy dualization (see Muller and Schupp [5]) provided by  the availability of both conjunctive and disjunctive transition  relations. However, to obtain an automaton accepting the  complement language of a given automaton, one also needs  to complement the acceptance condition (see for example  [6]). For LTL one can first translate a formula (e.g., the  negation of the specification) into negation normal form  (NNF) by pushing negation to the propositional level, and  then use automata with weak acceptance conditions [7],  [8], in which the structured of the automaton consists of  strongly connected components (SCC) all of which are  either accepting or rejecting. Extensions of LTL with regular  expression, like RLTL, do not have negation normal forms.  Hence, a translation of the logical negation operator must  be given, precluding the use of weak acceptance conditions.  In this paper we show how to translate RLTL into strong  parity automata on words (APW) with a particular internal  structure, and study the complementation construction for  the resulting APW. The classical complementation for the  parity condition increments in one unit the color assigned  to every state, turning an arbitrary sequence of states from  accepting into rejecting (and viceversa). However, if this  construction is used to translate the logical negation operator,  the total number of colors in the resulting automaton can  grow linearly in the size of the formula. The best known  algorithm [9] for translating an APW with n states and k  colors into a non-deterministic BuĚchi automaton requires  2O(nk log nk) . In this work, we use a faster complementation  construction based on the following intuition. Traces of runs  of the automaton get trapped in an SCC, meaning that all  states in a suffix of a given trace belong to some SCC  of the automaton. Hence, it is sufficient for a complementation construction to consider SCCs independently. This  idea enables a translation of RLTL (including the negation  operator) into APW using only colors 0, 1 and 2. These  automata are equivalent to alternating Streett automata on  words (ASW) with one accepting pair (denoted ASW{1}).  The translation proceeds inductively, building at each step  a pair of complement automata. Then, inspired by this  translation we enrich RLTL with new constructs, including  universal sequential composition. The enriched logic admits  a negation normal form.  Finally, we study the translation into non-deterministic  BuĚchi automata (NBW). Streett{1} rankings (see [10])  directly allow to translate an ASW{1} into an NBW of  size 2O(n log n) . Here, we use again the particular stratified  structure of the ASW{1} automata obtained from RLTL  expressions. Each stratum in the generated ASW{1} is either  BuĚchi (only colors 1 and 2) or coBuĚchi (colors 0 and  1), making these automata equivalent to hesitant automata  AHW (see [11]). We introduce a notion of stratified ranking  and show that for all RLTL operators (except one), the  ranking of each state can be statically predetermined. This  result produces NBW with size 2O(n log m) where m is the  size of the largest stratum that cannot be predetermined. In  particular, all LTL operators generate strata of size 1, which  result into NBW of size 2O(n) when using our method to  translate LTL into NBW.  The rest of the of paper is structured as follows. Section II  presents the preliminaries, and Section III introduces RLTL.  Section IV shows the translation from RLTL into stratified  ASW{1}, and Section V the translation into NBW, including  stratified rankings. Section VI shows our empirical study.  Finally, Section VII concludes.  II. P RELIMINARIES  +  We use B (X ) for the positive Boolean formulas over a  set of propositions X . These formulas are built from true,  false and elements of X , using â§ and â¨. A minimal model  M of a positive Boolean formula Î¸ is a subset of X such  that M satisfies Î¸ but no strict subset of M satisfies Î¸. For  example, given the set Q = {q0 , q1 , q2 , q3 }, the formula  Î¸1 = (q1 â§ q2 ) â¨ q3 is a B + (Q) formula. The minimal  models of Î¸1 are {q1 , q2 } and {q3 }. Given a positive Boolean  formula Î¸ there is a dual formula Î¸e obtained by switching  â§ and â¨, and switching true and false. For example, the  dual of Î¸1 above is Î¸e1 = (q1 â¨ q2 ) â§ q3 , or equivalently in  disjunctive normal form Î¸e1 = (q1 â§ q3 ) â¨ (q2 â§ q3 ). The  minimal models of Î¸e1 are {q1 , q3 } and {q2 , q3 }.  An alternating automaton is a tuple A : hÎŁ, Q, Î´, I, F i  where ÎŁ is a propositional alphabet, Q is a finite set of states,  Î´ : Q Ă ÎŁ â B + (Q) is the transition function, I â B + (Q)  is the initial condition, and F is the acceptance condition.  A frame of an automaton A is the tuple hÎŁ, Q, Î´, Ii. A  frame is called non-deterministic whenever I, and Î´(q, a)  for all states q and symbols a, have singleton sets as  minimal models. In other words, I and Î´(q, a) are equivalent  to disjunctive formulas. A frame is called universal if I,  and Î´(q, a) for all states q and symbols a, have a unique  minimal model. In other words, I and Î´(q, a) are equivalent  to conjunctive formulas. A frame is deterministic if it is  both non-deterministic and universal, that is if both the  initial condition and transition functions correspond to true,  false or a single successor state. In general a frame is  neither universal nor non-deterministic, but fully alternating.  A transition function Î´ can be extended to positive Boolean  formulas Î´ : B + (Q)ĂÎŁ â B + (Q) in the standard way, taking Î´(q, a) as the base case and letting Î´(true, a) = true,  Î´(false, a) = false, Î´(A â¨ B, a) = Î´(A, a) â¨ Î´(B, a) and  Î´(A â§ B, a) = Î´(A, a) â§ Î´(B, a).  Given a word w â ÎŁĎ , a run of w on a frame F :  hÎŁ, Q, Î´, Ii is a DAG (V, E) with nodes V â Q Ă N, s.t. :  1) The set {m | (m, 0) â V } is a minimal model for I.  2) â(q, k) â V , {q 0 | (q 0 , k + 1) â V â§ ((q, k), (q 0 , k +  1)) â E} is a minimal model for Î´(q, w[k]).  A trace of a run is an infinite path in the run, or a finite  path finishing in an state with no successor in the run. A  non-deterministic frame may admit multiple different runs  for a given word, but each run contains a unique trace. A  universal frame admits just one run for each word, but this  run may contain multiple traces. In general a frame admits  multiple runs each with multiple traces.  Given a frame F : hÎŁ, Q, Î´, Ii, the specular frame is  e Ii,  e where Ie is the dual of I and Î´e is the dual  Fe : hÎŁ, Q, Î´,  e a) is the dual formula of Î´(q, a) for  transition function: Î´(q,  all states q and symbols a. The graph of a frame has Q  as a set of nodes and contains an edge p â q whenever q  is in some minimal model of Î´(p, a) for some symbol a.  The graphs of a frame and its specular frame are identical,  because if q is in some minimal model of Î´(p, a) then q is  e a). Therefore, a frame  also in some minimal model of Î´(p,  admits a trace iff its specular frame also admits the trace.  An automaton equips a frame with an acceptance condition, which determines whether an infinite sequence of states  is accepting. A finite trace finishing in a state (q, i) with no  successor is accepting. Given an infinite sequence of states  Ď : q0 , q1 , q2 . . . we let inf(Ď) be those states from Q that  occur infinitely many times in Ď. In this paper we consider  the following acceptance conditions:  â˘ BuĚchi: F â Q. Ď is accepting when inf(Ď) âŠ F 6= â.  â˘ coBuĚchi: F â Q. Ď is accepting when inf(Ď) âŠ F = â.  â˘ parity: F : Q â {0 . . . d}. Ď is accepting when  max{F (q) | q â inf(Ď)} is even. The elements of  {0 . . . d} are called colors.  â˘ Streett: F = {hB1 , G1 i, hB2 , G2 i, . . . , hBk , Gk i}. Ď is  accepting when for all 1 â¤ i â¤ k, if inf(Ď) âŠ Bi 6= â  then inf(Ď) âŠ Gi 6= â.  â˘ Streett{1}: F = (B, G). Ď is accepting when if inf(Ď)âŠ  B 6= â then inf(Ď) âŠ G 6= â.  â˘ hesitant: F â Q, and H = h(S0 . . . , Sk ), <, Îąi is a  partition of Q induced by the SCCs, ordered by <  according to reachability in the automaton graph, and  Îą marks each partition as either BuĚchi or coBuĚchi. A  trace Ď is accepting when  â inf(Ď) â Si , Si is BuĚchi and inf(Ď) âŠ F 6= â, or  â inf(Ď) â Sj , Sj is coBuĚchi and inf(Ď) âŠ F = â.  Observation: A parity acceptance condition with colors  {0, 1, 2} corresponds to the Streett condition (B, G) with  B = {q | F (q) = 1} and G = {q | F (q) = 2}. The Streett  pair (B, G) forces (for a trace to be accepting) that if some  state marked 1 is visited infinitely often, then some state  marked 2 is also visited infinitely often. The other possible  case is that only states that are not marked either B or G  states are visited infinitely often. In this case, the trace is  also good for the parity automaton.  We use stratum to refer to an SCC of an automaton  graph. The stratification of hesitant automata given by the  partition implies that every infinite trace gets trapped in a  stratum Si . Then, the BuĚchi or coBuĚchi condition on the  stratum determines whether the trace is accepting. We use  ABW (resp. AcBW, APW, ASW and AHW) to represent  BuĚchi (resp. coBuĚchi, parity, Streett and hesitant) alternating  automata on words. We use APW{0, 1, 2} for APW that only  use colors 0, 1 and 2 and ASW{1} for ASW with only one  pair.  When a trace Ď is accepted according to an acceptance  condition F , we write Ď â acc(F ). A run of an alternating  automaton is called accepting whenever all its traces are  accepting. We say that a word w is in the language of  automaton A, and we write w â L(A), whenever there is  an accepting run for w on A.  The following definition and theorem relate the notions  of specular pairs and complement languages.  Definition 1 Two automata A and B over the same alphabet are a specular pair whenever their frames are specular  and for all paths Ď in the frame graph Ď â acc(FA ) if and  only if Ď â  / acc(FB ).  Theorem 2 (Specular Automata and Complement)  Let A and B be a specular pair of automata. Then  L(A) = ÎŁĎ \ L(B).  Theorem 2 reduces the proof that two automata with dual  frames are complements to checking that the traces that can  happen have opposite acceptance. In the next section, we  use this result to build an incremental translation, in which  we only need to check the new traces added at each step.  III. T HE L OGIC RLTL  Regular Linear Temporal Logic [1], [2] is a formalism  for specifying w-regular languages. The logic is defined in  two stages, similarly to PSL [12] or ForSpec [13]. In the  first stage we build regular expressions that define finite  non-empty segments of infinite words. In the second stage,  we build RLTL expressions to define sets of infinite words.  The syntax of each of these two formalisms contain only  a finite collection of constructor symbols. In particular, the  language of RLTL contains no fix-point binders or automata  constructors.  Regular Expressions: The basic elements of regular  expressions are basic expressions, which are Boolean combinations of a finite set of atomic propositions, whose truth  value is interpreted in a single state. The syntax of regular  expressions is given by the following grammar:  Îą ::= Îą + Îą  Îą;Îą  ÎąâÎą  p  where p ranges over basic expressions. The intended interpretation of the operators +, ; and â are the standard union,  concatenation and binary Kleene-star.  Our version of regular expressions describe segments of  infinite words. Given an infinite word w â ÎŁĎ , a position  is a natural number. We use w[i] for the symbol at position  i in word w. Given an infinite word w and two positions i  and j, the tuple (w, i, j) is called the segment of the word  w between positions i and j. Note that a segment consists  of the whole word w with two tags, not just the sequence of  symbols that occur between two positions. This allows the  extension of regular expressions to past expressions [2], but  in this paper we only study future expressions. A pointed  word is a pair (w, i) formed by a word w and a position  i. The formal semantics of regular expressions is defined  as a binary relation RE between segments and regular  expressions, as follows. Given a basic expression p, regular  expressions r and s, and a word w:  â˘ (w, i, j) RE p, whenever w[i] satisfies p and j = i + 1.  â˘ (w, i, j) RE r + s whenever either (w, i, j) RE r or  (w, i, j) RE s, or both.  â˘ (w, i, j) RE r ; s whenever for some k, (w, i, k) RE r  and (w, k, j) RE s.  â˘ (w, i, j) RE r â s whenever either (w, i, j) RE s, or  for some sequence (i0 = i, i1 , . . . im ) and all k â  {0, .., m â 1}, (w, ik , ik+1 ) RE r and (w, im , j) RE s.  RLTL: Expressions in Regular Linear Temporal Logic  define languages over infinite words. The key elements  of RLTL are the power operators that generalize many  constructs from different linear-time logics and calculi. The  syntax of RLTL expressions is defined by the grammar:  Ď ::= â  Ďâ¨Ď  ÂŹĎ  Îą;Ď  Ď|ÎąiiĎ  Ď|ÎąiĎ  where Îą ranges over regular expressions. The symbol â¨  stands for union of languages (logical disjunction), and  ÂŹ represents language complement (logical negation). The  symbol ; stands for the concatenation of an expression over  finite words followed by an expression over infinite words.  The operator â defines the empty language (logical false).  The operators Ď|ÎąiiĎ and its weak version Ď|ÎąiĎ are  called the power operators. The expressions x|riiy and x|riy  (read x at r until y, and, respectively, x at r weak-until y) are  built from three elements: y (the attempt), x (the obligation)  and r (the delay). For x|riiy to hold, either the attempt holds,  or the obligation is met and the whole expression evaluates  successfully after the delay. For x|riiy to hold, the obligation  must be met after a finite number of delays. On the contrary,  x|ziy does not require the attempt to be met after a finite  number of delays, allowing the obligation and delay to be  repeated ad infinitum.  These two simple operators allow the definition of many  other temporal operators. For example, the strong until  operator x U y of LTL can be seen as an attempt for y  to hold, or otherwise an obligation for x to be met and a  delay of a single step. Similarly, the Ď-regular expression  xĎ can be interpreted as a weak power operator having no  possible escape and a trivially fulfilled obligation, with a  delay indicated by x. Then, conventional Ď-regular expressions can describe sophisticated delays with trivial attempts  and obligations, while conventional LTL constructs allow  complex attempts and obligations but trivial one-step delays.  Power operators generalize both types of constructs. The  completeness of RLTL with respect to Ď-regular languages  follows immediately from the expressibility of Ď-regular  expressions. In particular, Wolperâs example [14] of an Ďregular language not definable in LTL (p happening at every  even state) can be defined as p|true ; trueiâ. The size  of an RLTL formula is defined as the total number of its  symbols.  The semantics of RLTL relates expressions and pointed  words. Given two RLTL expressions x and y, a regular  expression r, and a word w:  â˘ (w, i)  â never holds.  â˘ (w, i)  x â¨ y iff either (w, i)  x or (w, i)  y.  â˘ (w, i)  ÂŹx iff (w, i) 6 x.  â˘ (w, i)  r ;y iff for some k, (w, i, k) REr and (w,k)  y.  â˘ (w, i)  x|riiy iff (w, i)  y or for some sequence  (i0 = i, i1 , . . . im ), for all k < m: (w, ik , ik+1 ) RE r  and (w, ik )  x, and (w, im )  y.  â˘ (w, i)  x|riy whenever either x|riiy or for some infinite seq (i0 = i, i1 , . . . ), for all k > 0, (w, ik , ik+1 ) REr  and (w, ik )  x.  The semantics of x|riiy establishes that either the obligation y is satisfied at the point i of the evaluation, or  there is a sequence of delaysâeach determined by râafter  which y holds, and x holds before each individual delay.  The semantics of x|riy also allow the case where y never  holds, but x always holds before any number of evaluations  of r. Languages are associated with RLTL expressions as  usual: a word w â ÎŁĎ is in the language of an expression  x, denoted by w â L(x), whenever (w, 0)  x.  Using [10], [9] to translate APW into NBW would produce  2  NBW with 2O(n log n) states for the old translation and  2O(n log n) states for the one presented here. In Section V  below we show how to reduce it further to 2O(n log m)  (where m is the size of the largest stratum), and 2O(n) for  the LTL fragment of RLTL.  The translation is described inductively. For every operator, we show how to compute the specular automata pair,  starting from the automata pairs for the sub-expressions. In  particular, assume that (Ax , Ax ) and (Ay , Ay ) are specular  pairs for RLTL expressions x and y and that Nr is an NFA  for regular expression r. We use q âa Fr for âq â Qr and  Î´(q, a) âŠ Fr 6= â,â and we use q 6âa Fr for âq â Qr and  Î´(q, a) âŠ Fr = â.â  Empty: The pair (Aâ , Aâ ) has state set Q = {q0 },  and initial conditions I = q0 and I = q0 . The acceptance  conditions are F (q0 ) = 0 and F (q0 ) = 0. The transition  relations are Î´(q0 , ) = false and Î´(q0 , ) = true. This  choice of Î´ and Î´ allow all traces to be accepting for Aâ and  no trace to be accepting for Aâ , so Aâ accepts all words  and Aâ accepts no word, as desired.  Disjunction: The state space of Axâ¨y : hÎŁ, Q, Î´, I, F i  and Axâ¨y : hÎŁ, Q, Î´, I, F i are Q = Qx âŞ Qy . The initial  conditions are I = Ix â¨ Iy and I = Ix â§ Iy . The transition  functions and acceptance condition are:  if  Î´(q, a)  Î´(q, a)  F (q)  F (q)  q â Qx  Î´x (q, a)  Î´x (q, a)  Fx (q)  Fx (q)  q â Qy  Î´y (q, a)  Î´y (q, a)  Fy (q)  Fy (q)  Sequential:  The  state  space  of  both  Ar;x : hÎŁ, Q, Î´, I, F i and Ar;x : hÎŁ, Q, Î´, I, F i are Qr âŞQx .  The initial conditions are I = Ir and I = Ier . The transition  function is:  if  Î´(q, a)  Î´(q, a)  Î´er (q, a)  q 6âa Fr  Î´r (q, a)  q âa Fr  Î´r (q, a) â¨ Ix Î´er (q, a) â§ Ix  q â Qx  Î´x (q, a)  Î´x (q, a)  The acceptance condition is: for q â Qx then F (q) = Fx (q)  and F (q) = Fx (q). For q â Qr then F (q) = 1 and F (q) =  0.  Complementation: Consider now an RLTL subexpression x, with specular pair (Ax , Ax ). Since (w, i)   Ax if and only if (w, i) 6 Ax , it follows that (Ax , Ax ) is a  specular pair for ÂŹx.  IV. RLTL INTO APW USING S PECULAR PAIRS  Power: Let q0 be a fresh state, not present in Qx  or Qy . The state spaces of Ax|riiy : hÎŁ, Q, Î´, I, F i and  Ax|riiy : hÎŁ, Q, Î´, I, F i are Qr âŞQx âŞQy âŞ{q0 }. The initial  conds. are I = q0 and I = q0 . For the transition relation:  if  Î´(q, a)  Î´(q, a)  q = q0  Î´(Iy â¨ (Ix â§ Ir ), a) Î´(Iy â§ (Ix â¨ Ir ), a)  q 6âa Fr  Î´r (q, a)  Î´er (q, a)  q âa Fr  Î´r (q, a) â¨ q0  Î´er (q, a) â§ q0  q â Qx  Î´x (q, a)  Î´x (q, a)  q â Qy  Î´y (q, a)  Î´y (q, a)  We present here a translation of RLTL expressions into  APW{0, 1, 2} based on Theorem 2. The main idea is to  generate, at each step, a specular automata pair with the first  automaton accepting the same language as the expression.  By duality, the specular automaton accepts the complement  language. Handling logical negation becomes trivial: one  simply needs to switch the elements of the pair.  A previous translation of RLTL presented in [2] needed  n colors (n being the size of the formula) instead of 3.  For the acceptance condition:  if  F (q)  F (q)  q â Qx  Fx (q) Fx (q)  Fy (q) Fy (q)  q â Qy  0  q â Qr or q = q0 1  Even though the frame of these automata could have been  defined without introducing q0 (by cleverly choosing I and  Î´), the introduction of q0 is justified by the necessity to  distinguish in the acceptance condition traces that visit q0  infinitely often versus traces that get trapped in Qr .  Weak Power: Again, the state spaces of both Ax|riy :  hÎŁ, Q, Î´, I, F i and Ax|riy : hÎŁ, Q, Î´, I, F i is Qr âŞQx âŞQy âŞ  {q0 } for a fresh state q0 . For the initial condition I = q0  and I = q0 . The transition relation and acceptance condition  are exactly the same as for the Power operator except for  the following cases:  (  (  1 if q = q0  2 if q = q0  F (q) =  F (q) =  0 if q â Qr  1 if q â Qr  Theorem 3 Let Ď be an RLTL expression and AĎ be the  automaton obtained using the construction described in this  section. Then, L(Ď) = L(AĎ ).  The proof of Theorem 3 is greatly simplified by Theorem 2 because at every stage the construction builds  automata with specular frame, so one only needs to reason  about the acceptance of traces that get trapped in SCCs  formed by the freshly added states. The construction also  satisfies two important properties:  1) each stage introduces a new stratum (SCC) that cannot  be reached from strata added in previous stages. That is,  traces that move to the automaton of a sub-expression  do not visit the stratum added for the containing expression.  2) The stratum at each stage is decorated only with color  0 (an accepting stratum), only with color 1 (a rejecting  stratum), only with colors 0 and 1 (a coBuĚchi stratum)  or only with colors 1 and 2 (a BuĚchi stratum).  These two observations imply that the automaton has the  particular structure of a stratified ASW{1} or equivalently  of hesitant automaton AHW. We show in Section V how to  efficiently translate these automata into NBW using a refined  version of Streett rankings.  A Universal Sequential Operator: In the previous  construction, we observe that the specular automaton for  the sequential operator r ; x describes the set of traces in  which âall occurrences of r (if any) are followed by failing  occurrences of xâ. This observation inspires the introduction  of the universal sequential operator r Âˇ x, whose semantics  is:  â˘ (w, i)  r Âˇ x iff forall k s.t. (w, i, k) RE r, (w, k)  x.  The translation of r Âˇ x is precisely Ar;ÂŹx above, and the  specular automaton is exactly Ar;ÂŹx . Note that the stratum  corresponding to r in ArÂˇx has a universal frame, obtained  by dualizing the non-deterministic transition relation of Nr .  The duality laws ÂŹ(r ; x) âĄ r Âˇ ÂŹx and ÂŹ(r Âˇ x) âĄ r ; ÂŹx  hold immediately.  Universal Power Operators: Similarly, we define new  operators xkriiy and xkriy, duals of x|riy and x|riiy,  respectively. These new operators force repetitions to hold  at all possible delays, instead of at some possible delay. The  semantics are:  â˘ (w, i)  xkriiy iff (w, i)  y and for all seq (i =  i0 , . . . , im ) with (w, ik , ik+1 ) RE r, either (w, ij )  x  for some j â¤ k or (w, ik+1 )  y, and for all infinite seq  (i = i0 , i1 . . .) with (w, ik , ik+1 ) RE r and (w, ik )  y,  there is an m with (w, im )  x.  â˘ (w, i)  xkriy iff (w, i)  xkriiy, or (w, i)  y and  for all k and j with (w, i, j) RE rk then (w, j)  y.  The translation of xkriiy is Ax|riy (the dual being  Axkriiy = Ax|riy ), and the translation of xkriy is the pair  (Ax|riiy , Ax|riiy ). The following duality laws hold:  ÂŹ(x|riiy) âĄ ÂŹxkriÂŹy  ÂŹ(x|riy) âĄ ÂŹxkriiÂŹy  ÂŹ(xkriy) âĄ ÂŹx|riiÂŹy  ÂŹ(xkriiy) âĄ ÂŹx|riÂŹy  (1)  (2)  Finally, x â§ y is defined with translation (Axâ¨y , Axâ¨y ). The  deMorgan laws hold: (ÂŹÂŹx âĄ x), (ÂŹ(x â¨ y) âĄÂŹx â§ÂŹy) and  (ÂŹ(x â§ y) âĄÂŹx â¨ÂŹy).  Orienting these duality laws from left to right allows  to push logical negation ÂŹ to the propositional level, so  RLTL extended with these operators admits a negation  normal form. Note that this negation normal form is obtained  after the translation by specular pairs. It does not follow  immediately that the existence of such a normal form enables  a translation into automata with weak acceptance condition,  because one has to show translations for the new operators,  including essentially all elements of pairs in the translation  of RLTL presented above.  V. F ROM S TRATIFIED ASW{1} INTO NBW  This section shows how to translate the alternating automata obtained in Section IV into NBW. We first revisit  the notion of Streett ranking from [10], which in turn is  based on the notion of coBuĚchi ranking [15]. Then, we refine  rankings to exploit the stratification of the automata obtained  as a result of the translation from RLTL. We first show a  general translation of ASW{1} into NBW.  Rankings for ASW{1}: We use [k] an abbreviation for  the set {0 . . . k}. The following definitions assume a given  ASW{1} automaton A with n states, acceptance condition  (B, G), a word w â ÎŁĎ and a run G : (V, E) of A on w.  Definition 4 An S{1}-ranking is a function f : V Ă N â  [2n] that satisfies: (i) if q â B then f (hq, li) is even, (ii) for  all hq, li â hq 0 , l0 i in E, either q â G or f (hq, li) âĽ  f (hq 0 , l0 i).  It follows that for every path Ď on a run DAG G, either Ď  visits infinitely often G states or, after some prefix, condition  (ii) applies continuously. Hence, since the image of f is  bounded, the value of f converges to a value: there is a  number l, such that, for every l0 > l, f (Ď(l0 )) = f (Ď(l)).  The following definition of odd S{1}-ranking relates the  convergence to an odd value with the fact that B states  are visited only finitely often. Then, the construction of the  NBW below is justified by Lemma 6.  Definition 5 (odd S{1}-ranking) An S{1}-ranking is odd  whenever, for every path Ď of G, either (i) Ď visits infinitely  often G states, or (ii) f converges to an odd value on Ď.  Lemma 6 G is an accepting run iff there is an odd  S{1}-ranking for G.  An equivalent NBW: We describe here the translation  from ASW{1} into NBW. The main idea is to encode in  the states of the NBW cuts of a run DAG of the ASW{1},  decorated with enough information to check whether an oddranking exists. In particular, each state of the alternating  automaton present in a given state of the NBW is labeled  with a ranking value. This annotation must respect the  definition of ranking (Def. 4). Additionally, the set of states  of the ASW{1} that form a state of the NBW are partitioned  into those that owe an improvement in the ranking (either  a visit to a G state or a decrease in the ranking), and those  that already showed improvement. Membership to the owe  set is propagated, so an accepting state is one in which all  constituent states have seen some progress since the last  accepting state. After an accepting state, the owe set is reset.  Formally, we start from an ASW{1} automaton A :  hÎŁ, QA , IA , Î´A , {(B, G)}i and we build an NBW N :  hÎŁ, QN , IN , Î´N , FN i as follows:  â˘ QN contains elements of the form (S, O, f ) where S â  QA is a subset of states of A, O â S, and f : S â [2n]  is a function that satisfies:  Q1. if q â B then f (q) is even.  â˘ IN contains all those (M, O, f ) â QN where  I1. M is a minimal model of IA and O = {q â  M |qâ  / G and f (q) is even}.  â˘ FN = {(S, O, f ) â QN | O = â}.  Q  0  0  0  â˘ Î´N : QN Ă ÎŁ â 2 N , such that (S , O , f ) â  Î´N ((S, O, f ), a) whenever there is one minimal model  Mq of Î´A (q, a) for each q â S satisfying:  D1. S 0 = âŞqâS Mq ,  D2. For all p â S 0 , the rank annotation f 0 (p) â¤  min{f (q) | q â pred(p) \ G} where pred(p) = {q â  S | p â Mq } denotes the set of predecessors of p.  D3. O0 is given as follows. Let p â S 0 \ G, we have  â˘ If O = â then p â O0 iff f 0 (p) is even.  â˘ If O 6= â then p â O0 iff f 0 (p) = f (q)  for some q â (pred(p) âŠ O).  The states of N consist of a set S representing elements  of a cut of a run DAG of A. The function f represents  an S{1}-ranking, where Q1 guarantees that no B node  receives an odd value, and D2 guarantees the non-increasing  condition of rankings. Condition D1 ensures that successor  states of N correspond to legal successor cuts of a run of A.  Finally, condition D3 ensures that O contains those vertices  of the run DAG that have not seen progress for some path  leading to them, where progress is defined as visiting a G  state, or experiencing a decrease in f . A reset of this check is  represented by a final state, which can happen only when all  paths to all states contain some progress, as captured by FN .  Finally, I1 captures that the initial states of N correspond  to initial cuts of runs of A. All these facts imply that a  successful run DAG of A is matched by a successful run of  N.  Theorem 7 Let A be an ASW{1} and N the corresponding  NBW. Then w â L(A) if and only if w â L(N ).  The automaton obtained can be easily pruned with one  simple observation: if there is an odd S{1}-ranking, then  there is an odd S{1}-ranking where all decreases (according  to D2) only drop to the highest legal value. That is:  (  M or M â 1 if p â  /B  0  f (p) =  M or M â 2 if p â B  where M = min{f (q) | q â pred(p) \ G}.  This observation reduces the guessing in f to only two  possibilities, providing a more efficient translation. The  next paragraphs exploit the internal structure of stratified  ASW{1} automata to introduce a faster solution, specific  for the particular case of AHW.  Rankings for Stratified ASW{1}: Consider a stratified  ASW{1}. This is an automaton for which Q is divided into  strata (S1 , . . . , Sk ) ordered according to <, and each stratum  is labeled by a function Îą as either BuĚchi (all states are  either B or G) or coBuĚchi (no state is G). The stratification  structure implies that for every q â Si and successor p with  p â Sj , either Sj = Si or Sj < Si .  Remark: This automaton is equivalent to an AHW with  H = h(S1 , . . . , Sk ), <, Îąi and  F =  [  i  {Si âŠ G | if Si is BuĚchi} âŞ  [  {Si âŠ B | if Si is coBuĚchi}  i  We use mj = |Sj | to refer to the number of states in stratum Sj . We first define the notion of stratified S{1}-ranking:  Definition 8 A stratified S{1}-ranking is a family of functions fj : Sj Ă N â [2mj ] that satisfies: (i) if q â Sj âŠ B  then fj (hq, li) is even, (ii) for every hq, li â hq 0 , l0 i in E  with q, q 0 â Sj , then fj (hq, li) âĽ fj (hq 0 , l0 i), unless q â G.  Intuitively, a stratified ASW{1} ranking is like an  ASW{1} ranking except values need not decrease when  moving across strata. Due to the stratification, every trace of  a run gets trapped in a stratum of the automaton. Once the  trace converges to a stratum, either the trace visits infinitely  many good nodes, or the ranking converges to a single value.  Again, the notion of odd ranking captures whether the suffix  traces are accepting.  Definition 9 A stratified S{1}-ranking is odd whenever, for  every infinite path Ď of G, either (i) Ď visits infinitely often G  states, or (ii) Ď gets trapped in stratum Sj and fj converges  to an odd value on Ď.  The following lemma justifies the construction of NBW  using stratified rankings.  Lemma 10 G is an accepting run iff there is a stratified  odd S{1}-ranking for G.  Stratified rankings drastically limit the guessing that is  necessary in the construction of the states of the NBW,  because each ranking is local to the stratum under consideration. The following choices produce a good ranking for  stratum Sj , if there is one such a good ranking  G1. If Sj is an accepting stratum and qj â Sj , fj (qj ) = 1.  G2. If Sj is a rejecting stratum and qj â Sj , fj (qj ) = 2.  G3. If Sj is BuĚchi, then assign fj (qj ) = 2 to qj â B, and  fj (qj ) = 1 to qj â G.  G4. If Sj is coBuĚchi then fj (qj ) â [2mj ].  Note that this restriction eliminates the guessing except  for coBuĚchi strata, and consequently ranking guessing only  happens to the states of Nr in expressions xkriiy. In terms  of the LTL fragment, all delays are one step so the size of  |Nr | = 1 and hence the maximum size of the coBuĚchi strata  is 1. In fact, for LTL sub-expressions of the form xkriiy,  Nr consists of a single B state, which can be assigned  value 2. Consequently, following the steps in this paper LTL  expressions get translated into NBW of size 2O(n) .  An equivalent NBW using Stratified Rankings:  We refine the construction for general ASW{1} rankings,  limiting the guesses using G1-G4. Also, only predecessors  within the same stratum are considered when computing f :  Q1s. if q â Sj âŠ B then fj (q) is even.  D2s. fj0 (p) â¤ min{fj (q) | q â pred(p) \ G} where  pred(p) = {q â Sj | p â Mq } now only considers  predecessors from the same stratum.  D3s. O0 is given as follows. Let p â Sj0 \ G, we have  â˘ If O = â then p â O0 iff fj0 (p) is even.  â˘ If O 6= â then p â O0 iff fj0 (p) = fj (q)  for some q â (pred(p) âŠ O âŠ Sj ).  Theorem 11 Let A be a stratified ASW{1} and N the corresponding NBW using stratified rankings. Then w â L(A)  if and only if w â L(N ).  VI. E MPIRICAL E VALUATION  This section reports the result of an empirical evaluation  of the translation algorithms presented above. The evaluation  was performed using a sequential implementation written in  OCaml, available online at [16]. The running times reported  in Fig. 1 were obtained using an Intel Core2 @ 2.83GHz  with 8GB of RAM running a 64 bit Linux kernel. Fig. 1  compares the number of states and the running time used  to compute explicit NBW representations of two families of  formulas (and their negation), for i = 8, 11, 17, 20. These  choices are inspired by [8]:    â˘ Ai  =  p1 U (p2 U (. . . U pi ) . . . . The expression Ai is equivalent  to the RLTL expression    p1 |trueii p2 |trueii. . . .    5  5  5  â˘ Bi = p1 |true ii p2 |true ii. . . , where true stands  for a five instant delay true ; true ; true ; true ; true.  These are not expressible in LTL.  The table illustrates that the general ASW{1} ranking is  only practical for the smallest cases. Limiting the guessing  to the highest ranks allows to handle slightly larger formulas. The stratified ranking translation results in a dramatic  improvement, comparable to state of the art LTL translators,  particularly considering that our prototype does not use  simulations or handle propositional alphabets (only discrete  alphabets). Simulation reductions have been reported [8] to  be a very effective method to reduce the size of the NBW  generated, but this optimization is currently ongoing work.  VII. C ONCLUSIONS AND F UTURE W ORK  This paper has presented a novel translation from the  logic RLTL into alternating parity automata using only  colors 0, 1 and 2, based on a bottom-up construction of  specular pairs accepting complement languages. Inspired by  the duality in the translation we introduce universal sequential operators that enrich the logic with negation normal  forms. We also show that the resulting automata enjoy some  stratified structure in their transition relation that makes all  their strata purely BuĚchi or coBuĚchi. These automata are  equivalent to hesitant automata. Then, we study translations  of the resulting automata into NBW. The main result is the  specialization of Street rankings to stratified automata to  obtain a more efficient ranking translation. Unlike [11] our  construction preserves the alphabet between the alternating  automaton an the NBW. We are currently investigating alternative algorithms for model-checking RLTL specifications  based on bounded model checking [17], antichains [18] and  IC3 [19].  R EFERENCES  [1] M. Leucker and C. SaĚnchez, âRegular linear temporal logic,â  in Proc. of ICTACâ07, ser. LNCS, vol. 4711. Springer, 2007,  pp. 291â305.  [2] C. SaĚnchez and M. Leucker, âRegular linear temporal logic  with past,â in Proc. of VMCAIâ10, ser. LNCS, vol. 5944.  Springer, 2010, pp. 295â311.  size  A8  A11  A17  A20  ÂŹA8  ÂŹA11  ÂŹA17  ÂŹA20  B8  B11  B17  B20  ÂŹB8  ÂŹB11  ÂŹB17  ÂŹB20  APW  time(s)  7  0.048  10  0.172  16  0.936  19  1.796  7  0.048  10  0.172  16  0.940  19  1.792  35  0.268  50  1.084  80  5.064  95  10.041  35  0.268  50  0.908  80  5.072  95  9.753  Figure 1.  NBW (direct)  size  time(s)  93  0.128  192  0.504  498  3.680  705  8.149  142  0.252  292  1.140  754  10.545  1066  25.718  2417  50.103  4952  360.571  12722  1h56m  17957  8h32m  3642  209.157  7452  26m56s  19122  18h15m  26982  58h8m  NBW (max2)  size  time(s)  93  0.100  192  0.336  498  1.700  705  3.184  100  0.100  202  0.336  514  1.688  724  3.160  2417  5.936  4952  26.846  12722  217.698  17957  598.129  2452  5.704  5002  25.106  12802  220.762  18052  674.070  NBW (strat)  size  time(s)  9  0.052  12  0.176  18  0.952  21  1.816  9  0.052  12  0.172  18  0.948  21  1.884  37  0.296  52  0.952  82  5.200  97  9.897  37  0.300  52  0.956  82  5.192  97  9.905  Number of states and running time to compute an APW{0, 1, 2} and an NBW.  [3] A. Pnueli, âThe temporal logic of programs,â in Proc. of  FOCSâ77. IEEE CS Press, 1977, pp. 46â67.  [4] Z. Manna and A. Pnueli, Temporal Verification of Reactive  Systems. Springer-Verlag, 1995.  [5] D. E. Muller and P. E. Schupp, âAltenating automata on  infinite trees,â Theoretical Computer Science, vol. 54, pp.  267â276, 1987.  [6] W. Thomas, âComplementation of BuĚchi automata revisited,â  in Jewels are Forever, Contributions on TCS in Honor of Arto  Salomaa. Springer, 1999, pp. 109â120.  [7] O. Kupferman and M. Y. Vardi, âWeak alternating automata  are not that weak,â ACM Transactions on Computational  Logic, vol. 2, no. 3, pp. 408â429, 2001.  [8] P. Gastin and D. Oddoux, âFast LTL to BuĚchi automata  translation,â in Proc. of CAVâ01, ser. LNCS, vol. 2102.  Springer, 2001, pp. 53â65.  [9] C. Dax and F. Klaedtke, âAlternation elimination by complementation,â in Proc. of LPARâ08, ser. LNCS, vol. 5530.  Springer, 2008, pp. 214â229.  [10] O. Kupferman and M. Y. Vardi, âComplementation constructions for nondeterministic automata on infinite words,â in  Proc. of TACASâ05, ser. LNCS, vol. 3440. Springer, 2005,  pp. 206â221.  [11] O. Kupferman, N. Piterman, and M. Y. Vardi, âExtended temporal logic revisited,â in Proc. of CONCURâ01, ser. LNCS,  vol. 2154. Springer, 2001, pp. 519â535.  [12] D. Fisman, C. Eisner, and J. Havlicek, Formal syntax and  Semantics of PSL: App. B of Accellera Property Language  Ref. Manual, Ver. 1.1, March 2004.  [13] A. Armando, S. Ranise, and M. Rusinowitch, âA rewriting  approach to satisfiability procedures,â Information and Computation, vol. 183, no. 2, pp. 140â164, 2003.  [14] P. Wolper, âTemporal logic can be more expressive,â Information and Control, vol. 56, pp. 72â99, 1983.  [15] O. Kupferman and M. Y. Vardi, âFrom complementation to  certification,â in Proc. of TACASâ04, ser. LNCS, vol. 2988.  Springer, 2004, pp. 591â606.  [16] http://software.imdea.org/rounded/.  [17] A. Biere, A. Cimatti, E. M. Clarke, and Y. Zhu, âSymbolic  model checking without BDDs,â in Proc. of TACASâ99, ser.  LNCS. Springer, 1999, pp. 193â207.  [18] M. D. Wulf, L. Doyen, N. Maquet, and J.-F. Raskin, âAntichains: Alternative algorithms for LTL satisfiability and  model-checking,â in Proc. of TACASâ08, ser. LNCS, vol.  4693. Springer, 2008, pp. 63â77.  [19] A. R. Bradley, âSAT-based model checking without unrolling,â in Proc. of VMCAIâ11, ser. LNCS, vol. 6538.  Springer, 2011, pp. 70â87.  A PPENDIX  This section shows a self-contained proof of Theorem 2.  Positive Boolean Formulas:: Every positive boolean  formula can be expressed in disjunctive normal form, as  disjunction of conjunctions of propositions. Given a positive  boolean formula Î¸ there is a dual formula Î¸e obtained by  switching â§ and â¨, and switching true and false. Some  easy properties of dual formulas are:  e and for every  Proposition 12 (Duals) For every Î¸ and Î¸,  M â Mod (Î¸):  e M âŠ M 0 6= â.  1) For every M 0 â Mod (Î¸),  e with q â M 0 .  2) Let q â M . There is an M 0 in Mod (Î¸)  For example, the dual of Î¸1 above is Î¸e1 = (q1 â¨ q2 ) â§  q3 , or equivalently in disjunctive normal form Î¸e1 = (q1 â§  q3 ) â¨ (q2 â§ q3 ). The minimal models of Î¸e1 are {q1 , q3 } and  {q2 , q3 }.  A choice function is a map f that chooses, for a model  M of Î¸ an element of M , i.e., f : Mod (Î¸) â X such  f (M ) â M . Some interesting properties of choice functions  follow:  Proposition 13 (Choice Functions) Let Î¸ be a formula  and Î¸e its dual. Then  e  1) If f is a choice function for Î¸, then Img f â Mod (Î¸).  2) If M â mod (Î¸) then there is a choice function f of Î¸e  such that Img f = M .  Proof: We prove 13.1 first. Consider Î¸ in disjunctive  normal form. Each child subexpression of the root expression corresponds to a conjunction of states that form a  model. The choice function f chooses one state from each  model of Î¸. Expressing Î¸e dualy, each child subexpression of  Î¸ is a disjunction of the corresponding set of states. Hence,  the element that f chooses in each child    S satisfies the corresponding disjunction, and Img f = M âMod(Î¸) f (M ) is  e  a model of Î¸.  We now show 13.2. Let M be a minimal model of Î¸.  Consider an arbitrary choice function f for Î¸e with:  f (M 0 ) = q for some q â M âŠ M 0 .  By Prop. 12.1 for any M 0 there is one such q, so f is well  defined, and by construction Img f â M . By Prop. 13.1  Img f is a model of Î¸, and since M is a minimal model it  has no proper sub-model, so Img f = M .    Automata and Games: We show now that specular  automata accept complement languages, using game theory.  From a given automaton A and a word w, we create a  parity game called a word game as a tuple G(A, w) :  hVA , VP , EA , EP , f i where:  VA = Q Ă Ď  VP = {(M, q, i) | M â Mod (Î´(q, w[i]))}  âŞ {(M, Âˇ, 0) | M â Mod (I)}  EA = (q, i) â (M, q, i) for each M â Mod (Î´(q, w[i]))  EP = (M, q, i) â (q 0 , i + 1) for q 0 â M  The game is played by two players: Automaton (A) and  Pathfinder (P ). The set of positions V = VA âŞ VP is  partitioned into positions in which A plays and those in  which P plays. The game begins by A choosing a model  of I, which determines the initial position (M, Âˇ, 0) (here Âˇ  represent an irrelevant state). The legal moves of the game  are captured by the relation E = EA âŞEP which correspond  to A choosing a model from a VA position, and P choosing  the next successor from a given model from a VP position.  A play is an infinite sequence of positions Ď : V0 v0 V1 v1 . . .  with V0 being an initial position, vi obtained from Vi by a P  move, and Vi+1 obtained from vi by an A move. The map  f : V â {0 . . . d} determines the outcome of a play. We  define the trace of a play Ď : V0 v0 V1 v1 . . . as the sequence  of states trace(Ď) : p0 p1 . . . obtained by projecting the first  component of the VP positions of the play (i.e., vi = (pi , i)).  The following follows directly from the definition:  Proposition 14 Every trace of a play of G(A, w) is also a  trace of some run of A on w.  As for parity automata the outcome of a play is determined by the highest color that is seen infinitely often in  the play. Player A wins play Ď whenever:  max{f (q) | q â inf(trace(Ď))} is even  Otherwise, P wins play Ď. A strategy for player A is a map  ĎA : (V â VA âŞ ) â V , that maps histories of positions into  moves. Here,  denotes the empty sequence of positions, to  let player A choose an initial state in the game. A memoryless strategy simply takes into account the last position:  ĎA : VA âŞ  â V . Since parity games are memoryless  determined it is enough to consider memoryless strategies.  Similarly, a strategy for player P is a map ĎP : VP â V .  A play Ď : V0 v0 V1 v1 . . . is played according to strategy ĎA  whenever the initial position is V0 = ĎA () and all moves of  A are played according to it Vi = ĎA (vi ). A strategy ĎA is  winning for player A whenever all plays played according  to ĎA are winning for A. Memoryless determinacy of parity  games guarantees that either player A has a memoryless  winning strategy or player P has a memoryless winning  strategy. We say that Ď is a G Âˇ ĎA play whenever Ď is  played in G according to ĎA .  We restrict our attention to strategies for A that choose  minimal models, and strategies for P that are proper choice  functions. This is not a drastic restriction. Clearly, if there  is a winning strategy for A that does not choose a minimal  model, then any strategy that chooses a smaller minimal  model is also winning. This is because the set of plays is  reduced, and all plays in the unrestricted set are winning for  A. Similarly, if ĎP is a winning strategy for P , then restricting its moves to be a proper choice functions (by restricting  the image) also gives a winning strategy. In both cases, the  set of successor moves is restricted but still confined within  winning regions. This lemma is essentially Prop. 2 from  [6], where complementation of weak alternation automata  by dualization is studied.  of the form (q, i) â (q 0 , i + 1) for all q 0 â M . We have to  show that Ď is successful run. We show by induction that all  traces of Ď correspond to plays in G(A, w) played according  to ĎA . For the base case (q, 0) is the initial state of the  trace. By construction (q, 0) â ĎA () so (q, 0) is a possible  choice of player P , and consequently a play prefix. For  the inductive case, assume that trace prefix (q0 , 0) . . . (qi , i)  is a play prefix, and let (qi , i) â (qi+1 , i + 1) be in EĎ .  By construction ĎA (qi , i) contains position (qi+1 , i + 1) so  player P can again move to it. This shows that the arbitrary  trace of Ď correspond to a play played according to ĎA .   Lemma 15 w â L(A) if and only if A has a winning  strategy in G(A, w).  Specular Pairs and Complementation: We show now  that specular automata accept complement languages. In the  rest of the section we let A and Ae be a specular automata  e : G(A,  e w) be the  pair, w be a word and G : G(A, w) and G  corresponding word games. First we need some preliminary  definitions.  Proof: Assume w â L(A) and let Ď : (VĎ , EĎ ) be a  successful run of w on A. We first build a strategy ĎA for  A on G(A, w) and then show that ĎA is winning:  ĎA () = (M0 , Âˇ, 0)  with M0 = {q | (q, 0) â VĎ }  ĎA (q, i) = (M, q, i + 1)  with M = {q 0 | (q, i) â (q 0 , i + 1) â EĎ }  The set M in (M, q, i + 1) is a model of Î´(q, i) because  Ď is a run. For positions (q, i) that do not appear in the  run Ď, the strategy ĎA (q, i) = (M, q, i + 1) can assign any  model M in Mod (Î´(q, w[i])). This model is not relevant  because no play played according to ĎA will visit these  states. Consider now an arbitrary play Ď : V0 v0 V1 v1 . . . of  G(A, w) played according to ĎA . We show by induction that  trace(Ď) : p0 p1 . . . is a trace of Ď.  â˘ base: By construction M0 is the set of initial positions  of Ď. Since p0 , chosen by player P , is v0 â M0 , then  v0 is a prefix of a trace of run Ď.  â˘ induction step: assume p0 . . . pi is a prefix of some trace  in Ď, so (pi , i) is in VĎ . Hence, ĎA (pi , i) = (M, pi , i +  1) for M being the set of successors of (pi , i) in EĎ .  Consequently pi+1 = (q, i + 1) for some (pi , i) â  (pi+1 , i + 1) in EĎ , so v0 . . . vi vi+1 is a longer prefix  of a trace of run in Ď.  This shows that trace(Ď) is a trace of the run Ď. Now,  since Ď is a successful run all its traces must be accepting,  and then:  max{F (q) | q â inf(trace(Ď)} is even,  which shows that ĎA is a winning strategy for G(A, w).  We now show the other direction: we start from a winning  strategy ĎA for A in G(A, w) and show that there is a  successful run Ď of w on A. Let (M, Âˇ, 0) = ĎA (). Then  we let VĎ contain (q, 0) for all q â M . Note that M is  a minimal model of I. Now, consider an arbitrary position  (q, i) and let (M, q, i+1) be ĎA (q, i). We add to EĎ all pairs  Definition 16 We say that strategies ĎA (for A in G) and  e are duals whenever both:  ĎeP (for P in G)  e Âˇ ĎP play Ď  â˘ for every G Âˇ ĎA play Ď there is a G  e s.t.  trace(e  Ď ) = trace(Ď).  e Âˇ ĎP play Ď  â˘ for every G  e there is a G Âˇ ĎA play Ď s.t.  trace(e  Ď ) = trace(Ď).  Theorem 17 (Dual Strategies) The following holds:  (1) For every strategy ĎA for A in G, there is a dual strategy  e  ĎeP for P in G.  (2) For every ĎP for P in G, there is a dual strategy ĎeA  e  for A in G.  Proof: We prove the two statements separately:  (1): Let ĎA be a strategy for A in G. This strategy ĎA  is characterized by  ĎA () = (M0 , Âˇ, 0)  where M0 â mod (I)  ĎA ((q, i)) = (M, q, i + 1) where M â mod (Î´(q, w[i]))  By Prop. 13.1 there are choice functions satisfying  e âQ  fM0 : Mod (I)  e a)) â Q  fhM,q,ai : Mod (Î´(q,  Img fM0 = M0  Img fhM,q,ai = M  Moreover, these functions are proper choice functions. We  e as follows:  now define the dual strategy ĎeP for P in G  ĎeP ((N0 , Âˇ, 0)) = (fM0 (N0 ), 0)  ĎeP ((N, q, i + 1)) = (fhM,q,ai (N ), q, i + 1)  where M is the move of A in G from (q, i): ĎA (q, i) =  (M, q, i + 1), and a = w[i]. Our choice of choice functions  fhM,q,ai guarantees that for every move of player P from  e that, when followed  M , there is a move for player A in G  by fhM,q,ai results in the same state. The properties of fM0  and fhM,q,ai ensure that the strategy ĎeP is proper.  We are ready to show that for every G Âˇ ĎA play there is  e Âˇ ĎP play with the same trace, and vice-versa.  aG  âââ Consider an arbitrary GÂˇĎA play Ď : V0 v0 V1 v1 . . ., and  let ĎA () = (M0 , Âˇ, 0) and ĎA (vi ) = (Mi+1 , qi , i + 1).  We use qi for vi = (qi , i). Note that qi+1 â Mi+1  because all moves of player P in Ď are legal moves. We  e Âˇ ĎP play Ď  f0 , ve0 , V  f1 , ve1 . . . as follows:  create the G  e:V  f  â V0 = (N0 , Âˇ, 0) where N0 is such that fM0 (N0 ) =  q0 . One such N0 exists since Img fM0 = M0 and  q0 â M0 (recall that (q0 , 0) is the result of a move  of P in G from (M0 , Âˇ, 0)).  e the position  â From (qi , i), player A chooses in G  (Ni+1 , qi , i + 1), where Ni+1 is chosen such that  fhMi+1 ,q,w[i]i = qi+1 .  By induction, we show that vi = vei . First, ve0 =  ĎeP ((N0 , Âˇ, 0)) = (fM0 (N0 ), 0) = (q0 , 0) = v0 .  Now, assume that for some i, vi = vei . Then, Vei =  (Ni+1 , qi , i+1), and Vi = ĎA (qi , i) = (Mi+1 , qi , i+1).  Now,  vei+1 = ĎeP (Vei ) = ĎeP ((Ni+1 , qi , i + 1))  =  = (fhMi+1 ,qi ,w[i]i (Ni+1 ), i + 1) =  = (qi+1 , i + 1)  =  = vi+1 .  Hence, trace(Ď) = trace(e  Ď ).  e Âˇ ĎP play Ď  âââ Consider an arbitrary G  e : Ve0 ve0 Ve1 ve1 . . .,  and let qi and Ni be such that:  vei = (qi , i) Ve0 = (N0 , Âˇ, 0) Vei+1 = (Ni+1 , qi , i + 1)  e Âˇ ĎP play, it satisfies that  Since Ď  e is a G  vei+1 = ĎeP (Vei+1 ) = (fhMi+1 ,qi ,w[i]i (Ni+1 ), i + 1)  where Mi is obtained from ĎA (qi , i) = (Mi+1 , i + 1).  Now, we define the play Ď : V0 v0 V1 v1 . . . as follows.  First the move for A is played according to ĎA :  V0 = ĎA () = (M0 , Âˇ, 0)  Vi+1 = ĎA (vi )  with  g0 : Mod (I) â Q  e  Img g0 â mod (I)  gq,i : Mod (Î´(q, w[i])) â Q  e w[i]))  Img gq,i â mod (Î´(q,  (3)  e as follows:  We define the strategy ĎeA for A in G  ĎeA () = Img g0  ĎeA ((q, i)) = Img gq,i  By (3), ĎeA is well defined. We show now that ĎeA and  ĎP are dual strategies. First, consider (q, i) an arbitrary  state and (M, q, i) a legal move for player A in G.  Player P will move to (q 0 , i + 1) = ĎP ((M, q, i)) with  e player A will move from  q 0 = gq,i ((M, q, i)). In G,  e to  (q, i) into (Img gq,i , q, i). We let player P move in G  0  0  (q , i + 1), which is legal, since q â Img gq,i . Consider  e  now an arbitrary state (p, i) and the move of A in G:  ĎeA ((p, i)) = (Img gp,i , p, i), and consider an arbitrary  legal move for P , (p0 , i + 1), hence p0 â Img gp,i .  Consequently, there is an M â Mod (Î´(p, w[i])) such  that gp,i ((M, p, i)) = p0 . Let A choose (M, p, i) as the  move from (p, i), which is a legal move. Then, playing  from (M, p, i) in G according to ĎP , the resulting state  is (p0 , i + 1). This shows that ĎA and ĎeP are dual  strategies.  It is important to note that the moves of the players  playing against the strategies are not restricted to follow  proper strategies (give minimal models or be proper choice  functions). Still, ĎA is winning precisely whenever ĎP is.    The following theorem follows directly from Lemma 15  and Theorem 17. This theorem allows to reason about  complementation simply by reasoning about traces of two  automata with dual frames.  Then, we let the moves of P to be:  v0 = (q0 , 0)  vi+1 = (qi+1 , i + 1)  We only need to show that these moves for P are legal.  First, q0 = fM0 (N0 ), and since Img fM0 = M0 it  follows that q0 â M0 , so moving from V0 into v0 is a  legal move.  Moreover, (qi+1  = fhMi+1 ,qi ,w[i]i (Ni )). Since  Img fhMi+1 ,qi ,w[i]i = Mi+1 it follows that qi+1 â  Mi+1 , so again moving from Vi+1 into vi+1 is a legal  move. By construction, trace(Ď) = trace(e  Ď ) again.  (2): Assume now that ĎP is a (proper) strategy for P  in G. The strategy ĎP is characterized by  ĎP ((M0 , Âˇ, 0)) = (q0 , 0)  ĎP ((M, q, i)) = (qi , i)  Since the strategy is proper there are proper choice  functions:  g0 : Mod (I) â Q  gq,i : Mod (Î´(q, w[i])) â Q  Theorem 18 Let A and Ae be specular automata. Then  e  L(A) = ÎŁĎ \ L(A).  We show the correctness of Streett ranking algorithm.  Lemma 19 Let G be an accepting run, and let G 0 be a nonempty sub-graph of G with no G vertices and only infinite  paths. Then, there is some node in G 0 that cannot access  any B node.  Proof: Consider, by contradiction that there is no one  such a node in G 0 = (V 0 , E 0 ), or equivalently, that all  vertices in G 0 can access a B node:  for all hq, li â V 0 , there is some hq 0 , l0 i â V 0  with q 0 â B and hq, li ââE 0 hq 0 , l0 i.  Then, every node can be associated with a B node by  a map next(hq, li) that returns one path to a B reachable  node (for example, the shortest non-empty path to a B state,  and picking the smallest according to some lexicographic  order among the shortest ones.) Then using induction define,  starting from an arbitrary node hq, li â V 0 , an infinite  path in G 0 that visits infinitely B nodes infinitely often by  concatenating the paths returned by next. Let us call Ď one  such path.  Since Ď(0) = hq, li is a node of G 0 , and consequently a  node of G, Ď(0) is reachable from some initial node by point  3 in the definition of a run. Let Ďpre be a finite path in G  from a node hq0 , 0i â V . The path Ďpre Ď is a trace in G that  visits G nodes finitely often (only nodes in Ďpre can possibly  be G nodes) and B nodes infinitely often in Ď. This trace  contradicts that G is an accepting run.    We will use the following notation, for a given sub-graph  G 0 of a run:  def  access(G 0 , hq, li) = {hq 0 , l0 i | hq, li ââ hq 0 , l0 i}  0  def  0  finite(G ) = {hq, li | access(G , hq, li) is finite}  def  nobad(G 0 ) = {hq, li | access(G 0 , hq, li) âŠ B = â}  def  width(G 0 , l) = |{hq, li â G 0 }|  Lemma 6 G is an accepting run iff there is an odd  S{1}-ranking for G.  Proof: We prove the two directions separately:  âââ Assume there is an odd S{1}-ranking f for G and let Ď  be an arbitrary trace of G. Since, f is odd, either Ď visits  infinitely many G states, in which case Ď is accepting,  or f (Ď) converges to an odd value. In this second case,  there is l such that for all l0 > l, f (Ď(l0 )) = f (Ď(l)) and  f (Ď(l)) is odd. By definition of S{1}-ranking (point  (i)), Ď(l0 ) cannot be a B state, and consequently Ď visits  only finitely many B states. Hence, Ď is an accepting  trace.  âââ Assume G is an accepting run for A.  â Initial Stage The construction of f starts by removing from G all G vertices. Let VG be {hq, li | q â G},  then f (hq, li) = 0 for all hq, li â VG . Also, let  V0 = finite(G \ VG ), we let f (hq, li = 0 for all  hq, li â V0 . Also G0 = G \ (VG âŞ V0 ), which contains  the original graph except the G nodes, and every  node that reach G nodes in all its outgoing paths.  â Incremental Stage The algorithm proceeds in at  most n rounds, performing the following two operations in each round k. The round begins with  subgraph G2k of G.  â Phase I: Let V2k+1 = nobad(G2k ). Then,  f (hq, li) = 2k + 1 for all hq, li â V2k+1 .  G2k+1 = G2k \ V2k+1 .  â Phase II: Let V2k+2 = finite(G2k+1 ). Then,  f (hq, li) = 2k + 2 for all hq, li â V2k+2 .  G2k+2 = G2k \ V2k+2 .  The graphs G0 as well all graphs G2k+2 are either  empty, or guaranteed to have only infinite paths,  since all nodes that can only access finitely many  nodes are removed. (a finite path ends in a node with  no successor).  Hence, if V2k is non-empty Lemma 19 guarantees  that V2k+1 is non-empty as well: there is a node in  V2k+1 that accesses infinitely many vertices, but no  B node. In particular there is an infinite path that  is removed in Phase I. Hence, for some level l, all  l0 > l satisfy that  width(G2k+1 , l0 ) + 1 â¤ width(G2k , l0 )  Phase II only removes nodes, so  width(G2k+2 , l0 ) â¤ width(G2k+1 , l0 )  Since, initially width(G, l) â¤ n for all levels l, it  follows that, at the end of round k, for a sufficiently  large l0 :  width(G2k+1 , l0 ) â¤ n â (k + 1)  Consequently, at the end of Phase II of round n â  1: width(G2nâ1 , l0 ) â¤ 0. All remaining vertices in  G2nâ1 can access only finitely many vertices. Hence  G2n = â, and the algorithm terminates. Note that  it is possible that G2k = â in an earlier round, but  guaranteed that after round n, G2n = â.  It remains to be seen that f is indeed an odd  S{1}-ranking.  The function f is a S{1}-ranking:: By construction,  all B vertices are marked in Phase II of some round  because B âŠ nobad(Gi ) = â, and hence receive an even  value. Therefore, all B nodes satisfy condition (i) of the  definition of S{1}-ranking. Now consider an arbitrary  node hq, li. We consider three cases:  1) If hq, li is removed in the Initial Stage then q is  either a G node, in which case (ii) holds trivially, or  it is in V0 . In the latter case, all its outgoing paths  hit a G node in a finite number of steps, and all  the intermediate nodes are mapped to 0. Hence, if  hq, li â hq 0 , l0 i, then f (hq 0 , l0 i) = 0 = f (hq 0 , l0 i)  and f (hq, li) âĽ f (hq 0 , l0 i), and condition (ii) holds.  2) If hq, li is removed in Phase I of round k, so hq, li â  V2k+1 . Then all its outgoing paths either hit a node  removed in a previous round or are in V2k+1 . In both  cases hq, li â hq 0 , l0 i implies f (hq, li) âĽ f (hq 0 , l0 i).  3) If hq, li is removed in Phase II of round k, so  hq, li â V2k+2 . Then all its outgoing paths either hit  a node removed in a previous round, or are in V2k+1  or in V2k+2 . In all cases hq, li â hq 0 , l0 i implies  f (hq, li) âĽ f (hq 0 , l0 i).  The function f is an odd S{1}-ranking:: Consider  an arbitrary path Ď. If Ď visits infinitely many G nodes,  then the condition for f being odd on Ď holds. If Ď does  not visit infinitely many G nodes, then f converges on  Ď to some value. This value cannot be even, because  that would imply that all these infinitely many vertices  are in some V2k+2 , but there are not infinite paths  containing these kind of node: by construction all nodes  label in Phase II have finite outgoing paths before  changing ranking.  This finishes the proof.   Theorem 7 Let A be an ASW{1} and N the corresponding  NBW. Then w â L(A) if and only of w â L(N ).  Proof: We prove the two directions separately:  âââ We assume w â L(A) and show that w â L(N ). Let  G be a run dag for w on A, and f an odd S{1}-ranking.  Consider the sequence Q0 Q1 . . . of states of N induced  by G and f as Qi = (Si , Oi , fi ) with the set of states  in Si :  Si  = {q | hq, ii â G}  and the pending states Oi :  O0 = {p | hp, 0i â G with p â  /G  and f (hp, 0i) is even}  Oi+1 = {p | hp, i + 1i â G with p â  /G  and f (hp, i + 1i) even}  Oi+1 = {p | hp, i + 1i â G  if Oi = â  and p â  / G, and for some q â Oi ,  f (hp, i + 1i) = f (hq, ii)  and hq, ii â hp, i + 1i}  if Oi 6= â  and  fi (q)  =  f (hq, ii)  It is routine to check that Q0 Q1 . . . is a run. We show  that this run is accepting for N . By contradiction, if  Q0 Q1 . . . is non accepting, there exists i such that,  for all j âĽ i, Qj â  / FN , hence Oj 6= â. By D3  every qj+1 â Oj+1 has a predecessor qj â Oj with  fj (qj ) = fj+1 (qj+1 ) being an even value by definition  of Oi above. Since, as shown above, every Oj 6= â,  it follows that there is an infinite sub-dag of nodes in  G of the form hqj , ji with f (hqj , ji) being even, and  with infinitely many nodes having an incident edge.  By KoĚnigâs lemma, since this dag is finitely branching,  it has an infinite path, all whose nodes are assigned  the same even value by f . This is a contradiction with  f being an odd S{1}-ranking for G. Hence we find  that Q0 Q1 . . . is a run that accepts w which shows  w â L(N ).  âââ We assume now w â L(N ) and show that w â L(A).  Let Q0 Q1 Q2 . . . be an accepting run for w on N and  let G = (V, E) and f be an induced run and function  V â [2n]. We conclude from Q1 and D2, respectively,  that properties (i) and (ii) of S{1}-ranking holds on  f . Therefore f is a S{1}-ranking. Now let us show  that f is an odd S{1}-ranking. To this end, consider  an arbitrary path Ď in G for which we will show that  either condition (i) or (ii) of the definition of odd  S{1}-ranking holds. If Ď visits G nodes infinitely often,  then condition (i) holds. Otherwise, there is an i after  which no more G nodes are visited in Ď. Hence, since  every node Ď(i0 ) with i0 > i + 1 has a predecessor not  in G, D2 shows that f converges on Ď to some value.  Let j âĽ i0 be such that f has converged already (i.e.,  f (Ď(j 0 )) = f (Ď(j)) for all j 0 âĽ j). Let Qk , Ql â FN  with j â¤ k < l be two accepting states in the run Q0 Q1  of w on N . It must be the case that Ď(k + 1) â  / Ok+1 .  Assume the contrary (i.e. Ď(k + 1) â Ok+1 ), since Ď  visits no G node after k and f has converged, then we  conclude by D3 that Ď(k 0 ) â Ok0 for all k 0 > k, hence  that Ol 6= â, and finally that Ql â  / FN by definition of  FN which is a contradiction.  Also since Ď(k + 1) â  / Ok+1 and Qk â FN , D3 shows  that f (Ď(k + 1)) is odd. Hence f converges on Ď to an  odd value showing that condition (ii) of the definition  of S{1}-ranking holds.  This concludes that f is an odd S{1}-ranking for G.  Finally Lem. 6 shows that G is an accepting run, hence  that w â L(A).   Lemma 20 G is an accepting run iff there is a stratified  odd S{1}-ranking for G.  Proof: We prove the two directions separately:  âââ Assume there is a stratified odd S{1}-ranking {fj } for  G and let Ď be an arbitrary trace of G. Since, {fj } is  odd, either Ď visits infinitely many G states, in which  case Ď is accepting, or Ď converges to a stratum Sj  and fj (Ď) converges to an odd value. In this second  case, there is l such that for all l0 > l, fj (Ď(l0 )) =  fj (Ď(l)) and fj (Ď(l)) is odd. By definition of stratified  S{1}-ranking (point (i)), Ď(l0 ) cannot be a B state,  and consequently Ď visits only finitely many B states.  Hence, Ď is an accepting trace.  âââ Assume now that G is an accepting run for A. The  construction of each fj works at each stratum independently. Fix Sj . First, one removes all G vertices and all  those vertices not in Sj . The algorithm works exactly  as with the proof of Lemma 6 by stages, at each stage  first removing those states that cannot access B nodes,  and then remove those states that only access finitely  many nodes. Since at each stage one removes at least  one element from all cuts at a sufficiently large l, at the  width of elements from Sj is at most |Sj |, the algorithm  is guaranteed to finish in |Sj | rounds, generating an odd  S{1}-ranking for stratum Sj . It is routine to check that  {fj } is indeed a stratified S{1}-ranking.    Theorem 11 Let A be a stratified ASW{1} and N the corresponding NBW using stratified rankings. Then w â L(A)  if and only of w â L(N ).  Proof: The proof is analogous to Theorem 11.  Fig. 2 depicts the translation of RLTL into APW.  q0 false  q0 true  Automaton Aâ for â.  Specular automaton Aâ .  =  =  =  Ay  Ax  =  Ay  Ax  Automaton Axâ¨y for x â¨ y.  Specular automaton Axâ¨y .  =  =  Ax  Ax  Automaton AÂŹx for ÂŹx.  1  Specular automaton AÂŹx .  0  =  Nr  Ax  Nr  Automaton Ar;x for r ; x.  q0  Ay  q0  Ay  Automaton Ax|riiy for x|riiy.  Ay  Ax  q0  =  =  Ax  1  Nr  Automaton Ax|riy for x|riy.  Figure 2.  0  Nr  Specular automaton Ax|riiy .  2  =  =  1  Nr  Ax  0  =  =  q0  Ax  Specular automaton Ar;x .  1  =  =  Ay  1  =  Ax  0  Nr  Specular automaton Ax|riy .  Specular automata pairs for â, x â¨ y, ÂŹx, x ; y, x|riiy and x|riy. 