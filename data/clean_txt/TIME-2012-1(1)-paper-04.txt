Efficient Regular Linear Temporal Logic using Dualization and Stratification  CeÄšÂsar SaÄšÂnchez  IMDEA Software Institute, Madrid, Spain  Institute for Applied Physics, CSIC, Spain  Email: Cesar.Sanchez@imdea.org  AbstractÃ¢Â€Â”We study efficient translations of Regular Linear  Temporal Logic (RLTL) into automata on infinite words. RLTL  is a temporal logic that fuses Linear Temporal Logic (LTL)  with regular expressions, extending its expressive power to all  ÄÂ‰-regular languages.  The first contribution of this paper is a novel bottom up  translation from RLTL into alternating parity automata of  linear size that requires only colors 0, 1 and 2. Moreover, the  resulting automata enjoy the stratified internal structure of  hesitant automata. Our translation is defined inductively for  every operator, and does not require an upfront transformation  of the expression into a normal form. Our construction builds  at every step two automata: one equivalent to the formula  and another to its complement. Inspired by this construction,  our second contribution is to extend RLTL with new operators,  including universal sequential composition, that enrich the logic  with duality laws and negation normal forms.  The third contribution is a ranking translation of the  resulting alternating automata into non-deterministic BuÄšÂˆchi  automata. To provide this efficient translation we introduce  the notion of stratified rankings, and show how the translation  is optimal for the LTL fragment of the logic.  Keywords-temporal logic; formal verification; formal methods;  I. I NTRODUCTION  We study the problem of formal temporal verification of  reactive systems, which starts from a specification of the  intended behavior in some temporal logic. In this paper we  study the logic RLTL [1], [2] that extends LTL [3], [4] with  regular expressions.  The automata-theoretic approach to model checking reduces this verification problem to automata constructions  and automata decision problems. The verification process  begins by translating the negation of the formula into an  equivalent automaton on infinite words. This automaton  accepts all the traces that violate the specification. Then,  the automaton is composed synchronously with the system  description. Finally, a non-emptiness check reveals whether  the system admits some counterexample trace.  Modernly, specifications are translated into alternating  automata because their richer structure enables a direct  This work was funded in part by the EU project FET IST-231620 HATS,  MICINN project TIN-2008-05624 DOVES, CAM project S2009TIC-1465  PROMETIDOS, and by the COST Action IC0901 Rich ModelToolkit-An  Infrastructure for Reliable Computer Systems.  JuliaÄšÂn Samborski-Forlese  IMDEA Software Institute, Madrid, Spain  Email: Julian.SF@imdea.org  translation from temporal logics, postponing a potentially  exponential blow-up. Another advantage of alternation is the  easy dualization (see Muller and Schupp [5]) provided by  the availability of both conjunctive and disjunctive transition  relations. However, to obtain an automaton accepting the  complement language of a given automaton, one also needs  to complement the acceptance condition (see for example  [6]). For LTL one can first translate a formula (e.g., the  negation of the specification) into negation normal form  (NNF) by pushing negation to the propositional level, and  then use automata with weak acceptance conditions [7],  [8], in which the structured of the automaton consists of  strongly connected components (SCC) all of which are  either accepting or rejecting. Extensions of LTL with regular  expression, like RLTL, do not have negation normal forms.  Hence, a translation of the logical negation operator must  be given, precluding the use of weak acceptance conditions.  In this paper we show how to translate RLTL into strong  parity automata on words (APW) with a particular internal  structure, and study the complementation construction for  the resulting APW. The classical complementation for the  parity condition increments in one unit the color assigned  to every state, turning an arbitrary sequence of states from  accepting into rejecting (and viceversa). However, if this  construction is used to translate the logical negation operator,  the total number of colors in the resulting automaton can  grow linearly in the size of the formula. The best known  algorithm [9] for translating an APW with n states and k  colors into a non-deterministic BuÄšÂˆchi automaton requires  2O(nk log nk) . In this work, we use a faster complementation  construction based on the following intuition. Traces of runs  of the automaton get trapped in an SCC, meaning that all  states in a suffix of a given trace belong to some SCC  of the automaton. Hence, it is sufficient for a complementation construction to consider SCCs independently. This  idea enables a translation of RLTL (including the negation  operator) into APW using only colors 0, 1 and 2. These  automata are equivalent to alternating Streett automata on  words (ASW) with one accepting pair (denoted ASW{1}).  The translation proceeds inductively, building at each step  a pair of complement automata. Then, inspired by this  translation we enrich RLTL with new constructs, including  universal sequential composition. The enriched logic admits  a negation normal form.  Finally, we study the translation into non-deterministic  BuÄšÂˆchi automata (NBW). Streett{1} rankings (see [10])  directly allow to translate an ASW{1} into an NBW of  size 2O(n log n) . Here, we use again the particular stratified  structure of the ASW{1} automata obtained from RLTL  expressions. Each stratum in the generated ASW{1} is either  BuÄšÂˆchi (only colors 1 and 2) or coBuÄšÂˆchi (colors 0 and  1), making these automata equivalent to hesitant automata  AHW (see [11]). We introduce a notion of stratified ranking  and show that for all RLTL operators (except one), the  ranking of each state can be statically predetermined. This  result produces NBW with size 2O(n log m) where m is the  size of the largest stratum that cannot be predetermined. In  particular, all LTL operators generate strata of size 1, which  result into NBW of size 2O(n) when using our method to  translate LTL into NBW.  The rest of the of paper is structured as follows. Section II  presents the preliminaries, and Section III introduces RLTL.  Section IV shows the translation from RLTL into stratified  ASW{1}, and Section V the translation into NBW, including  stratified rankings. Section VI shows our empirical study.  Finally, Section VII concludes.  II. P RELIMINARIES  +  We use B (X ) for the positive Boolean formulas over a  set of propositions X . These formulas are built from true,  false and elements of X , using Ã¢ÂˆÂ§ and Ã¢ÂˆÂ¨. A minimal model  M of a positive Boolean formula ÃÂ¸ is a subset of X such  that M satisfies ÃÂ¸ but no strict subset of M satisfies ÃÂ¸. For  example, given the set Q = {q0 , q1 , q2 , q3 }, the formula  ÃÂ¸1 = (q1 Ã¢ÂˆÂ§ q2 ) Ã¢ÂˆÂ¨ q3 is a B + (Q) formula. The minimal  models of ÃÂ¸1 are {q1 , q2 } and {q3 }. Given a positive Boolean  formula ÃÂ¸ there is a dual formula ÃÂ¸e obtained by switching  Ã¢ÂˆÂ§ and Ã¢ÂˆÂ¨, and switching true and false. For example, the  dual of ÃÂ¸1 above is ÃÂ¸e1 = (q1 Ã¢ÂˆÂ¨ q2 ) Ã¢ÂˆÂ§ q3 , or equivalently in  disjunctive normal form ÃÂ¸e1 = (q1 Ã¢ÂˆÂ§ q3 ) Ã¢ÂˆÂ¨ (q2 Ã¢ÂˆÂ§ q3 ). The  minimal models of ÃÂ¸e1 are {q1 , q3 } and {q2 , q3 }.  An alternating automaton is a tuple A : hÃÅ, Q, ÃÂ´, I, F i  where ÃÅ is a propositional alphabet, Q is a finite set of states,  ÃÂ´ : Q Ä‚Â— ÃÅ Ã¢Â†Â’ B + (Q) is the transition function, I Ã¢ÂˆÂˆ B + (Q)  is the initial condition, and F is the acceptance condition.  A frame of an automaton A is the tuple hÃÅ, Q, ÃÂ´, Ii. A  frame is called non-deterministic whenever I, and ÃÂ´(q, a)  for all states q and symbols a, have singleton sets as  minimal models. In other words, I and ÃÂ´(q, a) are equivalent  to disjunctive formulas. A frame is called universal if I,  and ÃÂ´(q, a) for all states q and symbols a, have a unique  minimal model. In other words, I and ÃÂ´(q, a) are equivalent  to conjunctive formulas. A frame is deterministic if it is  both non-deterministic and universal, that is if both the  initial condition and transition functions correspond to true,  false or a single successor state. In general a frame is  neither universal nor non-deterministic, but fully alternating.  A transition function ÃÂ´ can be extended to positive Boolean  formulas ÃÂ´ : B + (Q)Ä‚Â—ÃÅ Ã¢Â†Â’ B + (Q) in the standard way, taking ÃÂ´(q, a) as the base case and letting ÃÂ´(true, a) = true,  ÃÂ´(false, a) = false, ÃÂ´(A Ã¢ÂˆÂ¨ B, a) = ÃÂ´(A, a) Ã¢ÂˆÂ¨ ÃÂ´(B, a) and  ÃÂ´(A Ã¢ÂˆÂ§ B, a) = ÃÂ´(A, a) Ã¢ÂˆÂ§ ÃÂ´(B, a).  Given a word w Ã¢ÂˆÂˆ ÃÅÄÂ‰ , a run of w on a frame F :  hÃÅ, Q, ÃÂ´, Ii is a DAG (V, E) with nodes V Ã¢ÂŠÂ† Q Ä‚Â— N, s.t. :  1) The set {m | (m, 0) Ã¢ÂˆÂˆ V } is a minimal model for I.  2) Ã¢ÂˆÂ€(q, k) Ã¢ÂˆÂˆ V , {q 0 | (q 0 , k + 1) Ã¢ÂˆÂˆ V Ã¢ÂˆÂ§ ((q, k), (q 0 , k +  1)) Ã¢ÂˆÂˆ E} is a minimal model for ÃÂ´(q, w[k]).  A trace of a run is an infinite path in the run, or a finite  path finishing in an state with no successor in the run. A  non-deterministic frame may admit multiple different runs  for a given word, but each run contains a unique trace. A  universal frame admits just one run for each word, but this  run may contain multiple traces. In general a frame admits  multiple runs each with multiple traces.  Given a frame F : hÃÅ, Q, ÃÂ´, Ii, the specular frame is  e Ii,  e where Ie is the dual of I and ÃÂ´e is the dual  Fe : hÃÅ, Q, ÃÂ´,  e a) is the dual formula of ÃÂ´(q, a) for  transition function: ÃÂ´(q,  all states q and symbols a. The graph of a frame has Q  as a set of nodes and contains an edge p Ã¢Â†Â’ q whenever q  is in some minimal model of ÃÂ´(p, a) for some symbol a.  The graphs of a frame and its specular frame are identical,  because if q is in some minimal model of ÃÂ´(p, a) then q is  e a). Therefore, a frame  also in some minimal model of ÃÂ´(p,  admits a trace iff its specular frame also admits the trace.  An automaton equips a frame with an acceptance condition, which determines whether an infinite sequence of states  is accepting. A finite trace finishing in a state (q, i) with no  successor is accepting. Given an infinite sequence of states  ÄÂ€ : q0 , q1 , q2 . . . we let inf(ÄÂ€) be those states from Q that  occur infinitely many times in ÄÂ€. In this paper we consider  the following acceptance conditions:  Ã¢Â€Ë˜ BuÄšÂˆchi: F Ã¢ÂŠÂ† Q. ÄÂ€ is accepting when inf(ÄÂ€) Ã¢ÂˆÅ  F 6= Ã¢ÂˆÂ….  Ã¢Â€Ë˜ coBuÄšÂˆchi: F Ã¢ÂŠÂ† Q. ÄÂ€ is accepting when inf(ÄÂ€) Ã¢ÂˆÅ  F = Ã¢ÂˆÂ….  Ã¢Â€Ë˜ parity: F : Q Ã¢Â†Â’ {0 . . . d}. ÄÂ€ is accepting when  max{F (q) | q Ã¢ÂˆÂˆ inf(ÄÂ€)} is even. The elements of  {0 . . . d} are called colors.  Ã¢Â€Ë˜ Streett: F = {hB1 , G1 i, hB2 , G2 i, . . . , hBk , Gk i}. ÄÂ€ is  accepting when for all 1 Ã¢Â‰Â¤ i Ã¢Â‰Â¤ k, if inf(ÄÂ€) Ã¢ÂˆÅ  Bi 6= Ã¢Âˆ  then inf(ÄÂ€) Ã¢ÂˆÅ  Gi 6= Ã¢ÂˆÂ….  Ã¢Â€Ë˜ Streett{1}: F = (B, G). ÄÂ€ is accepting when if inf(ÄÂ€)Ã¢ÂˆÅ   B 6= Ã¢ÂˆÂ… then inf(ÄÂ€) Ã¢ÂˆÅ  G 6= Ã¢ÂˆÂ….  Ã¢Â€Ë˜ hesitant: F Ã¢ÂŠÂ† Q, and H = h(S0 . . . , Sk ), <, ÃÄ…i is a  partition of Q induced by the SCCs, ordered by <  according to reachability in the automaton graph, and  ÃÄ… marks each partition as either BuÄšÂˆchi or coBuÄšÂˆchi. A  trace ÄÂ€ is accepting when  Ã¢Â€Â“ inf(ÄÂ€) Ã¢ÂŠÂ† Si , Si is BuÄšÂˆchi and inf(ÄÂ€) Ã¢ÂˆÅ  F 6= Ã¢ÂˆÂ…, or  Ã¢Â€Â“ inf(ÄÂ€) Ã¢ÂŠÂ† Sj , Sj is coBuÄšÂˆchi and inf(ÄÂ€) Ã¢ÂˆÅ  F = Ã¢ÂˆÂ….  Observation: A parity acceptance condition with colors  {0, 1, 2} corresponds to the Streett condition (B, G) with  B = {q | F (q) = 1} and G = {q | F (q) = 2}. The Streett  pair (B, G) forces (for a trace to be accepting) that if some  state marked 1 is visited infinitely often, then some state  marked 2 is also visited infinitely often. The other possible  case is that only states that are not marked either B or G  states are visited infinitely often. In this case, the trace is  also good for the parity automaton.  We use stratum to refer to an SCC of an automaton  graph. The stratification of hesitant automata given by the  partition implies that every infinite trace gets trapped in a  stratum Si . Then, the BuÄšÂˆchi or coBuÄšÂˆchi condition on the  stratum determines whether the trace is accepting. We use  ABW (resp. AcBW, APW, ASW and AHW) to represent  BuÄšÂˆchi (resp. coBuÄšÂˆchi, parity, Streett and hesitant) alternating  automata on words. We use APW{0, 1, 2} for APW that only  use colors 0, 1 and 2 and ASW{1} for ASW with only one  pair.  When a trace ÄÂ€ is accepted according to an acceptance  condition F , we write ÄÂ€ Ã¢ÂˆÂˆ acc(F ). A run of an alternating  automaton is called accepting whenever all its traces are  accepting. We say that a word w is in the language of  automaton A, and we write w Ã¢ÂˆÂˆ L(A), whenever there is  an accepting run for w on A.  The following definition and theorem relate the notions  of specular pairs and complement languages.  Definition 1 Two automata A and B over the same alphabet are a specular pair whenever their frames are specular  and for all paths ÄÂ€ in the frame graph ÄÂ€ Ã¢ÂˆÂˆ acc(FA ) if and  only if ÄÂ€ Ã¢ÂˆÂˆ  / acc(FB ).  Theorem 2 (Specular Automata and Complement)  Let A and B be a specular pair of automata. Then  L(A) = ÃÅÄÂ‰ \ L(B).  Theorem 2 reduces the proof that two automata with dual  frames are complements to checking that the traces that can  happen have opposite acceptance. In the next section, we  use this result to build an incremental translation, in which  we only need to check the new traces added at each step.  III. T HE L OGIC RLTL  Regular Linear Temporal Logic [1], [2] is a formalism  for specifying w-regular languages. The logic is defined in  two stages, similarly to PSL [12] or ForSpec [13]. In the  first stage we build regular expressions that define finite  non-empty segments of infinite words. In the second stage,  we build RLTL expressions to define sets of infinite words.  The syntax of each of these two formalisms contain only  a finite collection of constructor symbols. In particular, the  language of RLTL contains no fix-point binders or automata  constructors.  Regular Expressions: The basic elements of regular  expressions are basic expressions, which are Boolean combinations of a finite set of atomic propositions, whose truth  value is interpreted in a single state. The syntax of regular  expressions is given by the following grammar:  ÃÄ… ::= ÃÄ… + ÃÄ…  ÃÄ…;ÃÄ…  ÃÄ…Ã¢ÂˆÂ—ÃÄ…  p  where p ranges over basic expressions. The intended interpretation of the operators +, ; and Ã¢ÂˆÂ— are the standard union,  concatenation and binary Kleene-star.  Our version of regular expressions describe segments of  infinite words. Given an infinite word w Ã¢ÂˆÂˆ ÃÅÄÂ‰ , a position  is a natural number. We use w[i] for the symbol at position  i in word w. Given an infinite word w and two positions i  and j, the tuple (w, i, j) is called the segment of the word  w between positions i and j. Note that a segment consists  of the whole word w with two tags, not just the sequence of  symbols that occur between two positions. This allows the  extension of regular expressions to past expressions [2], but  in this paper we only study future expressions. A pointed  word is a pair (w, i) formed by a word w and a position  i. The formal semantics of regular expressions is defined  as a binary relation RE between segments and regular  expressions, as follows. Given a basic expression p, regular  expressions r and s, and a word w:  Ã¢Â€Ë˜ (w, i, j) RE p, whenever w[i] satisfies p and j = i + 1.  Ã¢Â€Ë˜ (w, i, j) RE r + s whenever either (w, i, j) RE r or  (w, i, j) RE s, or both.  Ã¢Â€Ë˜ (w, i, j) RE r ; s whenever for some k, (w, i, k) RE r  and (w, k, j) RE s.  Ã¢Â€Ë˜ (w, i, j) RE r Ã¢ÂˆÂ— s whenever either (w, i, j) RE s, or  for some sequence (i0 = i, i1 , . . . im ) and all k Ã¢ÂˆÂˆ  {0, .., m Ã¢ÂˆÂ’ 1}, (w, ik , ik+1 ) RE r and (w, im , j) RE s.  RLTL: Expressions in Regular Linear Temporal Logic  define languages over infinite words. The key elements  of RLTL are the power operators that generalize many  constructs from different linear-time logics and calculi. The  syntax of RLTL expressions is defined by the grammar:  ÄÂ• ::= Ã¢Âˆ  ÄÂ•Ã¢ÂˆÂ¨ÄÂ•  Ã‚Å¹ÄÂ•  ÃÄ…;ÄÂ•  ÄÂ•|ÃÄ…iiÄÂ•  ÄÂ•|ÃÄ…iÄÂ•  where ÃÄ… ranges over regular expressions. The symbol Ã¢ÂˆÂ¨  stands for union of languages (logical disjunction), and  Ã‚Å¹ represents language complement (logical negation). The  symbol ; stands for the concatenation of an expression over  finite words followed by an expression over infinite words.  The operator Ã¢ÂˆÂ… defines the empty language (logical false).  The operators ÄÂ•|ÃÄ…iiÄÂ• and its weak version ÄÂ•|ÃÄ…iÄÂ• are  called the power operators. The expressions x|riiy and x|riy  (read x at r until y, and, respectively, x at r weak-until y) are  built from three elements: y (the attempt), x (the obligation)  and r (the delay). For x|riiy to hold, either the attempt holds,  or the obligation is met and the whole expression evaluates  successfully after the delay. For x|riiy to hold, the obligation  must be met after a finite number of delays. On the contrary,  x|ziy does not require the attempt to be met after a finite  number of delays, allowing the obligation and delay to be  repeated ad infinitum.  These two simple operators allow the definition of many  other temporal operators. For example, the strong until  operator x U y of LTL can be seen as an attempt for y  to hold, or otherwise an obligation for x to be met and a  delay of a single step. Similarly, the ÄÂ‰-regular expression  xÄÂ‰ can be interpreted as a weak power operator having no  possible escape and a trivially fulfilled obligation, with a  delay indicated by x. Then, conventional ÄÂ‰-regular expressions can describe sophisticated delays with trivial attempts  and obligations, while conventional LTL constructs allow  complex attempts and obligations but trivial one-step delays.  Power operators generalize both types of constructs. The  completeness of RLTL with respect to ÄÂ‰-regular languages  follows immediately from the expressibility of ÄÂ‰-regular  expressions. In particular, WolperÃ¢Â€Â™s example [14] of an ÄÂ‰regular language not definable in LTL (p happening at every  even state) can be defined as p|true ; trueiÃ¢ÂˆÂ…. The size  of an RLTL formula is defined as the total number of its  symbols.  The semantics of RLTL relates expressions and pointed  words. Given two RLTL expressions x and y, a regular  expression r, and a word w:  Ã¢Â€Ë˜ (w, i)  Ã¢ÂˆÂ… never holds.  Ã¢Â€Ë˜ (w, i)  x Ã¢ÂˆÂ¨ y iff either (w, i)  x or (w, i)  y.  Ã¢Â€Ë˜ (w, i)  Ã‚Å¹x iff (w, i) 6 x.  Ã¢Â€Ë˜ (w, i)  r ;y iff for some k, (w, i, k) REr and (w,k)  y.  Ã¢Â€Ë˜ (w, i)  x|riiy iff (w, i)  y or for some sequence  (i0 = i, i1 , . . . im ), for all k < m: (w, ik , ik+1 ) RE r  and (w, ik )  x, and (w, im )  y.  Ã¢Â€Ë˜ (w, i)  x|riy whenever either x|riiy or for some infinite seq (i0 = i, i1 , . . . ), for all k > 0, (w, ik , ik+1 ) REr  and (w, ik )  x.  The semantics of x|riiy establishes that either the obligation y is satisfied at the point i of the evaluation, or  there is a sequence of delaysÃ¢Â€Â”each determined by rÃ¢Â€Â”after  which y holds, and x holds before each individual delay.  The semantics of x|riy also allow the case where y never  holds, but x always holds before any number of evaluations  of r. Languages are associated with RLTL expressions as  usual: a word w Ã¢ÂˆÂˆ ÃÅÄÂ‰ is in the language of an expression  x, denoted by w Ã¢ÂˆÂˆ L(x), whenever (w, 0)  x.  Using [10], [9] to translate APW into NBW would produce  2  NBW with 2O(n log n) states for the old translation and  2O(n log n) states for the one presented here. In Section V  below we show how to reduce it further to 2O(n log m)  (where m is the size of the largest stratum), and 2O(n) for  the LTL fragment of RLTL.  The translation is described inductively. For every operator, we show how to compute the specular automata pair,  starting from the automata pairs for the sub-expressions. In  particular, assume that (Ax , Ax ) and (Ay , Ay ) are specular  pairs for RLTL expressions x and y and that Nr is an NFA  for regular expression r. We use q Ã¢Â†Â’a Fr for Ã¢Â€Âœq Ã¢ÂˆÂˆ Qr and  ÃÂ´(q, a) Ã¢ÂˆÅ  Fr 6= Ã¢ÂˆÂ…,Ã¢Â€Â and we use q 6Ã¢Â†Â’a Fr for Ã¢Â€Âœq Ã¢ÂˆÂˆ Qr and  ÃÂ´(q, a) Ã¢ÂˆÅ  Fr = Ã¢ÂˆÂ….Ã¢Â€Â  Empty: The pair (AÃ¢ÂˆÂ… , AÃ¢ÂˆÂ… ) has state set Q = {q0 },  and initial conditions I = q0 and I = q0 . The acceptance  conditions are F (q0 ) = 0 and F (q0 ) = 0. The transition  relations are ÃÂ´(q0 , ) = false and ÃÂ´(q0 , ) = true. This  choice of ÃÂ´ and ÃÂ´ allow all traces to be accepting for AÃ¢ÂˆÂ… and  no trace to be accepting for AÃ¢ÂˆÂ… , so AÃ¢ÂˆÂ… accepts all words  and AÃ¢ÂˆÂ… accepts no word, as desired.  Disjunction: The state space of AxÃ¢ÂˆÂ¨y : hÃÅ, Q, ÃÂ´, I, F i  and AxÃ¢ÂˆÂ¨y : hÃÅ, Q, ÃÂ´, I, F i are Q = Qx Ã¢ÂˆÅ Qy . The initial  conditions are I = Ix Ã¢ÂˆÂ¨ Iy and I = Ix Ã¢ÂˆÂ§ Iy . The transition  functions and acceptance condition are:  if  ÃÂ´(q, a)  ÃÂ´(q, a)  F (q)  F (q)  q Ã¢ÂˆÂˆ Qx  ÃÂ´x (q, a)  ÃÂ´x (q, a)  Fx (q)  Fx (q)  q Ã¢ÂˆÂˆ Qy  ÃÂ´y (q, a)  ÃÂ´y (q, a)  Fy (q)  Fy (q)  Sequential:  The  state  space  of  both  Ar;x : hÃÅ, Q, ÃÂ´, I, F i and Ar;x : hÃÅ, Q, ÃÂ´, I, F i are Qr Ã¢ÂˆÅQx .  The initial conditions are I = Ir and I = Ier . The transition  function is:  if  ÃÂ´(q, a)  ÃÂ´(q, a)  ÃÂ´er (q, a)  q 6Ã¢Â†Â’a Fr  ÃÂ´r (q, a)  q Ã¢Â†Â’a Fr  ÃÂ´r (q, a) Ã¢ÂˆÂ¨ Ix ÃÂ´er (q, a) Ã¢ÂˆÂ§ Ix  q Ã¢ÂˆÂˆ Qx  ÃÂ´x (q, a)  ÃÂ´x (q, a)  The acceptance condition is: for q Ã¢ÂˆÂˆ Qx then F (q) = Fx (q)  and F (q) = Fx (q). For q Ã¢ÂˆÂˆ Qr then F (q) = 1 and F (q) =  0.  Complementation: Consider now an RLTL subexpression x, with specular pair (Ax , Ax ). Since (w, i)   Ax if and only if (w, i) 6 Ax , it follows that (Ax , Ax ) is a  specular pair for Ã‚Å¹x.  IV. RLTL INTO APW USING S PECULAR PAIRS  Power: Let q0 be a fresh state, not present in Qx  or Qy . The state spaces of Ax|riiy : hÃÅ, Q, ÃÂ´, I, F i and  Ax|riiy : hÃÅ, Q, ÃÂ´, I, F i are Qr Ã¢ÂˆÅQx Ã¢ÂˆÅQy Ã¢ÂˆÅ{q0 }. The initial  conds. are I = q0 and I = q0 . For the transition relation:  if  ÃÂ´(q, a)  ÃÂ´(q, a)  q = q0  ÃÂ´(Iy Ã¢ÂˆÂ¨ (Ix Ã¢ÂˆÂ§ Ir ), a) ÃÂ´(Iy Ã¢ÂˆÂ§ (Ix Ã¢ÂˆÂ¨ Ir ), a)  q 6Ã¢Â†Â’a Fr  ÃÂ´r (q, a)  ÃÂ´er (q, a)  q Ã¢Â†Â’a Fr  ÃÂ´r (q, a) Ã¢ÂˆÂ¨ q0  ÃÂ´er (q, a) Ã¢ÂˆÂ§ q0  q Ã¢ÂˆÂˆ Qx  ÃÂ´x (q, a)  ÃÂ´x (q, a)  q Ã¢ÂˆÂˆ Qy  ÃÂ´y (q, a)  ÃÂ´y (q, a)  We present here a translation of RLTL expressions into  APW{0, 1, 2} based on Theorem 2. The main idea is to  generate, at each step, a specular automata pair with the first  automaton accepting the same language as the expression.  By duality, the specular automaton accepts the complement  language. Handling logical negation becomes trivial: one  simply needs to switch the elements of the pair.  A previous translation of RLTL presented in [2] needed  n colors (n being the size of the formula) instead of 3.  For the acceptance condition:  if  F (q)  F (q)  q Ã¢ÂˆÂˆ Qx  Fx (q) Fx (q)  Fy (q) Fy (q)  q Ã¢ÂˆÂˆ Qy  0  q Ã¢ÂˆÂˆ Qr or q = q0 1  Even though the frame of these automata could have been  defined without introducing q0 (by cleverly choosing I and  ÃÂ´), the introduction of q0 is justified by the necessity to  distinguish in the acceptance condition traces that visit q0  infinitely often versus traces that get trapped in Qr .  Weak Power: Again, the state spaces of both Ax|riy :  hÃÅ, Q, ÃÂ´, I, F i and Ax|riy : hÃÅ, Q, ÃÂ´, I, F i is Qr Ã¢ÂˆÅQx Ã¢ÂˆÅQy Ã¢ÂˆÅ  {q0 } for a fresh state q0 . For the initial condition I = q0  and I = q0 . The transition relation and acceptance condition  are exactly the same as for the Power operator except for  the following cases:  (  (  1 if q = q0  2 if q = q0  F (q) =  F (q) =  0 if q Ã¢ÂˆÂˆ Qr  1 if q Ã¢ÂˆÂˆ Qr  Theorem 3 Let ÄÂ• be an RLTL expression and AÄÂ• be the  automaton obtained using the construction described in this  section. Then, L(ÄÂ•) = L(AÄÂ• ).  The proof of Theorem 3 is greatly simplified by Theorem 2 because at every stage the construction builds  automata with specular frame, so one only needs to reason  about the acceptance of traces that get trapped in SCCs  formed by the freshly added states. The construction also  satisfies two important properties:  1) each stage introduces a new stratum (SCC) that cannot  be reached from strata added in previous stages. That is,  traces that move to the automaton of a sub-expression  do not visit the stratum added for the containing expression.  2) The stratum at each stage is decorated only with color  0 (an accepting stratum), only with color 1 (a rejecting  stratum), only with colors 0 and 1 (a coBuÄšÂˆchi stratum)  or only with colors 1 and 2 (a BuÄšÂˆchi stratum).  These two observations imply that the automaton has the  particular structure of a stratified ASW{1} or equivalently  of hesitant automaton AHW. We show in Section V how to  efficiently translate these automata into NBW using a refined  version of Streett rankings.  A Universal Sequential Operator: In the previous  construction, we observe that the specular automaton for  the sequential operator r ; x describes the set of traces in  which Ã¢Â€Âœall occurrences of r (if any) are followed by failing  occurrences of xÃ¢Â€Â. This observation inspires the introduction  of the universal sequential operator r Ã‚Ë‡ x, whose semantics  is:  Ã¢Â€Ë˜ (w, i)  r Ã‚Ë‡ x iff forall k s.t. (w, i, k) RE r, (w, k)  x.  The translation of r Ã‚Ë‡ x is precisely Ar;Ã‚Å¹x above, and the  specular automaton is exactly Ar;Ã‚Å¹x . Note that the stratum  corresponding to r in ArÃ‚Ë‡x has a universal frame, obtained  by dualizing the non-deterministic transition relation of Nr .  The duality laws Ã‚Å¹(r ; x) Ã¢Â‰Ä„ r Ã‚Ë‡ Ã‚Å¹x and Ã‚Å¹(r Ã‚Ë‡ x) Ã¢Â‰Ä„ r ; Ã‚Å¹x  hold immediately.  Universal Power Operators: Similarly, we define new  operators xkriiy and xkriy, duals of x|riy and x|riiy,  respectively. These new operators force repetitions to hold  at all possible delays, instead of at some possible delay. The  semantics are:  Ã¢Â€Ë˜ (w, i)  xkriiy iff (w, i)  y and for all seq (i =  i0 , . . . , im ) with (w, ik , ik+1 ) RE r, either (w, ij )  x  for some j Ã¢Â‰Â¤ k or (w, ik+1 )  y, and for all infinite seq  (i = i0 , i1 . . .) with (w, ik , ik+1 ) RE r and (w, ik )  y,  there is an m with (w, im )  x.  Ã¢Â€Ë˜ (w, i)  xkriy iff (w, i)  xkriiy, or (w, i)  y and  for all k and j with (w, i, j) RE rk then (w, j)  y.  The translation of xkriiy is Ax|riy (the dual being  Axkriiy = Ax|riy ), and the translation of xkriy is the pair  (Ax|riiy , Ax|riiy ). The following duality laws hold:  Ã‚Å¹(x|riiy) Ã¢Â‰Ä„ Ã‚Å¹xkriÃ‚Å¹y  Ã‚Å¹(x|riy) Ã¢Â‰Ä„ Ã‚Å¹xkriiÃ‚Å¹y  Ã‚Å¹(xkriy) Ã¢Â‰Ä„ Ã‚Å¹x|riiÃ‚Å¹y  Ã‚Å¹(xkriiy) Ã¢Â‰Ä„ Ã‚Å¹x|riÃ‚Å¹y  (1)  (2)  Finally, x Ã¢ÂˆÂ§ y is defined with translation (AxÃ¢ÂˆÂ¨y , AxÃ¢ÂˆÂ¨y ). The  deMorgan laws hold: (Ã‚Å¹Ã‚Å¹x Ã¢Â‰Ä„ x), (Ã‚Å¹(x Ã¢ÂˆÂ¨ y) Ã¢Â‰Ä„Ã‚Å¹x Ã¢ÂˆÂ§Ã‚Å¹y) and  (Ã‚Å¹(x Ã¢ÂˆÂ§ y) Ã¢Â‰Ä„Ã‚Å¹x Ã¢ÂˆÂ¨Ã‚Å¹y).  Orienting these duality laws from left to right allows  to push logical negation Ã‚Å¹ to the propositional level, so  RLTL extended with these operators admits a negation  normal form. Note that this negation normal form is obtained  after the translation by specular pairs. It does not follow  immediately that the existence of such a normal form enables  a translation into automata with weak acceptance condition,  because one has to show translations for the new operators,  including essentially all elements of pairs in the translation  of RLTL presented above.  V. F ROM S TRATIFIED ASW{1} INTO NBW  This section shows how to translate the alternating automata obtained in Section IV into NBW. We first revisit  the notion of Streett ranking from [10], which in turn is  based on the notion of coBuÄšÂˆchi ranking [15]. Then, we refine  rankings to exploit the stratification of the automata obtained  as a result of the translation from RLTL. We first show a  general translation of ASW{1} into NBW.  Rankings for ASW{1}: We use [k] an abbreviation for  the set {0 . . . k}. The following definitions assume a given  ASW{1} automaton A with n states, acceptance condition  (B, G), a word w Ã¢ÂˆÂˆ ÃÅÄÂ‰ and a run G : (V, E) of A on w.  Definition 4 An S{1}-ranking is a function f : V Ä‚Â— N Ã¢Â†Â’  [2n] that satisfies: (i) if q Ã¢ÂˆÂˆ B then f (hq, li) is even, (ii) for  all hq, li Ã¢Â†Â’ hq 0 , l0 i in E, either q Ã¢ÂˆÂˆ G or f (hq, li) Ã¢Â‰Ä½  f (hq 0 , l0 i).  It follows that for every path ÄÂ€ on a run DAG G, either ÄÂ€  visits infinitely often G states or, after some prefix, condition  (ii) applies continuously. Hence, since the image of f is  bounded, the value of f converges to a value: there is a  number l, such that, for every l0 > l, f (ÄÂ€(l0 )) = f (ÄÂ€(l)).  The following definition of odd S{1}-ranking relates the  convergence to an odd value with the fact that B states  are visited only finitely often. Then, the construction of the  NBW below is justified by Lemma 6.  Definition 5 (odd S{1}-ranking) An S{1}-ranking is odd  whenever, for every path ÄÂ€ of G, either (i) ÄÂ€ visits infinitely  often G states, or (ii) f converges to an odd value on ÄÂ€.  Lemma 6 G is an accepting run iff there is an odd  S{1}-ranking for G.  An equivalent NBW: We describe here the translation  from ASW{1} into NBW. The main idea is to encode in  the states of the NBW cuts of a run DAG of the ASW{1},  decorated with enough information to check whether an oddranking exists. In particular, each state of the alternating  automaton present in a given state of the NBW is labeled  with a ranking value. This annotation must respect the  definition of ranking (Def. 4). Additionally, the set of states  of the ASW{1} that form a state of the NBW are partitioned  into those that owe an improvement in the ranking (either  a visit to a G state or a decrease in the ranking), and those  that already showed improvement. Membership to the owe  set is propagated, so an accepting state is one in which all  constituent states have seen some progress since the last  accepting state. After an accepting state, the owe set is reset.  Formally, we start from an ASW{1} automaton A :  hÃÅ, QA , IA , ÃÂ´A , {(B, G)}i and we build an NBW N :  hÃÅ, QN , IN , ÃÂ´N , FN i as follows:  Ã¢Â€Ë˜ QN contains elements of the form (S, O, f ) where S Ã¢ÂŠÂ†  QA is a subset of states of A, O Ã¢ÂŠÂ† S, and f : S Ã¢Â†Â’ [2n]  is a function that satisfies:  Q1. if q Ã¢ÂˆÂˆ B then f (q) is even.  Ã¢Â€Ë˜ IN contains all those (M, O, f ) Ã¢ÂˆÂˆ QN where  I1. M is a minimal model of IA and O = {q Ã¢ÂˆÂˆ  M |qÃ¢ÂˆÂˆ  / G and f (q) is even}.  Ã¢Â€Ë˜ FN = {(S, O, f ) Ã¢ÂˆÂˆ QN | O = Ã¢ÂˆÂ…}.  Q  0  0  0  Ã¢Â€Ë˜ ÃÂ´N : QN Ä‚Â— ÃÅ Ã¢Â†Â’ 2 N , such that (S , O , f ) Ã¢ÂˆÂˆ  ÃÂ´N ((S, O, f ), a) whenever there is one minimal model  Mq of ÃÂ´A (q, a) for each q Ã¢ÂˆÂˆ S satisfying:  D1. S 0 = Ã¢ÂˆÅqÃ¢ÂˆÂˆS Mq ,  D2. For all p Ã¢ÂˆÂˆ S 0 , the rank annotation f 0 (p) Ã¢Â‰Â¤  min{f (q) | q Ã¢ÂˆÂˆ pred(p) \ G} where pred(p) = {q Ã¢ÂˆÂˆ  S | p Ã¢ÂˆÂˆ Mq } denotes the set of predecessors of p.  D3. O0 is given as follows. Let p Ã¢ÂˆÂˆ S 0 \ G, we have  Ã¢Â€Ë˜ If O = Ã¢ÂˆÂ… then p Ã¢ÂˆÂˆ O0 iff f 0 (p) is even.  Ã¢Â€Ë˜ If O 6= Ã¢ÂˆÂ… then p Ã¢ÂˆÂˆ O0 iff f 0 (p) = f (q)  for some q Ã¢ÂˆÂˆ (pred(p) Ã¢ÂˆÅ  O).  The states of N consist of a set S representing elements  of a cut of a run DAG of A. The function f represents  an S{1}-ranking, where Q1 guarantees that no B node  receives an odd value, and D2 guarantees the non-increasing  condition of rankings. Condition D1 ensures that successor  states of N correspond to legal successor cuts of a run of A.  Finally, condition D3 ensures that O contains those vertices  of the run DAG that have not seen progress for some path  leading to them, where progress is defined as visiting a G  state, or experiencing a decrease in f . A reset of this check is  represented by a final state, which can happen only when all  paths to all states contain some progress, as captured by FN .  Finally, I1 captures that the initial states of N correspond  to initial cuts of runs of A. All these facts imply that a  successful run DAG of A is matched by a successful run of  N.  Theorem 7 Let A be an ASW{1} and N the corresponding  NBW. Then w Ã¢ÂˆÂˆ L(A) if and only if w Ã¢ÂˆÂˆ L(N ).  The automaton obtained can be easily pruned with one  simple observation: if there is an odd S{1}-ranking, then  there is an odd S{1}-ranking where all decreases (according  to D2) only drop to the highest legal value. That is:  (  M or M Ã¢ÂˆÂ’ 1 if p Ã¢ÂˆÂˆ  /B  0  f (p) =  M or M Ã¢ÂˆÂ’ 2 if p Ã¢ÂˆÂˆ B  where M = min{f (q) | q Ã¢ÂˆÂˆ pred(p) \ G}.  This observation reduces the guessing in f to only two  possibilities, providing a more efficient translation. The  next paragraphs exploit the internal structure of stratified  ASW{1} automata to introduce a faster solution, specific  for the particular case of AHW.  Rankings for Stratified ASW{1}: Consider a stratified  ASW{1}. This is an automaton for which Q is divided into  strata (S1 , . . . , Sk ) ordered according to <, and each stratum  is labeled by a function ÃÄ… as either BuÄšÂˆchi (all states are  either B or G) or coBuÄšÂˆchi (no state is G). The stratification  structure implies that for every q Ã¢ÂˆÂˆ Si and successor p with  p Ã¢ÂˆÂˆ Sj , either Sj = Si or Sj < Si .  Remark: This automaton is equivalent to an AHW with  H = h(S1 , . . . , Sk ), <, ÃÄ…i and  F =  [  i  {Si Ã¢ÂˆÅ  G | if Si is BuÄšÂˆchi} Ã¢ÂˆÅ  [  {Si Ã¢ÂˆÅ  B | if Si is coBuÄšÂˆchi}  i  We use mj = |Sj | to refer to the number of states in stratum Sj . We first define the notion of stratified S{1}-ranking:  Definition 8 A stratified S{1}-ranking is a family of functions fj : Sj Ä‚Â— N Ã¢Â†Â’ [2mj ] that satisfies: (i) if q Ã¢ÂˆÂˆ Sj Ã¢ÂˆÅ  B  then fj (hq, li) is even, (ii) for every hq, li Ã¢Â†Â’ hq 0 , l0 i in E  with q, q 0 Ã¢ÂˆÂˆ Sj , then fj (hq, li) Ã¢Â‰Ä½ fj (hq 0 , l0 i), unless q Ã¢ÂˆÂˆ G.  Intuitively, a stratified ASW{1} ranking is like an  ASW{1} ranking except values need not decrease when  moving across strata. Due to the stratification, every trace of  a run gets trapped in a stratum of the automaton. Once the  trace converges to a stratum, either the trace visits infinitely  many good nodes, or the ranking converges to a single value.  Again, the notion of odd ranking captures whether the suffix  traces are accepting.  Definition 9 A stratified S{1}-ranking is odd whenever, for  every infinite path ÄÂ€ of G, either (i) ÄÂ€ visits infinitely often G  states, or (ii) ÄÂ€ gets trapped in stratum Sj and fj converges  to an odd value on ÄÂ€.  The following lemma justifies the construction of NBW  using stratified rankings.  Lemma 10 G is an accepting run iff there is a stratified  odd S{1}-ranking for G.  Stratified rankings drastically limit the guessing that is  necessary in the construction of the states of the NBW,  because each ranking is local to the stratum under consideration. The following choices produce a good ranking for  stratum Sj , if there is one such a good ranking  G1. If Sj is an accepting stratum and qj Ã¢ÂˆÂˆ Sj , fj (qj ) = 1.  G2. If Sj is a rejecting stratum and qj Ã¢ÂˆÂˆ Sj , fj (qj ) = 2.  G3. If Sj is BuÄšÂˆchi, then assign fj (qj ) = 2 to qj Ã¢ÂˆÂˆ B, and  fj (qj ) = 1 to qj Ã¢ÂˆÂˆ G.  G4. If Sj is coBuÄšÂˆchi then fj (qj ) Ã¢ÂˆÂˆ [2mj ].  Note that this restriction eliminates the guessing except  for coBuÄšÂˆchi strata, and consequently ranking guessing only  happens to the states of Nr in expressions xkriiy. In terms  of the LTL fragment, all delays are one step so the size of  |Nr | = 1 and hence the maximum size of the coBuÄšÂˆchi strata  is 1. In fact, for LTL sub-expressions of the form xkriiy,  Nr consists of a single B state, which can be assigned  value 2. Consequently, following the steps in this paper LTL  expressions get translated into NBW of size 2O(n) .  An equivalent NBW using Stratified Rankings:  We refine the construction for general ASW{1} rankings,  limiting the guesses using G1-G4. Also, only predecessors  within the same stratum are considered when computing f :  Q1s. if q Ã¢ÂˆÂˆ Sj Ã¢ÂˆÅ  B then fj (q) is even.  D2s. fj0 (p) Ã¢Â‰Â¤ min{fj (q) | q Ã¢ÂˆÂˆ pred(p) \ G} where  pred(p) = {q Ã¢ÂˆÂˆ Sj | p Ã¢ÂˆÂˆ Mq } now only considers  predecessors from the same stratum.  D3s. O0 is given as follows. Let p Ã¢ÂˆÂˆ Sj0 \ G, we have  Ã¢Â€Ë˜ If O = Ã¢ÂˆÂ… then p Ã¢ÂˆÂˆ O0 iff fj0 (p) is even.  Ã¢Â€Ë˜ If O 6= Ã¢ÂˆÂ… then p Ã¢ÂˆÂˆ O0 iff fj0 (p) = fj (q)  for some q Ã¢ÂˆÂˆ (pred(p) Ã¢ÂˆÅ  O Ã¢ÂˆÅ  Sj ).  Theorem 11 Let A be a stratified ASW{1} and N the corresponding NBW using stratified rankings. Then w Ã¢ÂˆÂˆ L(A)  if and only if w Ã¢ÂˆÂˆ L(N ).  VI. E MPIRICAL E VALUATION  This section reports the result of an empirical evaluation  of the translation algorithms presented above. The evaluation  was performed using a sequential implementation written in  OCaml, available online at [16]. The running times reported  in Fig. 1 were obtained using an Intel Core2 @ 2.83GHz  with 8GB of RAM running a 64 bit Linux kernel. Fig. 1  compares the number of states and the running time used  to compute explicit NBW representations of two families of  formulas (and their negation), for i = 8, 11, 17, 20. These  choices are inspired by [8]:    Ã¢Â€Ë˜ Ai  =  p1 U (p2 U (. . . U pi ) . . . . The expression Ai is equivalent  to the RLTL expression    p1 |trueii p2 |trueii. . . .    5  5  5  Ã¢Â€Ë˜ Bi = p1 |true ii p2 |true ii. . . , where true stands  for a five instant delay true ; true ; true ; true ; true.  These are not expressible in LTL.  The table illustrates that the general ASW{1} ranking is  only practical for the smallest cases. Limiting the guessing  to the highest ranks allows to handle slightly larger formulas. The stratified ranking translation results in a dramatic  improvement, comparable to state of the art LTL translators,  particularly considering that our prototype does not use  simulations or handle propositional alphabets (only discrete  alphabets). Simulation reductions have been reported [8] to  be a very effective method to reduce the size of the NBW  generated, but this optimization is currently ongoing work.  VII. C ONCLUSIONS AND F UTURE W ORK  This paper has presented a novel translation from the  logic RLTL into alternating parity automata using only  colors 0, 1 and 2, based on a bottom-up construction of  specular pairs accepting complement languages. Inspired by  the duality in the translation we introduce universal sequential operators that enrich the logic with negation normal  forms. We also show that the resulting automata enjoy some  stratified structure in their transition relation that makes all  their strata purely BuÄšÂˆchi or coBuÄšÂˆchi. These automata are  equivalent to hesitant automata. Then, we study translations  of the resulting automata into NBW. The main result is the  specialization of Street rankings to stratified automata to  obtain a more efficient ranking translation. Unlike [11] our  construction preserves the alphabet between the alternating  automaton an the NBW. We are currently investigating alternative algorithms for model-checking RLTL specifications  based on bounded model checking [17], antichains [18] and  IC3 [19].  R EFERENCES  [1] M. Leucker and C. SaÄšÂnchez, Ã¢Â€ÂœRegular linear temporal logic,Ã¢Â€Â  in Proc. of ICTACÃ¢Â€Â™07, ser. LNCS, vol. 4711. Springer, 2007,  pp. 291Ã¢Â€Â“305.  [2] C. SaÄšÂnchez and M. Leucker, Ã¢Â€ÂœRegular linear temporal logic  with past,Ã¢Â€Â in Proc. of VMCAIÃ¢Â€Â™10, ser. LNCS, vol. 5944.  Springer, 2010, pp. 295Ã¢Â€Â“311.  size  A8  A11  A17  A20  Ã‚Å¹A8  Ã‚Å¹A11  Ã‚Å¹A17  Ã‚Å¹A20  B8  B11  B17  B20  Ã‚Å¹B8  Ã‚Å¹B11  Ã‚Å¹B17  Ã‚Å¹B20  APW  time(s)  7  0.048  10  0.172  16  0.936  19  1.796  7  0.048  10  0.172  16  0.940  19  1.792  35  0.268  50  1.084  80  5.064  95  10.041  35  0.268  50  0.908  80  5.072  95  9.753  Figure 1.  NBW (direct)  size  time(s)  93  0.128  192  0.504  498  3.680  705  8.149  142  0.252  292  1.140  754  10.545  1066  25.718  2417  50.103  4952  360.571  12722  1h56m  17957  8h32m  3642  209.157  7452  26m56s  19122  18h15m  26982  58h8m  NBW (max2)  size  time(s)  93  0.100  192  0.336  498  1.700  705  3.184  100  0.100  202  0.336  514  1.688  724  3.160  2417  5.936  4952  26.846  12722  217.698  17957  598.129  2452  5.704  5002  25.106  12802  220.762  18052  674.070  NBW (strat)  size  time(s)  9  0.052  12  0.176  18  0.952  21  1.816  9  0.052  12  0.172  18  0.948  21  1.884  37  0.296  52  0.952  82  5.200  97  9.897  37  0.300  52  0.956  82  5.192  97  9.905  Number of states and running time to compute an APW{0, 1, 2} and an NBW.  [3] A. Pnueli, Ã¢Â€ÂœThe temporal logic of programs,Ã¢Â€Â in Proc. of  FOCSÃ¢Â€Â™77. IEEE CS Press, 1977, pp. 46Ã¢Â€Â“67.  [4] Z. Manna and A. Pnueli, Temporal Verification of Reactive  Systems. Springer-Verlag, 1995.  [5] D. E. Muller and P. E. Schupp, Ã¢Â€ÂœAltenating automata on  infinite trees,Ã¢Â€Â Theoretical Computer Science, vol. 54, pp.  267Ã¢Â€Â“276, 1987.  [6] W. Thomas, Ã¢Â€ÂœComplementation of BuÄšÂˆchi automata revisited,Ã¢Â€Â  in Jewels are Forever, Contributions on TCS in Honor of Arto  Salomaa. Springer, 1999, pp. 109Ã¢Â€Â“120.  [7] O. Kupferman and M. Y. Vardi, Ã¢Â€ÂœWeak alternating automata  are not that weak,Ã¢Â€Â ACM Transactions on Computational  Logic, vol. 2, no. 3, pp. 408Ã¢Â€Â“429, 2001.  [8] P. Gastin and D. Oddoux, Ã¢Â€ÂœFast LTL to BuÄšÂˆchi automata  translation,Ã¢Â€Â in Proc. of CAVÃ¢Â€Â™01, ser. LNCS, vol. 2102.  Springer, 2001, pp. 53Ã¢Â€Â“65.  [9] C. Dax and F. Klaedtke, Ã¢Â€ÂœAlternation elimination by complementation,Ã¢Â€Â in Proc. of LPARÃ¢Â€Â™08, ser. LNCS, vol. 5530.  Springer, 2008, pp. 214Ã¢Â€Â“229.  [10] O. Kupferman and M. Y. Vardi, Ã¢Â€ÂœComplementation constructions for nondeterministic automata on infinite words,Ã¢Â€Â in  Proc. of TACASÃ¢Â€Â™05, ser. LNCS, vol. 3440. Springer, 2005,  pp. 206Ã¢Â€Â“221.  [11] O. Kupferman, N. Piterman, and M. Y. Vardi, Ã¢Â€ÂœExtended temporal logic revisited,Ã¢Â€Â in Proc. of CONCURÃ¢Â€Â™01, ser. LNCS,  vol. 2154. Springer, 2001, pp. 519Ã¢Â€Â“535.  [12] D. Fisman, C. Eisner, and J. Havlicek, Formal syntax and  Semantics of PSL: App. B of Accellera Property Language  Ref. Manual, Ver. 1.1, March 2004.  [13] A. Armando, S. Ranise, and M. Rusinowitch, Ã¢Â€ÂœA rewriting  approach to satisfiability procedures,Ã¢Â€Â Information and Computation, vol. 183, no. 2, pp. 140Ã¢Â€Â“164, 2003.  [14] P. Wolper, Ã¢Â€ÂœTemporal logic can be more expressive,Ã¢Â€Â Information and Control, vol. 56, pp. 72Ã¢Â€Â“99, 1983.  [15] O. Kupferman and M. Y. Vardi, Ã¢Â€ÂœFrom complementation to  certification,Ã¢Â€Â in Proc. of TACASÃ¢Â€Â™04, ser. LNCS, vol. 2988.  Springer, 2004, pp. 591Ã¢Â€Â“606.  [16] http://software.imdea.org/rounded/.  [17] A. Biere, A. Cimatti, E. M. Clarke, and Y. Zhu, Ã¢Â€ÂœSymbolic  model checking without BDDs,Ã¢Â€Â in Proc. of TACASÃ¢Â€Â™99, ser.  LNCS. Springer, 1999, pp. 193Ã¢Â€Â“207.  [18] M. D. Wulf, L. Doyen, N. Maquet, and J.-F. Raskin, Ã¢Â€ÂœAntichains: Alternative algorithms for LTL satisfiability and  model-checking,Ã¢Â€Â in Proc. of TACASÃ¢Â€Â™08, ser. LNCS, vol.  4693. Springer, 2008, pp. 63Ã¢Â€Â“77.  [19] A. R. Bradley, Ã¢Â€ÂœSAT-based model checking without unrolling,Ã¢Â€Â in Proc. of VMCAIÃ¢Â€Â™11, ser. LNCS, vol. 6538.  Springer, 2011, pp. 70Ã¢Â€Â“87.  A PPENDIX  This section shows a self-contained proof of Theorem 2.  Positive Boolean Formulas:: Every positive boolean  formula can be expressed in disjunctive normal form, as  disjunction of conjunctions of propositions. Given a positive  boolean formula ÃÂ¸ there is a dual formula ÃÂ¸e obtained by  switching Ã¢ÂˆÂ§ and Ã¢ÂˆÂ¨, and switching true and false. Some  easy properties of dual formulas are:  e and for every  Proposition 12 (Duals) For every ÃÂ¸ and ÃÂ¸,  M Ã¢ÂˆÂˆ Mod (ÃÂ¸):  e M Ã¢ÂˆÅ  M 0 6= Ã¢ÂˆÂ….  1) For every M 0 Ã¢ÂˆÂˆ Mod (ÃÂ¸),  e with q Ã¢ÂˆÂˆ M 0 .  2) Let q Ã¢ÂˆÂˆ M . There is an M 0 in Mod (ÃÂ¸)  For example, the dual of ÃÂ¸1 above is ÃÂ¸e1 = (q1 Ã¢ÂˆÂ¨ q2 ) Ã¢ÂˆÂ§  q3 , or equivalently in disjunctive normal form ÃÂ¸e1 = (q1 Ã¢ÂˆÂ§  q3 ) Ã¢ÂˆÂ¨ (q2 Ã¢ÂˆÂ§ q3 ). The minimal models of ÃÂ¸e1 are {q1 , q3 } and  {q2 , q3 }.  A choice function is a map f that chooses, for a model  M of ÃÂ¸ an element of M , i.e., f : Mod (ÃÂ¸) Ã¢Â†Â’ X such  f (M ) Ã¢ÂˆÂˆ M . Some interesting properties of choice functions  follow:  Proposition 13 (Choice Functions) Let ÃÂ¸ be a formula  and ÃÂ¸e its dual. Then  e  1) If f is a choice function for ÃÂ¸, then Img f Ã¢ÂˆÂˆ Mod (ÃÂ¸).  2) If M Ã¢ÂˆÂˆ mod (ÃÂ¸) then there is a choice function f of ÃÂ¸e  such that Img f = M .  Proof: We prove 13.1 first. Consider ÃÂ¸ in disjunctive  normal form. Each child subexpression of the root expression corresponds to a conjunction of states that form a  model. The choice function f chooses one state from each  model of ÃÂ¸. Expressing ÃÂ¸e dualy, each child subexpression of  ÃÂ¸ is a disjunction of the corresponding set of states. Hence,  the element that f chooses in each child    S satisfies the corresponding disjunction, and Img f = M Ã¢ÂˆÂˆMod(ÃÂ¸) f (M ) is  e  a model of ÃÂ¸.  We now show 13.2. Let M be a minimal model of ÃÂ¸.  Consider an arbitrary choice function f for ÃÂ¸e with:  f (M 0 ) = q for some q Ã¢ÂˆÂˆ M Ã¢ÂˆÅ  M 0 .  By Prop. 12.1 for any M 0 there is one such q, so f is well  defined, and by construction Img f Ã¢ÂŠÂ† M . By Prop. 13.1  Img f is a model of ÃÂ¸, and since M is a minimal model it  has no proper sub-model, so Img f = M .    Automata and Games: We show now that specular  automata accept complement languages, using game theory.  From a given automaton A and a word w, we create a  parity game called a word game as a tuple G(A, w) :  hVA , VP , EA , EP , f i where:  VA = Q Ä‚Â— ÄÂ‰  VP = {(M, q, i) | M Ã¢ÂˆÂˆ Mod (ÃÂ´(q, w[i]))}  Ã¢ÂˆÅ {(M, Ã‚Ë‡, 0) | M Ã¢ÂˆÂˆ Mod (I)}  EA = (q, i) Ã¢Â†Â’ (M, q, i) for each M Ã¢ÂˆÂˆ Mod (ÃÂ´(q, w[i]))  EP = (M, q, i) Ã¢Â†Â’ (q 0 , i + 1) for q 0 Ã¢ÂˆÂˆ M  The game is played by two players: Automaton (A) and  Pathfinder (P ). The set of positions V = VA Ã¢ÂˆÅ VP is  partitioned into positions in which A plays and those in  which P plays. The game begins by A choosing a model  of I, which determines the initial position (M, Ã‚Ë‡, 0) (here Ã‚Ë‡  represent an irrelevant state). The legal moves of the game  are captured by the relation E = EA Ã¢ÂˆÅEP which correspond  to A choosing a model from a VA position, and P choosing  the next successor from a given model from a VP position.  A play is an infinite sequence of positions ÄÂ€ : V0 v0 V1 v1 . . .  with V0 being an initial position, vi obtained from Vi by a P  move, and Vi+1 obtained from vi by an A move. The map  f : V Ã¢Â†Â’ {0 . . . d} determines the outcome of a play. We  define the trace of a play ÄÂ€ : V0 v0 V1 v1 . . . as the sequence  of states trace(ÄÂ€) : p0 p1 . . . obtained by projecting the first  component of the VP positions of the play (i.e., vi = (pi , i)).  The following follows directly from the definition:  Proposition 14 Every trace of a play of G(A, w) is also a  trace of some run of A on w.  As for parity automata the outcome of a play is determined by the highest color that is seen infinitely often in  the play. Player A wins play ÄÂ€ whenever:  max{f (q) | q Ã¢ÂˆÂˆ inf(trace(ÄÂ€))} is even  Otherwise, P wins play ÄÂ€. A strategy for player A is a map  ÄÂA : (V Ã¢ÂˆÂ— VA Ã¢ÂˆÅ ) Ã¢Â†Â’ V , that maps histories of positions into  moves. Here,  denotes the empty sequence of positions, to  let player A choose an initial state in the game. A memoryless strategy simply takes into account the last position:  ÄÂA : VA Ã¢ÂˆÅ  Ã¢Â†Â’ V . Since parity games are memoryless  determined it is enough to consider memoryless strategies.  Similarly, a strategy for player P is a map ÄÂP : VP Ã¢Â†Â’ V .  A play ÄÂ€ : V0 v0 V1 v1 . . . is played according to strategy ÄÂA  whenever the initial position is V0 = ÄÂA () and all moves of  A are played according to it Vi = ÄÂA (vi ). A strategy ÄÂA is  winning for player A whenever all plays played according  to ÄÂA are winning for A. Memoryless determinacy of parity  games guarantees that either player A has a memoryless  winning strategy or player P has a memoryless winning  strategy. We say that ÄÂ€ is a G Ã‚Ë‡ ÄÂA play whenever ÄÂ€ is  played in G according to ÄÂA .  We restrict our attention to strategies for A that choose  minimal models, and strategies for P that are proper choice  functions. This is not a drastic restriction. Clearly, if there  is a winning strategy for A that does not choose a minimal  model, then any strategy that chooses a smaller minimal  model is also winning. This is because the set of plays is  reduced, and all plays in the unrestricted set are winning for  A. Similarly, if ÄÂP is a winning strategy for P , then restricting its moves to be a proper choice functions (by restricting  the image) also gives a winning strategy. In both cases, the  set of successor moves is restricted but still confined within  winning regions. This lemma is essentially Prop. 2 from  [6], where complementation of weak alternation automata  by dualization is studied.  of the form (q, i) Ã¢Â†Â’ (q 0 , i + 1) for all q 0 Ã¢ÂˆÂˆ M . We have to  show that ÄÂƒ is successful run. We show by induction that all  traces of ÄÂƒ correspond to plays in G(A, w) played according  to ÄÂA . For the base case (q, 0) is the initial state of the  trace. By construction (q, 0) Ã¢ÂˆÂˆ ÄÂA () so (q, 0) is a possible  choice of player P , and consequently a play prefix. For  the inductive case, assume that trace prefix (q0 , 0) . . . (qi , i)  is a play prefix, and let (qi , i) Ã¢Â†Â’ (qi+1 , i + 1) be in EÄÂƒ .  By construction ÄÂA (qi , i) contains position (qi+1 , i + 1) so  player P can again move to it. This shows that the arbitrary  trace of ÄÂƒ correspond to a play played according to ÄÂA .   Lemma 15 w Ã¢ÂˆÂˆ L(A) if and only if A has a winning  strategy in G(A, w).  Specular Pairs and Complementation: We show now  that specular automata accept complement languages. In the  rest of the section we let A and Ae be a specular automata  e : G(A,  e w) be the  pair, w be a word and G : G(A, w) and G  corresponding word games. First we need some preliminary  definitions.  Proof: Assume w Ã¢ÂˆÂˆ L(A) and let ÄÂƒ : (VÄÂƒ , EÄÂƒ ) be a  successful run of w on A. We first build a strategy ÄÂA for  A on G(A, w) and then show that ÄÂA is winning:  ÄÂA () = (M0 , Ã‚Ë‡, 0)  with M0 = {q | (q, 0) Ã¢ÂˆÂˆ VÄÂƒ }  ÄÂA (q, i) = (M, q, i + 1)  with M = {q 0 | (q, i) Ã¢Â†Â’ (q 0 , i + 1) Ã¢ÂˆÂˆ EÄÂƒ }  The set M in (M, q, i + 1) is a model of ÃÂ´(q, i) because  ÄÂƒ is a run. For positions (q, i) that do not appear in the  run ÄÂƒ, the strategy ÄÂA (q, i) = (M, q, i + 1) can assign any  model M in Mod (ÃÂ´(q, w[i])). This model is not relevant  because no play played according to ÄÂA will visit these  states. Consider now an arbitrary play ÄÂ€ : V0 v0 V1 v1 . . . of  G(A, w) played according to ÄÂA . We show by induction that  trace(ÄÂ€) : p0 p1 . . . is a trace of ÄÂƒ.  Ã¢Â€Ë˜ base: By construction M0 is the set of initial positions  of ÄÂƒ. Since p0 , chosen by player P , is v0 Ã¢ÂˆÂˆ M0 , then  v0 is a prefix of a trace of run ÄÂƒ.  Ã¢Â€Ë˜ induction step: assume p0 . . . pi is a prefix of some trace  in ÄÂƒ, so (pi , i) is in VÄÂƒ . Hence, ÄÂA (pi , i) = (M, pi , i +  1) for M being the set of successors of (pi , i) in EÄÂƒ .  Consequently pi+1 = (q, i + 1) for some (pi , i) Ã¢Â†Â’  (pi+1 , i + 1) in EÄÂƒ , so v0 . . . vi vi+1 is a longer prefix  of a trace of run in ÄÂƒ.  This shows that trace(ÄÂ€) is a trace of the run ÄÂƒ. Now,  since ÄÂƒ is a successful run all its traces must be accepting,  and then:  max{F (q) | q Ã¢ÂˆÂˆ inf(trace(ÄÂ€)} is even,  which shows that ÄÂA is a winning strategy for G(A, w).  We now show the other direction: we start from a winning  strategy ÄÂA for A in G(A, w) and show that there is a  successful run ÄÂƒ of w on A. Let (M, Ã‚Ë‡, 0) = ÄÂA (). Then  we let VÄÂƒ contain (q, 0) for all q Ã¢ÂˆÂˆ M . Note that M is  a minimal model of I. Now, consider an arbitrary position  (q, i) and let (M, q, i+1) be ÄÂA (q, i). We add to EÄÂƒ all pairs  Definition 16 We say that strategies ÄÂA (for A in G) and  e are duals whenever both:  ÄÂeP (for P in G)  e Ã‚Ë‡ ÄÂP play ÄÂ€  Ã¢Â€Ë˜ for every G Ã‚Ë‡ ÄÂA play ÄÂ€ there is a G  e s.t.  trace(e  ÄÂ€ ) = trace(ÄÂ€).  e Ã‚Ë‡ ÄÂP play ÄÂ€  Ã¢Â€Ë˜ for every G  e there is a G Ã‚Ë‡ ÄÂA play ÄÂ€ s.t.  trace(e  ÄÂ€ ) = trace(ÄÂ€).  Theorem 17 (Dual Strategies) The following holds:  (1) For every strategy ÄÂA for A in G, there is a dual strategy  e  ÄÂeP for P in G.  (2) For every ÄÂP for P in G, there is a dual strategy ÄÂeA  e  for A in G.  Proof: We prove the two statements separately:  (1): Let ÄÂA be a strategy for A in G. This strategy ÄÂA  is characterized by  ÄÂA () = (M0 , Ã‚Ë‡, 0)  where M0 Ã¢ÂˆÂˆ mod (I)  ÄÂA ((q, i)) = (M, q, i + 1) where M Ã¢ÂˆÂˆ mod (ÃÂ´(q, w[i]))  By Prop. 13.1 there are choice functions satisfying  e Ã¢Â†Â’Q  fM0 : Mod (I)  e a)) Ã¢Â†Â’ Q  fhM,q,ai : Mod (ÃÂ´(q,  Img fM0 = M0  Img fhM,q,ai = M  Moreover, these functions are proper choice functions. We  e as follows:  now define the dual strategy ÄÂeP for P in G  ÄÂeP ((N0 , Ã‚Ë‡, 0)) = (fM0 (N0 ), 0)  ÄÂeP ((N, q, i + 1)) = (fhM,q,ai (N ), q, i + 1)  where M is the move of A in G from (q, i): ÄÂA (q, i) =  (M, q, i + 1), and a = w[i]. Our choice of choice functions  fhM,q,ai guarantees that for every move of player P from  e that, when followed  M , there is a move for player A in G  by fhM,q,ai results in the same state. The properties of fM0  and fhM,q,ai ensure that the strategy ÄÂeP is proper.  We are ready to show that for every G Ã‚Ë‡ ÄÂA play there is  e Ã‚Ë‡ ÄÂP play with the same trace, and vice-versa.  aG  Ã¢Â€ÂœÃ¢Â†Â’Ã¢Â€Â Consider an arbitrary GÃ‚Ë‡ÄÂA play ÄÂ€ : V0 v0 V1 v1 . . ., and  let ÄÂA () = (M0 , Ã‚Ë‡, 0) and ÄÂA (vi ) = (Mi+1 , qi , i + 1).  We use qi for vi = (qi , i). Note that qi+1 Ã¢ÂˆÂˆ Mi+1  because all moves of player P in ÄÂ€ are legal moves. We  e Ã‚Ë‡ ÄÂP play ÄÂ€  f0 , ve0 , V  f1 , ve1 . . . as follows:  create the G  e:V  f  Ã¢Â€Â“ V0 = (N0 , Ã‚Ë‡, 0) where N0 is such that fM0 (N0 ) =  q0 . One such N0 exists since Img fM0 = M0 and  q0 Ã¢ÂˆÂˆ M0 (recall that (q0 , 0) is the result of a move  of P in G from (M0 , Ã‚Ë‡, 0)).  e the position  Ã¢Â€Â“ From (qi , i), player A chooses in G  (Ni+1 , qi , i + 1), where Ni+1 is chosen such that  fhMi+1 ,q,w[i]i = qi+1 .  By induction, we show that vi = vei . First, ve0 =  ÄÂeP ((N0 , Ã‚Ë‡, 0)) = (fM0 (N0 ), 0) = (q0 , 0) = v0 .  Now, assume that for some i, vi = vei . Then, Vei =  (Ni+1 , qi , i+1), and Vi = ÄÂA (qi , i) = (Mi+1 , qi , i+1).  Now,  vei+1 = ÄÂeP (Vei ) = ÄÂeP ((Ni+1 , qi , i + 1))  =  = (fhMi+1 ,qi ,w[i]i (Ni+1 ), i + 1) =  = (qi+1 , i + 1)  =  = vi+1 .  Hence, trace(ÄÂ€) = trace(e  ÄÂ€ ).  e Ã‚Ë‡ ÄÂP play ÄÂ€  Ã¢Â€ÂœÃ¢Â†ÂÃ¢Â€Â Consider an arbitrary G  e : Ve0 ve0 Ve1 ve1 . . .,  and let qi and Ni be such that:  vei = (qi , i) Ve0 = (N0 , Ã‚Ë‡, 0) Vei+1 = (Ni+1 , qi , i + 1)  e Ã‚Ë‡ ÄÂP play, it satisfies that  Since ÄÂ€  e is a G  vei+1 = ÄÂeP (Vei+1 ) = (fhMi+1 ,qi ,w[i]i (Ni+1 ), i + 1)  where Mi is obtained from ÄÂA (qi , i) = (Mi+1 , i + 1).  Now, we define the play ÄÂ€ : V0 v0 V1 v1 . . . as follows.  First the move for A is played according to ÄÂA :  V0 = ÄÂA () = (M0 , Ã‚Ë‡, 0)  Vi+1 = ÄÂA (vi )  with  g0 : Mod (I) Ã¢Â†Â’ Q  e  Img g0 Ã¢ÂˆÂˆ mod (I)  gq,i : Mod (ÃÂ´(q, w[i])) Ã¢Â†Â’ Q  e w[i]))  Img gq,i Ã¢ÂˆÂˆ mod (ÃÂ´(q,  (3)  e as follows:  We define the strategy ÄÂeA for A in G  ÄÂeA () = Img g0  ÄÂeA ((q, i)) = Img gq,i  By (3), ÄÂeA is well defined. We show now that ÄÂeA and  ÄÂP are dual strategies. First, consider (q, i) an arbitrary  state and (M, q, i) a legal move for player A in G.  Player P will move to (q 0 , i + 1) = ÄÂP ((M, q, i)) with  e player A will move from  q 0 = gq,i ((M, q, i)). In G,  e to  (q, i) into (Img gq,i , q, i). We let player P move in G  0  0  (q , i + 1), which is legal, since q Ã¢ÂˆÂˆ Img gq,i . Consider  e  now an arbitrary state (p, i) and the move of A in G:  ÄÂeA ((p, i)) = (Img gp,i , p, i), and consider an arbitrary  legal move for P , (p0 , i + 1), hence p0 Ã¢ÂˆÂˆ Img gp,i .  Consequently, there is an M Ã¢ÂˆÂˆ Mod (ÃÂ´(p, w[i])) such  that gp,i ((M, p, i)) = p0 . Let A choose (M, p, i) as the  move from (p, i), which is a legal move. Then, playing  from (M, p, i) in G according to ÄÂP , the resulting state  is (p0 , i + 1). This shows that ÄÂA and ÄÂeP are dual  strategies.  It is important to note that the moves of the players  playing against the strategies are not restricted to follow  proper strategies (give minimal models or be proper choice  functions). Still, ÄÂA is winning precisely whenever ÄÂP is.    The following theorem follows directly from Lemma 15  and Theorem 17. This theorem allows to reason about  complementation simply by reasoning about traces of two  automata with dual frames.  Then, we let the moves of P to be:  v0 = (q0 , 0)  vi+1 = (qi+1 , i + 1)  We only need to show that these moves for P are legal.  First, q0 = fM0 (N0 ), and since Img fM0 = M0 it  follows that q0 Ã¢ÂˆÂˆ M0 , so moving from V0 into v0 is a  legal move.  Moreover, (qi+1  = fhMi+1 ,qi ,w[i]i (Ni )). Since  Img fhMi+1 ,qi ,w[i]i = Mi+1 it follows that qi+1 Ã¢ÂˆÂˆ  Mi+1 , so again moving from Vi+1 into vi+1 is a legal  move. By construction, trace(ÄÂ€) = trace(e  ÄÂ€ ) again.  (2): Assume now that ÄÂP is a (proper) strategy for P  in G. The strategy ÄÂP is characterized by  ÄÂP ((M0 , Ã‚Ë‡, 0)) = (q0 , 0)  ÄÂP ((M, q, i)) = (qi , i)  Since the strategy is proper there are proper choice  functions:  g0 : Mod (I) Ã¢Â†Â’ Q  gq,i : Mod (ÃÂ´(q, w[i])) Ã¢Â†Â’ Q  Theorem 18 Let A and Ae be specular automata. Then  e  L(A) = ÃÅÄÂ‰ \ L(A).  We show the correctness of Streett ranking algorithm.  Lemma 19 Let G be an accepting run, and let G 0 be a nonempty sub-graph of G with no G vertices and only infinite  paths. Then, there is some node in G 0 that cannot access  any B node.  Proof: Consider, by contradiction that there is no one  such a node in G 0 = (V 0 , E 0 ), or equivalently, that all  vertices in G 0 can access a B node:  for all hq, li Ã¢ÂˆÂˆ V 0 , there is some hq 0 , l0 i Ã¢ÂˆÂˆ V 0  with q 0 Ã¢ÂˆÂˆ B and hq, li Ã¢Â†Â’Ã¢ÂˆÂ—E 0 hq 0 , l0 i.  Then, every node can be associated with a B node by  a map next(hq, li) that returns one path to a B reachable  node (for example, the shortest non-empty path to a B state,  and picking the smallest according to some lexicographic  order among the shortest ones.) Then using induction define,  starting from an arbitrary node hq, li Ã¢ÂˆÂˆ V 0 , an infinite  path in G 0 that visits infinitely B nodes infinitely often by  concatenating the paths returned by next. Let us call ÄÂ€ one  such path.  Since ÄÂ€(0) = hq, li is a node of G 0 , and consequently a  node of G, ÄÂ€(0) is reachable from some initial node by point  3 in the definition of a run. Let ÄÂ€pre be a finite path in G  from a node hq0 , 0i Ã¢ÂˆÂˆ V . The path ÄÂ€pre ÄÂ€ is a trace in G that  visits G nodes finitely often (only nodes in ÄÂ€pre can possibly  be G nodes) and B nodes infinitely often in ÄÂ€. This trace  contradicts that G is an accepting run.    We will use the following notation, for a given sub-graph  G 0 of a run:  def  access(G 0 , hq, li) = {hq 0 , l0 i | hq, li Ã¢Â†Â’Ã¢ÂˆÂ— hq 0 , l0 i}  0  def  0  finite(G ) = {hq, li | access(G , hq, li) is finite}  def  nobad(G 0 ) = {hq, li | access(G 0 , hq, li) Ã¢ÂˆÅ  B = Ã¢ÂˆÂ…}  def  width(G 0 , l) = |{hq, li Ã¢ÂˆÂˆ G 0 }|  Lemma 6 G is an accepting run iff there is an odd  S{1}-ranking for G.  Proof: We prove the two directions separately:  Ã¢Â€ÂœÃ¢Â‡ÂÃ¢Â€Â Assume there is an odd S{1}-ranking f for G and let ÄÂ€  be an arbitrary trace of G. Since, f is odd, either ÄÂ€ visits  infinitely many G states, in which case ÄÂ€ is accepting,  or f (ÄÂ€) converges to an odd value. In this second case,  there is l such that for all l0 > l, f (ÄÂ€(l0 )) = f (ÄÂ€(l)) and  f (ÄÂ€(l)) is odd. By definition of S{1}-ranking (point  (i)), ÄÂ€(l0 ) cannot be a B state, and consequently ÄÂ€ visits  only finitely many B states. Hence, ÄÂ€ is an accepting  trace.  Ã¢Â€ÂœÃ¢Â‡Â’Ã¢Â€Â Assume G is an accepting run for A.  Ã¢Â€Â“ Initial Stage The construction of f starts by removing from G all G vertices. Let VG be {hq, li | q Ã¢ÂˆÂˆ G},  then f (hq, li) = 0 for all hq, li Ã¢ÂˆÂˆ VG . Also, let  V0 = finite(G \ VG ), we let f (hq, li = 0 for all  hq, li Ã¢ÂˆÂˆ V0 . Also G0 = G \ (VG Ã¢ÂˆÅ V0 ), which contains  the original graph except the G nodes, and every  node that reach G nodes in all its outgoing paths.  Ã¢Â€Â“ Incremental Stage The algorithm proceeds in at  most n rounds, performing the following two operations in each round k. The round begins with  subgraph G2k of G.  Ã¢ÂˆÂ’ Phase I: Let V2k+1 = nobad(G2k ). Then,  f (hq, li) = 2k + 1 for all hq, li Ã¢ÂˆÂˆ V2k+1 .  G2k+1 = G2k \ V2k+1 .  Ã¢ÂˆÂ’ Phase II: Let V2k+2 = finite(G2k+1 ). Then,  f (hq, li) = 2k + 2 for all hq, li Ã¢ÂˆÂˆ V2k+2 .  G2k+2 = G2k \ V2k+2 .  The graphs G0 as well all graphs G2k+2 are either  empty, or guaranteed to have only infinite paths,  since all nodes that can only access finitely many  nodes are removed. (a finite path ends in a node with  no successor).  Hence, if V2k is non-empty Lemma 19 guarantees  that V2k+1 is non-empty as well: there is a node in  V2k+1 that accesses infinitely many vertices, but no  B node. In particular there is an infinite path that  is removed in Phase I. Hence, for some level l, all  l0 > l satisfy that  width(G2k+1 , l0 ) + 1 Ã¢Â‰Â¤ width(G2k , l0 )  Phase II only removes nodes, so  width(G2k+2 , l0 ) Ã¢Â‰Â¤ width(G2k+1 , l0 )  Since, initially width(G, l) Ã¢Â‰Â¤ n for all levels l, it  follows that, at the end of round k, for a sufficiently  large l0 :  width(G2k+1 , l0 ) Ã¢Â‰Â¤ n Ã¢ÂˆÂ’ (k + 1)  Consequently, at the end of Phase II of round n Ã¢ÂˆÂ’  1: width(G2nÃ¢ÂˆÂ’1 , l0 ) Ã¢Â‰Â¤ 0. All remaining vertices in  G2nÃ¢ÂˆÂ’1 can access only finitely many vertices. Hence  G2n = Ã¢ÂˆÂ…, and the algorithm terminates. Note that  it is possible that G2k = Ã¢ÂˆÂ… in an earlier round, but  guaranteed that after round n, G2n = Ã¢ÂˆÂ….  It remains to be seen that f is indeed an odd  S{1}-ranking.  The function f is a S{1}-ranking:: By construction,  all B vertices are marked in Phase II of some round  because B Ã¢ÂˆÅ  nobad(Gi ) = Ã¢ÂˆÂ…, and hence receive an even  value. Therefore, all B nodes satisfy condition (i) of the  definition of S{1}-ranking. Now consider an arbitrary  node hq, li. We consider three cases:  1) If hq, li is removed in the Initial Stage then q is  either a G node, in which case (ii) holds trivially, or  it is in V0 . In the latter case, all its outgoing paths  hit a G node in a finite number of steps, and all  the intermediate nodes are mapped to 0. Hence, if  hq, li Ã¢Â†Â’ hq 0 , l0 i, then f (hq 0 , l0 i) = 0 = f (hq 0 , l0 i)  and f (hq, li) Ã¢Â‰Ä½ f (hq 0 , l0 i), and condition (ii) holds.  2) If hq, li is removed in Phase I of round k, so hq, li Ã¢ÂˆÂˆ  V2k+1 . Then all its outgoing paths either hit a node  removed in a previous round or are in V2k+1 . In both  cases hq, li Ã¢Â†Â’ hq 0 , l0 i implies f (hq, li) Ã¢Â‰Ä½ f (hq 0 , l0 i).  3) If hq, li is removed in Phase II of round k, so  hq, li Ã¢ÂˆÂˆ V2k+2 . Then all its outgoing paths either hit  a node removed in a previous round, or are in V2k+1  or in V2k+2 . In all cases hq, li Ã¢Â†Â’ hq 0 , l0 i implies  f (hq, li) Ã¢Â‰Ä½ f (hq 0 , l0 i).  The function f is an odd S{1}-ranking:: Consider  an arbitrary path ÄÂ€. If ÄÂ€ visits infinitely many G nodes,  then the condition for f being odd on ÄÂ€ holds. If ÄÂ€ does  not visit infinitely many G nodes, then f converges on  ÄÂ€ to some value. This value cannot be even, because  that would imply that all these infinitely many vertices  are in some V2k+2 , but there are not infinite paths  containing these kind of node: by construction all nodes  label in Phase II have finite outgoing paths before  changing ranking.  This finishes the proof.   Theorem 7 Let A be an ASW{1} and N the corresponding  NBW. Then w Ã¢ÂˆÂˆ L(A) if and only of w Ã¢ÂˆÂˆ L(N ).  Proof: We prove the two directions separately:  Ã¢Â€ÂœÃ¢Â‡Â’Ã¢Â€Â We assume w Ã¢ÂˆÂˆ L(A) and show that w Ã¢ÂˆÂˆ L(N ). Let  G be a run dag for w on A, and f an odd S{1}-ranking.  Consider the sequence Q0 Q1 . . . of states of N induced  by G and f as Qi = (Si , Oi , fi ) with the set of states  in Si :  Si  = {q | hq, ii Ã¢ÂˆÂˆ G}  and the pending states Oi :  O0 = {p | hp, 0i Ã¢ÂˆÂˆ G with p Ã¢ÂˆÂˆ  /G  and f (hp, 0i) is even}  Oi+1 = {p | hp, i + 1i Ã¢ÂˆÂˆ G with p Ã¢ÂˆÂˆ  /G  and f (hp, i + 1i) even}  Oi+1 = {p | hp, i + 1i Ã¢ÂˆÂˆ G  if Oi = Ã¢Âˆ  and p Ã¢ÂˆÂˆ  / G, and for some q Ã¢ÂˆÂˆ Oi ,  f (hp, i + 1i) = f (hq, ii)  and hq, ii Ã¢Â†Â’ hp, i + 1i}  if Oi 6= Ã¢Âˆ  and  fi (q)  =  f (hq, ii)  It is routine to check that Q0 Q1 . . . is a run. We show  that this run is accepting for N . By contradiction, if  Q0 Q1 . . . is non accepting, there exists i such that,  for all j Ã¢Â‰Ä½ i, Qj Ã¢ÂˆÂˆ  / FN , hence Oj 6= Ã¢ÂˆÂ…. By D3  every qj+1 Ã¢ÂˆÂˆ Oj+1 has a predecessor qj Ã¢ÂˆÂˆ Oj with  fj (qj ) = fj+1 (qj+1 ) being an even value by definition  of Oi above. Since, as shown above, every Oj 6= Ã¢ÂˆÂ…,  it follows that there is an infinite sub-dag of nodes in  G of the form hqj , ji with f (hqj , ji) being even, and  with infinitely many nodes having an incident edge.  By KoÄšÂˆnigÃ¢Â€Â™s lemma, since this dag is finitely branching,  it has an infinite path, all whose nodes are assigned  the same even value by f . This is a contradiction with  f being an odd S{1}-ranking for G. Hence we find  that Q0 Q1 . . . is a run that accepts w which shows  w Ã¢ÂˆÂˆ L(N ).  Ã¢Â€ÂœÃ¢Â‡ÂÃ¢Â€Â We assume now w Ã¢ÂˆÂˆ L(N ) and show that w Ã¢ÂˆÂˆ L(A).  Let Q0 Q1 Q2 . . . be an accepting run for w on N and  let G = (V, E) and f be an induced run and function  V Ã¢Â†Â’ [2n]. We conclude from Q1 and D2, respectively,  that properties (i) and (ii) of S{1}-ranking holds on  f . Therefore f is a S{1}-ranking. Now let us show  that f is an odd S{1}-ranking. To this end, consider  an arbitrary path ÄÂ€ in G for which we will show that  either condition (i) or (ii) of the definition of odd  S{1}-ranking holds. If ÄÂ€ visits G nodes infinitely often,  then condition (i) holds. Otherwise, there is an i after  which no more G nodes are visited in ÄÂ€. Hence, since  every node ÄÂ€(i0 ) with i0 > i + 1 has a predecessor not  in G, D2 shows that f converges on ÄÂ€ to some value.  Let j Ã¢Â‰Ä½ i0 be such that f has converged already (i.e.,  f (ÄÂ€(j 0 )) = f (ÄÂ€(j)) for all j 0 Ã¢Â‰Ä½ j). Let Qk , Ql Ã¢ÂˆÂˆ FN  with j Ã¢Â‰Â¤ k < l be two accepting states in the run Q0 Q1  of w on N . It must be the case that ÄÂ€(k + 1) Ã¢ÂˆÂˆ  / Ok+1 .  Assume the contrary (i.e. ÄÂ€(k + 1) Ã¢ÂˆÂˆ Ok+1 ), since ÄÂ€  visits no G node after k and f has converged, then we  conclude by D3 that ÄÂ€(k 0 ) Ã¢ÂˆÂˆ Ok0 for all k 0 > k, hence  that Ol 6= Ã¢ÂˆÂ…, and finally that Ql Ã¢ÂˆÂˆ  / FN by definition of  FN which is a contradiction.  Also since ÄÂ€(k + 1) Ã¢ÂˆÂˆ  / Ok+1 and Qk Ã¢ÂˆÂˆ FN , D3 shows  that f (ÄÂ€(k + 1)) is odd. Hence f converges on ÄÂ€ to an  odd value showing that condition (ii) of the definition  of S{1}-ranking holds.  This concludes that f is an odd S{1}-ranking for G.  Finally Lem. 6 shows that G is an accepting run, hence  that w Ã¢ÂˆÂˆ L(A).   Lemma 20 G is an accepting run iff there is a stratified  odd S{1}-ranking for G.  Proof: We prove the two directions separately:  Ã¢Â€ÂœÃ¢Â‡ÂÃ¢Â€Â Assume there is a stratified odd S{1}-ranking {fj } for  G and let ÄÂ€ be an arbitrary trace of G. Since, {fj } is  odd, either ÄÂ€ visits infinitely many G states, in which  case ÄÂ€ is accepting, or ÄÂ€ converges to a stratum Sj  and fj (ÄÂ€) converges to an odd value. In this second  case, there is l such that for all l0 > l, fj (ÄÂ€(l0 )) =  fj (ÄÂ€(l)) and fj (ÄÂ€(l)) is odd. By definition of stratified  S{1}-ranking (point (i)), ÄÂ€(l0 ) cannot be a B state,  and consequently ÄÂ€ visits only finitely many B states.  Hence, ÄÂ€ is an accepting trace.  Ã¢Â€ÂœÃ¢Â‡Â’Ã¢Â€Â Assume now that G is an accepting run for A. The  construction of each fj works at each stratum independently. Fix Sj . First, one removes all G vertices and all  those vertices not in Sj . The algorithm works exactly  as with the proof of Lemma 6 by stages, at each stage  first removing those states that cannot access B nodes,  and then remove those states that only access finitely  many nodes. Since at each stage one removes at least  one element from all cuts at a sufficiently large l, at the  width of elements from Sj is at most |Sj |, the algorithm  is guaranteed to finish in |Sj | rounds, generating an odd  S{1}-ranking for stratum Sj . It is routine to check that  {fj } is indeed a stratified S{1}-ranking.    Theorem 11 Let A be a stratified ASW{1} and N the corresponding NBW using stratified rankings. Then w Ã¢ÂˆÂˆ L(A)  if and only of w Ã¢ÂˆÂˆ L(N ).  Proof: The proof is analogous to Theorem 11.  Fig. 2 depicts the translation of RLTL into APW.  q0 false  q0 true  Automaton AÃ¢ÂˆÂ… for Ã¢ÂˆÂ….  Specular automaton AÃ¢ÂˆÂ… .  =  =  =  Ay  Ax  =  Ay  Ax  Automaton AxÃ¢ÂˆÂ¨y for x Ã¢ÂˆÂ¨ y.  Specular automaton AxÃ¢ÂˆÂ¨y .  =  =  Ax  Ax  Automaton AÃ‚Å¹x for Ã‚Å¹x.  1  Specular automaton AÃ‚Å¹x .  0  =  Nr  Ax  Nr  Automaton Ar;x for r ; x.  q0  Ay  q0  Ay  Automaton Ax|riiy for x|riiy.  Ay  Ax  q0  =  =  Ax  1  Nr  Automaton Ax|riy for x|riy.  Figure 2.  0  Nr  Specular automaton Ax|riiy .  2  =  =  1  Nr  Ax  0  =  =  q0  Ax  Specular automaton Ar;x .  1  =  =  Ay  1  =  Ax  0  Nr  Specular automaton Ax|riy .  Specular automata pairs for Ã¢ÂˆÂ…, x Ã¢ÂˆÂ¨ y, Ã‚Å¹x, x ; y, x|riiy and x|riy. 