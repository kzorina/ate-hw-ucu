Journal of Applied Logic 4 (2006) 141â167  www.elsevier.com/locate/jal  A clausal resolution method for extended  computation tree logic ECTL  Alexander Bolotov â , Artie Basukoski  Harrow School of Computer Science, University of Westminster, HA1 3TP, UK  Available online 21 July 2005  Abstract  A temporal clausal resolution method was originally developed for linear time temporal logic and  further extended to the branching-time framework of Computation Tree Logic (CTL). In this paper,  following our general idea to expand the applicability of this efficient method to more expressive  formalisms useful in a variety of applications in computer science and AI requiring branching time  logics, we define a clausal resolution technique for Extended Computation Tree Logic (ECTL). The  branching-time temporal logic ECTL is strictly more expressive than CTL in allowing fairness operators. The key elements of the resolution method for ECTL, namely the clausal normal form, the  concepts of step resolution and a temporal resolution, are introduced and justified with respect to  this new framework. Although in developing these components we incorporate many of the techniques defined for CTL, we need novel mechanisms in order to capture fairness together with the  limit closure property of the underlying tree models. We accompany our presentation of the relevant  techniques by examples of the application of the temporal resolution method. Finally, we provide a  correctness argument and consider future work discussing an extension of the method yet further, to  the logic CTLâ , the most powerful logic of this class.  ÂŠ 2005 Elsevier B.V. All rights reserved.  Keywords: Branching-time; Automated deduction; Resolution; Program specification and verification  * Corresponding author.  E-mail addresses: a.bolotov@wmin.ac.uk (A. Bolotov), a.basukoski@wmin.ac.uk (A. Basukoski).  1570-8683/$ â see front matter ÂŠ 2005 Elsevier B.V. All rights reserved.  doi:10.1016/j.jal.2005.06.003  142  A. Bolotov, A. Basukoski / Journal of Applied Logic 4 (2006) 141â167  1. Introduction  A Computation Tree Logic (CTL), first proposed in [9], and its extensions have shown  to play a significant role in potential applications [11]. CTL does not permit boolean combinations of formulae with temporal operators or their nesting. Two combinations of future  time temporal operators âŚ (âsometimeâ) and  (âalwaysâ), are useful in expressing fairness [10]: âŚp (p is true along the path of the computation except possibly some finite  initial interval of it) and âŚp (p is true along the computation path at infinitely many  moments of time).  The logic ECTL (Extended CTL [12]) bridges this gap in CTL expressiveness, admitting simple fairness constraints. While ECTL is strictly more expressive than CTL, their  syntactic and semantic features have much in common.  In [5,6] a clausal resolution approach to CTL was developed, extending the original  definition of the method for the linear-time case [14]. In this paper, following our general aim to expand the applicability of the method to more expressive formalisms, we  define it for the logic ECTL.1 As a normal form for ECTL, called SNFCTL , we utilise  the Separated Normal Form developed for CTL formulae. This enables us to apply the  resolution technique defined over SNFCTL as the refutation technique for ECTL formulae.  The main contribution of this paper is the extension of the set of rules used to translate  CTL formulae into SNFCTL by a novel transformation technique to cope with ECTL fairness. SNFCTL can be used for more expressive formalisms, such as ECTL: in translating  CTL or ECTL formulae into our normal form, similarly to the linear time case [7], we derive propositional formulae that are existentially quantified, and to utilise the normal form  as part of a proof, we effectively skolemize them producing temporal formulae without any  quantification.  The structure of the paper is as follows. In Section 2 we introduce the logic ECTL, outlining the ECTL syntax in Section 2.1, its semantics in Section 2.2 and those properties  of ECTL syntax and semantics that are important for our analysis in Section 2.3. Further,  in Section 3, we review SNFCTL . In the next section, Section 4 we describe the translation of ECTL formulae into SNFCTL . The translation algorithm which includes a novel  transformation technique to cope with ECTL fairness constraints is given in Section 4.1.  Main rules invoked in this algorithm are given in Section 4.2. Some of these rules are  used in the example transformation which can be found in Section 4.3. We conclude this  section providing in Section 4.4 the correctness argument. Note also that in this paper we  present the full correctness argument which bridges the gap contained in the correctness  proof contained in [3], where we only show that the transformation procedure preserves  satisfiability: now we also establish that it preserves unsatisfiability. Having provided the  translation of ECTL formulae into SNFCTL , we represent all temporal statements within  ECTL as sets of SNFCTL clauses. Now, in order to achieve a refutation, we incorporate the  temporal resolution method already defined over SNFCTL in [2,6]. The method is outlined  1 Note that while working on the preparation of this article the authors have developed the resolution technique  for the logic ECTL+ , the extension of ECTL, allowing Boolean combination of fairness constraints [4], and are  currently working on the extended version of this paper.  A. Bolotov, A. Basukoski / Journal of Applied Logic 4 (2006) 141â167  143  in Section 5, where we also apply the temporal resolution to a set of SNFCTL clauses (previously obtained in Section 4.3). Finally, in Section 6, we draw conclusions and discuss  future work.  2. Syntax and semantics of ECTL  2.1. ECTL syntax  For clarity we will introduce the normal form for ECTL (see Section 3) and the resolution rules defined over a set of clauses in normal form (see Section 5), based on the set of  classical logic operators â§, â¨, â, ÂŹ, future time temporal operators  (always), âŚ (sometime),  (next time), U (until) and W (unless) and path quantifiers A (on all future paths)  and E (on some future path). Thus, to unify the presentation, here we define the language  of ECTL also based upon this extended set of operators.  We fix a countable set, Prop, of atomic propositions. In the syntax of ECTL we distinguish state (S) and path (P ) formulae, such that well formed formulae are state formulae.  These classes of formulae are inductively defined below (where C is a formula of classical  propositional logic)  S ::= C|S â§ S|S â¨ S|S â S|ÂŹS|AP |EP  P ::= S|âŚS|S|SUS|SWS|âŚS|âŚS  Thus, ECTL has a richer syntax than CTL allowing nesting of  and âŚ in the scope  of path quantifiers. Examples of ECTL formulae are AâŚB, AâŚB, EâŚB and EâŚB  (where B is any ECTL formula), which express the fairness properties.  Note that a succinct representation of branching-time logics which invokes a minimum  set of temporal logic operators, U and  (from which we can derive other operators), can  be found, for example, in [10].  2.2. ECTL semantics  Let us introduce the notation of tree structures, the underlying structures of time assumed for branching-time logics, which we utilise in our presentation.  Definition 1. A tree is a pair (S, R), where S is a set of states and R â S Ă S is a relation  between states of S such that  â˘ s0 â S is a unique root node, i.e., there is no state si â S such that R(si , s0 );  â˘ for every si â S there exists sj â S such that R(si , sj );  â˘ for every si , sj , sk â S, if R(si , sk ) and R(sj , sk ) then si = sj .  A path, Ďsi is a sequence of states si , si+1 , si+2 , . . . such that for all j  i, (sj , sj +1 ) â  R. A path Ďs0 is called a fullpath. Let X be a family of all fullpaths of M. Given a path Ďsi  and a state sj â Ďsi (i < j ) we term a finite subsequence [si , sj ] = si , si+1 , . . . , sj of Ďsi a  144  A. Bolotov, A. Basukoski / Journal of Applied Logic 4 (2006) 141â167  prefix of a path Ďsi and an infinite sub-sequence sj , sj +1 , sj +2 , . . . of Ďsi a suffix of a path  Ďsi abbreviated Suf (Ďsi , sj ).  Definition 2 (Branching degree of a state). The number of immediate successors of a state  si â S in a tree (S, R) is called the branching degree of si .  In a general case a state of a tree can have an infinite number of successors. However,  following [10, p. 1011], trees with arbitrary, even uncountable, branching, âas far as our  branching temporal logic are concerned, are indistinguishable from trees with finite, even  bounded, branchingâ. Thus, without loss of generality, we assume that underlying ECTL  tree models are of at most countable branching.  Definition 3 (Branching factor of a tree structure). Given the set K = {k1 , k2 , . . . , kn },  of the branching degrees of the states of a tree, the maximal ki (1  i  n) is called the  branching factor of this tree.  We interpret a well-formed ECTL formula in a structure M = S, R, s0 , X, L , where  (S, R) is a tree with a root s0 , X is a set of all fullpaths and L is an interpretation function mapping atomic propositional symbols to truth values at each state and the following  conditions are satisfied:  â˘ X is R-generable [10], i.e., for every state si â S, there exists Ďj â X such that si â  Ďj , and for every sequence Ďj = s0 , s1 , s2 , . . . , Ďj â X if, and only if, for every i,  R(si , si+1 );  â˘ a tree (S, R) is of at most countable branching.  Now in Fig. 1 we define a relation ââ, which evaluates well-formed ECTL formulae at a  state si in a model M.  M, si  M, si  M, si  M, si  M, si  M, si  M, si  M, Ďsi  M, Ďsi  M, Ďsi  M, Ďsi  M, Ďsi  p   ÂŹA  Aâ§B  Aâ¨B  AâB   AB   EB  A   B   âŚB   B   AU B  M, Ďsi  AWB  iff p â L(si ), for p â Prop.  iff M, si  A  iff M, si  A and M, si  B  iff M, si  A or M, si  B  iff M, si  A or M, si  B  iff for each Ďsi , M, Ďsi  B.  iff there exists Ďsi such that M, Ďsi  B  iff M, si  A, for state formula A  iff for each sj â Ďsi , if i  j then M, Suf (Ďsi , sj )  B.  iff there exists sj â Ďsi such that i  j and M, Suf (Ďsi , sj )  B.  iff M, Suf (Ďsi , si+1 )  B.  iff there exists sj â Ďsi such that i  j and M, Suf (Ďsi , sj )  B and  for each sk â Ďsi , if i  k < j then M, Suf (Ďsi , sk )  A.  iff M, Ďsi  A or M, Ďsi  AU B  Fig. 1. ECTL semantics.  A. Bolotov, A. Basukoski / Journal of Applied Logic 4 (2006) 141â167  145  Fig. 2. Limit closure.  Definition 4 (Satisfiability). A well-formed ECTL formula, B, is satisfiable if, and only if,  there exists a model M such that M, s0  B.  Definition 5 (Validity). A well-formed ECTL formula, B, is valid if, and only if, it is  satisfied in every possible model.  As an example, let us consider the following satisfiable ECTL formula  AâŚp â§ EEâŚÂŹp  (1)  A model, M, for this formula (see Fig. 2) can be derived as follows. Let for the states along  Îąs0 , the following holds: k = j + 1, l = k + 1, . . . ; let p be satisfied at Suf (Îąs0 , sj ) and  also at Suf (Îłs0 , sj +2 ), Suf (Ďsj , sk+2 ), Suf (Ďsk , sl+2 ), . . . . Finally, let sj +1 , sk+1 , sl+1 , . . .  along paths Îł , Ď, Ď, . . . , respectively, satisfy ÂŹp.  Note that if we change the first conjunct of formula (1) to AâŚAp then the whole  formula becomes unsatisfiable.  Closure properties of ECTL models. When trees are considered as models for distributed  systems, paths through a tree are viewed as computations. The natural requirements for  such models would be suffix and fusion closures. Following [10], the former means that  every suffix of a path is itself a path. The latter requires that a system, following the prefix  of a computation Îł , at any point sj â Îł , is able to follow any computation Ďsj originating  from sj .  Finally, we might require that âif a system can follow a path arbitrarily long, then it can  be followed foreverâ [10]. This corresponds to limit closure property, meaning that for any  fullpath Îłs0 and any paths Ďsj , Ďsk , . . . such that Îłs0 has the prefix [s0 , sj ], Ďsj has the prefix  [sj , sk ], Ďsk has the prefix [sk , sl ], etc, and 0 < j < k < l, the following holds (see Fig. 2):  there exists an infinite path Îąs0 that is a limit of the prefixes [s0 , sj ], [sj , sk ], [sk , sl ], . . . .  In our definition of an ECTL model structure M the set of fullpaths X is R-generable.  Therefore, following [10], it satisfies all three closure properties, i.e., it is suffix, fusion and  limit closed.  2.3. Some useful features of ECTL  Here we summarize those features of ECTL that are important in our analysis and, thus,  affect both the translation of ECTL formulae to the normal form and the clausal resolution  method.  146  A. Bolotov, A. Basukoski / Journal of Applied Logic 4 (2006) 141â167  Fairness constraints. Validity of the following equivalences can be easily shown in ECTL  semantics:  AâŚB âĄ AAâŚB,  EâŚB âĄ EâŚEB  (2)  Therefore, AâŚB and EâŚB have their CTL counterparts. However, EâŚB and AâŚB  have no analogues in CTL [10]. Note that in the case of EâŚ, the âŚ operator is in the scope  of the  operator, which is a maximal fixpoint prefixed by the âEâ quantifier. In the second  case, the  operator is in the scope of the âŚ operator, which is a minimal fixpoint and is  prefixed by the âAâ quantifier. These nestings of temporal operators significantly affect  the renaming of the embedded paths subformulae in the corresponding ECTL fairness  constraints.  Notation.  â˘ In the rest of the paper, let T abbreviate any unary and T2 any binary temporal operator  and P either of path quantifiers.  â˘ Any expression of the type PT or PT2 is called a basic CTL modality. A class of  basic ECTL modalities consists of basic CTL modalities, enriched by ECTL fairness  constraints, PâŚ and PâŚ.  â˘ Let F be an ECTL formula and let Fi be its subformula with a path quantifier as its  main operator. We will abbreviate the latter by P-embedded subformula of F .  â˘ A literal is an atomic proposition or its negations.  â˘ We will use the symbol = in the expression A = B to refer to the graphical equivalence of formulae A and B, while A âĄ B would mean the logical equivalence, i.e., it  abbreviates (A â B) â§ (B â A).  As we will see in Section 3, the idea behind the normal form for ECTL is to identify  the core operators, P and PâŚ, to enable us to generate formulae relevant to either the  first state in a model, or to all subsequent states in a model. Therefore, an important part of  the transformation procedure for ECTL formulae into the normal form is simplifying the  structures of the given ECTL formulae. Some of these transformations deal with embedded  state subformulae of ECTL formulae.  Managing embedded state subformulae. For an ECTL formula F , we define a notion of  the degree of nesting of its path quantifiers, denoted N (F ), as follows.  Definition 6 (Degree of path quantifier nesting).  â˘ if F is a purely classical formula then N (F ) = 0;  â˘ if F = TF1 |F1 T2 F2 , and F1 , F2 are purely classical formulae then N (TF1 ) =  N(F1 T2 F2 ) = 0;  â˘ if F = ÂŹF1 |F1 â§ F2 |F1 â¨ F2 |F1 â F2 |TF1 |F1 T2 F2 | then N (ÂŹF1 ) = N (TF1 ) =  N(F1 ) and N (F1 â§ F2 ) = N (F1 â¨ F2 ) = N (F1 â F2 ) = N (F1 T2 F2 ) = max(N (F1 ),  N(F2 ));  A. Bolotov, A. Basukoski / Journal of Applied Logic 4 (2006) 141â167  147  â˘ N(PF1 ) = N (F1 ) + 1.  Emerson and Sistla [13] showed that any CTLâ formula F can be transformed into  F such that N (F ) = 2 and F is satisfiable if, and only if, F is satisfiable. This can be  achieved by a continuous renaming of the P-embedded state subformulae. The result is  obviously valid for the logic ECTL, and below we introduce a corresponding recursive  procedure Red.  Definition 7 (Reduction of the path quantifier nesting). Given an ECTL formula F such  that N(F ) > 2, the following procedure reduces the nesting of path quantifiers in F to  the degree 2: Red[F ] = A(x1 âĄ S1 ) â§ Red[F (S1 /x1 )], where S1 is the designated Pembedded state subformula of F , x1 is a new atomic proposition and F (S1 /x1 ) is a  result of the replacement of S1 in F by x1 . If N (Si ) = 1 then the procedure terminates.  For example, given F = AâŚ(EâŚÂŹp â§ AâŚAp) we can obtain Red[F ] as follows  Red[F ] = A(x1 âĄ Ap) â§ A(x2 âĄ AâŚx1 ) â§  A(x3 âĄ EâŚÂŹp) â§ AâŚ(x3 â§ x2 )  Therefore, procedure Red terminates here producing the conjunction of formulae such that  each of them has a degree of nesting of path quantifiers at most 2.  The following Proposition 1 is due to Emerson and Sistla [13].  Proposition 1 (Correctness of the Reduction procedure). For any ECTL formula F , F is  satisfiable if, and only if, Red(F ) is satisfiable, where Red is introduced in Definition 7.  Since normal form for ECTL is invoked as part of the resolution method, and similarly  to classical resolution, the resolution based refutation commences here with the negation  of a given ECTL formula (see Section 5), we will aim at translating this negation into  negation normal form.  Definition 8 (Negation normal form for ECTL). An ECTL formula is in the negation normal form if every negation operation applies to an atomic proposition.  Using the standard technique we can translate an ECTL formula F into its negation  normal form, NNFECTL (F ) [10] preserving both satisfiability and unsatisfiability.  Proposition 2 (Correctness of NNFECTL ). For any ECTL formula, F , F is satisfiable if,  and only if, NNFECTL (F ) is satisfiable.  Fixpoint characterization of basic CTL modalities. Our translation to SNFCTL and temporal resolution rules are essentially based upon the fixpoint characterizations of basic  148  A. Bolotov, A. Basukoski / Journal of Applied Logic 4 (2006) 141â167  CTL modalities (see [8]). The corresponding definitions are given below, where maximal  fixpoint operator is abbreviated by âÎ˝â and minimal fixpoint operator by âÎźâ:  Ep = Î˝Îś (p â§ EÎś )  Ap = Î˝Îˇ(p â§ AÎˇ)      E(pWq) = Î˝Îş q â¨ (p â§ EÎş)      A(pWq) = Î˝Îž q â¨ (p â§ AÎž )  (3)  EâŚp = ÎźĎ(p â¨ EĎ)  AâŚp = ÎźĎ (p â¨ AĎ )      E(pUq) = ÎźĎ q â¨ (p â§ EĎ)      A(pUq) = ÎźÎ´ q â¨ (p â§ AÎ´)  (4)  Next we recall some results on interpreting CTL-type branching time logics over so  called canonical models. We will formulate these general results in relation to the logic  ECTL, noting that they cover all CTL-type logics, including CTL .  Definition 9 (Labelled tree). Given a tree T = (S, R) (where S is a set of nodes and R is a  set of edges) and a finite alphabet, ÎŁ , a ÎŁ -labelled tree is a structure (T , L) where L is a  mapping S ââ ÎŁ , which assigns for each state, element of S, some label, element of ÎŁ .  Observe that in Section 2 we introduced the notion of satisfiability and validity of ECTL  formulae in relation to M, s0 . Now, let us, following [15], call such a structure a tree  interpretation.  Next we recall a notion of a k-ary tree canonical model which plays a fundamental  role in our correctness argument. For these purposes, again following [15] and preserving  its notation, we will look at tree interpretations as tree generators: the root of the tree  is understood as an empty string, Îť, and the whole tree is seen as a result of unwinding  of the root applying the successor function {(s, si) | s â [k] , i â K}, where [k] = S and  si (i â K) is a set of successors of a state s.  Definition 10 (Tree canonical interpretation). Let T = (S, R) be a k-ary infinite tree  such that [k] denotes the set {1, . . . , k}, of branching degrees of the states in S and  R = {(s, si) | s â [k] , i â K}. Now, given an alphabet ÎŁ = 2Prop , a k-ary tree canonical interpretation for an ECTL formula F is of the form M, Îť , where M = ([k] , R, Ď) such  that Ď : [k] ââ 2Prop is a function which assigns truth values to the atomic propositions  in each state.  As it is stated in [15], since in a canonical interpretation ([k] , R, Ď), Îť , âthe set of  states, the initial state and the successor relation are all fixed they reduce to a function  [k] ââ 2Prop , that is to a labelled tree over the alphabet 2Prop â. We will refer to this tree  as a canonical model. Proposition 3 given below collects the results of [15, Lemma 3.5,  p. 145].  A. Bolotov, A. Basukoski / Journal of Applied Logic 4 (2006) 141â167  149  Proposition 3 (Existence of a canonical model for ECTL). If an ECTL formula F containing n (existential) path quantifiers has a model, then it has an (n + 1)-ary canonical  model.  Thus, given an interpretation M, s0 for an ECTL formula F , there exists an (n + 1)ary canonical tree interpretation M , Îť , where n is the number of existential path  quantifiers in F , such that F is satisfied in M, s0 iff F is satisfied in M , Îť . We  will essentially use these results for the formulation of the transformation rule managing ECTL fairness constraints, namely, formulae that contain AâŚâsee Section 4.2. The  results are also central to the correctness proof of this transformation presented in Section 4.4.  3. Normal form for ECTL  As a normal form for ECTL we utilise a clausal normal form, defined for the logic CTL,  SNFCTL , which has been developed in [2,6]. The idea behind SNFCTL is to identify the core  operators, P and PâŚ, which enables us to generate formulae relevant to either the first  state in a model, or to all subsequent states in a model. Therefore, as an important part of  the transformation procedure for ECTL formulae into SNFCTL we incorporate removal of  all other, unwanted modalities A, E, AU, EU, AW, EW (see Section 4.2).  Additionally, to preserve a specific path context during the translation, we incorporate  indices.  Indices.  The language for indices is based on the set of terms               IND = f , g , h , LC(f) , LC(g) , LC(h) . . .  where f, g, h . . . denote constants. Thus, EA f means that A holds on some path labelled  as f . A designated type of indices in SNFCTL are indices of the type LC(ind) which  represent a limit closure of ind . All formulae of SNFCTL of the type P â EQ or P â  EâŚQ, where Q is a purely classical expression, are labelled with some index. Labelling  clauses of the normal form by indices is related to the branching factor of the canonical  model for the clauses and will be explained later.  The SNFCTL language is obtained from the ECTL language by omitting the U and W  operators, and adding classically defined constants true and false, and a new operator,  start (âat the initial moment of timeâ) defined as  M, si  start iff  i=0  Definition 11 (Separated normal form SNFCTL ). SNFCTL is a set of formulae    A  (Pi â Fi )  i  where each of the clauses Pi â Fi is further restricted as below, each Îąi , Î˛j or l is a literal,  true or false and ind â IND is some index.  150  A. Bolotov, A. Basukoski / Journal of Applied Logic 4 (2006) 141â167  k  start â  an Initial Clause  Î˛j  j =1  m    Îąi â A  i=1  m  Step Clauses  n  an A step clause  Î˛j  j =1   n  Îąi â E  i=1  an E step clause  Î˛j  ind  j =1  Sometime Clauses  m  Îąi â AâŚl  an A sometime clause  i=1  m  Îąi â EâŚl LC(ind)  an E sometime clause  i=1  Interpreting SNFCTL . An initial SNFCTL clause, start â F , is understood as âF is satisfied at the initial state of some model Mâ. Any other SNFCTL clause is interpreted taking  also into account that it occurs in the scope of A.  Thus, a clause A(x â Ap) (a model for which is given in Fig. 3, Diagram 1) is  interpreted as âfor any fullpath Ď and any state si â Ď (0  i), if x is satisfied at a state si  then p must be satisfied at the moment, next to si , along each path which starts from si â.  Recall that following Proposition 3, for a set, R, of clauses with n existential path quantifiers, we have an (n + 1)-ary canonical model for R. Now, associating every k â 1 . . . n  with a unique index indk â IND, we label each E step clause with the unique indk and  each E sometime clause with the unique LC(indk ). Thus, a clause A(x â Eq ind )  (see Fig. 3, Diagram 1) is understood as âfor any fullpath Ď and any state si â Ď (0  i),  if x is satisfied at a state si then q must be satisfied at the moment, next to si , along some  path ind which departs from si â.  Fig. 3. Interpretation of step and sometime clauses.  A. Bolotov, A. Basukoski / Journal of Applied Logic 4 (2006) 141â167  151  Finally, A(x â EâŚp LC(ind) ) (see Fig. 3, Diagram 2) has the following meaning âfor  any fullpath Ď and any state si â Ď (0  i), if x is satisfied at a state si then p must be  satisfied at some state, say sj (i  j ), along some path Îąsi which is the limit closure of  ind which departs from si â.  4. Transformation of ECTL formulae into SNFCTL  As we have already mentioned, an important part of the transformation procedure for  ECTL formulae includes removal of all unwanted modalities A, E . . . . The corresponding rules are formulated in such way that these basic CTL modalities are removed being  applied to literals. Thus, a significant part of the translation aims at simplifying the structure of formulae preparing them for application of removal rules. While many of these  methods were developed in our previous work [2,6], we here introduce a novel technique  to cope with ECTL fairness constraints.  4.1. Description of the transformation algorithm  As SNFCTL is a part of the resolution technique, to check validity of an ECTL formula  G, we first negate the latter and translate ÂŹG into its Negation Normal Form, deriving  C = NNFECTL (ÂŹG). Now we introduce the transformation procedure  Ď = [Ď2 [Ď1 [C]]]  to be applied to C, where Ď1 and Ď2 are described respectively by the steps 1â2 and 3â7  below.  1. Anchor C to start and apply the initial renaming rule obtaining A((start â x0 ) â§  (x0 â C)), where x0 is a new atomic proposition.  2. Apply Eqs. (2) and then procedure Red (see Definition 7) to C. Thus, we derive a set  of constraints of the following structure    m  A (start â x0 ) â§  (Pj â Qj )  j =0  where Pj is a proposition, Qj is either a purely classical formula or if Qj contains an  ECTL modality then the degree of nesting of path quantifiers in Qj is 1.  Let us call a formula G in pre-clause form if Ď1 [G] = G, i.e., it is of the form Pj â Qj  where Pj is a literal, or conjunction of literals, or start, Qj is either a purely classical  formula or Qj = PTCj or Qj = PâŚCj or Qj = PâŚCj or Qj = P(Cj1 T2 Cj2 ), and  Cj , Cj1 and Cj2 are purely classical formulae.  3. For every pre-clause Pj â Qj , we obtain the following conditions. If Qj contains a  basic CTL modality then  â If Qj = PTCj and PT is not P then Cj is a literal,  else Cj is a purely classical formula.  â If Qj = PâŚCj or Qj = PâŚCj then Cj is a literal,  152  4.  5.  6.  7.  A. Bolotov, A. Basukoski / Journal of Applied Logic 4 (2006) 141â167  â If Qj = P(Cj1 T2 Cj2 ) then Cj1 and Cj2 are literals.  This can be achieved by continuous renaming of the embedded classical subformulae  by auxiliary propositions together with some classical transformations.  Label each pre-clause containing the E modality by a unique index indi â IND and  any other pre-clause containing the E quantifier by a unique index LC(indj ) â IND.  Let LIST_IND be a list of all indices introduced during this labelling.  Transform pre-clauses containing EâŚ and AâŚ.  Remove all unwanted basic CTL modalities.  Steps 5 and 6 are described in the next section.  Derive the desired form of SNFCTL clauses. At this final stage we transform preclauses Pj â Qj , where Qj is either PCj or a purely classical formula:  â for every pre-clause Pj â PCj , we obtain the structure where P applies either  to a literal or to disjunction of literals. This can be achieved, again, by renaming of  the embedded classical subformulae, translating Cj into conjunctive normal form  (CNF), and distributing P over conjunction, together with some classical transformations.  â for every remaining purely classical pre-clause Pj â Qj , we apply a number of  procedures including those that are used in classical logic in transforming formulae  to CNF, some simplifications and the introduction of a temporal context.  4.2. Transformation rules towards SNFCTL  In the transformation procedure Ď outlined above, the first stage, the procedure Ď1 , except for the application of equations (2) at step 2, is taken from the translation of CTL  formulae to SNFCTL [2]. In the procedure Ď2 we introduce novel techniques to cope with  ECTL fairness constraints that do not have their CTL counterparts. Here we describe these  techniques and recall some of those rules that will be used in our example given in Section 4.3. For the full set of rules preserved from the CTL the reader is referred to [2,6].  In the presentation below we omit the outer âAâ connective that surrounds the conjunction of pre-clauses (note that any pre-clause is also a clause) and, for convenience,  consider a set of pre-clauses rather than the conjunction. Expressions P and Q will abbreviate purely classical formulae.  Indices. Recall that at step 4 of the transformation procedure, we introduce labelling of  the SNFCTL pre-clauses containing the E quantifier: here we first label every pre-clause  P â EQ by a unique index indi , indicating a âdirectionâ in which Q is satisfied, given  that P is satisfied. Secondly, with any other pre-clause containing the E quantifier we  associate a unique index LC(indj ) . The justification of the latter labelling is based upon  fixpoint characterization of basic CTL modalities E, EW and EU (see Eqs. (3) and (4)).  Assume that a pre-clause P â Ey has been derived at some stage of the transformation procedure. Since Ey is a maximal fixpoint of the equation Î˝Îś (y â§ EÎś ), we can  represent this recursion by the following set of constraints:  P ây â§x  x â E(y â§ x) ind  (5)  A. Bolotov, A. Basukoski / Journal of Applied Logic 4 (2006) 141â167  153  Fig. 4. Labelling ECTL formulae: the LC index.  where we introduce a new atomic proposition, x, and require that the conjunction y â§  x also occurs at those moments where P itself is satisfied. The second constraint, x â  E(y â§ x), represents a loop in y, i.e., the situation, where y occurs from some point at  all subsequent states along some path in the model (given that x is satisfied at that point).  Now, labelling x â E(y â§ x) by a new index, ind , and noting that pre-clauses are in  the scope of the outer A, we can show that P â Ey is satisfiable in some model, M,  if, and only if, there is a model M which satisfies both formulae in (5). Here we present a  proof establishing that if P â Ey is satisfiable in a model M then there is a model M  which satisfies both formulae in (5).  The satisfiability of pre-clause P â Ey in a model M would mean  âfor any fullpath Ď and any state sk â Ď (0  k), if M, sk  P then M, sk  Eyâ  Choose arbitrarily a fullpath Ď (see Fig. 4).  If P is never satisfied along Ď then let M be the same as M except for a new proposition x such that x is false everywhere along Ď. Thus, we obtain      M , Ď   P â (y â§ x) ,      M , Ď   x â E(y â§ x) ind  regardless of the indices since the left hand side of each implication is false. Alternatively,  let si â Ď be the first moment along Ď satisfying P . In this case there must be a path Ďsi  (associated with ind ) such that M, Ďsi  y. Due to the fusion closure property, there  is a fullpath [s0 , si ] âŚ Ďsi , where ââŚâ is a concatenation of [s0 , si ] and Ďsi . Now we define  a model M to be the same as M except for a new proposition x such that for any state  sn â [s0 , si ] âŚ Ďsi , if i  n then M , sn  x else M , sn  x. Now we derive that sj , the  successor of si on path Ďsi , satisfies y â§ x. Thus, setting in the conditions for P â Ey  that Ď = [s0 , si ] âŚ Ďsi and k = j , we conclude that M, sj  E(y â§ x) ind . Therefore,  there is a path Ďsj associated with ind such that there is a state, next to si , say sm , on  this path, which satisfies y â§ x. Continuing to reason in this way, according to the limit  closure property, we must have in the model a path, LC(ind) , going through the states  si , sj , sm . . . . Each state along LC(ind) satisfies y â§ x. Therefore, we have identified a  154  A. Bolotov, A. Basukoski / Journal of Applied Logic 4 (2006) 141â167  path which satisfies Ey, which enables us to label pre-clause P â Ey by LC(ind) .  Note also that this justifies that (x â E(y â§ x)ind ) indeed represents a loop in y on  the path LC(ind) . Searching for loops is essential for application of resolution rules, see  Section 5.  Providing analogous reasoning, we can justify the labelling of pre-clauses containing EW, taking into account their definitions as maximal fixpoints, and the labelling of  pre-clauses containing EâŚ and EU modalities based upon their definitions as minimal fixpoints.  Obviously, this representations of basic CTL modalities as sets of pre-clauses allows  us to formulate corresponding rules to substitute basic CTL modalities by their fixpoint  definitions. Thus, given P â Ey LC(ind) , we apply (5) to remove the E modality as  follows (in the formulation of the rule below x is a new atomic proposition):  Removal of E.  P â Ey  LC(ind)  P ây â§x  x â E(y â§ x) ind  Additionally, we give the removal rule for EW referring the reader to [2,6] for the formulation of the full set of rules to remove basic CTL modalities.  Removal of EW.  P â E(pWq) LC(ind)  P â q â¨ (p â§ x)  x â E(q â¨ (p â§ x)) ind  where x is a new atomic proposition.  Managing embedded path subformulae in ECTL. The rules to rename purely path formulae embedded in ECTL fairness constraints are based upon our analysis of the problematic  variety of nesting of temporal operators in ECTL (see Section 2.3). Thus, when renaming  âŚP within EâŚP or P within AâŚP by a new variable x, we must be sure that x and  P in the former case, and x and âŚP in the latter case, occur along the same path. Second, we must establish a link between satisfiability of x and âŚP (P ), i.e., any state in a  model which satisfies x should also satisfy âŚP (P ). These observations have led us to  the following formulation of the renaming rules.  Renaming: the EâŚ case.  P â EâŚQ LC(ind)  P â Ex LC(ind)  x â EâŚQ LC(ind)  where x is a new atomic proposition.  A. Bolotov, A. Basukoski / Journal of Applied Logic 4 (2006) 141â167  155  Applying this rule, the label, LC(ind) introduced for the premise at stage 4 of the  transformation procedure, is preserved for both components of the conclusion.  Things are much more difficult when we deal with the AâŚ constraint. Recall that once  we have provided the labelling of formulae at stage 4 of the transformation procedure, the  number of indices is equal to the number of different E pre-clauses. Now we use this information about the number of existential path quantifiers based upon proof of Proposition 3,  namely, from the fact that âone needs only sufficient paths from each state of a model to  satisfy all the existential path formulae that have to be true in that state. Moreover the number of existential state formulae that can appear in a formula is bounded by the number of  path quantifiers in that formulaâ [15].  Renaming: the AâŚ case. Let LIST_IND = ind1 , . . . , indn . If for some index ind â  LIST_IND we do not have LC(ind) â LIST_IND then we upgrade LIST_IND by  LC(ind) (which can be easily justified).  Now, based on Proposition 3, we rename the Q subformula of AâŚQ as follows (if  the number of indices in LIST_IND, n = 0, then we create LIST_IND = ind with the new  index ind ).  if n = 0  if n > 0  P â AâŚQ  P â AâŚQ  P â EâŚx LC(ind)  x â EQ LC(ind)  P â EâŚx1 LC(ind1 )  x1 â EQ LC(ind1 )  ...  P â EâŚxn LC(indn )  xn â EQ LC(indn )  where x, x1 , . . . , xn are new atomic propositions.  Next we present another useful rule, called âTemporisingâ, which allows us to introduce  a temporal context, rewriting into SNFCTL purely classical formulae of the type Q â P .  Temporising.  P âQ  start â ÂŹP â¨ Q  true â A (ÂŹP â¨ ÂŹQ)  Finally, we utilize two rules allowing us to distribute the A and E modalities over  conjunction. In the latter rule, which will be used in our example, we again, incorporate  indices: given that the premise of this rule is labelled by LC(ind) , we preserve this label  for both conclusions, thus, assuring that they refer to the same path.  Distributing A and E over conjunction.  P â A(P â§ Q)  P â AP  P â AQ  P â E(P â§ Q) ind  P â EP ind  P â EQ ind  156  A. Bolotov, A. Basukoski / Journal of Applied Logic 4 (2006) 141â167  4.3. Example transformation  As an example we consider the application of the temporal resolution method, to check  the validity of the following ECTL formula:  AâŚp â AâŚp  (6)  To check that (6) is valid we negate it, obtaining  ÂŹ(AâŚp â AâŚp)  (7)  and then translate (7) into Negation Normal Form  AâŚp â§ EÂŹp  (8)  Following the translation algorithm, we obtain steps 0â2 below, where x is a new atomic  proposition.  0. start â AâŚp â§ EÂŹp anchoring to start  1. start â x  0, Initial Renaming  2.  x â AâŚp â§ EÂŹp 0, Initial Renaming  Now we split conjunction on the right hand side of the formula at step 2, generating steps  3â4.  3. x â AâŚp from 2, splitting â§  4. x â EÂŹp from 2, splitting â§  At this stage we first label pre-clause 4 by a new label, LC(f ) creating LIST_ IND and  then rename p in 3, introducing a new variable, l.  5. x â EâŚl LC(f) from 3, Renaming : AâŚ case  6. l â Ep LC(f) from 3, Renaming : AâŚ case  Now we must first apply the E removal rule to 4, introducing a new variable, y, thus,  deriving steps 7 and 8 below.  from 4, Removal of E  7. x â ÂŹp â§ y  8. y â E(ÂŹp â§ y) f from 4, Removal of E  Similarly we remove the E modality from 6 deriving 9â10 below (and introducing a  new variable, r).  from 6, Removal of E  9. l â p â§ r    10. r â E (p â§ r) f from 6, Removal of E  Now we split conjunctions on the right hand side of formulae 7 and 9.  11.  12.  13.  14.  x  x  l  l  â  â  â  â  ÂŹp  y  p  r  from 7, splitting â§  from 7, splitting â§  from 9, splitting â§  from 9, splitting â§  A. Bolotov, A. Basukoski / Journal of Applied Logic 4 (2006) 141â167  157  As steps 11â14 are purely classical expressions we introduce a temporal context incorporating the rule Temporising, deriving the steps below:  15.  16.  17.  18.  19.  20.  21.  22.  start  true  start  true  start  true  start  true  â  â  â  â  â  â  â  â  ÂŹx â¨ ÂŹp  A(ÂŹx â¨ ÂŹp)  ÂŹx â¨ y  A(ÂŹx â¨ y)  ÂŹl â¨ p  A(ÂŹl â¨ p)  ÂŹl â¨ r  A(ÂŹl â¨ r)  from 11, Temporising  from 11, Temporising  from 12, Temporising  from 12, Temporising  from 13, Temporising  from 13, Temporising  from 14, Temporising  from 14, Temporising  Finally, we distribute the E operator over conjunction in steps 8 and 10, preserving the  labelling:  23.  24.  25.  26.  y  y  r  r  â  â  â  â  EÂŹp f  Ey f  Ep f  Er f  from 8, Distributing E over â§  from 8, Distributing E over â§  from 10, Distributing E over â§  from 10, Distributing E over â§  The normal form of the given ECTL formula is represented by clauses 1, 5, 15â26.  4.4. Correctness of the transformation of ECTL formulae into SNFCTL  Here we give the correctness proof for the transformation procedure Ď = Ď2 (Ď1 (G))  applied to an ECTL formula G. We first show that an ECTL formula G is satisfiable, if  and only if, Ď1 (G) is satisfiable (Lemma 1). Next, we will establish that the transformation  procedure Ď2 preserves satisfiability (Lemma 2), and, finally, we prove that the converse of  Lemma 2 is true, i.e., that given Ď2 (Ď1 (G)) is satisfiable so is Ď1 (G) (Lemma 3).  Lemma 1. An ECTL formula, G, is satisfiable if, and only if, Ď1 (G) is satisfiable.  Proof. Recall that procedure Ď1 consists of the following steps: anchoring the initial formula, G, to start, application of equivalences (2) and Procedure Red. Here we first must  establish that given a satisfiable formula G, we derive a satisfiable formula A((start â  x0 ) â§ (x0 â G)), where x0 is a new atomic proposition. This can be shown by taking  a model M for the former and obtaining from it a model M which differs from M  only in the evaluation of x0 which is set to be true at the initial state and false elsewhere.  On the other hand, given a model that satisfies A((start â x0 ) â§ (x0 â G)), we also  have start â G satisfiable in the same model. Secondly, from the semantics of ECTL, application of equivalences (2) also preserves satisfiability and unsatisfiability. Finally, due  to Proposition 1, procedure Red preserves satisfiability and unsatisfiability. Therefore, an  ECTL formula, G, is satisfiable if, and only if, Ď1 (G) is satisfiable. 2  Lemma 2. Given a SNFCTL formula G, if Ď1 (G) is satisfiable then so is Ď2 (Ď1 (G)).  158  A. Bolotov, A. Basukoski / Journal of Applied Logic 4 (2006) 141â167  Recall that  â˘ a formula G in pre-clause form is of the form Pj â Qj , where Pj is a literal or start,  Qj is either a purely classical formula or Qj = PTCj or Qj = PâŚCj or Qj =  PâŚCj or Qj = P(Cj1 T2 Cj2 ), and Cj , Cj1 and Cj2 are purely classical formulae.  â˘ any SNFCTL clause is also a formula in a pre-clause form.  We must show that any step of the transformation procedure Ď2 preserves satisfiability.  Proposition 4. Let M be a model such that    ARi â§ AS  M, s0   i  where each Ri and S are in a pre-clause form.  Then there exists a model M such that    ARi â§ AS  M , s0   i  where each Ri is in a pre-clause form and S is a result of one step of the transformation  Ď2 [S].  Since S = (P â Q) is in a pre-clause form, we must consider the cases, corresponding  to possible applications of Ď2 [AS]. These cases are given by the stages 3â7 of the transformation algorithm described in Section 4. Here we outline the proof for the cases which  represent the core transformation technique of the paper, i.e., where Q = EâŚB (Case 1)  and Q = AâŚB (Case 2), omitting other cases, as proof of Proposition 4 for them repeats  stages of the corresponding proof for CTL [2].  Case 1. Here we apply Ď2 in the following way (y is a new atomic proposition).  Ď2 [A(P â EâŚB LC(ind) )]  Ď2 [A(P â Ey LC(ind) )]  Ď2 [A(y â EâŚB LC(ind) )]  Let M be a model which satisfies the condition of Proposition 4 in this case:        M, s0   ARi â§ A P â EâŚB LC(ind)  i  We show that there exists a model M such that the following holds:    ARi  (a) M , s0   i    (b) M , s0  A P â Ey LC(ind)      (c) M , s0  A y â EâŚB LC(ind)  A. Bolotov, A. Basukoski / Journal of Applied Logic 4 (2006) 141â167  159  In the corresponding proof we obtain a model M from M by letting a new atomic proposition y to be satisfied in the relevant places and then establishing the conditions (a)â(c)  taking into account the interpretation of the E clauses labelled with the âLCâ type indices.  Choose arbitrarily a fullpath Ď in M. If P is never satisfied along Ď then let M be the  same as M accept for a new atomic proposition y which is false everywhere along Ď.  Thus, (a)â(c) are satisfied in M as the left hand side of every implication of (a)â(c) is  false. Alternatively, let si â Ď be the first state along Ď which satisfies P . Thus, according  to SNFCTL semantics, there must be a path Ďsi associated with the LC(ind) such that  M, Ďsi  âŚB. According to fusion closure there also must be a path [s0 , si ] âŚ Ďsi . Now  we define a model M to be the same as M accept for a new atomic proposition y such  that for a path [s0 , si ] âŚ Ďsi associated with the LC(ind) , for any state sn â [s0 , si ] âŚ Ďsi , if  i  n then M , sn  x else M , sn  x. This guarantees that (a)â(c) are now satisfied in  M.  Case 2. Here we apply Ď2 in the following way  Ď2 [A(P â AâŚQ)]  Ď2 [A(P â EâŚx1 ) LC(ind1 ) ]  Ď2 [A(x1 â EQ) LC(ind1 ) ]  ...  Ď2 [A(P â EâŚxn ) LC(indn ) ]  Ď2 [A(xn â EQ) LC(indn ) ]  Let M be a model which satisfies the condition of Proposition 4 in this case. According  to Proposition 3, there exists an (n + 1)-ary canonical model M , which also satisfies these  conditions. Let LC(ind1 ), . . . LC(indn ) be labels which correspond to linear interpretations  of M . Note that each of these linear interpretations must satisfy P â AâŚQ. Now we  update M to M labelling the states of the paths corresponding to linear interpretations by  x1 similar to the labelling carried out in the Case 1 considered above. Thus, we guarantee  that all formulae in the conclusion of Proposition 4 in Case 2 are satisfied in M . Note  also that, once the labelling at stage 4 of the transformation procedure has been provided,  no more new indices will appear in the proof.  Lemma 3. Given an ECTL formula G, if Ď2 (Ď1 (G)) is satisfiable then so is Ď1 (G).  Recall that any formula to which Ď2 is applied is a formula in a pre-clause form, and  thus, has a structure A(P â Q). Thus, we must ensure the transformation Ď2 has the  following property:  Proposition 5. For any ECTL formula Q if Ď2 (A(P â Q)) is satisfiable then so is  A(P â Q), where P is a literal or conjunction of literals.  Proof. We prove this proposition by induction on the structure of Q.  For the base cases, (B1âB5 below) we have:  160  A. Bolotov, A. Basukoski / Journal of Applied Logic 4 (2006) 141â167  (B1) Q = PâŚl where P is either of path quantifiers and l is a literal. In this case      Ď2 A(P â PâŚl) = A(P â PâŚl)  Therefore, given      M, s0  Ď2 A(P â PâŚl)  we immediately conclude that  M, s0  A(P â PâŚl)  (B2) Q = (l1 â¨ Âˇ Âˇ Âˇ â¨ ln ), where li (1  i  n) is a literal. In this case           Ď2 A P â (l1 â¨ Âˇ Âˇ Âˇ â¨ ln ) = A start â (ÂŹP â¨ l1 â¨ Âˇ Âˇ Âˇ â¨ ln ) â§      A true â A(ÂŹP â¨ l1 â¨ Âˇ Âˇ Âˇ â¨ ln )  Thus, given      M, s0  A start â (ÂŹP â¨ l1 â¨ Âˇ Âˇ Âˇ â¨ ln ) â§      A true â A(ÂŹP â¨ l1 â¨ Âˇ Âˇ Âˇ â¨ ln )  we conclude that      M, s0  start â (ÂŹP â¨ l1 â¨ Âˇ Âˇ Âˇ â¨ ln )      M, s0  A true â A(ÂŹP â¨ l1 â¨ Âˇ Âˇ Âˇ â¨ ln )  (B3)â(B4) Q = true and Q = false, respectively. Here the proof is immediate.  (B5) Q = P(l1 â¨ Âˇ Âˇ Âˇ â¨ ln ) where P is either of path quantifiers.  Here          Ď2 (A P â P(l1 â¨ Âˇ Âˇ Âˇ â¨ ln ) = A P â P(l1 â¨ Âˇ Âˇ Âˇ â¨ ln )  Hence, given       M, s0  Ď2 A P â P(l1 â¨ Âˇ Âˇ Âˇ â¨ ln )  we immediately obtain      M, s0  A P â P(l1 â¨ Âˇ Âˇ Âˇ â¨ ln )  Now, assuming as an induction hypothesis that Proposition 5 holds for any formula D1 ,  D2 , ÂŹD1 and ÂŹD2 , we will show that it also holds for any of the following combinations:  D1 â§ D2 , P(D1 â§ D2 ), PTD1 , PT2 D1 , EâŚD1 , AâŚD1 , etc.  Noting that proofs for PTD1 , PD1 T2 D2 (where D1 and D2 are classical but not literals, true or false) and P(D1 â§ D2 ) follow immediately from ECTL semantics, proof  for D1 â§ D2 , which involves only classical reasoning, follows directly from SNFCTL semantics, and that proofs for the cases ED1 , A(D1 UD2 ), E(D1 UD2 ), E(D1 WD2 ) and  A(D1 WD2 ) are similar to the case (AD1 ), we first consider the latter case and then two  cases corresponding to the novel techniques introduced in this paper, namely, for EâŚD1  and AâŚD1 .  A. Bolotov, A. Basukoski / Journal of Applied Logic 4 (2006) 141â167  161  Consider the case Q = AD1 . Here we are given      (â ) M, s0  Ď2 A(P â AD1 )  from which we will show that  (âĄ)  M, s0  A(P â AD1 )  1. M, s0  Ď2 (A(P â Ay)), from the condition (â );  2. M, s0  Ď2 (A(y â D1 )), from the condition (â ).  Therefore, as Ď2 here is the âAâ removal rule, from 1 we obtain 3 and 4:  3. M, s0  Ď2 (A(P â (y â§ z));  4. M, s0  A(z â Ay) and M, s0  A(z â Az);  Now, following SNFCTL semantics, we derive 5 and 6.  5. M, s0  A(start â ÂŹP â¨ y) and M, s0  A(true â A(ÂŹP â¨ y)), from 3;  6. M, s0  A(start â ÂŹP â¨ z) and M, s0  A(true â A(ÂŹP â¨ z)), from 3.  By inductive hypothesis, from 2, we also have  7. M, s0  A(y â D1 ).  Now we can see that M indeed satisfies A(P â AD1 ): from 5 we conclude that wherever P is satisfied in M so is y and hence, from 7, so is D1 . Also, 6 indicates that if P is  satisfied at an arbitrary state si on an arbitrary fullpath Ď then so is z. Hence, from 4, for  any path Ďsi , a state si+1 , the successor of si along Ďsi , satisfies both y and z. Therefore,  from 7, si+1 satisfies D1 . Again, as si+1 satisfies z then any successor of si+1 also satisfies  y and z, hence, satisfies D1 , etc. Therefore, each path departing at si satisfies D1 , i.e.,  we have shown that the conditions (âĄ) holds: M, s0  A(P â AD1 ) as required.  Consider the case Q = EâŚB. Here we are given      (â ) M, s0  Ď2 A(P â EâŚB LC(ind) )  from which we will show that  (âĄ)  M, s0  A(P â EâŚB LC(ind) )  As here Ď2 is the application of the Renaming rule (the EâŚ case) we have  1. M, s0  Ď2 (A(P â Ex LC(ind) )), from the condition (â );  2. M, s0  Ď2 (A(x â EâŚB LC(ind) )), from the condition (â );  By inductive hypothesis we have  3. M, s0  A(x â EâŚB LC(ind) ), from 2;  Now we can see that M indeed satisfies A(P â EâŚB LC(ind) ): from 1 we conclude  that wherever P is satisfied in M, from that point there exists a path associated with  LC(ind) which satisfies x. Also 3 indicates that if x is satisfied at an arbitrary state  162  A. Bolotov, A. Basukoski / Journal of Applied Logic 4 (2006) 141â167  si on an arbitrary fullpath Ď then there must be path from si associated LC(ind) which  satisfies âŚB. Therefore, we have shown that the conditions (âĄ) holds: M, s0  A(P â  EâŚB LC(ind) ) as required.  Consider the case Q = AâŚB. Here we are given  M, s0  M, s0  (â ) . . .  M, s0  M, s0   Ď2 A(P â EâŚx1 LC(ind1 ) )   Ď2 A(x1 â EB LC(ind1 ) )   Ď2 A(P â EâŚxn LC(indn ) )   Ď2 A(xn â EB LC(indn ) )  from which we will show that  (âĄ)  M, s0  A(P â AâŚB)  Recall that here Ď2 is the application of the Renaming rule (the AâŚ case). Let us abbreviate A(P â EâŚx1 LC(ind1 ), A(x1 â EB LC(ind1 ) ), . . . , A(P â EâŚxn LC(indn ) ),  A(xn â EB LC(indn ) ) as a1 , . . . , an , respectively, and let M be a model which satisfies (â ), where M = (S, R, L). Thus, we have M, s0  a1 â§ Âˇ Âˇ Âˇ â§ an . From Proposition 3, we know that if a formula with n path quantifiers has a model, then it has an  (n + 1)âary canonical model. We will now construct this canonical model M and show  that it also satisfies âĄ. The construction proceeds in the manner of [15]. We define our  (n + 1)-ary tree interpretation for formula â  as M , Îť , where M = ([n + 1] , R, Ď)  such that Ď : [n + 1] ââ 2Prop (see Definition 10), and inductively construct a mapping  Ď : [n + 1]â ââ S, taking Ď(s) = L(Ď(s)).  We start by first selecting a linear interpretation Ml , s0 , where Ml = (Sl , Rl , Ll ) from  M, s0  (a1 ) â§ Âˇ Âˇ Âˇ â§ (an ) such that Ml , s0  aj (1  j  n), and define a mapping Ď0  on the set X0 = 1â , as Ď0 (1k ) = Rl k (s0 ) (k  0). This will be a basis path (labelled by Ď)  which is also referred to as the âleftmostâ path of the canonical model in [15].  Now, given Ďi defined on the set of nodes Xi , we define Ďi+1 and the set Xi+1 . For  each aj from â , we choose a linear interpretation, Mlj , Ď(s) and define Ďi+1 (s(j +  1)) = Rlj (Ď(s)) and Ďi+1 (s(j + 1)1k ) = Rlj k (Ď(s)) for k  0. Finally, taking Ď to be ĎĎ  completes the canonical model (see Fig. 5).  Fig. 5. (n + 1)âary canonical model for âĄ.  A. Bolotov, A. Basukoski / Journal of Applied Logic 4 (2006) 141â167  163  The construction of M ensures that P â EâŚB is satisfied on every path from Îť. Thus  M , Îť  A(P â AâŚQ), from ECTL semantics. We also know that for any ECTL  formula F , M , Îť  F iff M, s0  F . Hence M, s0  A(P â AâŚQ) (âĄ). 2  Now from Lemmas 1, 2 and 3 we have the following theorem:  Theorem 1. An ECTL formula, G, is satisfiable if, and only if, Ď (G) is satisfiable.  5. The temporal resolution method  Having provided the translation of ECTL formulae into SNFCTL , we represent all temporal statements within ECTL as sets of clauses. Now, in order to achieve a refutation, we  incorporate two types of resolution rules already defined in [2,6]: step resolution (SRES)  and temporal resolution (TRES).  Step resolution rules. Step resolution is used between formulae that refer to the same  initial moment of time or same next moment along some or all paths. In the formulation of  the SRES rules below l is a literal and C and D are disjunctions of literals.  SRES 1  start â C â¨ l  start â D â¨ ÂŹl  SRES 2  P â A(C â¨ l)  Q â A(D â¨ ÂŹl)  start â C â¨ D  (P â§ Q) â A(C â¨ D)  SRES 3  SRES 4  P â A(C â¨ l)  Q â E(D â¨ ÂŹl) ind  P â E(C â¨ l) ind  Q â E(D â¨ ÂŹl) ind  (P â§ Q) â E(C â¨ D) ind  (P â§ Q) â E(C â¨ D) ind  When an empty constraint is generated on the right hand side of the conclusion of the  resolution rule, we introduce a constant false to indicate this situation and, for example,  the conclusion of the SRES 1 rule, when resolving start â l and start â ÂŹl, will be  start â false.  Temporal resolution rules. The basic idea of invoking temporal resolution is to resolve  a clause containing âŚÂŹl together with a set of formulae characterizing a loop in l, a  set of SNFCTL clauses indicating a situation when l occurs at all future moments along  every (an A-loop in l) or some path (a E-loop in l) from a particular point in an ECTL  model [5].  164  A. Bolotov, A. Basukoski / Journal of Applied Logic 4 (2006) 141â167  TRES 1  TRES 2  P â AAl  Q â AâŚÂŹl  P â AAl  Q â EâŚÂŹl LC(ind)  Q â A(ÂŹP WÂŹl)  Q â E(ÂŹP WÂŹl) LC(ind)  TRES 3  P â EEl LC(ind)  Q â AâŚÂŹl LC(ind)  TRES 4  Q â A(ÂŹP WÂŹl) LC(ind)  Q â E(ÂŹP WÂŹl) LC(ind)  P â EEl LC(ind)  Q â EâŚÂŹl LC(ind)  where the first premise is the abbreviation for the A loop or E loop in l given that P is  satisfied.  The aim of applying the temporal resolution method to a set of SNFCTL clauses, R, is to  derive an empty clause start â false. If we have derived an empty clause then the procedure terminates and the set R is unsatisfiable. If we have not achieved this applying SRES  rules and there is no eventuality clause in the set of clauses then the procedure terminates  indicating that R is satisfiable. Alternatively, we create a list of eventualities, say l1 , . . . , ln  and start looking for loops in ÂŹl1 , ÂŹl2 , . . . which will lead us to the application of the corresponding TRES rule and subsequent chain of transformations and further applications  of SRES. This chain repeats until we either derive an empty clause or no more rules have  become applicable. (For full details of the method see [5,6].)  Correctness of the transformation of ECTL formulae into SNFCTL (Section 4.4) together  with the termination and correctness of the resolution method defined over SNFCTL (shown  in [2,6]) enables us to apply the latter as the refutation method for ECTL. Namely, given  an ECTL formula G, translate ÂŹG into SNFCTL (G) and apply the temporal resolution  method to the latter. If an empty clause is derived then ÂŹG is unsatisfiable, hence G is  valid, otherwise ÂŹG is satisfiable, hence G is not valid.  Example refutation. We apply the resolution method to the set of SNFCTL clauses obtained for ECTL formula AâŚp â AâŚp (formula (6) in section Section 4.3). We commence the proof presenting at steps 1â8 only those clauses that are involved into the  resolution refutation in the following order: initial clauses, step clauses and, finally, any  sometime clauses.  1.  2.  3.  4.  5.  6.  7.  8.  start  start  start  start  true  y  y  x  â  â  â  â  â  â  â  â  x  ÂŹx â¨ y  ÂŹx â¨ ÂŹp  ÂŹl â¨ p  A(ÂŹl â¨ p)  EÂŹp f  Ey f  EâŚl LC(f)  A. Bolotov, A. Basukoski / Journal of Applied Logic 4 (2006) 141â167  165  As we mentioned, the first stage of applying the temporal resolution method is the application of SRES rules in order to either derive an empty clause or to specify a set of  step clauses for a loop searching technique. Thus, applying step resolution rules we obtain  steps 9â12.  9. start â ÂŹp  10. start â y  11. start â ÂŹl  12.  y â EÂŹl f  1, 3 SRES 1  1, 2 SRES 1  4, 9 SRES 1  5, 6 SRES 2  As we have not derived an empty clause and there is an eventuality clause 8, we are looking  for a loop in ÂŹl. The desired loop is given by clauses 7 and 12, namely these formulae  together represent a E loop in ÂŹl: y â EEÂŹl LC(f) . Thus, we apply the TRES 4 rule  to resolve this loop and clause 8, obtaining 13.  13. x â E(ÂŹyWl) LC(f) 7, 12, 8 TRES 4  At this stage we remove EW, and use only one of the conclusions of this rule. This  gives us a purely classical formula on step 14 below, where z is a new variable.  14. x â l â¨ ÂŹy â§ z 13, Removal of EW  Now, applying some classical transformations together with the temporising rule, we  derive 15, and finally, a chain of applications of the SRES 1 gives us the terminating clause  start â false.  15. start â ÂŹx â¨ l â¨ ÂŹy 14, classical, Temporizing  16. start â false  1, 10, 11, 15 SRES 1  6. Conclusions and future work  We have described the extension of the clausal resolution method to the useful  branching-time logic ECTL. To the best of our knowledge there are no analogous clausal  resolution methods developed for branching-time logics. One of the obvious benefits of  using the clausal resolution technique is the possibility of invoking a variety of welldeveloped methods and refinements used in the framework of classical logic. Another  obvious advantage of using this technique is its capacity to handle arbitrary systems, while  other methods, such as for example, the model checking technique [1], are restricted to the  analysis of finite state systems.  Note also, that in [7], it was shown that the normal form developed for linear-time  temporal logic is as expressive as BĂźchi word automata, and, therefore, as propositional  linear-time Îź-calculus [8]. Thus, in the linear-time case we are able to represent a problem specification directly as a set of formulae in the normal form and apply a resolution  based verification technique to the latter. This opens another direction of our future workâ  analysis of the correspondence of SNFCTL , the normal form for several branching-time  logics, CTL, ECTL, and ECTL+ , and automata for branching-time logics.  166  A. Bolotov, A. Basukoski / Journal of Applied Logic 4 (2006) 141â167  The algorithm to search for loops needed for temporal resolution was introduced in [5].  With the proof that SNFCTL can be served as the normal form for ECTL, the algorithm  becomes fully functional for the latter. Taking into account these observations, we define  a future task to refine this algorithm, to analyse the complexity of the clausal resolution  method for logics CTL, ECTL and ECTL+ , and to develop corresponding prototype systems.  We believe that a number of techniques explored in this paper will be useful in developing the resolution method for other extensions of CTL culminating in CTLâ :  (1) The method of identifying different types of nesting of temporal operators understood as minimal or maximal fixpoints. We have shown that in the âbadâ nesting, a temporal  operator defined as a maximal fixpoint is prefixed by an âEâ quantifier or a temporal operator defined as a minimal fixpoint is prefixed by an âAâ quantifier.  (2) Our novel technique to transform ECTL formulae which contain fairness constraints  representing these âbadâ cases of nesting of temporal operators is based upon the indexing  and the existence of the canonical model. Note that the canonical model construction was  crucial in our correctness argument.  (3) The technique of analysing formulae which have some structural similarity but have  different satisfiability characteristics. For example, a âtinyâ change of the satisfiable CTL  formula AâŚ(p â§ EÂŹp) to AâŚ(Ep â§ EÂŹp) makes the latter unsatisfiable. Thus,  in developing the required transformation rules it will be useful to have a test-bench of  such CTL formulae which will also be an effective method of testing the correlation of  the transformation rules under development and the desired resolution procedure.  Acknowledgements  We would like to thank Michael Fisher, Clare Dixon and Mark Reynolds for useful  discussions during the preliminary work on the paper, and Renate Schmidt for valuable  comments on the relevant material in the PhD thesis [2]. We are also grateful to anonymous  referees for their suggestions on improving this article.  References  [1] O. Bernholtz, M.Y. Vardi, P. Wolper, An automata-theoretic approach to branching-time model checking,  in: Computer Aided Verification, Proc. 6th Int. Workshop, Stanford, CA, in: Lecture Notes in Computer  Science, vol. 818, Springer, Berlin, 1994, pp. 142â155.  [2] A. Bolotov, Clausal resolution for branching-time temporal logic, PhD thesis, Department of Computing  and Mathematics, The Manchester Metropolitan University, 2000.  [3] A. Bolotov, Clausal resolution for extended computation tree logic ECTL, in: Proceedings of the Time2003/International Conference on Temporal Logic 2003, Cairns, IEEE, 2003.  [4] A. Bolotov, A. Basukoski, A clausal resolution for branching-time logic ECTL+ , in: Proceedings of the  Time-2004, IEEE, 2004, pp. 140â147.  [5] A. Bolotov, C. Dixon, Resolution for branching time temporal logics: applying the temporal resolution rule,  in: Proceedings of the 7th International Conference on Temporal Representation Reasoning (TIME2000),  Cape Breton, Nova Scotia, Canada, IEEE Computer Society, 2000, pp. 163â172.  [6] A. Bolotov, M. Fisher, A clausal resolution method for CTL branching time temporal logic, J. Experimental  Theoret. Artificial Intelligence 11 (1999) 77â93.  A. Bolotov, A. Basukoski / Journal of Applied Logic 4 (2006) 141â167  167  [7] A. Bolotov, M. Fisher, C. Dixon, On the relationship between âwâ-automata and temporal logic normal form,  J. Logic Comput. 12 (2002) 561â581.  [8] J. Bradfield, C. Stirling, Modal logics and mu-calculi, in: J. Bergstra, A. Ponse, S. Smolka (Eds. ), Handbook  of Process Algebra, Elsevier, North-Holland, Amsterdam, 2001, pp. 293â330.  [9] E.M. Clarke, E.A. Emerson, Design and synthesis of synchronisation skeletons using branching time temporal logic, in: Logic of Programs, Proceedings of Workshop, in: Lecture Notes in Computer Science, vol. 131,  Springer, Berlin, 1981, pp. 52â71.  [10] E.A. Emerson, Temporal and modal logic, in: J. van Leeuwen (Ed. ), Handbook of Theoretical Computer  Science, vol. B, Formal Models and Semantics, Elsevier, Amsterdam, 1990, pp. 996â1072.  [11] E.A. Emerson, Automated reasoning about reactive systems, in: Logics for Concurrency: Structures Versus  Automata, Proc. of International Workshop, in: Lecture Notes in Computer Science, vol. 1043, Springer,  Berlin, 1996, pp. 41â101.  [12] E.A. Emerson, J.Y. Halpern, âSometimesâ and âNot neverâ revisited: On branching versus linear time temporal logic, J. ACM 33 (1) (1986) 151â178.  [13] E.A. Emerson, A.P. Sistla, Deciding full branching time logic, in: Proceedings of the Sixteenth Annual ACM  Symposium on Theory of Computing (STOC 1984), 1984, pp. 14â24.  [14] M. Fisher, A resolution method for temporal logic, in: Proc. of the XII International Joint Conference on  Artificial Intelligence (IJCAI), 1991, pp. 99â104.  [15] P. Wolper, On the relation of programs and computations to models of temporal logic, in: L. Bolc, A. SzaĹas  (Eds. ), Time and Logic, a Computational Approach, UCL Press Limited, 1995, pp. 131â178, Chapter 3. 