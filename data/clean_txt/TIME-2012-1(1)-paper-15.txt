2012 19th International Symposium on Temporal Representation and Reasoning  Compositional Reﬁnement for Real-Time Systems  with Priorities  Abdeldjalil Boudjadar, Jean-Paul Bodeveix, Mamoun Filali  IRIT-UPS, Université de Toulouse  Toulouse, France  {boudjada, bodeveix, ﬁlali}@irit.fr  Si is an abstraction of Si . With the above fact, checking  that S satisﬁes a property P becomes more tractable and  simply consists of checking that each component Si satisﬁes  a property Pi , where P is a composition of Pi . That is what  happen in compositional veriﬁcation [14] and abstractionbased veriﬁcation [6]. Deﬁning the parallel composition and  ﬁnding a suitable reﬁnement relation for real-time systems  with communication, priorities and variables is a tough task.  Real-time system properties are often formalized using timeconstraints and priorities. To consider such concepts, we  introduce real-time systems with a global space (variables  and clocks) and priorities (static and dynamic). Similarly to  process algebras, to deal with hierarchical design and speciﬁcations, real-time formalisms have known a large number of  composition approaches. However, a compositional framework  with high-level concepts like variables, communication and  priorities is still lacking. Several works [11], [16], [22], [13]  have focused on this subject by analyzing thoroughly the  problem and criticizing existing solutions. In fact, this paper  is a follow up of [12] where we have revisited the composition of timed systems, without priorities, and proposed a  new communication mechanism for UPPAAL timed automata.  In [12], we have deﬁned an original composition operator  endowed with good properties (associativity, reﬁnement, etc. ),  and supporting communications via synchronization of actions  and shared variables. Through the introduction of priority,  we revisit the framework deﬁned in [12] for reasoning about  the composition of timed systems. Thereafter, our framework,  deﬁned with priorities, will be instantiated for UPPAAL timed  automata with three priority orders : static priority, priority  on channels and priority on processes, where we will analyze  different priority relations, and give both operational semantics  and reﬁnement of timed automata TA and networks of timed  automata NTA (in compositional way). The rest of our paper  is organized as follows: Section 2 presents the existing related  work. In Section 3, we present the formal basis of our  work, where we introduce Communicating Labelled Transition  Systems with location Invariants and Priorities (CLTSIP). We  give a sufﬁcient condition for the bisimilarity and deﬁne an  associative product of CLTSIPs. Moreover, we deﬁne ETTSs  as CLTSIPs which synchronize on time instants. Section 4  introduces UPPAAL TA and NTA with committed locations,  priority on channels and priority on processes. Here, we  show the compositionality of NTA semantics in terms of  ETTSs, where the two corresponding ETTS-based semantics  Abstract—High-level requirements of real-time systems like as  time constraints, communications and execution schedulability  make the veriﬁcation of real-time models arduous, where a system  is the interaction of a possibly unbounded set of components.  Priorities have been introduced to resolve execution conﬂicts, and  by that, prevent the combinatorial explosion of state space. In  this paper, we are interested in the composition and reﬁnement  of timed systems by considering static and dynamic priorities.  Firstly, we propose a revised deﬁnition of the product of extended  timed transition systems with static and dynamic priorities  associated to individual transitions. Afterwards, we study the  (compositional) reﬁnement of compound extended timed systems.  Without sacriﬁcing compositionality, we instantiate this framework for the case of UPPAAL networks of timed automata  with static priority Committedness, dynamic priority between  channels and priority between processes. Moreover, we show how  to associate an Extended Timed Transition System (ETTS) to  timed automata (TA), where an unique generalized dynamic  priority system of ETTS is derived from both dynamic priority  orders: priority between channels and priority between processes.  Keywords-Timed systems; composition; reﬁnement; priorities.  I. I NTRODUCTION  The concurrency theory [25] is an extremely helpful concept  whereby the design of complex systems becomes as far as  tractable. It has by now established itself as an extensive  research ﬁeld for mastering the schedulability of executions.  However, concurrency has a real impact on model checking  of real-time systems, where conﬂicts and non-determinism  of executions are greatly diverging together with the number of system (competing) processes, which often leads to  combinatorial explosion of the state space, the reason for this  being that time is considered as part of the state. To tackle  non-determinism and execution conﬂicts, priorities have been  introduced as a scheduling order. Composition, reﬁnement and  model-checking of timed systems with priorities have been  intensively studied [9], [18], [22], [3], [17], [16], [13]. The  ultimate goal of these work is to deal with details resulted  from the use of clock variables and evolutive data structures,  required by real-time applications. Abstraction reﬁnement [19]  plays a key role in the design and veriﬁcation of real-time  systems. It enables to abstract unbounded data structures and  implementation details whereby, we are able to perform model  checking on a system S  = S1  ...  Sn instead of the  original complex system S = S1  ...  Sn , where each  1530-1311/12 $26.00 © 2012 IEEE  DOI 10.1109/TIME.2012.21  57  priority orders on channels and on processes, and establish  their compositional semantics in terms of ETTSs.  are equivalent: a direct one (an ETTS associated to the NTA)  and the product of ETTSs, associated to individual timed  automata, composed with a restriction. We also establish an  interesting reﬁnement property stating that: the reﬁnement of  a NTA consists in the reﬁnements (separately) of its individual  TA. Finally, we show an application of our framework to reﬁne  a version of the Alternating Bit Protocol [28], and conclude  with future work.  III. T RANSITION S YSTEM E XTENSIONS  In this section, after introducing priorities, we give a brief  recall of one of the fundamental models of concurrency,  transition systems, originally introduced in [27] and since then  studied extensively by [26] and others. Roughly speaking,  transition systems are an elegant model for representing the  behavioral aspects. Due to their safety properties veriﬁable  using model-checking, transition systems have been intensively applied to the modelling of complex systems, as well  as for giving semantics to synchronous languages and realtime formalisms. In what follows, we deﬁne composable symbolic transition systems (CLTSIP) as a modeling framework.  Thereafter, we give their associative product and study the  reﬁnement of their parallel composition.  II. R ELATED W ORK  Composition and reﬁnement of real-time systems with priorities have been intensively studied [18], [16], [13], [22],  [9] during the last two decades. However, a compositional  framework merging different priority systems is still relatively  lacking. Several works of Sifakis [11], [18], [3], Cleaveland  [9], [15] and UPPAAL team [16], [17] have focused on the  modeling and synthesis of timed systems with priorities. They  represent a common theoretical basis for the modeling with  priorities.  The authors of [18] deﬁne a design framework for both  safety and deadlock-freedom requirements. The framework  consists of a priority system, where an action ai has (dynamic)  priority over another action aj once a condition cij is satisﬁed  together with the enabledness of actions. In the same way,  [11] deﬁnes a dynamic priority on actions, where an action ai  has a priority on an action aj during a certain time interval.  In fact, such dynamic priority relations are a partial function  because they are only applied under the satisfaction of an extra  condition on comparable actions.  In [16], the authors deﬁne an extension of timed automata  with a dynamic priority order between actions and another  priority order between processes. They give an efﬁcient algorithm to compute subtractions of DBMs (Difference Bounded  Matrices). The authors deﬁne a non compositional semantics  of networks of extended TA, in terms of timed transition  systems. Under certain restrictions, they show how an unique  generalized priority order can be derived from both action and  process priority orders.  In [9], the authors describe a modeling framework for  real-time systems, using dynamic priorities, which essentially  extends CCS (Calculus of Communicating Systems) algebra  [25] with dynamic priorities. Such a proposal reduces drastically the state space of systems and preserves their functional  behavior. In fact, action priorities are not constant and may  change when the system evolves. Formally, each action priority  is inferred from delays preceding that action. Accordingly, the  longer is the delay preceding an action, the lower is its priority.  In this paper, we present a compositional framework for  the composition and reﬁnement of timed systems with both  static and dynamic priorities. To this end, we consider an  extended structure of timed transition systems ETTS with  variables, location invariants and communication where each  transition possesses a static priority s and a dynamic one d. We  deﬁne an associative parallel product of ETTSs together with  a compositional reﬁnement property. Moreover, we instantiate  our framework for the case of UPPAAL networks of timed  automata, with the static priority committedness and dynamic  A. Priority Systems  Priorities [9], [15], [18], [3], [22], [13] have been introduced  as a way to structure and control the usage of shared resources,  by specifying that some actions or behavior are privileged  over others. They offer a scheduling order to deal with nondeterminism and execution conﬂicts. The BIP language [3] and  ACSR algebra [13] provide a powerful mechanism to express  different sort of priorities. Mainly, we distinguish static and  dynamic priorities:  •  •  Static priorities [12], [7], [4] deﬁne an order between  transition executions regardless of their enabledness. With  such priorities, non-enabled higher-priority transitions  hide enabled lower-priority transitions, which often leads  to a deadlock. In UPPAAL timed automata [4], the static  priority is represented by the notion of Committedness  (two priority levels) where committed transitions [7],  those outgoing from a committed location, have priority  over non-committed ones.  Dynamic priorities [22], [18], [9], [16] state that an  enabled transition hides a lower-priority transition. [18]  introduces a conditional dynamic priority relation, where  an enabled transition hides a lower-priority one if a given  condition holds. Another class of priority relations [11]  consists to restrict the applicability of priority to a given  time interval. The semantics of priority relations [11],  [18], deﬁned over timed systems, is given by a model  transformation where only dynamically higher-priority  transitions are held.  Deﬁnition 1 (Priority system): A priority system P is a  triplet P, ,  where P,  is a join semi-lattice, and   : P × P → P is an associative and commutative operator  deﬁning the maximum of two values. We also use i pi to  represent the maximum of a ﬁnite non empty set of values.  In fact, the join semi-lattice P,  represents a partially  ordered set of priority values, where each subset of P has  a least upper bound.  58  •  B. Labelled Transition Systems  Labelled transition systems [2] are the reference model  used to express and compare behaviors through simulations.  They offer a strong notion of equivalence that can be checked  efﬁciently. Firstly, let us start with a brief recall of classical  labelled transition systems (LTS).  Deﬁnition 2 (LTS): A labelled transition system (LTS) over  an alphabet Σ is a tuple Q, Q0 , T r, α, β, λ where:  0  • Q is the state space such that Q ⊆ Q is the set of initial  states,  • T r is the set of transitions,  • α : T r → Q and β : T r → Q are functions associating,  respectively, source and target states to each transition,  • λ : T r → Σ is a function associating to each transition a  label.  l  For the sake of simplicity, we write t : q → q  for t ∈ T r    with α(t) = q, β(t) = q , λ(t) = l. If useless, the name  of a transition will be omitted. Moreover, projection functions  α, β and λ can be omitted and systematically inferred from  the transition relation →. By now, we give LTSs simulation  to check that a concrete LTS implements an abstract one.  Deﬁnition 3 (Simulation): Given two labelled transition  systems Tc = Qc , Q0c , T rc  (concrete) and Ta =  Qa , Q0a , T ra  (abstract), Ta simulates Tc through a relation  R ⊆ Qc × Qa , denoted by Tc R Ta , if:  0  0  • ∀qc ∈ Qc , there exists qa ∈ Qa such that R(qc , qa ).  l        • ∀qc qc qa l, if qc →c qc and R(qc , qa ) there exists qa ∈  l        Qa such that qa →a qa and R(qc , qa ).  Accordingly, two LTSs Ti and Tj are bisimilar through a  relation R ⊆ Qi × Qj , denoted by Ti ∼R Tj , if Ti R Tj  and Tj R−1 Ti .  •  Static priority expresses that a higher-priority transition  hides a lower-priority one. The hiding is supposed to  be static: a non-ﬁrable high-priority transition can hide  a ﬁrable lower-priority transition.  Dynamic priority states that an enabled priority transition  hides lower-priority ones. An enabled transition is ﬁrable  if it is not hidden by another higher-priority enabled  transition.  Throughout this paper, the static priority is considered ﬁrst.  We have also introduced location invariants over the global  space to restrict the set of states, by reducing the global space  valuations.  Deﬁnition 4 (CLTSIP): Given two priority systems Ps =  Ps , s , s  (static) and Pd = Pd , d , d  (dynamic), a  composable LTS with location invariants and priorities (CLTSIP) over a shared space G, an action language A 1 , a set of  one-to-one channels C and a set of synchronization events M  is a tuple Q, q 0 , G0 , I, T r, α, β, λ where:  •  •  •  •  •  •  •  C. Composable LTS with Location Invariants and Priorities  Q is the set of locations (local states),  q 0 is the initial location,  G0 is the set of initial global states,  I : Q → 2G associates an invariant to each location,  T r is the set of transitions,  α : T r → Q and β : T r → Q are functions associating,  respectively, the source and target locations of each  transition,  λ : T r → L×A×Ps ×Pd is a function associating to each  transition the corresponding label, action, static priority  value and dynamic one, where L = C? ∪ C! ∪ M ∪ {τ }  is the set of labels. C! and C? correspond respectively to  send and receive labels over channels C. M is the set of  multiple (many to many) synchronization events and τ is  the internal event.  Moreover, a CLTSIP must satisfy the wellformedness condition: n-ary synchronization transitions, with a label in M , are  supposed to have the lowest static and dynamic priorities.  In this section, we deﬁne composable LTS with location  invariants and priorities (CLTSIPs), as an extension of labelled  transition systems with shared variables, communication, static  priority, dynamic priority and location invariants. Moreover,  we specialize both state space and alphabet to allow several  communication protocols between transition systems:  • via a shared space: we distinguish local and global state  spaces, and introduce abstract actions that update the  global state space. These actions can be non-deterministic  and blocking.  • via CCS-like channels [25]: we introduce a set C of sendreceive channels, where two transitions synchronize if  their actions are complementary. The resulting transition,  of such a synchronization, corresponds to an internal  transition in the composition.  • via CSP (Communicating Sequential Processes)-like synchronization [21]: we introduce a set M of many-to-many  synchronization events, which enable to model a system  transition where all processes perform a lock-step [21].  Throughout this paper, we use such a synchronization to  model time-evolution transitions.  Furthermore, to reduce the non-determinism and execution  conﬂicts, we consider the following priority mechanisms.  l/a  Here and elsewhere, we write t : q −−→s,d q  for a transition  t ∈ T r with α(t) = q, β(t) = q  , λ(t) = l, a, s, d. If not  needed, the name of a transition will be omitted. Again, the  set of transitions T r is often denoted by the transition relation  →, which enables to omit the projection functions α, β and  λ. The semantics [[.]] of the action language A is given by  [[.]] : A → 2G×G . Let us consider the following predicates:  •  •  l/a  A transition t : q −−→s,d q  is said to be enabled in a  global state G if ∃G | (G, G ) ∈ [[a]] and G |= I(q  ).  l/a  A transition t : q −−→s,d q  is said to be statically hidden      l /a  if ∃t : q −−−→s ,d q  such that s ≺s s .  •  l/a  A transition t : q −−→s,d q  is said to be dynamically    l /a  hidden if ∃t : q −−−→s ,d q  enabled and non statically  hidden such that d ≺d d .  Accordingly, a transition is said to be hidden if it is statically  and dynamically hidden.  1 This action language is abstract here. It will be made more precise in  section IV-B  59  Deﬁnition 5 (Semantics of a CLTSIP): Given a global  space G, a static priority system Ps = Ps , s , s , a  dynamic priority system Pd = Pd , d , d  and an action  language semantics [[.]] : A → 2G×G . The semantics of the  CLTSIP Q, q 0 , G0 , I, T r is the LTS:  • Q × G,  0  0  0  • {q } × (G ∩ I(q )),    l/a    from a location corresponding to q in the abstract CLTSIP  T2 . The universal quantiﬁer given in Item (2) dissociates the  condition on priorities from that of reﬁnement and makes, by  that, the proofs further simpler than that of the LTS-based  reﬁnement.  Proof. Straightforward.  1) Restriction of a CLTSIP: The restriction [25] of a  CLTSIP, over a set of channels, is a CLTSIP where transitions  composable over these channels have been removed together  with transitions of lower static priority.  Deﬁnition 7 (CLTSIPs restriction): Given a CLTSIP T =  Q, q 0 , G0 , I, −→ over a shared space G and a set of channels  C. Let C  ⊆ C, we deﬁne the restriction of T over C  , denoted  l/a  by T \C  , to be the CLTSIP Q, q 0 , G0 , I, {t : q −−→s,d q  |    {(q, G), l, (q , G ) | ∃t : q −−→s,d q ∈ T r, G |= I(q),  enabled(t, G), ¬statically hidden(t) and  ¬dynamically hidden(t)}  In fact, LTS states correspond to the product of both locations and space valuations of the CLTSIP. Namely, an enabled  transition t, of CLTSIP, is held if it is not statically hidden by  a higher-priority transition t , i.e. s ⊀s s , and if it is not again  dynamically hidden by another enabled non-hidden transition,  i.e enabled(t , G) ∧ ¬statically hidden(t ) ⇒ d ⊀d d .  Deﬁnition 6 (Similarity): A CLTSIP Ti is said to be  (bi)similar to CLTSIP Tj if their associated LTSs are  (bi)similar.  The presence of both static and dynamic priorities makes the  semantics of CLTSIPs rather complex. It would be much more  readable if we could get rid of managing priorities during simulation proofs. To this end, we consider a sufﬁcient condition  for the reﬁnement of CLTSIPs, expressed as the simulation  of the corresponding LTSs. Firstly, we introduce the predicate  •  l /a  l∈  / C  ∧ ∀t : q −−−→s ,d q  , l ∈ C  ⇒ s s s}.  In fact, from each location, a transition is held if it is neither  labelled by a communication l ∈ C  , nor statically hidden by  another communicating transition (over C  ) outgoing from that  location.  Theorem 2 (Reﬁnement and restriction): Let Tc , Ta be two  CLTSIPs deﬁned on the same set of channels C, then Tc  Ta ⇒ Tc \C Ta \C.  Proof. It consists to show that each non-hidden concrete transition of Tc \C, labelled by τ or m ∈ M , has a corresponding  abstract transition non-hidden in Ta \C.  2) Product of CLTSIPs: In what follows, we deﬁne an  associative n-ary product of CLTSIPs, where locations of  composition are simply obtained by the product of individual  CLTSIP locations. Moreover, our product is parameterized by  two internal operations deﬁned on the action language:  • a1  a2 is used to compose actions associated to sendreceive communication.  • a1  a2 is used to compose actions associated to global  synchronizations (lock-step). This operation is supposed  to be commutative, respectively associative, in order to  establish the commutativity, respectively associativity, of  the product.  Deﬁnition 8 (N-ary product of a family of CLTSIPs):  Given an indexed family Ti = Qi , qi0 , G0i , Ii , →i 1..n of  n CLTSIPs deﬁned over the same shared space G, action  language A, static priority system Ps and dynamic priority  system  Pd , their product     Π1..n Ti is deﬁned by the CLTSIP   i Qi   , q10 , . . . , qn0 , i G0i , I, → over G, Ps and Pd where  I(q) = i Ii (qi ) and → is the smallest relation such that:  l /a  l/a  Ismax ts (t : q −−→s,d q  )  ∀t : q −−−→s ,d q  ¬(s ≺s s )  deﬁning a higher static priority transition outgoing from lol/a  cation q. In the same way, Ismax td (t : q −−→s,d q  )   l /a  ∀t : q −−−→s ,d q  ¬((d ≺d d ) ∧ enabled(t , G)), with  (G, G ) ∈ [[a ]], is a predicate deﬁning a higher dynamic  priority transition outgoing from location q.  Theorem 1 (Reﬁnement of CLTSIPs): Given two CLTSIPs  T1 and T2 with their respective static and dynamic priority  systems (Ps1 , Pd1 ) and (Ps2 , Pd2 ). T1 reﬁnes T2 through the  reﬁnement relations Rl ⊆ Q1 ×Q2 and Rg ⊆ G1 ×G2 , denoted  T1 Rl ,Rg T2 , if  1) The associated LTSs satisfy the sufﬁcient condition for  simulation, i.e:  0 0  • Rl (q1 , q2 ),  0  0  • ∀x ∈ G1 , ∃y ∈ G2 | Rg (x, y),  •  l/a1  ∀t : q1 −−−→s1 ,d1 q1 , ∀q2 x x y such that  (x, x ) ∈ [[a1 ]]. If Rl (q1 , q2 ) and Rg (x, y) then there  exist q2 ∈ Q2 , a2 , y  , s2 ∈ Ps2 , d2 ∈ Pd2 such that  l/a2  q2 −−−→s2 ,d2 q2 ∧ (y, y  ) ∈ [[a2 ]] ∧ Rl (q1 , q2 ) ∧  Rg (x , y  ),  • ∀q1 ∈ Q1 q2 ∈ Q2 , Rl (q1 , q2 ) ∧ I2 (q2 ) ⇒ I1 (q1 ),  2) For all  t1 ∈ T r1 and t2 ∈ T r2 such  that Rl (α1 (t1 ), α2 (t2 )) and Rl (β1 (t1 ), β2 (t2 )), then  Ismax ts (t1 ) ⇒ Ismax ts (t2 ),  Ismax td (t1 ) ⇒ Ismax td (t2 ).  Roughly speaking, the reﬁnement consists of establishing  a mapping between the transitions of reﬁning and reﬁned  CLTSIPs. In fact, from each location q of the concrete CLTSIP  T1 , the presence of a transition t1 , with a maximal priority,  states the presence of a maximal-priority transition outgoing  ti :qi −  −→s,d qi  l/a  l∈C!∪C?∪{τ }  q−  −→s,d q[i←qi ]  l/a  Async(ti )  m/ai  (∀i) qi −−−→si ,di qi m ∈ M  m/  J  i ai  q−  −−−−−→s s  q  ,d d  i i  i    Sync  c?/aj  c!/ai  ti : qi −−−→si ,di qi tj : qj −−−→sj ,dj qj  (P C) i =   j  τ /ai aj  q−  −−−−→s  60  q[i←qi ,j←qj ]  s  d  i  sj ,di  dj  SR(ti , tj )  where (P C) is a priority condition stating that if static,  respectively dynamic, priorities of transitions ti and tj are  increased upto the maximum si s sj , respectively di d dj ,  no new hiding may occur. For example, the static priority  condition for CLTSIP Ti can be formally expressed as  ∃t :  l/a  qi −−→s,d qi | (s s si ) ∧ (s s si s sj ).  The notation q[i ← qi ] states the replacement of the ith  location of vector q by location qi . If we consider UPPAAL  TA, in which transition priorities are assigned to channels, then  di = dj = di d dj . About transition rules, Async(ti ) represents internal transitions and potential synchronizations that a  CLTSIP may be willing to engage in with its environment.  Rule Sync deﬁnes a n-ary synchronization of a set of transitions on the same event m, which will be instantiated by a  time-transition in the ETTS. Rule SR(ti , tj ), for send/receive,  corresponds to a synchronized communication of both Ti and  Tj on compatible events through a channel c ∈ C. Let us  mention that n-ary synchronization transitions, labelled by m,  cannot block or be blocked. One may remark that our product  is syntactical, whereby, all of the CLTSIP non-composable  transitions are held.  Theorem 3 (Generalized associativity): If  is associative,  i.e. i∈I j∈Ji ai,j = i∈I,j∈Ji ai,j , the product of CLTSIPs  is associative, i.e. : Πi∈I (Πj∈Ji Ti,j ) ∼ Πi∈I,j∈Ji Ti,j  Proof. It essentially consists of deﬁning an isomorphism  between the two structures, state space and transitions, preserving labels and priorities.   3) Compositional Reﬁnement of CLTSIPs Product: Modelchecking of real-time systems suffers from the state explosion  problem, the reason for this being that time is considered  as part of the state, leading then to a widely large or even  inﬁnite state space of the system. Abstraction reﬁnement  plays a key role in the model-checking of complex systems  where unbounded data structures can be abstracted. However,  for compound systems, deﬁning the reﬁnement of the whole  system is an arduous task. In what follows, we show how the  (compositional) reﬁnement [19] of CLTSIPs product has been  brought to a set of simpler reﬁnements of individual CLTSIPs.  Theorem 4 (Compositional reﬁnement): Given two products of CLTSIPs T1  ...  Tn and T1  ...  Tn deﬁned on the  same priority systems (with total orders). T1  ...  Tn reﬁnes  T1  ...  Tn , denoted by T1  ...  Tn ⊗i Rli ,Rg T1  ...  Tn  where Rli ⊗ Rlj (qi , qj )(qi , qj ) = Rli (qi , qi ) ∧ Rlj (qj , qj ), if:    • ∀i Ti  Rli ,Rg Ti ,  • each concrete transition and its corresponding abstract  one have the same priorities (morphism),  • reﬁnement preserves deadlock-freeness, where deadlockfreeness is deﬁned by the existence of ﬁrable transitions.  Through this theorem, we are able to perform model checking  on the composition of CLTSIPs, T1  ...  Tn , instead of the  original composition T1  ...  Tn . In fact, through the last two  conditions of this theorem, we may reduce the reﬁnement of  CLTSIPs to classical reﬁnement relations of transition systems,  and by that, the proof would be much more tractable (note that  we do not claim that composition preserves deadlock freeness).  Proof. Given a transition of the concrete product, it is either  asynchronous from some Ti and has a corresponding abstract  transition in Ti with the same priority, which is in turn present  in the abstract product, or a synchronization SR of two  transitions from Ti and Tj that have abstractions in Ti and  Tj which synchronize in the abstract product with the same  priority, or again an n-ary synchronization Sync which, as  previously stated, leads to an n-ary synchronization in the  abstract product. Moreover, if a concrete transition has priority  over ready 2 transitions, then the corresponding abstract one  has also priority.   D. Timed Transition System Extensions  Timed transition systems [20] are the reference model to  deﬁne the semantics of real-time formalisms such as time Petri  nets and timed automata. Basically, a Timed Transition System  (TTS) is a labeled transition system where labels can be events  or durations. In this section, we deﬁne extended timed transition systems (ETTS) as CLTSIPs which synchronize on time.  ETTS actions are considered as a pair (guard, assignment)  of CLTSIPs. Furthermore, we consider the global state space  structured as valued variables.  Deﬁnition 9 (ETTS): An Extended Timed Transition System (ETTS) on a set of variables V valued over a domain  D, a static priority system Ps , a dynamic priority system Pd  and a set of channels C is a CLTSIP over the global space  G = DV where the synchronization events m ∈ M are time  instants of Δ = R≥0 . Its action language is deﬁned as the set  of pairs (guard, assignment), where a guard is a predicate over  variables of V and an assignment is a partial function mapping  variables to expressions built on V.  The semantics of an ETTS depends on its action language  semantics. Here, we have chosen the following deﬁnition for  the (guard, assignment) pairs:  Action  a:=  language  g/ v∈V v := ev  | aa  | j∈J aj  Semantics    [[g/ v∈V   v := ev ]](x, x ) =  g(x) ∧ v∈V x (v) = [[ev ]](x)  The notation g/ v∈V states the parallel update of variables  of V as an assignment guarded by g. Both action composition  operators  and  are left undeﬁned. Their semantics will  be chosen to conform with the semantics of timed automata  action composition.  IV. I NSTANTIATION FOR UPPAAL  UPPAAL [4] is an integrated tool environment for modeling,  validation and model checking of real-time systems modeled  as networks of timed automata. The tool has been used  successfully and routinely for many industrial case studies. In  this section, we consider UPPAAL timed automata (TA) [4]  as an instantiation of CLTSIPs. The UPPAAL language [24]  considers 3 priority orders: a static binary priority so-called  Committedness associated to locations, a dynamic priority  order on channels and another dynamic priority order between  2 Transitions outgoing from the same state and, for dynamic priority,  enabled.  61  processes. In fact, location committedness is a high level  mechanism deﬁning two priority levels, where transitions outgoing from committed locations have priority over transitions  outgoing from non-committed locations, independently of their  enabledness.  • In UPPAAL [4], committedness is associated to states  where systems cannot delay if the current state is committed.  • In order to deﬁne a compositional semantics of timed  automata composition, using a products of TTSs (Timed  Transition Systems), [7] proposes a restriction on UPPAAL so that a committed state has always a ﬁrable  outgoing transition.  • With respect to our previous work [10], we do not require  such a restriction but we use a slightly modiﬁed structure  of TTSs. Location committedness is considered as a static  priority system with two priority values {true, f alse}.  Moreover, the dynamic priority order on channels [11], [18],  [16] states that a synchronizing transition t on a channel  c, which has priority over a channel c , has priority over  transitions composable on c if it is ﬁrable, i.e. the guard of t is  satisﬁed. We also consider the priority order on TA processes,  which is a dynamic relation stating that the executions of a  timed automaton have priority over the executions of other  TA. In what follows, we introduce UPPAAL TA with the  three priority orders (committedness, priority on channels and  priority on TA) and deﬁne their ETTS-based semantics, where  an unique generalized dynamic priority system is derived  from both priority on channels and priority on TA. To this  end, on a composition, static priority is checked ﬁrst and if  the conﬂict is not solved we may refer to the priority order on  channels. Again, if the choice of a transition from a conﬂict  cannot be made, we compare then the dynamic priorities  associated to the involved TA.  of the static priority system with two values. Moreover, the  unique dynamic priority system of ETTS semantics is derived  from a merge of both priority orders c and ta .  Deﬁnition 11 (Priority systems corresponding to TA):  Given a timed automaton T ∈ TA deﬁned on a total priority  order c on channels and a total priority order ta on  elements of TA, where TA is the set of timed automata  names, the static priority   system associated to T is deﬁned  by Ps = {⊥, }, ⇒,  and the dynamic one is deﬁned  by Pd = ({, default} ∪ C) × TA, d , d  where  (x, y) d (x , y  )  x ≺c x ∨ (x = x ∧ y ta y  ).  Since the orders c and ta are total in UPPAAL, the priority  order d is total. default is the UPPAAL priority level  assigned to τ -transitions and  is the lowest priority level. In  fact, the static priority system is straightforward, whereas the  dynamic priority system consists in checking ﬁrst the priority  on channels and if the choice of a transition cannot be made,  we refer then to priorities of the corresponding TA. By now,  we give the semantics of TA in terms of ETTSs where ETTS  locations are TA locations.  Deﬁnition 12 (ETTS of a TA): Given a set of channels C, a  priority order c on channels, a priority order ta on TA and  a set χ of clocks. The semantics of a timed automaton with  committed locations and priorities T = Q, q 0 , K, I, →ta   is deﬁned by the ETTS Q, q 0 , G0 , I, → over the global  space χ → Δ, static priority system Ps and dynamic priority  system Pd where G0 = χ × {0} and → is the smallest  relation such that:  q−  −−−→ta q  g/τ /r  g/τ /x∈r x:=0  q−  −−−−−−−−→q∈K,(default,T ) q  −−−→  g/l/r    q  l∈C  ta q  g/l/x∈r x:=0  q∈K,(l,T )  q−  −−−−−−−−→  q∈K  A. TA with Committed Locations and Priorities  Timed automata [1] have been introduced as a modeling  framework to support the description and analysis of timed  systems. In fact, a timed automaton is structured as a ﬁnitestate machine extended with a ﬁnite collection of real-valued  clocks initialized to zero and increased synchronously.  Deﬁnition 10 (TA with committedness and priorities):  Given a set of clocks χ, a set of channels C, a priority order  c on channels of C and a priority order ta on TA, a  timed automaton with committedness and priorities is a tuple  Q, q 0 , K, I, → where:  0  • Q is a set of locations where q ∈ Q is the initial location,  • K ⊆ Q is a set of committed locations,  χ→Δ  • I : Q → 2  associates a clock invariant (a set of  clock valuations) to each location,  χ→Δ  • →⊆ Q × 2  × 2χ × Σ × Q is the transition relation  deﬁned with a clock guard, a reset set and an event l ∈ Σ.  Σ = C? ∪ C! ∪ {τ } is the set of transition labels.  ⊥/τ /skip  q−  −−−−−→,(default,T ) q  Tau  Com  q  Empty  q ∈K  [x∈χ x:=x+δ]I(q)/δ/x∈χ x:=x+δ  q−  −−−−−−−−−−−−−−−−−−−−−→⊥,(,T ) q  Time  For transition rules T au and Com, both guards and labels of  T transitions are still unchanged in the corresponding ETTS  transitions. The semantics of a reset r consists in a parallel  reinitialization of clocks x ∈ r. Moreover, the static priority  of each ETTS transition corresponds to the committedness of  the TA source location q, whereas the dynamic priority is the  pair of label l for a communication, respectively default  for internal and Empty transitions and  for Time transitions,  and the name of the automaton T . Empty transitions are not  ﬁrable and especially introduced to hold the committedness  of TA locations, when that locations do not have outgoing  transitions. From each non committed location q, we may  perform a Time-transition adding an amount δ, respecting the  invariant of q, to each clock x ∈ χ. One may distinguish that  no transition can be blocked by Time-transitions because they  have the lowest static and dynamic priority values.  g/l/r  We write q −−−→ q  for (q, g, r, l, q  ) ∈→. Different semantics  of TA with priorities in terms of TTS have been proposed [19],  [23], [29], [5]. Here, we deﬁne the semantics of TA with priorities in terms of ETTSs where committedness is an instance  Simulation: a timed automaton Tc reﬁnes another TA  62  Ta if the simulation relation holds between their associated  ETTSs: Tc Ta  ET T S(Tc ) ET T S(Ta ).  qi ∈ K i  ⊥/τ /skip  q −−−−−−→    B. Networks of TA with Committedness and Priorities  In order to model concurrency and communication, TA  have been extended with parallel compositions, giving rise to  the NTA. Several semantics for TA composition have been  studied [4], [7], [16], [23], [29] and various parallel composition operators have been proposed, the well known ones  are those of CCS [25] and CSP [21]. The UPPAAL language  [24] has adopted the CCS parallel composition which allows  interleaving of actions as well as hand-shake synchronization.  In this section, to compare NTA through simulation and  bisimulation relations, we deﬁne their semantics in terms of  ETTS and establish a compositionality result.  Deﬁnition 13 (Networks of timed automata): A network of  timed automata with committed locations, priority on channels  c and priority on TA ta is a ﬁnite collection of TA.  First, let us choose the following action language and its  underlying semantics for ETTS.  q  The semantics of NTA is parameterized by the way guarded  actions are composed on a send/receive synchronization, i.e.  (gs /as )  (gr /ar ). The semantics [[a  a]], depends on the  semantics chosen for TA composition, is still unspeciﬁed.  Deﬁnition 14 (NTA semantics): Given a set of clocks  χ, a set of channels C, a priority order c on C and a  priority order ta on timed automata, the semantics of an  0  NTA   N = Qi , qi , Ki , Ii , →i 1..n is deﬁned by the ETTS   i Qi , q10 , . . . , qn0 , χ × {0}, I, →  over the global space  χ → Δ, static and dynamic priority   systems Ps and Pd  given in Deﬁnition 11 where I(q) = i Ii (qi ) and → is the  smallest relation such that:  g/τ /r  g/τ /    j  q j ∈ K j ⇒ qi ∈ K i  x∈r x:=0  q −−−−−−−−−→qi ∈Ki ,(def ault,Ti ) q[i ← qi ]  gi /c!/ri  g/τ /r  Taui  gj /c?/rj  qi −−−−−→i qi qj −−−−−→j qj i = j  g/r = gi /ri  gj /rj    q  ∈  Kk ⇒ (qi ∈ Ki ∨ qj ∈ Kj )  k  k  q −−−−→qi ∈Ki ∨qj ∈Kj ,(c,max(Ti ,Tj )) q   i qi ∈ Ki  xi :=xi +δ  −−−−−−−−−−−−→⊥,(,max({Ti |i∈1..n})  g/δ/  Time  J  i  q      where, for rule SRi,j (c), q  =  q[i ← qi , j ← qj ] and for Time  transitions, the guard g = [ i xi := xi + δ]I(q) states that  the location invariant I(q) should be respected after updating  clocks. Such an invariant corresponds to the intersection of  individual TA location invariants. Through rule Tau, an internal  (statically) non-hidden transition of a TA corresponds to an  internal transition of the ETTS semantics. Hiding is not local,  i.e not only attached to a given TA. In fact, from each TA  location, after checking that such a location of the NTA  state vector does not have the weakest committedness, we  check then whether the current TA transition is not hidden by  another transition outgoing from that location. Rule SRi,j (c)  describes the synchronization of TA Ti and Tj on a channel c,  where the input transition guard is only checked after taking  into account the effect of the output transition action. Such  a synchronization is held if either the send or the receive  transition is not statically hidden. The dynamic priority of the  resulting transition corresponds to that of channel c and the  maximum process priority of both Ti and Tj . Finally, both  Empty and Time rules have been earlier explained.  Deﬁnition 15 (NTA reﬁnement): The reﬁnement between  networks of timed automata is deﬁned as the reﬁnement  between their associated ETTSs. Formally, given two NTA  Nc and Na ; then: Nc Na  ET T S(Nc ) ET T S(Na ).  Accordingly, we establish the following theorems:  Theorem 5 (Compositionality of NTA semantics): The  ETTS of a NTA is bisimilar to the restriction to Time  and Tau-transitions of the product of ETTSs associated to  individual TA, i.e. ET T S(N T A) ∼ Πi ET T S(T Ai )\C.  Proof. It is direct because we have the same composition  rules in both sides. The difference resides in the occurrence of  unmatched communication transitions in the ETTSs product,  but these transitions will be suppressed by the restriction.  This proof has been formalized and validated using the C OQ  theorem prover.   Theorem 6 (Reﬁnement and parallel composition): Given  2 networks of TA N = T1 , .., Tn  and N  = T1 , .., Tn   deﬁned on the same set of channels, N reﬁnes N  if:    • ∀i Ti  Rli ,Rg Ti ,    • channel priority orders of N and N are equivalent,  • each concrete process and its corresponding abstract one  have the same priority (morphism),        • ∀q q , Rl (q, q ) ⇒ Comm(q) ⇔ Comm(q ),  • reﬁnement preserves deadlock-freeness.  Proof. It follows from theorems 4 and 5 together with the  restriction theorem 2.  Action language  a:= a  a  | j∈J aj  | (g/r)  | (g/c := c + d)  | (g/skip)  Semantics  a  a is still unspeciﬁed    [[j aj ]](x, x ) = j [[aj ]](x, x )          [[g/r]](x, x ) = g(x) ∧ c∈r x (c) = 0 ∧ c∈r  / x (c) = x(c)      [[g/c := c + d]](x, x ) = g(x) ∧ x (c) = x(c) + d  [[g/skip]](x, x ) = g(x) ∧ (x = x)  qi −−−−→i qi  ,(def ault,Ti )  Empty  q  SRi,j (c)  C. Experiments  In this section, we give an application of our compositional  framework to reﬁne a version of the well known Alternating  63  Bit Protocol [28] (ABP). In fact, we aim to verify that the  number of correctly received messages is less than the number  of correctly sent ones, and their difference is bounded by one.  To send a new message, the TA Sender synchronizes with  the TA Mmedium on channel send and increments the shared  variable s. The TA Receiver receives the sent message via  a synchronization with the Mmedium on channel receive and  updates the shared variable r by adding one. The intended  property is represented by the auxiliary Boolean variable  Ok  s == r ∨ s == (r + 1). This property cannot be  veriﬁed using the UPPAAL toolbox on the NTA formed  by Sender, Receiver, Mmedium, Amedium because of the  unboundedness3 of s and r. To deal with the unboundedness,  a clever idea consists in the replacement of both Sender and  Receiver automata by ﬁnite abstractions, where the evolutions  of variables s and r are respectively modeled by two shared  Boolean variables b1 = (s == r), initialized to true, and  b2 = (s == r+1), initialized to f alse, with a slight modiﬁcation of the corresponding involved transitions. The abstraction  reﬁnement of processes Mmedium and Amedium is the identity  relation. Accordingly, the new property Ok = b1 ∨ b2 can  be checked. The abstraction reﬁnement of each TA by its  corresponding ﬁnite abstraction has been checked using a  manual proof of the reﬁnement ref in between their ETTSbased semantics, where both local and global spaces have  been considered. The local space reﬁnement Rl consists in:  (a) the correspondence of local states; (b) the identity of local  variables values. However, for the global space, the reﬁnement  Rg consists to: (a) match the values of b1 and b2 of the  abstract system to the corresponding expressions computed  through s and r in the concrete system; (b) check the identity  between the other shared variables values. We may write then  ref in = RlSender ∧RlReceiver ∧RlM medium ∧RlAmedium ∧Rg .  This result has been checked using UPPAAL and a manual  proof of reﬁnement using observers.  Acknowledgment. We wish to thank the anonymous referee  for his scrutinous reading and valuable remarks.  R EFERENCES  [1] R. Alur. Timed automata. In 11th International Conference on Computer  Aided Veriﬁcation, volume 1633 of LNCS, pages 8–22. 1999.  [2] A. Arnold. Finite transition systems: semantics of communicating  systems. Prentice Hall International Ltd., Hertfordshire, UK, 1994.  [3] A. Basu, M. Bozga, and J. Sifakis. Modeling heterogeneous real-time  components in BIP. In SEFM’06, pages 3–12. IEEE Computer Society,  2006.  [4] G. Behrmann, A. David, and K. G. Larsen. A Tutorial on Uppaal.  Department of computer science, Aalborg university, 2004.  [5] J. Bengtsson and W. Yi. Timed automata: Semantics, algorithms and  tools. In Lectures on Concurrency and Petri Nets, pages 87–124. volume  3098 of LNCS, Springer-Verlag, 2004.  [6] B. Berard, M. Bidoit, A. Finkel, F. Laroussinie, A. Petit, L. Petrucci,  and P. Schnoebelen. Systems and Software Veriﬁcation - Model-Checking  Techniques and Tools. Springer-Verlag Berlin, 2001.  [7] J. Berendsen and F. Vaandrager. Compositional Abstraction in RealTime Model Checking. In FORMATS’08, pages 233–249, 2008.  [8] B. Berthomieu, J. Bodeveix, M. Filali, H. Garavel, F. Lang, F. Peres,  R. Saad, J. Stoecker, F. Vernadat, P. Gauﬁllet, and F. Lang. The syntax  and semantics of FIACRE. Technical report, 2009.  [9] G. Bhat, R. Cleaveland, and G. Lüttgen. Dynamic priorities for  modeling real-time. In FORTE X/PSTV XVII ’97, Osaka, pages 321–  336. Chapman and Hall, 1996.  [10] J. P. Bodeveix, A. Boudjadar, and M. Filali. An alternative deﬁnition  for timed automata composition. In ATVA’11, pages 105 –119, Taiwan,  2011. LNCS 6996.  [11] S. Bornot, G. Gössler, and J. Sifakis. On the construction of live timed  systems. In TACAS’00, pages 109–126, 2000.  [12] A. Boudjadar, J.-P. Bodeveix, and M. Filali. Revising and extending the  UPPAAL communication mechanism. In SC’12, volume LNCS 7306,  pages 114 – 131. Springer Heidelberg, 2012.  [13] P. Brémond-Grégoire, I. Lee, and R. Gerber. ACSR: An algebra of  communicating shared resources with dense time and priorities. In  CONCUR, pages 417–431, 1993.  [14] E. M. Clarke, D. E. Long, and K. L. McMillan. Compositional model  checking. In LICS’89, pages 353–362, 1989.  [15] R. Cleaveland, G. Lüttgen, and V. Natarajan. Priority in process  algebras. Information and Computation, 87:58–77, 1999.  [16] A. David, J. Hakansson, K. G. Larsen, and P. Pettersson. Model  checking Timed Automata with Priorities Using DBM Subtraction. In  FORMAT’06, pages 128–142. LNCS volume 4202, 2006.  [17] E. Fersman, P. Pettersson, and W. Yi. Timed Automata with asynchronous processes: Schedulability and decidability. In TACAS’02, pages  67–82. Volume LNCS 2280, Springer-Verlag, 2002.  [18] G. Gössler and J. Sifakis. Priority systems. In FMCO’03, pages 314–  329, 2003.  [19] F. He, H. Zhu, W. Hung, X. Song, and M. Gu. Compositional abstraction  reﬁnement for timed systems. In TASE’10, pages 168 –176, 2010.  [20] T. A. Henzinger, Z. Manna, and A. Pnueli. Timed transition systems.  1992.  [21] C. A. R. Hoare. Communicating Sequential Processes. Prentice-Hall,  1985.  [22] P.-A. Hsiung and S.-W. Lin. Model checking timed systems with  priorities. In RTCSA’05, pages 539–544, USA, 2005.  [23] H. E. Jensen, K. G. Larsen, and A. Skou. Scaling up Uppaal:  Automatic Veriﬁcation of Real-Time Systems using Compositionality  and Abstraction. In FTRTFT’00, pages 19–30, 2000.  [24] K. G. Larsen, P. Pettersson, and W. Yi. Uppaal in a nutshell. In Journal  on software tools for technology transfert, 1997.  [25] R. Milner. Communication and Concurrency. Prentice Hall Ltd., 1989.  [26] M. Nielsen, G. Rozenberg, and P. Thiagarajan. Transition-systems, event  structures, and unfoldings. Information and Computation, 118:191 –  207, 1995.  [27] M. Nielsen, G. Rozenberg, and P. S. Thiagarajan. Elementary transition  systems. Theoritical Computer Science, pages 3–33, 1992.  [28] G. J. Veltink and S. Mauw. Algebraic Speciﬁcation of Communication  Protocols. Cambridge Tracts in Theoretical Computer Science No. 36,  2008.  [29] S. Yovine. Model checking Timed Automata. In Lectures on Embedded  Systems. Lecture Notes in Computer Science 1494, Springer-Verlag,  1998.  V. C ONCLUSION  In this paper, we have studied the reﬁnement and composition of different timed systems with priorities. For the  parallel composition operator we have deﬁned, we give a corresponding (compositional) reﬁnement relation. As a semantic  model, our compositional framework has been successfully  instantiated to deﬁne a compositional semantics of networks  of timed automata, in which an unique generalized dynamic  priority system of ETTS is deﬁned from both NTA priority  orders (channels, TA) with an important reﬁnement property  stating that: if each individual TA of an NTA reﬁnes another  individual TA of another NTA, then the ETTS corresponding  to the semantics of the ﬁrst NTA reﬁnes the ETTS corresponding to the semantics of the second NTA. Furthermore, the  theorems established within our framework have been proved  4  . In the future, we wish to extend our framework by other  concepts, like assume-guarantee properties, in order to model  and to analyze the semantics of the Fiacre language [8].  3 In fact, it is checked upto the size of UPPAAL integers, then UPPAAL  throws an out of range exception.  4 Proofs will be available in the forthcoming PhD thesis of Abdeldjalil  Boudjadar.  64 