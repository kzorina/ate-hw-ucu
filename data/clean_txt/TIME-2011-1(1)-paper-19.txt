2011 Eighteenth International Symposium on Temporal Representation and Reasoning  Synthesising Classic and Interval Temporal Logic  Sven Schewe  Department of Computer Science  University of Liverpool  Liverpool, United Kingdom  sven.schewe@liverpool.ac.uk  Cong Tian  ICTT and ISN Lab  Xidian University  Xi’an, 710071, P.R.China  c.tian.xdu@gmail.com  Abstract—Linear-Time Temporal Logic (LTL) is one of the  most inﬂuential logics for the speciﬁcation and veriﬁcation  of reactive systems. An important selling point of LTL is  its striking simplicity, which might be a reason why none  of the many extensions suggested to LTL have gained the  same inﬂuence. Interval based temporal logics like Interval  Temporal Logic (ITL) are a more recent branch of temporal  logics with their own niche of interesting applications. On  ﬁrst glance, interval based temporal logics very little resemble  LTL and the spread of these logics beyond their niche is  hampered by a seeming structural incompatibility with LTL.  When competing for being applied on a larger scale, interval  based temporal logics would ﬁght a losing battle against a more  established competitor with better complexity and mature tools.  In this paper, we suggest to extend ITL to Pop Logic (PL) by  introducing a simple pop operator that revokes the binding  of the chop operation—very much like the popping operation  in a stack—and show that LTL can be viewed as a syntactic  subset of PL. This is a surprising twist: by strengthening the  comparably exotic logic ITL slightly and by using the new pop  and the old chop operator as primitive constructs, we obtain a  logic for which LTL is a de-facto syntactic fragment. The power  of this extension is that it can, by subsuming both interval and  classic temporal logics, synthesise both concepts to a common  framework. The charm of this extension is that PL does not  sacriﬁce the simplicity that makes its sub-logics attractive.  power of LTL is restricted to star-free expressions. To overcome this limitation, several extensions and variations have  been proposed. Notably, Quantiﬁed Linear Time Temporal  Logic (QLTL) [17] and Extended Temporal Logic (ETL)  [22], [21] are extensions of LTL for the expressiveness of  full ω-regular language. Temporal Logic of Actions (TLA)  is a variation of LTL where state changes can be easily  handled through actions [12]. However, these extensions (or  variations) affect the simplicity of LTL and make it less  intuitive. This might be one of the reasons why none of  them has gained the same inﬂuence as LTL itself.  Interval based temporal logics are a more recent branch of  temporal logics with their own niche of interesting applications. The characteristic operator of these logics is the chop  operator, often denoted by the symbol ‘;’. Different from the  traditional temporal operators  (always) and U (until), a  chop construct, p ; q, holds over a path (or an interval) if,  and only if, the path can be split into two parts, such that  p holds over the ﬁrst part and q holds over the second part.  The chop operator was ﬁrst used as a temporal construct by  Harel, Kozen and Parikh [11] and studied in more depth by  Chandra, Halpern, Meyer and Parikh [3]. Halpern, Manna,  and Moszkowski showed that chop is a useful operator  when reasoning about time-dependent digital hardware [10],  which triggered the development Interval Temporal Logic  (ITL), a temporal logic based on chop, chop star, next, and  projection operations, by Moszkowski [13], [14]. Initially,  ITL is conﬁned within ﬁnite models. Projection Temporal  Logic (PTL) [5], [6], [7] is an extension of ITL with inﬁnite  models and a new projection construct, (P1 , . . . , Pm ) pr j Q.  Compared to classic temporal logics, interval based temporal logics greatly simplify the formulation of certain  correctness properties [8], which underlines the usefulness  of these logics for speciﬁcation and formal reasoning about  concurrent systems. Interval based temporal logics lend  themselves particularly well to reasoning about properties with a ‘scope’; such properties are very common in  most programming languages. Further, with chop operations, sequential behaviours can be described elegantly and  succinctly; and full regular expressiveness can easily be  achieved by the introduction of a chop star operator, which  can be intuitively understood as the multi-time implementa-  I. I NTRODUCTION  Temporal logics are popular formalisations that can express properties about the temporal order of events. The family of temporal logics has grown over the years, containing  linear [15] and branching time logics [4], [2], and, more  recently, game, alternating time, and coordination logics  [1], [9]. While linear time temporal logics are concerned  with properties of paths, branching time logics describe  properties that depend on the branching of computational  tree structures.  There has been a long debate between linear time and  branching time temporal logics, but three decades worth  experiences have shown that branching time logics are hard  to be understood and error-prone [16], [20]. In contrast,  linear time temporal logics seem to lend themselves to the  system designers. This makes Linear-time Temporal Logic  (LTL) [15], the original linear time temporal logic, one of the  most inﬂuential logics in speciﬁcation and veriﬁcation. From  a theoretical point of view, one can show that the expressive  1530-1311/11 $26.00 © 2011 IEEE  DOI 10.1109/TIME.2011.19  64  operator. Intuitively, a chop operator pushes a new interval  into an interval stack, while a pop-operator pops the top  element of this stack (hence the name). Just like ITL, its  extension PL has a natural semantics for ﬁnite and inﬁnite  words.  tion of a chop operation.  Interval based temporal logics very little resemble LTL  and the spread of these logics beyond their niche is hampered  by a seemingly structural incompatibility with LTL. When  competing for being applied on a larger scale, interval  based temporal logics would ﬁght a losing battle against  a more established competitor with better complexity and  well developed tools. This leads to the question of whether  or not the differences between these logics can be bridged  without affecting their simplicity. A ﬁrst approach would  be to consider a simple merge of the operators. Why not  enrich LTL by a chop operator? Or, likewise, ITL with  an until? The disadvantage of such a solution is that the  strongest advantages of these logics is their simplicity: they  are build around a single intuitive concept. In this sense,  each extension comes to the cost of elegance and effects the  intuitive access to these logics.  In this paper, we discuss an alternative approach. We  introduce a natural extension of ITL, Pop Logic (PL), by  introducing a simple operator pop operation, denoted as ↑,  that revokes the binding of a chop operation. (The name  is inspired by the popping operation in a stack.) The pop  operation is interesting in itself: it can be used as a pseudo  inverse of a chop operation, as (↑ ϕ) ; true is logically  equivalent to ϕ, and it provides a fresh view on the interval  temporal logics. In PL, we view the scoping implied by  the chop operator as the scoping invoked by a call. The  pop operation provides access to lower levels of the call  tree, which implies a recognition of the call structure in  the semantics of the logic. This entails a semantics that  accurately reﬂects this call structure. But while it clearly  provides some insight into the relation of calls and interval  logic, the main advancement is the link it establishes with  LTL: We show that LTL operators can be viewed as snippets  of PL operators. LTL can therefore justly be viewed as a defacto syntactic subset of PL. This, in turn, provides another  insight to interval temporal logics: Using the extension,  we get—with LTL—a meaningful—and even popular—a  PSPACE-complete sub-logic of PL. We use this observation  to deﬁne more general structural restrictions of PL that  preserve this low complexity.  The remainder of the paper is organised as follows. The  following section presents the syntax and semantics of Pop  Logic and we discuss its relation to ITL in Section III. We  then discuss the embedding of LTL into PL in Section IV  and demonstrate the decidability of PL by embedding it in  QLTL in Section V. (This proof simpliﬁes, as a small side  result, the known decidability proof of ITL.) Finally, we  study PSPACE-complete subsets of PL in Section VI.  A. Syntax of Pop Logic  Pop Logic is interpreted over ﬁnite and inﬁnite words over  a countable set Π of atomic propositions, which includes a  special proposition  (true) that holds in every position of  the word. The syntax of Pop Logic is given by the grammar  ϕ ::= p | ¬ϕ | ϕ ∨ ϕ |  ϕ | ϕ; ϕ | ↑ ϕ,  where p ∈ Π is an atomic proposition. PL extends the  syntax of ITL (see the following section) by the unary pop  operator ↑.  B. Semantics of Pop Logic  We call a PL formula ϕ well formed if there exists no node  in the formula tree of ϕ such that strictly more pop operators  than chop operators occur on the way from the root of the  formula tree to this node. We deﬁne the PL semantics only  for well formed formulas. The intuition for the exclusion of  ill formed formulas is that we would otherwise try to pop  the bottom element of an interval stack.  For l, u ∈ ω and u ∈ ω  {∞}, [l, u] = {k ∈ ω | l ≤ k ≤ u}  and [l, u [= {k ∈ ω | l ≤ k < u } are (integer) intervals.  The semantics of a well formed PL formula ϕ leans on  the semantics of ITL, but as we have the power to revoke  the effect of previous chop operators, we have to keep track  of a stack of intervals, comparable to the call structure in  recursive procedures. Consequently, a sub-formula ψ of ϕ  needs to be interpreted in the context of this stack of intervals  at the time where ψ is evaluated.  PL is interpreted over a (ﬁnite or inﬁnite) word σ ∈  (2Π )∗  (2Π )ω . When convenient, we interpret σ as a function from [0, |σ|[ to 2Π , σ : [0, |σ|[→ 2Π . In the following,  I0 , . . . , In (with n ∈ ω) is a non-empty interval stack with  [0, |σ|[= I0 ⊇ I1 ⊇ . . . ⊇ In . We ﬁrst deﬁne the interpretation  of a word σ in an interval stack I0 , . . . , In at a position k.  σ; I0 , . . . , In ; k |= p  σ; I0 , . . . , In ; k |= ¬ϕ  σ; I0 , . . . , In ; k |= ϕ ∨ ψ  II. P OP L OGIC  iff k ∈ In and p ∈ σ(k),  iff σ; I0 , . . . , In ; k |= ϕ,  iff σ; I0 , . . . , In ; k |= ϕ  or σ; I0 , . . . , In ; k |= ψ,  σ; I0 , . . . , In ; k |= ϕ  iff σ; I0 , . . . , In ; k + 1 |= ϕ,  σ; I0 , . . . , In , [b, e[; k |= ϕ ; ψ iff k ∈ [b, e[ and  ∃l ∈ [k, e[. σ; I0 , . . . , In , [b, e[, [b, l]; k |= ϕ and  σ; I0 , . . . , In , [b, e[, [l, e[; l |= ψ, and  σ; I0 , . . . , In , In+1 ; k |=↑ ϕ  iff σ; I0 , . . . , In ; k |= ϕ.  In this section, we introduce Pop Logic (PL), a syntactical  extension of ITL with a pop operator ‘↑’ that revokes the  most recent effect (interval restriction) imposed by a chop  A ﬁnite of inﬁnite word σ is a model of ϕ, denoted σ |= ϕ,  if, and only if, ϕ holds initially on the complete word, that  is, if, and only if, σ; [0, |σ|[; 0 |= ϕ holds.  65  Note that, as usual, for all ﬁnite words σ and all k ≥ |σ|,  σ; k |= .  No pop on the singleton stack. : If the interval stack  contains only one element, then the semantics of the pop  operator is not properly deﬁned. Note that we could easily  avoid this by deﬁning ‘σ; I0 ; k |= ↑ ϕ if, and only if, σ; I0 ; k |=  ϕ’. Choosing to do so would also allow us to treat ill formed  formulas by a convention that could intuitively be phrased  as ‘an attempt to pop the bottom element of an interval stack  is ignored’. However, we consider it more natural to simply  disallow such operations.  In PL, we have the following abbreviations:  PUSH  EVENTUALLY  ALWAYS  UNTIL  In order to obtain a simple logic, we have extended a  basic version of ITL, ITL without star [5], [7], whose syntax  simply represents the PL syntax without pop. The semantics  of ITL, however, is traditionally ‘ﬂat’ in the sense that the  semantics of ITL is normally not deﬁned using an interval  stack: Without the introduced pop operation, there is no  requirement for it because preserving the top-most interval  is unnecessary.  The traditional ITL semantics for chop is  σ; [b, e[; k |= ϕ ; ψ iff k ∈ [b, e[ and  ∃l ∈ [k, e[. σ; [k, l]; k |= ϕ and σ; [l, e[; l |= ψ.  This has no effect on the evaluation of σ; [0, |σ|[; 0 |= ϕ,  because without a pop operation we would never refer to  any other than the top interval on the interval stack.  =  =  =  =  ψ ; ↑ϑ   : ψ  ¬  ¬ψ      ↑ (ψ ∨ ϑ) : ϑ  V. D ECIDABILITY OF P OP L OGIC  There are two obvious approaches to show the decidability  of PL: A direct translation to automata and an embedding  into QLTL. We describe an embedding into QLTL, because  it is a much simpler transformation. It also simpliﬁes the  decidability proofs for the sub-logic ITL with ﬁnite [13] and  inﬁnite [5] word semantics. The main reason for our choice,  however, is that it again outlines the connection between PL  (or ITL) and classic temporal logics. The embedding of PL  into QLTL is also a counter position to the embedding of  LTL into PL discussed in the previous section.  QLTL: extends LTL slightly by introducing quantiﬁcation [17], yielding the full power of ω-regular expressions.  QLTL formulas are described by the following grammar:  IV. E MBEDDING LTL IN P OP L OGIC  In the following, we brieﬂy present the related temporal  logic LTL and discuss its embedding in PL. The syntax of  LTL is given by the following grammar:  ϕ | ϕ Uϕ  The semantics of LTL formulas is only deﬁned on inﬁnite  words. Like with ITL, the concept of interval stacks does  not exist in LTL and the interpretation of a formula ϕ at a  position k is deﬁned inductively by:  σ; k |= p  σ; k |= ¬ϕ  σ; k |= ϕ ∨ ψ  σ; k |= ϕ  σ; k |= ϕ U ψ  The ﬁrst abbreviation introduces a push operator ‘:’,  which is closely related to the chop. Different to chop, a  push operation only increases the call stack on the left. There  is little difference in the effect of push and chop, as the  evaluation of the truth of the formula on the right is started  at the beginning of the second interval. In our view, the push  operation is the more useful, as it reﬂects a call and return  situation; our intuition is that we ﬁrst satisfy the formula  on the right (pushing down one level) and then come back  (pop) and satisfy the right side.  On inﬁnite intervals, the eventually and always operators  ‘ ’ and ‘ ’ have the same semantics as in LTL, with  the natural extension for ﬁnite intervals (holds somewhere  within the interval and holds throughout the interval, respectively). A similar claim holds for until.  Using only the LTL operators, it is plain to see that  we maintain the semantics of LTL. Note that, in the LTL  fragment, a chop (or pop) operator can only occur in  the abbreviations for a temporal operator, and there it is  ‘guarded’ in the sense that the stack cannot grow to a size  of more than three.  III. R ELATION OF P OP L OGIC TO ITL  ϕ ::= p | ¬ϕ | ϕ ∨ ϕ |  ψ :ϑ  ψ  ψ  ψ Uϑ  ϕ ::= p | ¬ϕ | ϕ ∨ ϕ |  ϕ | ϕ U ϕ | ∃x. ϕ  p ∈ σ(k),  σ; k |= ϕ,  σ; k |= ϕ or σ; k |= ψ,  σ; k + 1 |= ϕ,  ∃i ≥ k.σ; i |= ψ and ∀ j ∈ [k, i[. σ; j |= ϕ.  Likewise, the semantics of QLTL extends the semantics  of LTL by introducing a rule for quantiﬁcation,  A central advantage of Pop Logic is that it provides us  with a very simple embedding of LTL, while preserving  the scoping allowed for by ITL. The LTL operators can be  viewed as abbreviations of small snippets of PL, just as  and  operators in LTL can be viewed as snippets of LTL  syntax.  where σ ⊕ σx : n → σ(n)  σx (n) ∀n ∈ ω, to the inductive  deﬁnition of the semantics of a formula.  While the quantiﬁers extend the expressiveness, quantiﬁcation does not seem to be a concept that lends itself to  human system analysts. We freely confess that we would  not trust ourselves when writing a QLTL speciﬁcation, in  iff  iff  iff  iff  iff  σ; k |= ∃x.ϕ iff ∃σx : ω → 2{x} . σ ⊕ σx ; k |= ϕ,  66   ϑ   = ϑ, and ϑ = ϑ , and for a formula ψ that appears  par(ψ),     = par(  as a direct sub-formula of ψ =↑ ψ, we set ψ  ψ ).     = ψ .  Otherwise, if ψ is a direct sub-formula of ψ , we set ψ  Using these terms, we deﬁne our translation κ from PL  to QLTL as follows:  particular with nested quantiﬁcation under the scope of  temporal operators.  A. Embedding Pop Logic into QLTL  The embedding of PL into QLTL builds on a simple  observation: The truth of a sub-formula depends on the  interval stack. In the interval stack, each interval but the  interval at the bottom of the interval stack is introduced by  a particular chop operator.  Each chop operator introduces two different intervals for  its left and right sub-formulas and we index the interval in  the interval stack with the respective sub-formula. That is,  for a sub-formula of a speciﬁcation ϕ that is a chop formula  ψ ; ϑ, we index with ψ and ϑ, respectively. We index the  interval at the bottom of the stack with ϕ.  An interval can be encoded by the existence of a proper  assignment of truth values to interval propositions that are  evaluated to true within the interval and to false outside of  the interval. We use pψ to denote the truth values of an  interval Iψ . This way, the existence of a suitable chop of an  interval can be translated to a QLTL formula that intuitively  says ‘there is a chopping point for the given interval’. The  respective encoding requires that (1) the new intervals are  proper intervals, (2) the last position of the left interval  coincides with the ﬁrst position of the right interval, and  (3) the union of these intervals coincides with the chopped  interval.  As the interpretation of a sub-formula depends—through  the interval stack—on its position in the formula tree, its  translation needs to take this position into account. We call  the complete formula ϕ and all direct sub-formulas ϑ and ϑ  of a chop sub-formula ϑ; ϑ of ϕ interval identiﬁers. ϕ can  be used to identify the interval [0, |σ|[ at the bottom of our  interval stack, while ϑ and ϑ can be used to identify the left  and right interval, respectively, which is added by the chop  operation in ϑ; ϑ to the interval stack. Note that ϑ and ϑ are  deﬁned by their positions in the formula tree; syntactically  identical sub-formulas of ϕ have to be distinguished.  For a sub-formula ψ of ϕ, we ﬁrst look for the relevant  interval identiﬁer, which is the index of the top interval  in the stack under which ψ is interpreted. The relevant  interval identiﬁer of ψ can be found by, starting at ψ,  walking the formula tree upwards towards its root. While  walking up, we maintain a counter, which is initially 0. The  counter is incremented each time we pass a pop operator  ‘↑’ and decremented each time we pass a chop operator  ‘ ; ’, reﬂecting the pushing and popping of the interval stack.  The ﬁrst interval identiﬁer we pass (including ψ itself) with  counter value 0 is the relevant interval identiﬁer of ψ,  .  denoted ψ  In other words: if, for a true sub-formula of a speciﬁcation  ϕ, par(ψ) denotes the sub-formula of ϕ whose direct subformula ψ is, then the following holds. For a speciﬁcation   = ϕ, for a chop formula ψ = ϑ; ϑ , we set ψ  =  ϕ, we set ϕ  •  •  •  •  •  leaves p (including ) of the formula tree are strengthened by a claim that the current position is within  the top interval of the interval stack, reﬂected by the  respective interval proposition: a sub-formula ψ =   is translated to κ(ψ) = pψ and an atomic proposition  ψ = q is translated to κ(ψ) = pψ ∧ q;  a sub-formula ψ = ¬ϑ is translated to κ(ψ) = ¬κ(ϑ)  and a sub-formula ψ = ϑ ∨ ϑ is translated to κ(ψ) =  κ(ϑ) ∨ κ(ϑ ) (all boolean connectives can be translated   = ϑ = ψ   );  in this simple manner, note that ϑ  a sub-formula ψ =  ϑ is translated to κ(ψ) =  (κ(ϑ)),  a sub-formula ψ =↑ ϑ is translated to1 κ(ϑ), and  a sub-formula ψ = ϑ ; ϑ is translated to  ∃pϑ , pϑ . κ(ϑ) ∧ γ(pϑ , pϑ , pψ ) ∧ (κ(ϑ ) ∧ pϑ ∧ pϑ ),  where         γ(p, q, r) = p ∧  ((p ∨ q) ↔ r) ∧  (p ∧ q) ∧  (q → ¬ p) simply checks if p and q deﬁne two  intervals that properly chop the interval deﬁned by r.  In order to ease the proof that a PL formula ϕ and its  translation κ(ϕ) to QLTL are semantically equivalent (that  is, have the same models), we introduce a natural extension  of the QLTL semantics to interval stacks. Assuming without  loss of generality that p0 , p1 , . . . , pn are fresh propositional  variables, we denote with ΠI0 ,...,In = Π  {p0 , . . . , pn } an extended set of atomic propositions. For a word σ = [0, |σ|[→  2Π , we denote by σ; I0 , . . . , In the ω-word with  •  •  σ; I0 , . . . , In (k) ∩ Π = σ(k) and  pi ∈ σ; I0 , . . . , In (k) if, and only if, k ∈ Ii .  Finally, we use σ |= ϕ as an abbreviation for σ; [0, |σ|[; 0 |= ϕ.  Note that there is a difference between the bottom element  of the stack and the remaining elements: While the bottom  element—[0, |σ|[—reﬂects the true length of a ﬁnite or  inﬁnite input word σ, the other elements of the stack are  introduced during the interpretation of the ϕ on σ. Thus, the  bottom element and the atomic proposition describing it (no  matter if named p0 , pϕ , or pϕ ) are assumed to be explicitly  given.  Theorem 5.1: For a PL formula ϕ and a word σ, σ |= ϕ  holds if, and only if, σ |= κ(ϕ).  Proof: By induction over the structure of the formula,  we show that σ; Iϕ , . . . , Iψ ; k |= ψ holds for every sub-formula  ψ of ϕ if, and only if, σ; Iϕ , . . . , Iψ ; k |= κ(ψ).  1 This translation might look a bit surprising at ﬁrst glance, because it  may convey the impression that the ↑ operator has no effect. However, it is  reﬂected in the   θ operations that identify the relevant interval identiﬁers—  and hence the interval propositions occurring in the translation.  67  The induction basis is trivial, as the claim holds by  deﬁnition for the atomic propositions (including ).  The induction step for boolean connectives is also trivial.  For the next operation, we have  σ; Iϕ , . . . , Iψ ; k |= ψ  σ; Iϕ , . . . , Iψ ; k + 1 |= ψ  ⇔PL  ⇔IH  σ; Iϕ , . . . , Iψ ; k + 1 |= κ(ψ)  de f  ⇔QLT L σ; Iϕ , . . . , Iψ ; k |= κ(ψ) =κ κ(  the satisﬁability problem and the word problem for ﬁnite  and ω-regular words.  For the lower bounds, we can use the matching hardness  results of the syntactic sub-logic ITL for both ﬁnite and  inﬁnite [18] words.  VI. A PSPACE-C OMPLETE S UBSET OF PL  While Section V establishes the decidability and complexity of PL, the non-elementary complexity of PL is not  appealing. But we have also seen that the popular and  inexpensive temporal logic LTL can be viewed as a de-facto  syntactic sub-logic of PL, which implies that relevant sublogics of PL are in PSPACE.  In this section, we deﬁne a wider fragment of PL—which  includes LTL—that is still decidable in polynomial space.  Depending on personal preferences, this sub-logic can be  considered as a restriction of PL or as an extension of LTL.  To get an intuition for the extension, we adjust our  translation κ with complexity considerations in mind. We  approach ﬁnding a PSPACE fragment by looking at the  translation of LTL, starting with the sub-logic of LTL that  uses the eventually operator instead of until.  In LTL,  ψ is an abbreviation for  ; ↑ ψ, and this subformula translates to ∃p , p↑ψ κ() ∧ γ(p , p↑ψ , p  )∧  ; ↑ψ  ,  (p↑ψ ∧ κ(↑ ψ)). γ states that p and p↑ψ do chop p  ; ↑ψ  and neither p nor p↑ψ occur in κ(↑ ψ). In such a situation, we can avoid the existential quantiﬁcation and simply  translate κ( ; ↑ ψ) to p  ∧ (p  ∧ κ(↑ ψ)).  ; ↑ψ  ; ↑ψ  Adjusting κ.: Avoiding quantiﬁcation is a very useful  tool, because without quantiﬁcation the target language is  LTL instead of QLTL. In the remainder of the paragraph  we therefore discuss properties of sub-formulas which allow  either avoiding quantiﬁcation, or at least to use it in a  monotone and inexpensive way. This raises the question of  whether or not we can avoid the introduction of quantiﬁcation. For this we adjust our translation κ from PL to QLTL  to κ, where we only touch the rules for chop sub-formula  ψ ; ϑ. For them we give two rules for cases, where the use  of quantiﬁcation can be avoided completely, and a fall-back  rule that only avoids the introduction of the pϑ .  This fall-back rule, which is only used if neither of the  two rules introduced later in this section apply, translates  ψ ; ϑ to ∃pψ .κ(ψ) ∧ (pψ ∧ pψ;ϑ   ) U (pψ ∧ pψ;ϑ   ∧ κ(ϑ)[pϑ →    pψ;ϑ  ¬pψ ) .  ] ∧  This fall-back rule is also a preparation for the more  powerful rules in the special cases where quantiﬁcation over  pψ can also be avoided, as it uses the concept of implicitly  expressing the existence of a reasonable representation of  the second interval. The right side of the until marks the  situation at the chopping point: pψ holds, but ceases to do  so in the next position, and the chopping point needs to be  within the interval identiﬁed by pψ;ϑ   . pϑ has to coincide  with pψ;ϑ   from the chopping point onwards (and cannot  ψ).  The induction step for the pop operator is also simple:  σ; Iϕ , . . . , Iψ , I↑ψ   ; k |=↑ ψ  ⇔PL σ; Iϕ , . . . , Iψ ; k |= ψ  ⇔IH σ; Iϕ , . . . , Iψ ; k |= κ(ψ)  de f  ⇔κ  σ; Iϕ , . . . , Iψ , I↑ψ   ; k |= κ(↑ ψ)  For the last equivalence, note that the leading ↑ operator   ). (Hence, its  prevents that the variable p↑ψ   occurs in κ(ψ  valuation does not matter.)  We conclude the inductive proof with the induction step  for the chop operator, using the abbreviations Iψ;ϑ   = [b, e[,  Iψ = [k, c], and Iϑ = [c, e[. We then get:  σ; Iϕ , . . . , Iψ;ϑ   ; k |= ψ; ϑ  PL  ⇔  ∃c ∈ [k, e[. σ; Iϕ , . . . , Iψ;ϑ   , Iψ ; k |= ψ and  ,  I  σ; Iϕ , . . . , Iψ;ϑ   ϑ ; c |= ϑ  IH  ⇔  ∃c ∈ [k, e[. σ; Iϕ , . . . , Iψ;ϑ   , Iψ ; k |= κ(ψ) and  σ; Iϕ , . . . , Iψ;ϑ  ,  I   ϑ ; c |= κ(ϑ)  QLT  L  σ; Iϕ , . . . , Iψ;ϑ  ⇔   ; k |= ∃pψ , pϑ . κ(ψ)∧  (κ(ϑ) ∧ pψ ∧ pϑ )  γ(pψ , pϑ , pψ;ϑ  ) ∧  de f  ⇔κ  σ; Iϕ , . . . , Iψ;ϑ   ; k |= κ(ψ; ϑ).  Note that we have to adjust κ(ϕ) if we are interested in  the satisﬁability or validity problem as there is no word σ  to start with. If we are only interested in inﬁnite models,  we can replace all occurrences of pϕ by , if are interested  only in ﬁnite models, we can use κ(ϕ) ∧ (pϕ U ¬pϕ ), and  if we want to allow for both we can use their disjunction.  B. Complexity of Pop Logic  Having established a linear translation of well formed PL  formulas to equivalent QLTL formulas, we can re-use the  decision procedures of QLTL to decide PL speciﬁcations.  We thus inherit the non-elementary decision procedures for  the satisﬁability and word problem of QLTL from [17].  Matching hardness results are inherited from the syntactic  sub-logic ITL of PL.  Theorem 5.2: The satisﬁability, word, and model checking problems for PL are non-elementary decidable, and hard  for this class even if restricted to ﬁnite or inﬁnite words.  Proof: With κ, we have established a linear translation  from PL to equivalent QLTL speciﬁcations. We therefore  inherit the non-elementary decision procedures of QLTL for  68  appear in κ(ψ)). We can therefore check the correctness of  κ(ϑ)[pϑ → pψ;ϑ   ] instead of κ(ϑ) at the chopping point and  avoid the introduction of pϑ .  Unfortunately, no similarly general technique for the left  side of a chop operation can exist, because this would  apply a lower complexity of Pop Logic. But the observation  that the introduction of pϑ can be avoided allows us to  concentrate on pψ when seeking sub-languages in PSPACE.  Our focus is on cases where the chopping point itself can  be guessed.  We can avoid the introduction of (and quantiﬁcation over)  pψ if we can identify a suitable chopping point within the  interval identiﬁed by pψ  . The simplest case in which this  ;ϑ  is possible is, of course, if pψ does not occur in κ(ψ). This  is, for example, the case in the de-facto sub-language that  resembles LTL. But we can do more.  We call a sub-formulas ψ long for an interval proposition  p if it holds that, if ψ holds if p identiﬁes the non-empty  interval [b, e[, then it holds if p identiﬁes the interval [b, e [  for all e ≥ e. Likewise, we call a sub-formula ψ short for  an interval proposition p if it holds that, if ψ holds if p  identiﬁes the non-empty interval interval [b, e[, then it holds  if p identiﬁes the interval [b, e [ for all b < e ≤ e. We call  a sub-formula ψ ﬁnite if the interval stack Iϕ , . . . , Iψ under  which ψ is evaluated contains an interval Iϑ stemming from  the left side of a chop sub-formula ϑ; ϑ of ϕ. (Finite simply  guarantees that the respective interval is ﬁnite; in the ﬁnite  semantics, all sub-formulas are ﬁnite.)  There are simple sufﬁcient conditions for formulas to  be long or short. In particular, a sub-formula is both long  and short for pψ if pψ does not occur in the translation  κ(ψ). This holds, for example, for ψ =↑ ψ . Also, atomic  propositions are short and long, longness is preserved by  next operations, and shortness and longness are preserved  by positive boolean combination, and shortness and longness  are toggled by negation. (That is, ¬ψ is long if ψ is short  and ¬ψ is short if ψ is long.)  We can use a simplifying translation for ψ; ϑ in two cases:  if ψ is both short and long, and if ψ is ﬁnite and long. If we  can identify the ﬁrst case (to which we give preference to  have an unambiguous rule) by the rules above we can deﬁne  κ(ψ; ϑ) to      κ(ψ)[pψ → pψ;ϑ  pψ;ϑ  ] ∧   ∧ κ(ϑ)[pϑ → pψ;ϑ  ] .  Finally, we call chop operators safe if the sub-formula  they govern is not translated to a quantiﬁed formula by κ,  and left if, on the path from the root to this formula, only  left turns were taken at every chop operator. As usual, we  call these formulas positive if they are bound by an even  number of negations, and negative otherwise.  A ﬁrst observation is that, provided all chop operators are  safe, the discussed translation goes to LTL, providing for a  PSPACE complexity.  Theorem 6.1: The PL subset where all occurring chops  are safe is a sub-logic of PL that contains LTL as a de-facto  syntactic subset. It has a PSPACE-complete satisﬁability,  validity, word, and model checking problem.  Proof: In the formulas from the LTL fragment of PL all  chop operations are safe and the translation of PL formulas  where all chop operations are safe go to LTL. (Which also  implies that this subset is no more expressive than LTL.)  Note that the formula tree of the target formula is not  necessarily polynomial in the size of the source speciﬁcation,  because the ‘long & ﬁnite’ case adds multiple occurrences  of  (pψ;ϑ   ∧ κ(ϑ)[pϑ → pψ;ϑ   ]) in the translation of a chop  sub-formula ψ; ϑ. However, if we represent the formula as  a directed acyclic graph (DAG), then this blow-up does not  occur: there are merely multiple edges pointing to the same  node. Hence, the number of sub-formulas stays linear in the  size of the PL formula.  This also outlines a difference between PL and LTL that  cannot be bridged: While the valuation of a sub-formula of  an LTL formula is independent of its position in the formula  tree, the valuation of sub-formulas in PL depend on the  interval stack under which they are interpreted. We therefore  cannot safely assume that the valuation is similar unless they  must refer to the same interval stack when evaluated. (Which  1 = ψ  2 .)  is the case for two sub-formulas ψ1 and ψ2 if ψ  We can extend the relative tractability to larger classes  of languages: There is no need for the target formula to  be in LTL. If we are interested in the satisﬁability or word  problem, then it sufﬁces to reside in prenex QLTL with only  existential quantiﬁcation.  Theorem 6.2: The PL subset where all occurring unsafe  chops are positive left formulas is a sub-logic with a  PSPACE-complete satisﬁability and word problem.  Proof: It is easy to show by induction that, provided  all unsafe chop operations in a PL formula ϕ are positive  left formulas, the target formula κ(ϕ) has a formula DAG  where no quantiﬁer is bound by a temporal operator and all  quantiﬁers occur positively. We can hence re-write κ(ϕ) to  prenex normal form by simply moving all quantiﬁers to the  front, which does not affect the size of the formula DAG.  For formulas of this type, the satisﬁability and word  problem are the same as for LTL, because leading existential  quantiﬁcation does not affect them.  Consequently, the co-problems of the negation of these  formulas are also in PSPACE.  The right conjunct requires that there is a chopping point  such that ϑ holds in the right interval. (Where, again, pϑ  and pψ;ϑ   coincide on that interval.) Shortness and longness  together imply that ψ holds on the left interval if, and only  if, it holds on the interval identiﬁed by pψ;ϑ   ; it is therefore  safe to use this interval instead.  If κ(ψ) is long for pψ and ψ; ϑ ﬁnite, we can use the well  deﬁned last possible chopping point—the last point where  α = (pψ;ϑ   ∧ κ(ϑ)[pϑ → pψ;ϑ   ]) holds. We set κ(ψ; ϑ) =  κ(ψ)[pψ → α] ∧ α.  69  ITL, but also the classic temporal logic LTL, as syntactic  sub-logics.  As a result, we think that PL provides a useful bridge  between classic and interval temporal logics: It allows for  using both logics individually for sub-problems, and yet  provides a simple framework to treat these speciﬁcations. It  therefore allows for naturally integrating aspects expressed  by interval temporal logic in a predominantly classic LTL  speciﬁcation, or, less often, LTL aspects in a predominantly  ITL speciﬁcation.  In addition, we have characterised a relatively inexpensive (PSPACE-complete) fragment of PL, which includes  and extends LTL. We consider the identiﬁcation of such  sub-logics useful, as they can guide a system analyst in  devising her speciﬁcation: When the expensive steps can  easily be identiﬁed, the decision to keep the speciﬁcation in  the current form—and pay the price in form of increased  complexity—or to invest more work in reformulating the  speciﬁcation can be made informed.  Corollary 6.3: The PL subset where all occurring unsafe chops are negative left formulas is a sub-logic with  a PSPACE-complete validity, word, and model-checking  problem.  VII. E XTENDED P OP L OGIC  The logic PL introduced in Section II extends the most  basic version of ITL. In order to reach the full expressiveness of regular and ω regular expressions, we extend the  widespread version of ITL with star to Extended Pop Logic  (EPL) in this section. This provides us with the following  grammar:  ϕ ::= p | ¬ϕ | ϕ ∨ ϕ |  ϕ | ϕ; ϕ | ↑ ϕ | ϕ∗  Like the chop operator, the star operator pushes new intervals in the stack. We extend the well formedness to: there  exists no node in the formula tree of ϕ such that strictly  more pop operators than chop and star operators (counted  together) occur on the way from the root of the formula tree  to this node. For the star operator, we use the following  semantics:  ACKNOWLEDGEMENT  Sven Schewe is supported by the Engineering and Physical Science Research Council (EPSRC) through the grant  EP/H046623/1 ‘Synthesis and Veriﬁcation in Markov Game  Structures’. Cong Tian is supported by the NSFC Grant No.  61003078, 91018010, and 60910004, 973 Program Grant  No. 2010CB328102, and ISN Lab Grant No. ISN1102001.  Both Sven Schewe and Cong Tian are corresponding authors.  σ; I0 , . . . , In , [b, e[; k |= ϕ∗ iff  k ∈ [b, e[ and there exist m ∈ N integers  k = r0 < r1 < ... < rm = e such that  ∀i ∈ [0, m[. σ; I0 , . . . , In , [b, e[, [ri , ri+1 + 1[; ri |= ϕ.  Lemma 7.1: EPL can be embedded in QLTL.  Proof: To prove this, it sufﬁces to extend the function  κ and Theorem 5.1 accordingly. The extension is a straight  forward generalization of the rules (and proof) for the chop,  with the difference that we mark ﬁnally many intervals  instead of marking exactly two. Technically this can be  done by guessing the fringes of the intervals (existential  quantiﬁcation) and showing that all intervals deﬁned by  these fringes are suitable (universal quantiﬁcation).  Theorem 7.2: EPL is decidable with non-elementary  complexity. It can express exactly the regular and ω-regular  languages.  Proof: The non-elementary lower bound and the expressiveness of EPL can be inferred from the respective  lower bounds and expressiveness of ITL [18], [19]. The  decidability and upper bound on the complexity are implied  by Lemma 7.1.  R EFERENCES  [1] R. Alur, T.A. Henzinger, and O. Kupferman. Alternating-Time  Temporal Logic. Journal of the ACM 49(5): pages 672–713,  2002.  [2] M. Ben-Ari, Z. Manna, and A. Pnueli. The temporal logic of  branching time. Acta Informatica 20: pages 207–226, 1983.  [3] A. Chandra, J. Halpern, A. Meyer, and R. Parikh. Equations  between regular terms and an application to process logic.  Proceedings of the Thirteenth Annual ACM Symposium on  Theory of Computing (STOC 1981). pages 384–390, 1981.  [4] E. M. Clarke and E. A. Emerson. Design and syntesis  of synchronization skeletons using branching time temporal  logic. In Proceedings of the IBM Workshop on Logics of  Programs (LP 1981). pages 52–71, 1982.  VIII. D ISCUSSION  [5] Z. Duan. An Extended Interval Temporal Logic and A Framing Technique for Temporal Logic Programming. PhD thesis,  University of Newcastle Upon Tyne, May 1996.  We have introduced Pop Logic, an interval temporal  logic that synthesises the concepts of classic and interval  temporal logic. Pop Logic extends ITL only very modestly  by introducing a pop operation that revokes the scoping of  a previous chop operation.  This modest extension preserves the most important property of ITL: Pop Logic remains simple and intuitive. But  while the extension is sufﬁciently modest to preserve this  important property, it is powerful enough to include not only  [6] Z. Duan, M. Koutny, and C. Holt. Projection in Temporal  Logic Programming. In Proceedings of Logic Programming  and Automated Reasoning (LPAR 94). pages 333–344, 1994.  [7] Z. Duan, C. Tian, and L. Zhang. A Decision Procedure  for Propositional Projection Temporal Logic with Inﬁnite  Models. Acta Informatica, 45(1): pages 43–78, 2008.  70  A PPENDIX : E MBEDDING LTL IN P OP L OGIC  In this appendix, we show the semantic equivalence of the  LTL fragment of PL in the PL semantics and the common  LTL semantics. Note that, for this comparison, the bottom  element of the stack is always ω = [0, ∞[.  The inductive proof below makes use of the ﬂatness of  the translation.  As induction basis, the following obviously holds for all  atomic propositions (including ) p ∈ Π:  [8] E. A. Emerson. Temporal and Modal Logic. Computer Science Department, University of Texas at Austin, USA, 1995.  [9] B. Finkbeiner and S. Schewe. Coordination Logic. In Proceedings of the 19th Annual Conference of the European  Association for Computer Science Logic (CSL 2010). pages  305–319, 2010.  [10] J. Halpern, Z. Manna, and B. Moszkowski. A hardware  semantics based on temporal intervals. In Proceedings of the  tenth International Colloquium on Automata, Languages and  Programming (ICALP 1983). pages 278–291, 1983.  σ; ω; k |=PL p ⇔PL p ∈ σ(k) ⇔LT L σ; k |=LT L p.  For the induction step, we have to cover boolean connectives, next, and until. Boolean connectives and next are  trivial:  σ; ω; k |=PL  ϕ∨ψ  σ; ω; k |=PL ϕ or σ; ω; k |=PL ψ  ⇔PL  σ; k |=LT L ϕ or σ; k |=LT L ψ  ⇔IH  ⇔LT L σ; k |=LT L ϕ ∨ ψ,  σ; ω; k |=PL  ¬ϕ  σ; ω; k |=PL ϕ  ⇔PL  ⇔IH  σ; k |=LT L ϕ  ⇔LT L σ; k |=LT L ¬ϕ, and  σ; ω; k |=PL  ϕ  σ; ω; k + 1 |=PL ϕ  ⇔PL  ⇔IH  σ; k + 1 |=LT L ϕ  ⇔LT L σ; k |=LT L ϕ,  [11] D. Harel, D. Kozen, and R. Parikh. Process logic: expressiveness, decidability, completeness. Journal of Computer and  System Sciences 2: pages 144–170, 1982.  [12] L. Lamport. The Temporal Logic of Actions. ACM Transactions on Programming Languages and Systems 16(3): pages  872–923, 1994.  [13] B. Moszkowski. Reasoning about digital circuits. Ph.D Thesis, Department of Computer Science, Stanford University.  TRSTAN-CS-83-970, 1983.  [14] B. Moszkowski. Compositional reasoning about projected and  inﬁnite time. In Proceeding of the First IEEE International  Conference on Enginneering of Complex Computer Systems  (ICECCS 1995), pages 238–245, 1995.  Finally, for the until we have:  [15] A. Pnueli. The temporal logic of programs. In Proceedings  of the 18th IEEE Symposium on Foundations of Computer  Science (FOCS 1977). pages 46–57, 1977.  σ; ω; k |=PL ψ U ϑ       de f  ⇔ U σ; ω; k |=PL ¬ ; ↑ ¬ ↑ (ψ ∨ ϑ) ; ↑ ϑ      ⇔PL ∃l ≥ k.σ; ω, [k, l]; k |=PL ¬ ; ↑ ¬ ↑ (ψ ∨ ϑ)  and σ; ω, [l, ∞[; l |=PL ↑ ϑ    ⇔PL ∃l ≥ k.σ; ω, [k, l]; k |=PL ; ↑ ¬ ↑ (ψ ∨ ϑ)  and σ; ω; l |=PL ϑ  ⇔PL ∃l ≥ k. ∃m ∈ [k, l]. σ; ω, [k, l], [k, m]; k |=PL   and σ; ω, [k, l], [m, l]; m |=PL ↑ ¬ ↑ (ψ ∨ ϑ)  and σ; ω; l |=PL ϑ  ⇔PL   ∃l ≥ k. ∃m ∈ [k, l]. σ; ω, [k, l], [m, l]; m |=PL  ↑ ¬ ↑ (ψ ∨ ϑ)σ; ω; l |=PL ϑ  ⇔PL ∃l ≥ k. ∃m ∈ [k, l]. σ; ω, [k, l]; m |=PL ¬ ↑ (ψ ∨ ϑ)  and σ; ω; l |=PL ϑ  ⇔PL ∃l ≥ k. ∃m ∈ [k, l]. σ; ω, [k, l]; m |=PL ↑ (ψ ∨ ϑ)  and σ; ω; l |=PL ϑ  ⇔ ∃l ≥ k.∀m ∈ [k, l]. σ; ω, [k, l]; m |=PL ↑ (ψ ∨ ϑ)  and σ; ω; l |=PL ϑ  ⇔PL ∃l ≥ k.∀m ∈ [k, l]. σ; ω; m |=PL ψ ∨ ϑ  and σ; ω; l |=PL ϑ  ⇔PL ∃l ≥ k.∀m ∈ [k, l]. σ; ω; m |=PL ψ  or σ; ω; m |=PL ϑ and σ; ω; l |=PL ϑ  ⇔IH ∃l ≥ k.∀m ∈ [k, l]. σ; m |=LT L ψ  or σ; m |=LT L ϑ and σ; l |=LT L ϑ  ⇔ ∃l ≥ k.σ; l |=LT L ϑ and ∀m ∈ [k, l[. σ; m |=LT L ψ  ⇔LT L σ; k |=LT L ψ U ϑ.  [16] T. Schlipf, T. Buechner, R. Fritz, M. Helms, and J. Koehl.  Formal veriﬁcation made easy. IBM Journal of Research and  Development, 41(4-5): pages 567–576, 1997.  [17] A. P. Sistla. Theoretical issues in the design and veriﬁcation  of distributed systems. PhD thesis, Harvard University, 1983.  [18] C. Tian and Z. Duan. Complexity of propositional projection  temporal logic with star. Mathematical Structures in Computer Science 19(1): pages 73–100, 2009.  [19] C. Tian and Z. Duan: Expressiveness of propositional projection temporal logic with star. Theoretical Computer Science  412(18): pages 1729–1744, 2011.  [20] M. Y. Vardi: Branching vs. Linear Time: Final Showdown.  In Proceedings of the Seventh International Conference on  Tools and Algorithms for the Construction and Analysis of  Systems (TACAS 2001). pages 1–22, 2001.  [21] M. Vardi and P. Wolper. Automata Theoretic Techniques for  Modal Logics of Programs, Journal of Computer and System  Sciences 32(2): pages 183–221, 1986.  [22] P. L. Wolper. Temporal logic can be more expressive. Information and Control, 56(1/2): pages 72–99, 1983.  71 