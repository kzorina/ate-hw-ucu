INSTITUT NATIONAL DE RECHERCHE EN INFORMATIQUE ET EN AUTOMATIQUE  Logical time and temporal logics:  Comparing UML MARTE/CCSL and PSL  NÂ° 7459  December 7, 2010  apport  de recherche  ISRN INRIA/RR--7459--FR+ENG  ThĂ¨me COM  ISSN 0249-6399  inria-00540738, version 1 - 7 Dec 2010  RĂŠgis Gascon â FrĂŠdĂŠric Mallet â Julien DeAntoni  inria-00540738, version 1 - 7 Dec 2010  Logi al time and temporal logi s:  Comparing UML MARTE/CCSL and PSL  RĂŠgis Gas on , FrĂŠdĂŠri  Mallet , Julien DeAntoni  ThĂ¨me COM  SystĂ¨mes  ommuni ants  Projet AOSTE  inria-00540738, version 1 - 7 Dec 2010  Rapport de re her he nÂ° 7459  De ember 7, 2010  22 pages  Abstra t:  The UML Prole for Modeling and Analysis of Real-Time and Embedded sys-  tems (MARTE) provides a means to spe ify embedded systems.  Spe i ation Language (CCSL) allows the spe i ation of  properties of MARTE models.  expressiveness that  ele troni  ausal,  The Clo k Constraint  hronologi al and timed  Due to its purposedly broad s ope of use, CCSL has an  an prevent formal veri ation.  However, when addressing hardware  systems, formal veri ation is an important step of the development. The IEEE  Property Spe i ation Language (PSL) provides a formal notation for expressing temporal  logi  properties that  an be automati ally veried on ele troni  system models.  We want to identify the part of MARTE/CCSL amenable to support the  methods from the Ele troni  tribute to this goal by  Design Automation (EDA)  lassi al analysis  ommunity. In this paper, we  on-  omparing the expressiveness of CCSL and the Foundation Language  of PSL. We show that none of these languages is subsumed by the other one. We identify  the CCSL  onstru ts that  annot be expressed in temporal logi s and propose restri tions of  these operators so that they be ome tra table in temporal logi s. Conversely, we also identify the  lass of PSL formulas that  an be en oded in CCSL. We dene translations between  these fragments of CCSL and PSL using automata as an intermediate representation.  Key-words:  High-level design, Linear temporal logi , Language equivalen e, Automaton  based approa h  UnitĂŠ de recherche INRIA Sophia Antipolis  2004, route des Lucioles, BP 93, 06902 Sophia Antipolis Cedex (France)  TĂŠlĂŠphone : +33 4 92 38 77 77 â TĂŠlĂŠcopie : +33 4 92 38 77 65  Temps logique et logiques temporelles:  Comparaison de UML MARTE/CCSL et PSL  RĂŠsumĂŠ :  Le prol UML MARTE (Modeling and Analysis of Real-Time and Embedded  systems) permet la spĂŠ i ation de systĂ¨mes embarquĂŠs. Le langage asso iĂŠ CCSL (Clo k  Constraint Spe i ation Language) est ore la possibilitĂŠ de spĂŠ ier des propriĂŠtĂŠs  sales,  au-  hronologiques et temporelles sur les modĂ¨les MARTE. En raison de son large spe tre  d'appli ations, CCSL a une grande expressivitĂŠ qui empĂŞ he l'appli ation de  ertaines te h-  niques de vĂŠri ation formelle. Cependant, la vĂŠri ation formelle est une ĂŠtape importante  du dĂŠveloppement dans le domaine des hardware ele troni  systems.  Pour  e faire, le  standard IEEE PSL (Property Spe i ation Language) fourni des notations formelles pour  l'expression de propriĂŠtĂŠs en logique temporelles qui peuvent ĂŞtre automatiquement vĂŠriĂŠe  sur le modĂ¨le du systĂ¨me ĂŠle tronique.  Nous voulons identier le fragment de MARTE/CCSL sus eptible de supporter les mĂŠthodes d'analyses  inria-00540738, version 1 - 7 Dec 2010  mation). Dans  lassiques utilisĂŠes dans la  e papier, nous  et du fragment de PSL  qu'au un de  ontribuons Ă  ommunautĂŠ EDA (Ele troni  e but en  orrespondant Ă  la logique temporelle linĂŠaire.  es langages n'est in lus dans l'autre.  Design Auto-  omparant l'expressivitĂŠ de CCSL  Nous identions les  Nous montrons  onstru teurs de  CCSL qui ne peuvent ĂŞtre exprimĂŠs par les logiques temporelles propositionnelles et proposons en  onsĂŠquen e des restri tions de  es opĂŠrateurs de maniĂ¨re Ă  les rendre exprimable  dans PSL. RĂŠ iproquement, nous identions la  lasse de propriĂŠtĂŠs de PSL qui peuvent ĂŞtre  odĂŠes dans CCSL. Nous dĂŠnissons des tradu tion entre  automates  es deux fragment utilisant des  omme reprĂŠsentation intermĂŠdiaire.  Mots- lĂŠs :  Con eption haut niveau, Logique temporelle linĂŠaire, Ăquivalen e de langages,  Appro he Ă  base d'automates.  Logi al time and temporal logi s: Comparing UML MARTE/CCSL and PSL  3  1 Introdu tion  The UML Prole for Modeling and Analysis of Real-Time and Embedded systems (MARTE [8â)  provides a mean to spe ify several aspe ts of embedded systems, ranging from large software systems on top of an operating system to spe i  hardware designs. The Clo k Con-  straint Spe i ation Language (CCSL [1â) oers a general set of notations to spe ify  ausal,  hronologi al and timed properties on these models and has been used in various subdomains [6, 5, 2â. From this spe i ation, it is possible to simulate the behavior of a CCSL  spe i ation at the model level. CCSL has been formally dened; however, due to its broad  s ope of use CCSL has an expressiveness that  spe ied system  an prevent formal veri ation, sin e the  an be, by intention, non-deterministi , innite, unbound. Very wide spe -  i ations at the system level should be progressively rened into more pre ise des riptions  down to a point where  ode generation, s hedulability, formal analysis be ome possible.  MARTE/CCSL oers a support at all the renement steps.  In the domain of hardware ele troni  systems, whi h one of the subdomains targeted  inria-00540738, version 1 - 7 Dec 2010  by MARTE, formal veri ation is an important step of the development. To allow simulation and formal veri ation of su h systems, the IEEE Property Spe i ation Language  (PSL [10â) provides a formal notation for the spe i ation of ele troni  ompatible with multiple ele troni  system behavior,  system design languages (VHDL, Verilog, SystemC,  SystemVerilog).  Even though a MARTE/CCSL spe i ation  overs a broad s ope and several sub-  domains, the intent remains to oer exhaustive veri ation apabilities when fo using on spei  aspe ts within a subdomain. When fo using on hardware ele troni  provides a support to  systems, MARTE  apture stru tural or behavioral, fun tional or non-fun tional aspe ts.  Its time model and CCSL , as part of MARTE, are natural  andidates to express safety prop-  erties on MARTE models. Two questions arise. Is MARTE expressive enough to  apture  an abstra t view of hardware systems ? Is CCSL expressive enough to express properties  usually modeled in PSL ? Some eorts has been made to answer the rst question [9, 13â.  We are addressing here the se ond question.  The main  ontribution of this paper is then the  omparison of PSL and CCSL expressive-  ness. The rst result is that none of these languages subsume the other one. Consequently,  we identied the CCSL  onstru ts that  annot be expressed in temporal logi s and proposed  restri tions to these operators so that they be ome tra table in temporal logi s. Conversely,  we also identify a  lass of PSL formulas that  an be en oded in CCSL . Then, We dene  translations between these fragments of CCSL and PSL using automata as an intermediate  representation. These transformations make possible the  ombined use of both formalisms  to adequately address the right level, CCSL at the model level and PSL at the implementation level. They also oer a way to provide an exhaustive analysis support for a  lass of  CCSL spe i ations.  The remaining of this paper is organized as follows. In Se t. 2 we introdu e CCSL and  PSL and determine whi h kind of properties  dene in Se t. 3 the  between fragments of CCSL and PSL. Se t. 5  RR nÂ° 7459  annot be expressed in ea h language.  We  lass of Boolean automata whi h is used in Se t. 4 to dene translations  ontains  on luding remarks and future work.  R. Gas on , F. Mallet , J. DeAntoni  4  2 Denitions of the languages  We dene here the languages that we  onsider in this paper and give rst  omparisons  related to their expressive power.  2.1 Clo k Constraint Spe i ation Language  CCSL is the  tems. It  ompanion language of MARTE UML prole for the design of embedded sys-  ombines  onstru ts from the general net theory and from the syn hronous lan-  guages. CCSL oers a set of  ausal and timed patterns  lassi ally used in embedded systems.  lo ks  More formally, the language CCSL is based on the notion of  to denote a totally ordered sequen e of event o  Instants do not  uren es,  arry values. CCSL denes a set of  whi h is a general name  alled the  lo k relations :  instants  of the  lo k.  inria-00540738, version 1 - 7 Dec 2010  r ::= c1 â c2 | c1 # c2 | c1 âş c2 | c1 4 c2 .  where  c 1 , c2  represent  lo ks of the system. Informally,  c 1 â c2  means that  c1  is a sub lo k  c2 , c1 # c2 that the instants of the two lo ks never o ur at the same time and c1 âş c2  nth o urren e of c1 stri tly pre edes the nth o urren e of c2 for every n â Nâ .  The relation c1 4 c2 is the non stri t version of the pre eden e relation.  of  that the  CCSL is a high level multi lo k language and the original semanti s does not require  totally ordered models.  However, at lower level or for simulation purposes, one needs to  represent the exe ution as a totally ordered sequen e. In this  introdu ed in [1â, identies  ontext, a possible semanti s,  lo ks with Boolean variables evolving along time .  In the  belongs to a set of propositions VAR and CCSL models  VAR  are nite or innite sequen es of elements in 2  . The set of instants of the lo k c  remaining, we will  onsider that  c  c holds.  Ď be a CCSL model. For su h a sequen e, we denote in the following by |Ď| the length  of Ď and we assume that |Ď| = Ď when Ď is an innite word. We also use the notations Ď(i)  th element of Ď and Ď i for the sux of Ď starting at the ith position. To evaluate the  for the i  orresponds to the set of positions where the variable  Let  satisfa tion of pre eden e relations, we need to know the number of o  at ea h position of  Ď.  We dene the fun tion  ĎĎ  su h that for every  urren es of the  iâN  and  lo ks  c â VAR  we  have  ĎĎ (c, i) = |{j â N  s.t.  jâ¤i  and  c â Ď(j)}|.  The satisfa tion of CCSL relations is dened by:  Â Ď |=ccsl c1 â c2  the  i for every  oin iden e relation  =  0 â¤ i â¤ |Ď|, if c1 â Ď(i) then c2 â Ď(i). We also dene  Ď |=ccsl c1 = c2 i Ď |=ccsl c1 â c2 and  su h that  Ď |=ccsl c2 â c1 .  Â Ď |=ccsl c1 # c2  i for every  0 â¤ i â¤ |Ď|  we have  c1 6â Ď(i)  or  c2 6â Ď(i).  INRIA  Logi al time and temporal logi s: Comparing UML MARTE/CCSL and PSL  Â Ď |=ccsl c1 âş c2 i for every 0 â¤ i â¤ |Ď|  have ĎĎ (c1 , i) > ĎĎ (c2 , i).  Â Ď |=ccsl c1 4 c2  CCSL  tions.  i for every  an also express more  CCSL  ĎĎ (c1 , i) > 0  ompli ated relations between  lo k denition is of the form  and  ĎĎ (c2 , i) > 0  we  ĎĎ (c1 , i) âĽ ĎĎ (c2 , i).  we have  lo k denitions allows one to dene a  given as arguments. A  expression  0 â¤ i â¤ |Ď|  su h that  5  lo k by  c , e  lo ks by using  lo k deni-  ombination of other  where  c â VAR  and  e  is a  lo ks  lo k  dened by the following grammar:  e := c | e + e | e â e | e  e|e  e|e  e | e H bw | e $e n | e â§ e | e â¨ e  c â VAR, n â Nâ and bw : Nâ â B is a binary word. The expressions e1 + e2  and e1 â e2 represent respe tively the union and interse tion of e1 and e2 . The stri t and  non stri t sample expressions are denoted respe tively by e1  e2 and e1 e2 . The delay  th o urren e of e .  operation e1 $e2 n is a variation of sampling that samples e1 on the n  2  The expression e1  e2 is the preemption (e1 up to e2 ), e H bw represents the ltering  operation. Finally, e1 â§ e2 (resp. e1 â¨ e2 ) represents the fastest (resp. slowest) of the lo ks  that are slower (resp. faster) than both e1 and e2 . This orresponds to greatest lower bound  inria-00540738, version 1 - 7 Dec 2010  where  and lowest upper bound.  Given a  lo k expression  i  holds at position  of  Ď.  e  and a CCSL model  Ď  we note  Ď, i |=ccsl e i the expression e  ĎĎ to expressions in  To dene this relation, we extend the fun tion  a natural way:  ĎĎ (e, i) = |{j â N  s.t.  jâ¤i  and  Ď, j |=ccsl e}|.  The satisfa tion relation for expressions is dened by:  Â Ď, i |=ccsl c  i  c â Ď(i).  Â Ď, i |=ccsl e1 + e2  i  Â Ď, i |=ccsl e1 â e2  i  Â Ď, i |=ccsl e1  i  e2  Ď, i |=ccsl e1  Ď, i |=ccsl e1  or  Ď, i |=ccsl e2 .  and  Ď, i |=ccsl e2 .   Ď, i |=ccsl e2 ,    0 â¤ j < i  Ď, k 6|=ccsl e2 .  there is  Â Ď, i |=ccsl e1  e2  su h that  Ď, j |=ccsl e1  and for every  j < k < i  we have  su h that  Ď, j |=ccsl e1  and for every  j < k < i  we have  i   Ď, i |=ccsl e2 ,    RR nÂ° 7459  0 â¤ j â¤ i  Ď, k 6|=ccsl e2 .  there is  R. Gas on , F. Mallet , J. DeAntoni  6  Â Ď, i |=ccsl e1 $e2 n   Ď, j |=ccsl e1    there is a position  k â {1, . . . , n}  e2  su h that  and  there are exa tly  Â Ď, i |=ccsl e1  0â¤jâ¤i  n  i 1 , . . . , i n (i n = i )  Ď, ik |=ccsl e2 .  distin t positions  j < ik â¤ i  we have  and  su h that for every  i   Ď, i |=ccsl e1 ,    for every  j<i  Â Ď, i |=ccsl e H bw  Ď, j 6|=ccsl e2 .  we have  i  inria-00540738, version 1 - 7 Dec 2010   Ď, i |=ccsl e   bw (ĎĎ (e, i)) = 1.  Â Ď, i |=ccsl e1 â¨ e2  i either   ĎĎ (e1 , i) > ĎĎ (e2 , i) and Ď, i |=ccsl e1 ,    or  ĎĎ (c1 , i) < ĎĎ (c2 , i)  and  Ď, i |=ccsl e2 ,    or  ĎĎ (e1 , i) = ĎĎ (e2 , i)  and  Ď, i |=ccsl e1  Â Ď, i |=ccsl e1 â§ e2  and  Ď, i |=ccsl e2 .  i either   ĎĎ (e1 , i) > ĎĎ (e2 , i) and Ď, i |=ccsl e2 ,    or  ĎĎ (e1 , i) < ĎĎ (e2 , i)  and    or  ĎĎ (c1 , i) = ĎĎ (c2 , i)  and we have  Ď, i |=ccsl e1 ,  Ď, i |=ccsl e1  or  Ď, i |=ccsl e2 .  A CCSL spe i ation is a list of denitions and relations seen as a  straints. We  an represent it by a triple  Â C â VAR  Â Def  Â Rel  A model  Â  is a set of  hC, Def , Reli  onjun tion of  on-  su h that  lo ks,  is a set of denitions,  is a set of relations.  Ď  over  2C  satises the spe i ation i  for every denition  c , e  in  Def  we have  c â Ď(i)  i  Ď, i |=ccsl e,  INRIA  Logi al time and temporal logi s: Comparing UML MARTE/CCSL and PSL  Â  every relation in  Rel  is satised by  7  Ď.  From the basis CCSL language, one  an dene other expressions and relations.  For  instan e, the following expressions will be useful in the following:  Â c1 â c2  is the dieren e of  en oded with the denition  Â c $c n  is a parti ular  lo ks  c1  and  c1 , c + c2  c2 .  The denition  and the relation  c , c1 â c2  an be  c # c2 .  ase of delay expression that we denote  c $ n.  This expression  represents the usual syn hronous delay operation. The resulting expression starts at  the  Â  nth  o  urren e of  Alternan e relation  inria-00540738, version 1 - 7 Dec 2010  câ˛1 , c1 $ 1.  c  and then  c1 âź= c2  Similarly,  oin ides with  c.  is dened by the relations  c1 =âź c2  is dened by  c1 4 c2  c1 4 c2  and  and  c2 âş câ˛1  where  c2 âş câ˛1 .  2.2 Property Spe i ation Language  The IEEE standard PSL [10â is a textual language to build temporal logi  assertions are used for instan e in hadware design and they  he king or equivalen e  logi  he king te hniques. Compared with the  LTL, PSL provides sugaring  expressions. PSL  an be validated by modellassi al linear temporal  onstru ts to build expressions in an easier and more  on ise way. However PSL is as expressive as LTL. As it would be tedious to  onsider the  dierent sugaring operators of PSL in formal reasoning, we use in this paper the minimal  ore language dened in [3â.  Let  VAR  be a set of propositions (Boolean variables) that aims at representing signals  of the system.  PSL atomi  formulas are  alled  Sequential Extended Regular Expressions  (SERE). SEREs are basi ally regular expressions built over the Boolean algebra:  b ::= x | x | b â§ b | b â¨ b  where  that  x â VAR  is a Boolean variable. We also  1  onsider the standard operators  â  and  â  an be dened from the grammar above . The set of SEREs is dened by:  r ::= b | r Âˇ r | r âŞ r | râ  where  b  is a Boolean formula.  on atenation,  r1 âŞ r2  The operators have their usual meaning: r1 Âˇ r2 is the  râ is the Kleene star operator. From these regular  the union and  expressions, PSL linear properties  2 are dened by:  Ď ::= r | Ď â§ Ď | ÂŹĎ | XĎ | ĎUĎ | r Ö Ď.  1 x â y is equivalent to x â¨ y  2 PSL standard also denes a  RR nÂ° 7459  and x â y to (x â y) â§ (y â x).  bran hing time part that we do not onsider here.  R. Gas on , F. Mallet , J. DeAntoni  8  where  r  is a SERE. The operators  operators. We also use the  X  (next) and  r Ö Ď is a sux  r and that Ď  (always). The formula  U (until) are the lassi al temporal logi  FĎ âĄ â¤UĎ (eventually) and GĎ âĄ ÂŹFÂŹĎ  lassi al abbreviations  exist a nite prex satisfying  onjun tion operator meaning that there must  must be satised at the position  orresponding  to the end of this prex.  The semanti s of PSL is dened in su h a way that properties  an be interpreted over  innite words as well as nite or trun ated words. This is important for some appli ation  domains of PSL su h that simulation or bounded model- he king. Similarly to CCSL, the  VAR  that represents the set  models of PSL are nite or innite sequen es over elements of 2  of variables that holds at ea h position.  VAR  and p â VAR, we note  For every X â 2  X |=b p i p â X  |=b is obvious.  The remaining of the Boolean satisfa tion relation  (possibly empty) prex of the model. So  relation (whi h is not the  Ď  and  X |=b p  i  p 6â X .  SEREs refer to a nite  is supposed to be nite in SERE satisfa tion  ase in PSL satisfa tion relation). The SERE satisfa tion is dened  inria-00540738, version 1 - 7 Dec 2010  by indu tion as following:  Â Ď |=re b  i  |Ď| = 1  Â Ď |=re r1 Âˇ r2  and  Ď(0) |=b b,  i there exist  Â Ď |=re r1 âŞ r2  i  Ď |=re r1  Â Ď |=re râ i either Ď = ÇŤ  â  and Ď2 |=re r .  Ď1 , Ď2  and  su h that  Ď = Ď1 Ď2  Ď1 |=re r1  and  and  Ď2 |=re r2 .  Ď |=re r2 .  or there exist  Ď1 , Ď2  su h that  Ď1 6= ÇŤ, Ď = Ď1 Ď2 , Ď1 |=re r  Finally, the satisfa tion of PSL properties is dened as following.  Â Ď |=psl ÂŹĎ  i  Ď 6|=psl Ď,  Â Ď |=psl Ď1 â§ Ď2  Â Ď |=psl XĎ  i  i  Ď |=psl Ď1  |Ď| > 1  and  and  Ď |=psl Ď2 ,  Ď 1 |=psl Ď,  Â Ď |=psl Ď1 UĎ2 i  j  have Ď |=psl Ď1 ,  there is  Â Ď |=psl r Ö Ď i  and Ď2 |=psl Ď,  there is a nite prex  Â Ď |=psl r  r Ö â¤.  0 â¤ i < |Ď|  i for every nite prex  Ď1  su h that  of  Ď1  Ď  of  Ď  Ď i |=psl Ď2  and  Ď2  and for every  su h that  there is a nite word  The addition of SEREs in PSL does not add expressiveness to the  LTL. Indeed, SEREs  Ď2  0â¤j<i  we  Ď = Ď1 Ď2 , Ď1 |=re r  su h that  Ď1 Ď2 |=re  lassi al temporal logi  an be translated into LTL formulas. However, this would imply an  exponential blowup of the size of the formulas.  INRIA  Logi al time and temporal logi s: Comparing UML MARTE/CCSL and PSL  9  2.3 Comparing PSL and CCSL  Sin e CCSL and PSL share  ommon models, we  be a CCSL spe i ation over a set of variables  VĎ â VAR.  Ď is  of variables  and every model of  The  S  S.  We will say that  also a model of  an  ompare their expressive power. Let  VS â VAR  Ď  S  a PSL formula over a set  is en oded by (or simulated by)  onverse simulation relation is a bit dierent.  that one  and  Ď  i  VS â VĎ  CCSL models have the properties  an add an unbounded amount of empty states between two relevant states and  left the satisfa tion un hanged. This  an easily be proved by indu tion on the stru ture of  a CCSL spe i ation.  Lemma 1.  i â¤ |Ď|  S  Let  the model  be a CCSL spe i ation. For every model  Ďâ˛  Ď  satisfying  S  and every  0â¤  dened by  inria-00540738, version 1 - 7 Dec 2010  Ď â˛ (j) = Ď(j) for every j < i  Ď â˛ (i) = â  Ď â˛ (j) = Ď(j â 1) for every i < j â¤ |Ď| + 1  S.  also satises  This property is a onsequen e of the multi lo k aspe t of CCSL. Even with the semanti s  we have introdu ed, it is not possible to ompletely link the exe ution of a CCSL spe i ation  to a global  lo k. However, the states where no  lo ks hold are irrelevant in CCSL point of  view as they do not make the system evolve. So it is not really a problem to dis ard them.  A tually, this is what is done in the CCSL simulator TimeSquare. We will say that  simulated by  of  S  i  VĎ â VS  and every model of  S with no irrelevant states  is  Ď.  By examining the denitions PSL and CCSL, we  an already make the following obser-  vations. Some CCSL relations or expressions impli itly introdu e unbounded  instan e, one have to store the number of o  urren es of the  dieren e between them) to en ode the pre eden e relation  c1  than  c2 .  Su h a language is neither regular nor  ounters. For  c1 and c2 (or at least the  4 c2 . The orresponding  lo ks  c1  language is made of all the words su h that every nite prex  of  Ď  is also a model  Ď -regular  ontains more o  and  urren es  annot be en oded in  PSL whi h is as expressive as LTL and regular expressions. The same remark holds for the  expressions  c1 â¨ c2  and  c1 â§ c2 .  On the other hand, the dierent CCSL relations and expressions only states safety  straints. As a spe i ation is a  property. CCSL  o  onjun tion of su h  annot express liveness like the rea habily property  urs for the next operator in  Fp.  A similar problem  ase of nite exe utions. There is no way to express that  the model must have a next position whi h  preliminary  an be stated by  Xâ¤  in PSL. To summarize, the  omparison of expressiveness of CCSL and PSL gives the following results.  Lemma 2. (I) There are PSL formulas that annot be en oded in CCSL.  (II) There are CCSL spe i ations that annot be en oded in PSL.  RR nÂ° 7459  on-  onstraints the result is always a safety  R. Gas on , F. Mallet , J. DeAntoni  10  It is now  lear that PSL and CCSL are not  omparable in their whole denition. How-  ever, we will see in the remaining of this paper that we  languages that  diate  an dene large fragments of these  an be en oded in ea h other. To that aim we will rst introdu e a interme-  lass of automata well tted to dene translations between these fragments.  3 Boolean automata  Translating dire tly PSL properties into CCSL is not obvious. For example, let us  onsider  the following PSL formula:  G(p0 â ÂŹ(p1 Up2 )).  One  an try to translate this property by  always  p1  in an interval starting with  modular approa h by  p0  omposing atomi  onsidering its general meaning whi h is there is  and ending with  p2 .  It is more di ult to dene a  translations from PSL operator to CCSL. We use an  automaton based approa h. We introdu e in this se tion a  lass of automata manipulating  inria-00540738, version 1 - 7 Dec 2010  Boolean variables that we will use to establish relations between PSL and CCSL fragments.  3.1 Denition  We  onsider automata that handle propositional variables in  VAR.  The transitions of these  automata are labeled by Boolean formulas interpreted like guard.  automaton  Â Q  is a stru ture  A = hQ, q0 , F, A, V, Î´i  is a set of states and  Â F âQ  and  Â V â VAR  AâQ  q0 â Q  Formally, a  Boolean  su h that:  an initial state,  are respe tively the set of nal and a  epting states,  is a set of propositions,  Â Î´ : Q Ă Bool (V ) Ă Q  formulas over VAR.  is a transition relation where  Bool (V )  is the set of Boolean  We use the denitions of Se t. 2.2 for Boolean formulas. A Boolean automaton is determini for every state in Q there do not exist two outgoing transitions labeled with  Ď â§ Ďâ˛ is satisable.  isti  Ďâ˛  Ď  and  su h that  A  hq, Xi  omposed of a state in Q and a subset of V . We  Ď  note hq, Xi â  â hq , X i i there is a transition q â  â q â˛ su h that X |=b Ď. A run of A is a  V  sequen e Ď : N â (Q Ă 2 ) su h that Ď(0) is of the form hq0 , X0 i (one starts in the initial  Ďi  â Ď(i + 1). A nite run is a epting  state) and for every i â N, there exists Ďi su h that Ď(i) â  A  onguration of  Ď  â˛  â˛  is a pair  i it ends in a nal state. An innite run is a  state (BĂź hi ondition). The language a  2V orresponding to a epting runs.  epting i it visits innitely often an a  epted by  A  Boolean automata an be omposed as following. Consider two automata  A2 = hQ2 , (q0 )2 , V2 , Î´2 i.  hQ, q0 , V, Î´i su h that:  and  epting  in made of the words on the alphabet  The produ t automaton  A = A1 Ă A2  A1 = hQ1 , (q0 )1 , F1 , V1 , Î´1 i  is the stru ture  INRIA  Logi al time and temporal logi s: Comparing UML MARTE/CCSL and PSL  Â Q = Q1 Ă Q2 Ă {0, 1} where the last  for the BĂź hi a  eptan e  omponent of ea h state (in  11  {0, 1}) is only needed  ondition,  Â q0 = h(q0 )1 , (q0 )2 , 0i,  Â F = F1 Ă F2 Ă {0, 1}  and  A = Q1 Ă A2 Ă {1},  Â V = V1 âŞ V2 ,  inria-00540738, version 1 - 7 Dec 2010  Â  For every  hq1 , q2 , ii  hq1â˛ , q2â˛ , iâ˛ i  Ď1  Q  in  Ď2    there exist    if  i=0  then  iâ˛ = 1  i  q1 â A1 ,    if  i=1  then  iâ˛ = 0  i  q2 â A2 .  Note that the last  (A1  and  = Q1  and  â q1â˛  q1 â  and  â q2â˛  q2 â  we have  Ď  s.t.  Ď  hq1 , q2 , ii â  â hq1â˛ , q2â˛ , iâ˛ i  is equivalent to  i  Ď1 â§ Ď2 ,  omponent of ea h state is not needed when every state is a  A2 = Q2 ),  whi h will be the  epting  ase in the following.  3.2 CCSL and Boolean automata  Sin e CCSL express only safety, the a  However, if every run is a  epting we  eptan e  ondition of automata  an en ode a deterministi  annot be en oded.  Boolean automaton into a  CCSL spe i ation.  Lemma 3.  Every deterministi  Boolean automaton su h that every exe ution is a  epting  an be simulated by a CCSL spe i ation.  Proof.  Consider a Boolean automaton  A = hQ, I, V, Î´i.  states are not needed sin e every exe ution is a  We dene the set of  denitions.  lo ks  We dene a global  C = V â Q.  lo k and a  The sets of a  epting and nal  epting. So, we forget them here.  To en ode  lo k  A,  we need the following CCSL  orresponding to the set of states  Q  as  following:  (1) Glob , c  X  cQ ,  and  câC  where  P  câX  c  is the CCSL union of all the  CCSL interse tion of all the lo ks in  Ď  is a transition q â  â q â˛ in A su h that  lo k  Iq  X.  lo ks in  X  qâ˛ â  âq  RR nÂ° 7459  X.  Similarly, we will note  For ease of presentation, we note  X |=b Ď.  X  q  qâQ  For every state  orresponding to the in oming transitions of  (2) Iq ,  X  qâ˛ â (  Y  pâX  p) â (  X  p6âX  qâ  â  q â Q \ {q0 },  q:    p) .  X  Q  câX c the  â˛  q i there  we dene the  R. Gas on , F. Mallet , J. DeAntoni  12  Now we build the set of CCSL relations. First we express that at every position in the  run, exa tly one state of the automaton holds. This  (3) cQ = Glob  q # qâ˛  and  We also impose that the global  lo k always  orrespond to the relations  for every  q, q â˛ â Q (q 6= q â˛ ).  oin ides with a valid transition in order to  avoid unexpe ted behaviours:  X  (4) Glob =  IQ .  qâQ  The transition relation is su h that every state alternates with its in oming transitions. This  means that for every  qâQ  q0 âź= Iq 0  (5)  The relation is symmetri  for  q0  Iq =âź q.  and  sin e the exe ution starts in this state. The alternan e is  inria-00540738, version 1 - 7 Dec 2010  not stri t on the side of the in oming transition sin e it is allowed to return to the same  step (loops).  Ď  i â N,  We have to show that a model  Ď of A  c â Xi .  run  su h that for every  satises the CCSL spe i ation obtained i there is a  for every  First we observe that for any model  q â Ď(i + 1)  has o  for every  i â N.  and  omplete ( f  (2)).  Iq  we have  c â Ď(i)  i  Ď(i) = hqi , Xi i  satisfying the CCSL spe i ation, if  The alternan e relations allows a  ured between the last o  denitions of the dierent  Ď  câV  uren e of  q  and the  lo k  q  urrent position ( f  to o  (5)).  and  Iq â Ď(i) then  ur only if Iq  However, the  A whi h is deterministi  Iq belongs to Ď(i) for every i â N. So,  to Ď(i + 1) is q . By (3), exa tly one  are dened w.r.t. transition relation of  This implies that exa tly one  Iq â Ď(i) the only element of Q that  element of Q must hold at ea h position.  if  an belonb  This  on lude the demonstration.  We pro eed by indu tion on the position of the sequen es. Suppose that we are given  Ď). For every i â N we note Ď(i) = hqi , vi i. We show for  position j < i and variable c â VAR we an build Ď (resp. Ď ) su  (resp.  Â c â Ď(j)  Â  and  i  lo k  qi + 1 â Ď(i + 1)  Iq  has o  relations (see  Now let  Ď  until position  (5)).  Ď  that for every  h that  i  qi + 1  is the state of  Ď(i + 1).  Q that an belong to Ď(0) is q0 . Indeed,  q â Q from o uring be ause of alternan e  A is always q0 .  lo k in  ured whi h prevent the other  Similarly, the initial sate of  be a model of the CCSL spe i ation. We suppose that the property holds  i  and that we have  qi â Ď(i)  and the state of  Ď(i)  â˛  is  qi .  Sin e the transition  Ď  su h that q â  â q â˛ and  omplete and deterministi , there is a unique q â Q  â˛  â˛  onsequen e, Iq â Ď(i) whi h implies that q â Ď(i + 1) as we shown before.  Ď  â q â˛ and setting c â Xi  an do the orresponding move in A by hoosing the transition q â  relation is  Ď(i) |= Ď.  We  iâN  c â Xj ,  At the begining of any model, the only  no  every  As a  INRIA  Logi al time and temporal logi s: Comparing UML MARTE/CCSL and PSL  13  c â Ď(i) âŠ V . By indu tion, one an build a run Ď of A su h that for every i â N, for  c â VAR we have c â Ď(i) i c â Ď(i).  Conversely, let Ď be a run of A. We suppose that the property holds until position i,  Ď(i) = hqi , vi i and qi â Ď(i). The demonstration is symmetri al. There is a unique transition  i  every  Ď  â qi+1 su h that vi |= Ď be ause the transition relation is deterministi and omplete.  qi â  Let set Ď(i) su h that for every c â VAR we c â Ď(i) i Ď(i) = hqi , vi i and vi (c) = â¤. By  onstru tion, we must have Iq i+1 â Ď(i) and so qi+1 â Ď(i + 1). Thus, one an build by  indu tion Ď verifying the property.  The  onverse translation is not possible.  CCSL spe i ations  annot be en oded by  Boolean automata for the same reasons that prevent en oding CCSL spe i ations into PSL  properties. Some relations or operators like pre eden e  annot be en oded by using nite  state systems (see Se t. 2.3).  3.3 PSL and Boolean automata  inria-00540738, version 1 - 7 Dec 2010  It is well known that one  an build a nite automaton or a BĂź hi automaton that a  epts  respe tively the nite and innite models of a given PSL formula. Given a PSL formula  the  onstru tion dened in [3â  the set of models of  Ď.  This  an easily be adapted to build a Boolean automata a  Ď,  epting  onstru tion itself is a slight extension of the automaton for LTL  originally dened by [12â. We do not develop this  onstru tion now sin e the  onstru tion  in the proof of up oming Lemma 6 will follow the same main steps.  Lemma 4.  language a  The  the  From any PSL properties  epted by  A  Ď  one  an build a Boolean automata  is exa tly the set of models of  AĎ  su h that the  Ď.  onverse translation is easy sin e the denition of LTL is in luded in PSL. By using  onstru tion in [11â one  an en ode the behaviour of a Boolean automaton into a LTL  formula.  Lemma 5.  From any Boolean automaton  set of models of  ĎA  A,  one  is exa tly the set of runs of  an build a PSL formula  ĎA  su h that the  A.  4 Translations between CCSL and PSL fragments  We dene in this se tion large fragments of CCSL and PSL that  an be simulated in ea h  other. We dene the translations between these fragments using intermediate Booelan automata en oding.  4.1 From PSL to CCSL  Lemma 3 states that Boolean automata an be en oded in CCSL when every run is a  Thus we restri t ourselves to the  sub lass of Boolean automata. We  lass of PSL formulas that  onsider the safety fragment of PSL dened similarly  to [4â by restri ting the use of negations. A PSL formula belongs to  RR nÂ° 7459  epting.  an be translated into this  safety PSL  formulas  R. Gas on , F. Mallet , J. DeAntoni  14  i (S1) subformulas of the form  Ď1 UĎ2  negations, and (S2) SEREs never o  and  r ÖĎ  never o  ur under an even number of  ur under an odd number of negations. Note that one  an dene safety fragments of PSL by restri ting temporal modalities but this one is more  general. For the nite  ase, we also have to restri t the denition of the next operator to its  weak variant (s.t. the formula is satised also if the model has no next position).  Lemma 6.  For every property in safety PSL, one  exe ution is a  Proof.  an build an automaton su h that every  epting.  In [3â is des ribed a way to build automata from PSL properties. We re all below  the main steps of this  onstru tion and show that the restri tions we have made allow us to  obtain an automaton su h that every run respe ting the transition relation is a  First, one  an easily build a nite automaton a  epting.  epting the set of nite words that  orresponds to a given SERE. Indeed, SERE are essentially regular expressions. So we  r there is a nite automaton Afr = h2VAR , Qr , Ir , Fr , Î´rf i su h  that Ď â L(Ar ) i Ď |=re r. From this automaton one an build a BĂź hi automaton  Ar = h2VAR , Qr , Ir , Qr , Qr , Î´r i su h that Ď â L(Ar ) i Ď |=psl r. The transition relation Î´r  f  is obtained by adding the following rules to Î´r :  inria-00540738, version 1 - 7 Dec 2010  assume that for every SERE  hqf , X, qf i â Î´r  This automaton has only a  relation, every prex that  a  for every  qf â Fr  and  X â 2VAR .  epting and nal states. Indeed, a  ording to PSL satisfa tion  an be extended to an expression satisfying the SERE must be  epted.  Then we pro eed by indu tion on the stru ture of the formula. The result of the  on-  stru tion is an alternating automata. This allows running automata for the SERE atomi  formulas in parallel of the temporal logi  automaton  part. Then, it is known that an alternating BĂź hi  an be translated into a standard BĂź hi automaton [7â.  The base ase is given above. So we suppose that for every subformula Ď of Ď we an build  AĎ = h2VAR , QĎ , IĎ , AĎ , FĎ , Î´r i su h that su h that every run is a epting  an automaton  Ď â L(AĎ ) i Ď |=psl Ď . There are a tually two onstru tions be ause the ase where  Ď is of the form ÂŹ(r Ö Ď) must be treated separately. In that ase, AĎ is built  f  VAR  , Qr , Ir , Fr , Î´rf i and AĎ = h2VAR , QĎ , IĎ , QĎ , QĎ , Î´Ď i  from the nite automaton Ar = h2  and  the formula  as follows.  Â  the set of states is the union of  Â  the set of initial states is  Â  the set of nal states is the union of  Â  the set of a  Qr  and  QĎ  and an additional state  qt ,  Ir ,  qt , Q r  and  epting states is the union of  FÂŹĎ ,  qt , Q r  so  FĎ = QĎ  and  AÂŹĎ ,  be ause  so  FÂŹĎ = QÂŹĎ ,  AĎ = QĎ  be ause  AÂŹĎ = QÂŹĎ ,  INRIA  Logi al time and temporal logi s: Comparing UML MARTE/CCSL and PSL  Â  For every  qf â Fr  and  X â 2VAR  15  we have  ^  Î´(qf , X) =  q â˛ â§ Î´ÂŹĎ (q0 , X)  qâ˛ âÎ´r (q,X)  where  Â  q0  For every    if  is the initial state of  q â Qr \ Fr  Î´r (q, X)  and  AÂŹĎ .  X â 2VAR  is dened then  Î´(q, X) =  ^  qâ˛  qâ˛ âÎ´r (q,X)  ,  inria-00540738, version 1 - 7 Dec 2010    Î´(q, X) = qt ,  otherwise  Â  for every  Â  nally  q â QÂŹĎ  the transition relation  Î´(qt , X) = qt  Note that we only have to  for every  oin ides with  Î´ÂŹĎ ,  X â 2VAR .  onsider negated o  urren es of  rÖĎ  by denition of the safety  fragment.  For the other  ases,  A  is dened as follows. The set of states is  Â  the set of states of the automata  Â  the set of states of the automata  Â  the set of subformulas of  The initial state is  Â Î´(p, X) = â¤  Ď.  i  Ď  Ar  for every SERE  AÂŹ(rÖĎ)  q0r  Î´  is the initial state of  Ar .  Â Î´(Ď1 â¨ Ď2 , X) = Î´(Ď1 , X) â¨ Î´(Ď2 , X).  Â Î´(ÂŹĎ, X) = Î´(Ď, X).  Â Î´(XĎ, X) = Ď.  Â Î´(Ď1 UĎ2 , X) = Î´(Ď2 , X) â¨ (Î´(Ď1 , X) â§ Ď1 UĎ2 ).  Where the overlined expressions are interpreted as follows:  Ď,  rÖĎ  ÂŹÂŹĎ  is dened re ursively:  Â Î´(Ď1 â§ Ď2 , X) = Î´(Ď1 , X) â§ Î´(Ď2 , X).  RR nÂ° 7459  urring in  for every subformula  p â X.  where  o  and their negation (we identify  The transition relation  Â Î´(r, X) = Î´(q0r , X)  r  omposed of  with  o  Ď ).  urring in  Ď,  R. Gas on , F. Mallet , J. DeAntoni  16  Â a â§ b = a â¨ b,  Â a â¨ b = a â§ b,  Â Î´(q0ÂŹr , X) = Î´(q0r , X)  ÂŹ(rÖĎ)  Â Î´(q0rÖĎ , X) = Î´(q0  Â Ď = ÂŹĎ ,  , X)  is the initial state of the automaton  where  ÂŹ(rÖĎ)  q0  is the initial state of  for every subformula (we still identify  Note that be ause we  o  q0r  where  ÂŹÂŹĎ  onsider the safety fragment the  with  ases  AÂŹ(rÖĎ) ,  Ď ).  Î´(q0r , X) and Î´(q0rÖĎ , X) never  ur (see restri tions of negation).  In the general  onstru tion, the a  the states of the automata  AÂŹ(rÖĎ)  epting states would be those of the form  and  Ar .  ÂŹĎ1 UĎ2  the  onstru tion above is parti ular. For every run of the automaton obtained it  the  ase that an innite bran h does not en ounter one of those nal states.  r  in the  ases  are a  epting.  property.  ÂŹ(r Ö Ď)  or  p, the bran  we are done sin e all the states of the  stri t subformulas of  only remaining  Ď.  ases, the dierent bran hes of  In that  ase is when  Ď  ases we  h is nite. Similarly,  Ď and its  Î´(Ď, X) goes  negation satisfy the  to states labeled by  an use the indu tion hypothesis to  is of the form  Ď1 UĎ2  sin e we are in the safety fragment. In the se ond  or  ÂŹĎ1 UĎ2 .  annot be  orresponding automata  Now we suppose that every subformula of  In almost all  or  However, for formulas in the safety fragment  We pro eed by indu tion. If we are in a state of the form  inria-00540738, version 1 - 7 Dec 2010  Ar ,  The rst  on lude. The  ase  annot arise  ase the transition rule is the follows:  Î´(ÂŹĎ1 UĎ2 ) = Î´(Ď1 UĎ2 ) = Î´(ÂŹĎ2 , X) â§ (Î´(ÂŹĎ1 , X) â¨ ÂŹ(Ď1 UĎ2 )).  We  an use the indu tion hypothesis on the bran h  bran h, we  Â  orresponding to  Ď2 .  For the other  an prove by indu tion that  either we rea h a position when  ÂŹĎ2  and  ÂŹĎ1  hold and then we  an use the indu tion  hypothesis,  Â  or  So we  By  a  ÂŹ(Ď1 UĎ2 )  an set  is visited innitely often. Sin e this state is a  epting we are also done.  AĎ = FĎ = QĎ .  onstru tion, every state of the alternating BĂź hi automaton obtained is nal and  epting. If we use the powerset  automaton, the sets of nal and a  onstru tion of [7â to build an equivalent non-alternating  epting states are also equal to the whole set of states.  So every run of the resulting automaton is a  The proof is given in Appendix  to ensure that every exe ution is a  ? ?  epting.  is a variant of the  onstru tion in [3â. We just have  epting. By Lemmas 6 and 3 we  an en ode every safety  PSL formula into CCSL spe i ations.  Lemma 7.  Every safety PSL formula  an be en oded by a CCSL spe i ation.  INRIA  Logi al time and temporal logi s: Comparing UML MARTE/CCSL and PSL  17  p0  p0 â§ p1 â§ p2  p1 â§ p2  q0  q1  p1  p0 â§ p1  Figure 1: Boolean automaton for  For instan e, Figure 1 represents the automaton  ÂŹ(p1 Up2 )) after  hV, Def , Reli su  simpli ations.  h that  inria-00540738, version 1 - 7 Dec 2010  Def =  Rel =  ďŁą  ďŁ´  ďŁ´  ďŁ´  ďŁ´  ďŁ˛  This automaton  V = {p0 , p1 , p2 }  G(p0 â ÂŹ(p1 Up2 ))  orresponding to the formula  and  Q , q0 + q1  Glob , Q + p0 + p1 + p2 ,    (q0 â p0 ) + (q0 â p0 â p1 ) + (q1 â p1 ) ,  ,  Iq0 ,  ďŁ´  ďŁ´  ďŁ´  ďŁ´  ďŁł Iq , ((q â p ) â (p + p )) + (q â (p + p ))  0  1  0  1  2  1  0  1  (  Glob = Q  G(p0 â  orresponds to the CCSL spe i ation  q0 # q1  ,  q0 =âź Iq0  ,  ,  Glob = Iq0 + Iq1 ,  Iq1 âź= q1  ďŁź  ďŁ´  ďŁ´  ďŁ´  ďŁ´  ďŁ˝  ,  ďŁ´  ďŁ´  ďŁ´  ďŁ´  ďŁž  )  .  4.2 From CCSL to PSL  To obtain a fragment of CCSL that  relations and the operators  the advan e of the fastest  n â N.  A model  Ď  c 1 â¨ c2  an be en oded in PSL, we restri t the pre eden e  and  c1 â§ c2 .  We dene a pre eden e relation su h that  âşn and 4n where  ĎĎ (c2 , i) < ĎĎ (c1 , i) â¤  lo k is bounded. We denote these relations  satises  c 1 âş n c2  i for every  iâN  we have  4n is dened similarly with non stri t inequalities. We dene  c1 â§n c2 and c1 â¨n c2 that restri t the dieren e of the lo ks c1 and c2 to  be bounded by n. Su h expressions are parti ular sin e they also imposes impli it onstraints  Ď(c2 , i) + m.  The relation  similar variants  on the parameters. However, this is the most  of CCSL that  We  all  onvenient way of dening a synta ti  fragment  an be translated into CCSL.  bounded CCSL  the language obtained by repla ing in CCSL the pre eden e  relations, greatest lower bound and lowest upper bound operators by their bounded variants.  This language is a fragment of CCSL. Indeed, the operators  Â c1 âş n c2  pre eden e  RR nÂ° 7459  is equivalent to  ase is similar.  c1 âş c2  and  c2 4 câ˛1  an be dened in full CCSL:  where  câ˛1 , c1 $ n.  Non stri t  R. Gas on , F. Mallet , J. DeAntoni  18  Â c , c1 â§n c2  c1 4  make  is equivalent to the  c , c 1 â¨ c2  onjun tion of  with the relations  câ˛2 and c2 4 câ˛1 where câ˛1 , c1 $ n and câ˛2 , c2 $ n. This equivalen e  lear the relations impli itly imposed on the parameters of the expression. The  operator  c1 â¨n c2  an be dened similarly.  These restri tions allow us to establish the following results.  Lemma 8. (I) Every bounded CCSL spe i ation an be en oded by a Boolean automata.  (II) Every bounded CCSL spe i ations an be en oded by a PSL formula.  Proof. (I) We pro eed by indu tion on the stru ture of CCSL spe i ations. As every state  in the resulting automata are nal and a  onsider CCSL relations.  epting, we do not mention them. First, let us  For every Boolean formula  inria-00540738, version 1 - 7 Dec 2010  Boolean automaton with a self loop labeled by  Â  The sub lo king relation  Â  Similarly, the ex lusion relation  Â  The bounded pre eden e relation  n  c 1 â c2  Ď  we denote by  true, to move ba k when  an be en oded by  c1 # c2  c1 on c2 .  c2 is true  an be en oded by an automaton with  c1 â§ c2  0  c1 â§ c2  c1 â§ c2  2  c1 â§ c2  3  c2 â§ c1  c1 â§ c2  Figure 2: Boolean automaton for  onstru tion for the relation  on state  0  Ae  c 1 4 n c2  1 ba  and a transition from state  A denition of the form  c , e  is  c1 â§ c2  c2 â§ c1  The  c1  n = 3.  1  c1 â§ c2  ounter  and to stay in the same state when both (or none)  c1 â§ c2  If  B(c1 â¨c2 ) .  So one needs to move to the next state when  c1 â§ c2  Â  B(c1 â¨c2 ) .  an be en oded by  c 1 âş n c2  are true. Fig. 2 is the automaton for  where  the single state  states. These states simulate the in rementation and de rementation of a  that store the advan e of  Â  BĎ  Ď.  c1 â§ c2  c 1 âş 3 c2  is similar an additional loop labeled  k to state  c 1 â§ c2  0.  an be en oded by the produ t automaton  Ae Ă Bcâe  is dened below.  e is of the form e1 + e2  B((e1 â¨e2 )âe) .  then  Ae  an be obtained by making the produ t of  Ae1 , Ae2  and  Â  The automaton for  e1 â e2  is built similarly by repla ing the third automaton by  B((e1 â§e2 )âe) .  INRIA  Logi al time and temporal logi s: Comparing UML MARTE/CCSL and PSL  Â  e2 is a bit more omplex. Consider two opies A and Aâ˛ of the  â˛  â˛  produ t automaton Ae1 Ă Ae2 . We denote by q0 , q1 . . . the states of A and q0 , q1 . . .  â˛  â˛  the states of A su h that qi and qi represent the same state in the dierent opies.  The en oding of  e1  To build the automaton Ae we use  â˛  yet and A the part where e1 has o  A  So, we have to move from  set  e  (â)  (ââ)  A  to simulate the part where  when  e1  â˛ Ďâ§e2 â§e  transition qi â  ââââ  urred  urren e of  A  e2 .  and  This automaton is obtained by making the following  Ď  â qjâ˛  qiâ˛ â  qj  has not o  is true. Then we move ba k to  Ď  â qj in A we repla e the label by  For every transition qi â  Ďâ§e1 â§e â˛  transition qi â  ââââ qj from A to Aâ˛ .  For every transition  e1  urred and we wait for the next o  Aâ˛  to  e2 is true.  A and Aâ˛ .  to true when  transformations on  inria-00540738, version 1 - 7 Dec 2010  19  from  in  Aâ˛  we repla e the label by  â˛  to  A.  A  Ď â§ e1 â§ e  and add the  Ď â§ e2 â§ e  and add the  Obviously if the Boolean formula of a label redu es to false then the  orresponding  transition is removed (or not added).  Â  The en oding of  e1  we are in the rst  the same  the step  e2  is very  e2 .  The dieren e is that when  are true then  e is also true and we stay in  e1 is true and e2 is false. So  lose to the  opy and both  e1  and  e2  opy. We only move to the se ond  (â)  e1  ase  opy when  has to be repla ed by  Ď  â qj in A we repla e the label by  For every transition qi â  Ďâ§e1 â§e2 â§e â˛  Ďâ§e1 â§e2 â§e  transitions qi ââââââ  â qj and qi âââââââ qj .  Ď â§ e1 â§ e  and add the  two  Â  The en oding of  e1 $e2 n  holds we have to wait for  opies of  Ae1 Ă Ae2 .  is a generalization of the previous  n  positions where  e2  holds. This  Another point of view is that a  ounter is en oded in the states of  the resulting automaton. In the same way than the  we add transitions between the dierent  from the rst    from the  ith    from the  n+1th to the rst when e2 o  where  Â  Now we  e  opy to the se ond when  must o  i + 1th  e2  ase  e1  e2  o  e1  o  urs for  urs,  2 â¤ i â¤ n + 1,  urs and this  orresponds to the transitions  ur.  e1 H bw . Suppose that bw = u Âˇ v Ď . The  similarly with |u| + |v| opies of Ae1 . Ea h opy is  onsider the ltering operation  expression  an also be en oded  asso iated with positions in  RR nÂ° 7459  when  onstru tion for the  opy as following:    to the  e1  n+1  onstru tion. When  an be done with  bw  in a natural way. The transition from a  opy to the  R. Gas on , F. Mallet , J. DeAntoni  20  next one is done when  one (periodi  position in  Â  e1  holds and after the last  part). The variable  bw  is equal to  e  urs i  e1    urs in a  e is of the form e1 e2 an easily  A = Ae1 Ă Ae2 Ă B((e1 â§e2 )âe) as following.  We add a sink state    qs  with a loop  Ď  qâ  â qâ˛  We repla e every transition  Ďâ§e2  â qs .  transition q ââ  This operation prevents future o  The way of en oding  need here  o  2n + 1  e1 â§n e2  in  is  e  c2  e  urren es of  n = 2.  c1 â§ c2 â§ e  The  e  ase  and  e  and  c2 .  To do this we  The right part (positive labels)  c1  is greater than  c2 .  So  1  2  c2 â§ c1 â§ e  c1 â§ c2 â§ e  is quite similar. For  c1 â§ c2 â§ e  c1 â§ c2 â§ e  0  c1 â§ c2 â§ e  n=2  c2 â§ c1 â§ e  c1 â§ c2 â§ e  c1 â§ c2 â§ e  c1 â§2 c2  the automaton is obtained by swit hing  in the transitions that are not loops in Fig. 3.  The global automaton  the automata  c1  c1 â§ c2 â§ e  c2 â§ c1 â§ e  e1 â¨n e2  ured.  c1 â§ c2 â§ e  Figure 3: Boolean automaton for  Â  has o  urren es of  c1 â§ c2 â§ e  â1  c2 â§ c1 â§ e  e2  and we add the  holds when the variable that has the less  c1 â§ c2 â§ e  â2  q âââ q â˛  is true. The left part is symmetri al.  c1 â§ c2 â§ e  c1 â§ c2 â§ e  as soon a  Ďâ§e2  by  lose to the bounded pre eden e relation sin e we  urren es holds. Fig 3 is the automaton for  is true in this part when  be obtained from the produ t  A (q, q â˛ 6= qs )  urren es of  states. The expression  c1 â§ c2 â§ e  orresponding  e  orresponds to positions where the number of o  c  opy whose  qs â  â qs .  need to store the dieren e between the o  inria-00540738, version 1 - 7 Dec 2010  o  (|u| + 1)th  1.  The automaton when  automaton  Â  o  opy we jump to the  orresponding to a given CCSL spe i ation is the produ t of all  orresponding to the dierent denitions and relations.  The set of models  orresponding to su h an automaton is the same than the set of models of the CCSL spe iation. A  areful analysis of the dierent steps shows that this  CCSL semanti s.  (II)  This se ond part is a dire t  formula obtained by  onsequen e of  (I)  onstru tion stri tly follows  and Lemma 5, even if the PSL  omposing the two transformations is not minimal.  We  an dene  a dire t translation from bounded CCSL to PSL. However, the result of the translation  remains  ompli ated.  We still have to en ode the  ounters of relations like pre eden e,  ltering, delay. . . whi h is tedious when using only propositional variables.  INRIA  Logi al time and temporal logi s: Comparing UML MARTE/CCSL and PSL  Here we have arbitrarily  where the  21  hosen to bound the pre eden e operators. There are examples  ontext already bounds the dieren e between the arguments of a pre eden e  relation (see for instan e the denition of alternan e in Se t. 2.1). So, bounded CCSL is  not the largest fragment that  an be en oded in PSL. Determining whether the state spa e  of a CCSL spe i ation is nite is an open question.  determine a synta ti  fragment  Moreover it seems very di ult to  orresponding to su h CCSL spe i ations.  5 Con lusion  In this paper, we have  ompared the expressiveness of CCSL and PSL, two formal languages  used for similare purposes but at dierent levels. We have identied the CCSL  that  annot be expressed in PSL and the  CCSL . We have also dened the  inria-00540738, version 1 - 7 Dec 2010  onstru ts  annot be stated in  ommon fragments between CCSL and PSL so that one  an be translated into the other. A su ient  PSL is to bound the integer  lass of PSL formulas that  ondition to translate CCSL spe i ations into  ounters used to  Pre isely, the relative advan e of the  ount the number of o  urren es of  lo ks put in relation by these CCSL  lo ks.  onstru ts must  be bounded. This translation is an important step towards the formal veri ation of a CCSL  spe i ation and the exploration of its state spa e. In the future, we  of the intermediate translation to automata to establish  an also take benets  omparison with other languages.  Conversely, we have dened the translation of PSL safety properties into CCSL. CCSL  annot express the  However, it  lass of liveness properties. CCSL has not been designed for this purpose.  an be interesting to  apture all the expressive power of PSL in a higher level  des ription language. A solution to ll the gap  ould be to introdu e temporal modalities in  a CCSL -like language while keeping the multi- lo ks aspe ts. CCSL is indeed a language  that is still evolving. We are  urrently dening a minimal kernel from whi h all the relations  and expressions introdu ed in this paper (and possibly others)  development, we should maintain the  an be derived.  In this  orresponden es with the other languages involved in  system design su h as PSL.  Referen es  [1â C. AndrĂŠ. Syntax and semanti s of the  lo k  onstraint spe i ation language. Te hni al  Report 6925, INRIA, 2009.  [2â C. AndrĂŠ, F. Mallet, and J. DeAntoni. VHDL observers for  lo k  onstraint he king. In  Industrial Embedded Systems (SIES), 2010 International Symposium on, pages 98107,  July 2010.  [3â D. Bustan, D. Fisman, and J. Havli ek. Automata  onstru tion for PSL.  Te hni al  report, IBM Haifa Resear h Lab, 2005.  [4â R. LaziÂ˘. Safely freezing LTL. In  RR nÂ° 7459  In FST&TCS'06,  pages 381392. Springer, 2006.  R. Gas on , F. Mallet , J. DeAntoni  22  [5â F. Mallet, C. AndrĂŠ, and J. DeAntoni. Exe uting AADL models with UML/Marte. In  ICECCS'09 - UML&AADL'09,  pages 371376, Potsdam, Germany, June 2009. IEEE  Computer Press.  [6â F. Mallet, M.-A. Peraldi-Frati, and C. AndrĂŠ.  timing requirements. In  ISORC'09,  Marte CCSL to exe ute East-ADL  pages 249253, Japan, Tokyo, Mar h 2009. IEEE  Computer Press.  [7â S. Miyano and T. Hayashi. Alternating nite automata on  puter S ien e, 32(3):321  330, 1984.  [8â OMG.  UML Prole for MARTE, v1.0.  Ď -words. Theoreti al Com-  Obje t Management Group, November 2009.  formal/2009-11-02.  [9â P. Peil, J. Medina, H. Posadas, and E. Villar.  Generating heterogeneous exe utable  spe i ations in SystemC from UML/MARTE models.  inria-00540738, version 1 - 7 Dec 2010  Software Engineering, 6:6571, 2010.  Innovations in Systems and  10.1007/s11334-009-0105-4.  [10â IEEE standard for Property Spe i ation Language (PSL), IEEE std 1850-2005.  [11â A. Sistla and E. Clarke. The  omplexity of propositional linear temporal logi .  J. ACM,  32(3):73374, 1985.  [12â M. Vardi and P. Wolper. An automata-theoreti   ation (preliminary report). In  LICS'86,  approa h to automati  [13â J. Vidal, F. de Lamotte, G. Gogniat, P. Soulard, and J.-P. Diguet. A  for embedded system modeling and  program veri-  pages 332344. IEEE, 1986.  o-design approa h  ode generation with UML and MARTE. In  DATE,  pages 226231, 2009.  INRIA  inria-00540738, version 1 - 7 Dec 2010  UnitĂŠ de recherche INRIA Sophia Antipolis  2004, route des Lucioles - BP 93 - 06902 Sophia Antipolis Cedex (France)  UnitĂŠ de recherche INRIA Futurs : Parc Club Orsay UniversitĂŠ - ZAC des Vignes  4, rue Jacques Monod - 91893 ORSAY Cedex (France)  UnitĂŠ de recherche INRIA Lorraine : LORIA, TechnopĂ´le de Nancy-Brabois - Campus scientifique  615, rue du Jardin Botanique - BP 101 - 54602 Villers-lĂ¨s-Nancy Cedex (France)  UnitĂŠ de recherche INRIA Rennes : IRISA, Campus universitaire de Beaulieu - 35042 Rennes Cedex (France)  UnitĂŠ de recherche INRIA RhĂ´ne-Alpes : 655, avenue de lâEurope - 38334 Montbonnot Saint-Ismier (France)  UnitĂŠ de recherche INRIA Rocquencourt : Domaine de Voluceau - Rocquencourt - BP 105 - 78153 Le Chesnay Cedex (France)  Ăditeur  INRIA - Domaine de Voluceau - Rocquencourt, BP 105 - 78153 Le Chesnay Cedex (France)  http://www.inria.fr  ISSN 0249-6399 