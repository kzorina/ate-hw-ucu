Symbolic Model Checking of Real-Time Systems  G. Logothetis and K. Schneider  University of Karlsruhe  Institute for Computer Design and Fault Tolerance (Prof. Dr.-Ing. D. Schmid)  P.O. Box 6980, 76128 Karlsruhe, Germany  email: {logo,schneide}@informatik.uni-karlsruhe.de  http://goethe.ira.uka.de/fmg  Abstract  We present a new real-time temporal logic for the specification and verification of discrete quantitative temporal properties. This logic is an extension of the well-known logic  CTL. Its semantics is defined on discrete time transition systems which are in turn interpreted in an abstract manner  instead of the usual stuttering interpretation. Hence, our  approach directly supports abstractions of real-time systems by ignoring irrelevant qualitative properties, but without loosing any quantitative information. We analyse the  complexity of the presented model checking algorithm and  furthermore present a fragment of the logic that can be efficiently checked.  point of time. It is therefore natural to label the transitions  of the abstract transition system by numbers that denote the  time required to move from one state to another one. In  general, there are two possible interpretations of these timed  transition systems:  1. Introduction  Interpretation I1 : A transition from state s1 to state s2  with label k â means that at any time t0 , where we  are in state s1 , we can perform an atomic action that  requires k units of time. The action terminates at time  t0 +k, where we are in state s2 . There is no information  about the intermediate points of time t0 < t < t0 + k.  Interpretation I2 : A transition from state s1 to state s2  with label k > 1 is seen as abbreviation for a stutter1  1  1  1  ing sequence s1 â s1,1 â . . . â s1,kâ1 â s2 where  all the states s1,i have the same variable assignment as  state s1 .  Formal verification methods have been developed to reason  about the correctness of a system with respect to a given  specification. In particular, model checking [4, 15] of temporal logics has become one of the most successful verification techniques. Using this technique requires to adequately  model a system by a finite state transition system so that  specifications given in temporal logics [8] can be checked  for that model.  In general, model checking procedures suffer from the  so-called state explosion problem: The size, i.e., the number of states of the system can exponentially grow with the  size of the implementation description. It is therefore often  necessary to use abstraction techniques like those given in  [6, 12, 14] to neglect irrelevant details so that the verification can concentrate on the necessary facts. As sets of states  are thereby collected into abstract states, this means that the  number of transitions to reach a certain state from another  one is changed. As a consequence, however, information  about quantitative time consumption is lost.  Real-time systems must perform certain actions within  limited time bounds or should start actions only after some  Clearly, only interpretation I1 can be used in a setting where  more powerful abstraction techniques than stuttering simulations are used. It is therefore surprising that none of the  previous real-time extensions of CTL is based on interpretation I1 , although this is the more general (expressive) one!  The development of discrete real-time extensions of CTL  has been initiated in [9], where the temporal operators have  been extended by time bounds to limit the number of fixpoint iterations required to evaluate the considered temporal expression. The models used in [9] were still traditional  finite-state transition systems where each transition requires  a single unit of time.  In order to represent real-time systems in a more compact way, [3] introduced timed transition systems, where  transitions are labeled by natural numbers that denote the  time consumption of the action associated with the transition. The meaning of these timed transitions is in our terms  the stuttering interpretation I2 .  In [10] a new real-time temporal logic was introduced,  where both interpretations I1 and I2 were unfortunately  mixed: Different temporal operators of this logic interpret  N  transitions differently, i.e., either according to I1 or I2 . As  the meaning of timed transitions therefore depends on the  context, it is impossible to reason about the meaning of  timed transitions. In particular, it is not possible to define  composition of structures.  Becoming aware of the misleading semantics of [10] (see  page 11 of [16]), another temporal logic that is solely based  on interpretation I2 has been presented in [16]. In principle,  the logic of [16] is defined on unit delay transition systems  that are obtained by expanding (cf. definition 6) a given  timed transition system. However, there are different expansion algorithms that yield in different transition systems  that are not bisimilar to each other. Hence, the verification  results obtained for an expanded structure can not be easily  transferred back to the timed transition system.  To summarize, the mentioned real-time extensions of  CTL have the following drawbacks:  â˘ None of the previous real-time extensions of CTL is  based on interpretation I1 that is necessary to benefit  from abstraction techniques.  â˘ None of the previous real-time extensions of CTL has a  time bounded next state operator to express facts about  actions that correspond with a single transition. As a  consequence, facts as the following one can not be expressed: âIs there a non-stop flight from New York to  Paris with a duration of at most 9 hours?â  â˘ The problem to compute the set of states of a timed  transition system K where a real-time CTL formula  holds, can not be easily translated to an equivalent  CTL model checking problem on a unit delay structure: Expansions of timed transition systems may yield  in different results [13], and furthermore different expansions are not equivalent to each other [13].  Hence, there has been much confusion and misconception  about the definition of a sound and reasonable real-time extension of the famous temporal logic CTL. All mentioned  previous approaches [3, 10, 16] are â from a logical perspective â questionable.  In [13], we have presented a real-time extension JCTL of  CTL that is based on interpreting timed transition systems  with interpretation I1 . This directly supports abstractions  of real-time systems by ignoring their irrelevant qualitative  properties, but without loosing their quantitative ones. For  example, we can model processes that compute some values within a certain limit of time with a single transition,  that does not state anything about the values of the variables  during the computation. Moreover, JCTL has a next-state  operator equipped with time bounds, so that one can reason  about real-time constraints of atomic actions.  In this paper, we reconsider the logic JCTL and its model  checking algorithm, and analyse its complexity. It turns  out that the complexity to compute the set of states where  a given JCTL formula holds is the same as for previous  approaches like [10]. However, we additionally present a  non-trivial fragment JCTLâ¤ of JCTL that can be more efficiently checked. In particular, less fixpoints need to be  evaluated in this fragment, and the model checking algorithm can ignore the time bounds of the transitions for many  of its computations.  This paper is organized as follows: In the next section,  we define our version of timed transitions systems and our  real-time temporal logic JCTL. We will then proceed with  the definition of a symbolic model checking procedure for  JCTL. After this, we analyze its complexity, and present  the fragment JCTLâ¤ of JCTL that can be checked more  efficiently.  Though not closely related to this paper, we want to finally mention that beneath the real-time extensions of CTL  that are defined on discrete time models, there are also very  successful approaches that are based on a continuous model  of time [1, 11, 7, 2]. These approaches usually rely on timed  automata, i.e., on finite state automata that are endowed by  a finite set of real-valued clocks. Most verification procedures based on timed automata require the construction of  a so-called region graph to reduce the infinite state space of  timed automata to a finite state problem. However, the construction of the region graph is very expensive in practice.  Approaches for discrete time models do not suffer from the  need of such a construction as they directly use finite state  transition systems to model the systems.  2. Syntax and Semantics of the Logic JCTL  2.1. Timed Kripke Structures  We consider systems modeled as timed Kripke structures 1  over some set of variables V. These timed Kripke structures  are formally defined as follows:  Definition 1 (Timed Kripke Structures (TKS)) A timed  Kripke structure over the variables V is a tuple  (I, S, R, L), such that S is a finite set of states, I â S  is the set of initial states, and R â S Ă Ă S is the set of  transitions. For any state s â S, the set L(s) â V is the set  of variables that hold on s. We furthermore demand that for  any (s, t, s0 ) â R, we have t > 0 and that for any s â S,  there must be a t â and a s0 â S such that (s, t, s0 ) â R  holds.  N  N  Timed Kripke structures may be pictorially drawn as given  in Figure 1, where initial states are drawn with double lines.  1 Timed  transition systems have been introduced by many authors with  different names like timed transitions graphs [3], quantitative temporal  structures [10], or timed temporal structures in [16]. Following the CTL  notations, we prefer the name timed Kripke structures.  4  {}  s1  3  {} s2  1  {p} s3  1  a fixed path Ď, since we may have more than one transition  between two states that are labeled with different numbers.  The set of paths starting in a state s is furthermore denoted  as PathsK (s).  Definition 3 (Semantics of JCTL) Given a TKS K = (I,  S, R, L), and s â S, then the semantics of the logic is  recursively defined as follows:  Figure 1. A Timed Kripke Structure  Some approaches, e.g. [3] label transitions with intervals  [a, b] of time. It is easily seen that our TKSs subsume these  models since we can add for any t â [a, b] a new transition  between the considered two states.  It is crucial to understand what is modeled by a TKS.  We use interpretation I1 : A transition from state s to state  s0 with label k â means that at any time t0 , where we are  in state s, we can perform an atomic action that requires k  units of time. The action terminates at time t0 +k, where we  are in state s0 . In particular, there is no information about  the intermediate points of time t with t0 < t < t0 + k.  N  2.2. JCTL as a Real-Time Extension of CTL  To write down specifications in a formal way, we use JCTL,  a real-time extension of the temporal logic CTL. For its definition below, we only use a small subset of logical operators that will be extended below by some abbreviations.  Definition 2 (Syntax of JCTL) Given a set of variables V,  the set of JCTL formulas is the least set satisfying the following rules, where Ď and Ď denote arbitrary JCTL formulas, and a, b â are arbitrary natural numbers:  N  â˘  â˘  â˘  â˘  â˘  â˘  â˘  â˘  V â JCTL, i.e, any variable is a JCTL formula  ÂŹĎ, Ď â§ Ď â JCTL  EX[a,b] Ď â JCTL  EXâĽa Ď â JCTL  E[Ď U[a,b] Ď] â JCTL  E[Ď UâĽa Ď] â JCTL  EG[a,b] Ď â JCTL  EGâĽa Ď â JCTL  The semantics of JCTL is defined with respect to a TKS. For  the definition of the semantics, we need the notion of paths.  A path Ď through a timed Kripke structure is a function Ď :  â S such that âi â .ât â . (Ď (i) , t, Ď (i+1) ) â R  holds (we write the function application with a superscript).  Hence, Ď (i) is the (i + 1)th state on path Ď. For a given path  Ď, we define an associated time consumption function ĎĎ ,  so that Ď and ĎĎ satisfy the condition âi â .ât â . (Ď (i) ,  (i)  ĎĎ , Ď (i+1) ) â R. Note that ĎĎ is not uniquely defined for  N  N  N  N  N  â˘  â˘  â˘  â˘  K, s |= p iff p â L(s) for any p â V  K, s |= ÂŹĎ iff (K, s) 6|= Ď  K, s |= Ď â§ Ď iff K, s |= Ď and K, s |= Ď  K, s |= EX[a,b] Ď iff there is a path Ď â PathsK (s) with  associated duration function ĎĎ with         a â¤ ĎĎ(0) â¤ b â§ K, Ď (1) |= Ď  â˘ K, s |= EXâĽa Ď iff there is a path Ď â PathsK (s) with  associated duration function ĎĎ with         a â¤ ĎĎ(0) â§ K, Ď (1) |= Ď  â˘ K, s |= E[Ď U[a,b] Ď] iff there is a path Ď â PathsK (s)  with associated duration function ĎĎ and an i â  with  ďŁś  ďŁŤ  iâ1      X  ďŁ­a â¤  ĎĎ(j) â¤ bďŁ¸ â§ K, Ď (i) |= Ď  N  j=0    â§ âj < i. K, Ď (j) |= Ď    â˘ K, s |= E[Ď UâĽa Ď] iff there is a path Ď â PathsK (s)  with associated duration function ĎĎ and an i â  with  ďŁś  ďŁŤ  iâ1      X  ďŁ­a â¤  ĎĎ(j) ďŁ¸ â§ K, Ď (i) |= Ď  N  j=0    â§ âj < i. K, Ď (j) |= Ď    â˘ K, s |= EG[a,b] Ď iff there is a path Ď â PathsK (s)  with associated duration function ĎĎ , such that for all  i â , we have  ďŁś  ďŁŤ  iâ1      X  ďŁ­a â¤  ĎĎ(j) â¤ bďŁ¸ â K, Ď (i) |= Ď  N  j=0  â˘ K, s |= EGâĽa Ď iff there is a path Ď â PathsK (s) with  associated duration function ĎĎ , such that for all i â  , we have  ďŁś  ďŁŤ  iâ1      X  ďŁ­a â¤  ĎĎ(j) ďŁ¸ â K, Ď (i) |= Ď  N  j=0  â E[Ď U>k Ď] := E[Ď UâĽk+1 Ď]  â E[Ď U=k Ď] := E[Ď U[k,k] Ď]  Given a TKS K and a JCTL formula Ď, we denote the set of  states of K where Ď holds as JĎKK .  Intuitively, K, s |= EX[a,b] Ď means that the state s has a  direct successor state s0 that satisfies Ď and can be reached  in time t â [a, b]. K, s |= EXâĽa Ď means that the state s has  a direct successor state s0 that satisfies Ď and can be reached  in time t âĽ a.  K, s |= E[Ď U[a,b] Ď] means that there is a path Ď starting  in Ď (0) = s and a number i â so that for the first i states  Ď (0) , Ď (1) , . . . , Ď (iâ1) the property Ď holds, and Ď holds on  Piâ1 (j)  Ď (i) , and the time t := j=0 ĎĎ required to reach state  Ď (i) satisfies the numerical relations a â¤ t and t â¤ b.  K, s |= E[Ď UâĽa Ď] means that there is a path Ď starting  in Ď (0) = s and a number i â so that for the first i states  Ď (0) , Ď (1) , . . . , Ď (iâ1) the property Ď holds, and Ď holds on  Piâ1 (j)  Ď (i) , and the time t := j=0 ĎĎ required to reach state  Ď (i) satisfies the numerical relation a â¤ t.  K, s |= EG[a,b] Ď means that there is a path Ď starting in  Ď (0) = s, such that for any state Ď (i) that is reached within  Piâ1 (j)  a time t := j=0 ĎĎ with t â [a, b], we have Ď (i) . Hence,  Ď holds in the interval [a, b].  Finally, K, s |= EGâĽa Ď means that there is a path Ď starting in Ď (0) = s, such that for any state Ď (i) that is reached  Piâ1 (j)  (i)  within a time t :=  j=0 ĎĎ with t âĽ a, we have Ď .  Hence, Ď holds for all states on Ď that are reached at time a  or after time a.  In the above definition, we have only used basic operators of the logic. Of course, we must introduce some further  operators to express some properties directly. For this reason, we give the following abbreviations:  N  â˘ EG Operators:  â  â  â  â  â  â˘ Let Îş be any time constraint, i.e., [a, b], âź k with âźâ  {<, â¤, =, â¤, >}, or the empty constraint. Then, we  define the following operators:  â  â  â  â  â  â  â  â  â  â  â  N  Definition 4 (Further Temporal Operators) We define  further temporal operators in JCTL as follows, where p is  an arbitrary variable:  â˘ Boolean Operators:  â  â  â  â  1 := p â¨ ÂŹp  0 := p â§ ÂŹp  Ď â¨ Ď := ÂŹ(ÂŹĎ â§ ÂŹĎ)  Ď â Ď := ÂŹĎ â¨ Ď  â˘ EX Operators:  â  â  â  â  â  EXĎ := EXâĽ0 Ď  EXâ¤k Ď := EX[0,k] Ď  EX<k Ď := EX[0,kâ1] Ď  EX>k Ď := EXâĽk+1 Ď  EX=k Ď := EX[k,k] Ď  â˘ E[Âˇ U Âˇ] Operators:  â E[Ď U Ď] := E[Ď UâĽ0 Ď]  â E[Ď Uâ¤k Ď] := E[Ď U[0,k] Ď]  â E[Ď U<k Ď] := E[Ď U[0,kâ1] Ď]  EGĎ := EGâĽ0 Ď  EGâ¤k Ď := EG[0,k] Ď  EG<k Ď := EG[0,kâ1] Ď  EG>k Ď := EGâĽk+1 Ď  EG=k Ď := EG[k,k] Ď  AXÎş Ď := ÂŹEXÎş ÂŹĎ  A[ĎUÎş Ď] := ÂŹE[(ÂŹĎ) UÎş ÂŹ(Ď â¨ Ď)]â§ÂŹEGÎş ÂŹĎ  EFÎş Ď := E[1 UÎş Ď]  AFÎş Ď := A[1 UÎş Ď]  AGÎş Ď := ÂŹEFÎş (ÂŹĎ)  E[Ď BÎş Ď] := E[(ÂŹĎ) UÎş (Ď â§ ÂŹĎ)]  A[Ď BÎş Ď] := A[(ÂŹĎ) UÎş (Ď â§ ÂŹĎ)]  E[Ď UÎş Ď] := ÂŹA[(ÂŹĎ) BÎş Ď]  A[Ď UÎş Ď] := ÂŹE[(ÂŹĎ) BÎş Ď]  E[Ď BÎş Ď] := ÂŹA[(ÂŹĎ) UÎş Ď]  A[Ď BÎş Ď] := ÂŹE[(ÂŹĎ) UÎş Ď]  The definitions of the further EX, E[Âˇ U Âˇ], and EX operators  should be clear. EFÎş Ď holds in state s iff a state can be  reached where Ď holds and that state can be reached within  a time that satisfies the the time constraint Îş.  E[ĎBÎş Ď] means that there must be a path Ď and a number  such that Ď holds on Ď (i) , and all states Ď (j) with  i â  j â¤ i do not satisfy Ď, and the time required to reach Ď (i)  satisfies the time constraint Îş (hence, Ď holds before Ď).  We also have weak variants E[Âˇ U Âˇ] and E[Âˇ B Âˇ] of E[Âˇ U Âˇ]  and E[Âˇ B Âˇ], respectively, that do not demand that the events  that are awaited for must actually occur. E[Ď UÎş Ď] implies  E[Ď UÎş Ď], but E[Ď UÎş Ď] may also hold, if there is a path  Ď where Ď can not be reached in time. In this case, Ď must  hold on those states on the path that can be reached within  a time that satisfies the constraint Îş. E[Âˇ B Âˇ] is defined in a  similar way. Finally, the versions with the A path quantifier  are defined such that the corresponding path property must  hold for all paths leaving the state.  As can be seen, the EG[a,b] operator states that some  property holds for all states that can be reached within [a, b],  while EF[a,b] Âˇ states a property for some point of time in that  interval. Nevertheless, the following lemma holds, which  shows that the EGâ¤k operator is a somehow hybrid operator that makes both a universal and an existential statement  (compare G2 and G3 in the following lemma). This is due  to the fact, that the equation EGâ¤k Ď = E[Ď U>k 1] is valid:  N  Lemma 1 (Semantics of EGâ¤k Ď) Given a JCTL formula  Ď and a number k â . Then, the following properties are  equivalent for any TKS K = (I, S, R, L):  N  (G1 ) K, s |= EGâ¤k Ď  (G2 ) there is a path Ď â PathsK (s) starting in state s, such  that  ďŁś i â , we have  ďŁŤ for all numbers  iâ1      X  ďŁ­  ĎĎ(j) â¤ k ďŁ¸ â K, Ď (i) |= Ď  N  j=0  (G3 ) there is a path Ď â PathsK (s) starting in state s and  aďŁŤnumber i â such that ďŁś  iâ1  i      X  X  (j)  ďŁ­  ĎĎ â¤ k <  ĎĎ(j) ďŁ¸ â§ âj â¤ i. K, Ď (j) |= Ď  N  j=0  j=0  (G4 ) there is a path Ď â PathsK (s) starting in state s and  aďŁŤnumber i â ďŁśsuch that  iâ1      X  ďŁ­  ĎĎ(j) > k ďŁ¸ â§ âj < i. K, Ď (j) |= Ď  N  function expand(I, S, R)  Se := {(s, 1) | s â S};  Re := {};  for (s, t, s0 ) â R do  for i := 2 to t do  Se := Se âŞ {(s, i)};  Re := Re âŞ {((s, i â 1), (s, i))};  end for;  Re := Re âŞ {((s, t), (s0 , 1))};  end for;  Ie := {(s, 1) | s â I};  return (Ie , Se , Re );  end function  Figure 2. Expansion of TKS to UDS  j=0  (G5 ) K, s |= E[Ď U>k 1]  The proof of the above lemma is not very difficult. We just  make use of the well-ordering of natural numbers, i.e., if  there is a number with some property, then there is also a  least number with the same property.  2.3. Expansion of TKSs  Normal Kripke structures are special cases of TKS that are  obtained by restricting TKSs so that (s, t, s0 ) â R implies  t = 1. To avoid confusion, we call the ânormal Kripke  structuresâ unit delay structures in the following:  Definition 5 (Unit Delay Structure (UDS)) A TKS K =  (I, S, R, L) is called to be unit delay structure iff TK :=  {t | (s, t, s0 ) â R} = {1}.  The previously mentioned approaches to define real-time  logics that rely on interpretation I2 are forced to expand  TKSs in order to define the semantics of their logics. For  example, the following expansion algorithm could be used  for that purpose:  Definition 6 (Expansion of TKS) Given a TKS K = (I, S,  R, L), we compute (Ie , Se , Re ) = expand(I, S, R) with  the function expand as defined in Figure 2. Moreover, we  define for any (s, u) â Se the label function Le ((s, u)) :=  L(s). The expansion of K is then the unit delay structure  Ke := (Ie , Se , Re , Le ).  As can be seen, the expansion relies on interpretation I2 ,  since we defined Le ((s, u)) := L(s), i.e., the states of Ke  have the same variable assignments as the corresponding  states of K. For conciseness, we use the following definition:  Definition 7 (Tracks of a State) Given a TKS K = (I, S,  R, L), its expanded structure Ke := (Ie , Se , Re , Le ), and  a state s â S. Then, we define TrackK (s) = {(s0 , u) â Se |  s = s0 }.  We emphasize that expansions of TKS can be performed in  many different ways that are not equivalent to each other  [13]. Furthermore, real-time model checking problems can  not be simply reduced to ordinary CTL model checking  problems, although this is widely believed [13]. For this  reason, we must extend the usual CTL model checking procedure to capture JCTL. This is shown in the next section.  3. Real Time Model Checking on TKSs  In this section, we present a model checking algorithm for  our real-time logic JCTL. We have implemented this algorithm in our verification tool JERRY by using the CUDD  BDD library [17]. The underlying algorithms for the basic  operators are given in Figure 4.  The essential idea to reason about the real-time constraints is to move fronts of tracks on a virtual expanded  structure. However, we emphasize that we do never expand  the structure. Furthermore, we do not run into semantic  problems since the result of any evaluation of a logical operator is a set of states instead of a set of tracks. Hence, all  calculations are independent of the virtual expansion. This  is achieved by abstraction of the set of tracks, so that the semantics of the evaluated temporal operator is respected. In  general, there are two possibilities: On the one hand, a state  s belongs to the result if its main track (s, 1) belongs to the  track set, on the other hand it may be sufficient if anyone  of its tracks (s, t) belongs to the track set. The choice between the two possibilities depends on the semantics of the  considered temporal operator (see Figure 4).  The key function for the evaluation of all real-time constraints is the function MoveFront. Given a set of tracks  t0  Ď  Ď  s1  s0  t1  Ď  tnâ2  snâ2  Ď  tnâ1  snâ1  Ď  sn  Figure 3. Correctness of MoveFront  TĎ and a set of states SĎ , this function computes the set of  tracks that have a path of a certain length through the tracks  SĎ Ă . The precise specification is as follows:  N  Lemma 2 (Correctness of MoveFront) Given a TKS K =  (I, S, R, L), a set of states SĎ , and a set of tracks TĎ , the  function MoveFront as given in Figure 4 satisfies the following equations for âźâ {=, âĽ} (cf. Figure 3):  â MoveFront(âź, k, SĎ , TĎ )  (s0 , t) ďŁŤ  âs1 , . . . , snâ1 â SĎ .â(sn , d) â TĎ .  ďŁŹ ât0 , . . . , tnâ1 â .  ďŁŹ  Vnâ1  ďŁŹ  )âRâ§  âďŁŹ  i=0(si , ti , si+1  Pnâ1   ďŁŹ  kâź  ďŁ­  i=0 ti + d â t â§  t â¤ t0  N  ďŁś  ďŁˇ  ďŁˇ  ďŁˇ  ďŁˇ  ďŁˇ  ďŁ¸  Hence, MoveFront(âź, k, SĎ , TĎ ) computes the set of tracks  that have a path through any expanded structure of length `  with ` âź k to a track in TĎ which runs only through tracks  of SĎ Ă .  N  Proof: The correctness easily follows by induction on k,  when we observe that our algorithm and the right hand sides  of the above equivalence both satisfy the following recursion equations (note that primitive recursive definitions are  uniquely determined):  â˘ MoveFront(âź, 0, SĎ , TĎ ) = TĎ  â˘ MoveFront(=, k + 1, SĎ , TĎ )  = (SĎ Ă ) âŠ preTracks(MoveFront(=, k, SĎ , TĎ ))  â˘ MoveFront(âĽ,  k + 1, SĎ , TĎ )      let T0 := MoveFront(âĽ, k, SĎ , TĎ )  =  in T0 âŞ ((SĎ Ă ) âŠ preTracks(T0 ))  N  N  Using these equations, we can easily prove that T0 =  MoveFront(âź, i, SĎ , TĎ ) is an invariant of the loop in the  algorithm given in Figure 4 for MoveFront. This directly  implies the correctness of the above lemma.  Please note that in the algorithm given in Figure 4 to implement the function MoveFront, we use (i 6= k) â§ (T0 6=  T1 ) as loop condition instead of (i 6= k) (which would  also be correct). The reason for this is that whenever  T0 = T1 holds for an iteration i < k, then it follows  that all fronts MoveFront(âź, i, SĎ , TĎ ), . . . , MoveFront(âź  , k, SĎ , TĎ ) would be identical, so that we already have the  result in this case.  Now consider the function StatesEU[a,b] . We first compute the set of tracks T0 that can reach a track of SĎ Ă {1}  in exactly a steps (where only tracks of the states SĎ are traversed). After this, we move the tracks T0 by further b â a  unit delay steps through the tracks of the states SĎ . By the  above lemma, we then obtain  (s00 , t0 ) â T1 â  ďŁŤ  âs01 , . . . , s0m â SĎ .ât00 , . . . , t0mâ1 â .  ďŁŹ âs0 , . . . , snâ1 â SĎ .ât0 , . . . , tnâ1 â .  ďŁŹ  ďŁŹ âsn â SĎ .ât â .  ďŁŹ Vmâ1 0 0 0  ďŁŹ  i=0 (si , ti , si+1 ) â Râ§  ďŁŹ  ďŁŹ (s0m = s0 ) â Râ§  ďŁŹ Vnâ1  ďŁŹ  ) â Râ§  ďŁŹ  i=0(si , ti , si+1  Pnâ1   ďŁŹ  ďŁŹ a=  ti + 1 â tâ§  ďŁŹ    P i=0  P  ďŁŹ  mâ1 0  nâ1  0  ďŁ­ bâĽ  i=0 ti +  i=0 ti + 1 â t â§  0  0  t â¤ t 0 â§ t â¤ t0  N  N  N  ďŁś  ďŁˇ  ďŁˇ  ďŁˇ  ďŁˇ  ďŁˇ  ďŁˇ  ďŁˇ  ďŁˇ  ďŁˇ  ďŁˇ  ďŁˇ  ďŁˇ  ďŁˇ  ďŁˇ  ďŁ¸   P    P  mâ1 0  nâ1  t  t  +  + 1 â t0 is the numNote that  i  i=0 i  i=0  ber of unit delay steps that are required to reach track  (sn , 1) â SĎ Ă {1} from track (s00 , t0 ). By the above result, it follows that this time is in the interval [a, b] (consider  the case m = 0, where the second MoveFront went along  a single transition, and the case where m > 0 holds). The  final step is to translate this result (given for tracks) to sets  of states. If (s00 , 1)r â T1 holds,zthen we clearly see that  state s0 belongs to E[Ď U[a,b] Ď]  (s00 , t0 )  0  K  . If, on the other hand,  â T1 holds for some t > 1, but (s00 , 1) is not included in T1 , then it follows by the above formula that the  0  time r  to reach (sn , 1)  z from (s0 , 1) is larger than b, so that  s00 6â E[Ď U[a,b] Ď] .  K  The correctness of EG[a,b] Ď is seen as follows: T0 is the  set of tracks that have a path of length b â a through SĎ Ă  in the expanded structure. T1 is the set of tracks of SĎ Ă  that can reach T0 while only traversing tracks of SĎ Ă .  Hence, T1 is the set of tracks that have a path of length  âĽ b â a through SĎ Ă in the expanded structure. Finally,  T2 is the set of tracks of S Ă that can reach T1 in exactly  a steps. Clearly, we only should consider those tracks with  time stamp 1 of T2 .  The correctness of the other two functions to evaluate  E[Ď UâĽa Ď] and EGâĽa Ď are proved in a similar way. Therefore, we obtain the following correctness result:  N  N  N  N  N  Theorem 1 (Correctness of Function States) For  any  TKS K = (I, S, R, L) and any JCTL formula Ď, the  function States given in Figure 4 satisfies the equation  States(Ď) = JĎKK .  functionpreStates(S0 )    âs0 â S0 .ât â .  ;  S1 := s â S  (s, t, s0 ) â R  return S1 ;  end function  N  function preTracks(T )  T1 := {(s, t) | (s, t + 1) â T };  T2 := {(s, t) | â(s0 , 1) â T . (s, t, s0 ) â R};  return T1 âŞ T2 ;  end function  function MoveFront(âź, k, SĎ , TĎ )  TĎ := SĎ Ă ;  T0 := TĎ ;  T1 := {};  i := 0;  while (i 6= k) â§ (T0 6= T1 ) do  T1 := T0 ;  T0 := TĎ âŠ preTracks(T1 );  if equal(âź, âĽ) then T0 := T1 âŞ T0 endif;  i := i + 1;  end;  return T0 ;  end function  N  function StatesEU[a,b] (SĎ , SĎ )  T0 := MoveFront(=, a, SĎ , SĎ Ă {1});  T1 := MoveFront(âĽ, b â a, SĎ , T0 );  return {s â S | (s, 1) â T1 };  end function  function StatesEUâĽa (SĎ , SĎ )  T0 := MoveFront(=, a, SĎ , SĎ Ă {1});  S0 := {s â S | ât â . (s, t) â T0 };  repeat  S1 := S0 ;  S0 := S0 âŞ (SĎ âŠ preStates(S1 )) ;  until (S0 = S1 );  return S0 ;  end function  N  function StatesEG[a,b] (SĎ )  T0 := MoveFront(=, (b â a) + 1, SĎ , S Ă {1});  T1 := MoveFront(âĽ, â1, SĎ, T0 );  T2 := MoveFront(=, a, S, T1 );  return {s â S | (s, 1) â T2 };  end function  function StatesEGâĽa (SĎ )  S0 := SĎ ;  repeat  S1 := S0 ;  S0 := SĎ âŠ preStates(S1 );  until S0 = S1 ;  (â we now have S0 = JEGĎKK â)  T0 := MoveFront(âĽ, a, S, S0 Ă {1});  return {s â S | (s, 1) â T0 };  end function  function States(ÎŚ)  case ÎŚ of  is_var(ÎŚ) : return {s â S | ÎŚ â L(s)};  ÂŹĎ  : SĎ := States(Ď);  return S \ SĎ ;  Ďâ§Ď  : SĎ := States(Ď); SĎ := States(Ď);  return SĎ âŠ SĎ ;  : SĎ :=   States(Ď);  EX[a,b] Ď    âs0 â SĎ .ât â [a, b].  ;  S0 := s â S  (s, t, s0 ) â R  return S0 ;  : SĎ :=   States(Ď);  EXâĽa Ď    âs0 â SĎ .ât âĽ a.  ;  S0 := s â S  (s, t, s0 ) â R  return S0 ;  [a,b]  Ď]: SĎ := States(Ď); SĎ := States(Ď);  E[Ď U  return StatesEU[a,b] (SĎ , SĎ );  âĽa  E[Ď U Ď] : SĎ := States(Ď); SĎ := States(Ď);  return StatesEUâĽa (SĎ , SĎ );  : SĎ := States(Ď);  EG[a,b] Ď  return StatesEG[a,b] (SĎ );  âĽa  : SĎ := States(Ď);  EG Ď  return StatesEGâĽa (SĎ );  end function  Figure 4. Model Checking of JCTL Formulas on a Timed Kripke Structure K = (I, S, R, L)  4. Complexity of JCTL  In this section, we analyze the complexity of the presented  model checking algorithm for JCTL. For this reason, we  first note that there is a model checking procedure for CTL,  e.g. the one given in [5], that runs in time O(|Ď| (|R|+|S|)).  This procedure is able to evaluate any CTL operator in time  O(|Ď| (|R| + |S|)).  It is easily seen that if we expand a TKS to a UDS,  the number of states and transition is multiplied with the  maximum delay time ĎĚK that appears in K. However, the  runtime of the JCTL model checking procedure is not in  O(ĎĚK |Ď| (|R| + |S|)), since the number of iterations does  also depend on the time constraints of the temporal operators that may enforce more than ĎĚK |S| iterations. The crucial part of our complexity analysis is the complexity of the  MoveFront function. To this end, we note that the following  holds:  Lemma 3 (Complexity of MoveFront (I)) Given a TKS  K = (I, S, R, L), a set of states SĎ , and a set of tracks  TĎ . Let moreover be Ke = (Ie , Se , Re , Le ) the expanded  structure of K according to definition 6, and Ď and Ď formulas so that the equations SĎ Ă âŠ Se = JĎKKe and  TĎ = JĎ KKe hold. Then, we have  N  MoveFront(âź, k, SĎ , TĎ ) = JÎŚ(âź, k, Ď, Ď)KKe ,  where the formula ÎŚ(âź, k, Ď, Ď) is recursively defined as  follows:  â˘ ÎŚ(âź, 0, Ď, Ď) = Ď  â˘ ÎŚ(=, k + 1, Ď, Ď) = ďŁŤ  Ď â§ EXÎŚ(=, k, Ď, Ď)  ďŁś  let y = ÎŚ(âĽ, k, Ď, Ď)  ďŁ¸  â˘ ÎŚ(âĽ, k + 1, Ď, Ď) = ďŁ­ in y â¨ Ď â§ EXy  end  Moreover, if common subformulas are shared, it is easily seen that |ÎŚ(âź, k, Ď, Ď)| â O(k) holds. Hence,  MoveFront(=, k, SĎ , TĎ ) can be computed in time  O(k(|Re | + |Se |)), and MoveFront(âĽ, k, SĎ , TĎ ) even in  time O(min{k, |Se |}(|Re | + |Se |)).  The complexity can also be directly derived from the implementation of MoveFront: Note that the value of T0 monotonically grows in function calls of MoveFront(âĽ, k, . . . ),  but not for calls of MoveFront(=, k, . . .). Therefore,  MoveFront(âĽ, k, . . .) runs in time O(min{k, |Se |}(|Re | +  |Se |)), but MoveFront(=, k, . . .) requires time O(k(|Re | +  |Se |)). For this reason, we have the following result:  Theorem 2 (Complexity of JCTL) For any TKS K = (I,  S, R, L) and any JCTL formula Ď, the function States  given in Figure 4 runs in time O(kĚĎ |Ď| ĎĚK (|R| + |S|)),  where ĎĚK := max{t | âs, s0 . (s, t, s0 ) â R} is the maximum delay time of K, and kĚĎ is the maximal number used  in time constraints in Ď.  The proof can be obtained by induction along the JCTL formulas. The induction steps are thereby obtained by the following facts, where Time(f ) denotes the runtime of function f :  â˘ Time(preStates) â O(|R| + |S|)  â˘ Time(preTracks) â O(ĎĚK (|R| + |S|))  â˘ Time(StatesEU[a,b] ) â O(kĎĚK (|R| + |S|)),  where k := max{a, min{b â a, ĎĚK |S|}} â¤ b  â˘ Time(StatesEUâĽa ) â O(aĎĚK (|R| + |S|))  â˘ Time(StatesEG[a,b] ) â O(kĎĚK (|R| + |S|)),  where k := max{b â a, a, 1} â¤ b  â˘ Time(StatesEGâĽa ) â O(kĎĚK (|R| + |S|)),  where k := min{a, ĎĚK |S| , 1} â¤ a  Hence, all operators can be evaluated in time O(kĚĎ ĎĚK (|R|+  |S|)). As a formula Ď may contain |Ď| operators, the above  theorem follows.  Hence, one key to define a more efficient fragment of  JCTL is to avoid calls of the form MoveFront(=, k, . . . ),  since this is not as efficient as MoveFront(âĽ, k, . . .). Using a specialized algorithm similar to the one given in  [5], we can even improve the complexity for computing  MoveFront(âĽ, k, . . . ):  Lemma 4 (Complexity of MoveFront (II)) Given a TKS  K = (I, S, R, L), a set of states SĎ , and a set of tracks  TĎ . Let moreover be Ke = (Ie , Se , Re , Le ) the expanded  structure of K according to definition 6, and Ď and Ď formulas so that the equations SĎ Ă âŠ Se = JĎKKe and  TĎ = JĎ KKe hold. Then, there is an algorithm to compute  MoveFront(âĽ, k, SĎ , TĎ ) in time O(|Re | + |Se |).  N  The specialized algorithm is similar to the one given in [5],  but it needs to additionally take care of the lengths of the  paths that have reached a certain track. For this reason, we  maintain for any track si â Se a list Ti = [si,1 ,. . . , si,mi ]  such that (si,j , si ) is a transition in Re . Any track si will  be marked with a number mi later on that is the minimal  length of a path to reach the set TĎ from si . Furthermore,  we create lists L` during the computations that contain the  tracks that are marked with the number `. The algorithm  performs then the following steps:  Step 1: We eliminate all si,j in each list Ti that does not  belong to TĎ . This can be done in time O(|Re |), since  we look at each transition once.  Step 2: We mark the tracks TĎ with the number 0, and list  them in our first list L0 . Let ` := 0. This step is  performed in time O(|Se |), since we look at each track  at most once.  Step 3: For each track si in L` , and each track si,j of Ti ,  we mark si,j with ` + 1 if it is not already marked,  and put si,j in list L`+1 in this case. We eliminate si,j  from Ti . We then increment `, and repeat this step until  ` = k holds or no transitions are left in the lists Ti .  Clearly, the repeated execution of step 3 does look at each  transition at most once, so that O(|Re |) is an upper bound  for its complexity. Hence, we see that the entire algorithm  runs in time O(|Re | + |Se |).  Note that the above sketched algorithm works with a  depth-first search and therefore performs â in theory â better than breadth-first searches like those used by symbolic  model checking based on BDDs. However, in practice, the  latter approaches are in general superior.  The next step is to define a subset of JCTL that can be  computed without calls MoveFront(=, k, Âˇ, Âˇ). Clearly, we  must therefore forbid the interval constraints, and therefore are restricted to the basic operators EX[a,b] , EXâĽa ,  E[Âˇ U[0,a] Âˇ], and EGâĽa only. Of course, we can still use  all macro operators that can be defined from these basic operators like, for example, E[Ď Uâ¤a Ď] := E[Ď U[0,a] Ď],  EFâ¤a Ď := E[1 Uâ¤a Ď], and EGâ¤a Ď := E[Ď U>a 1]  (cf. lemma 1). The following interesting theorem allows  us however to further extend this set of formulas:  Theorem 3 The following equations are valid, and therefore allow to reduce âĽ constraints to â¤ constraints:  â˘  â˘  â˘  â˘  â˘  â˘  â¤k  E[Ď UâĽk+1 Ď] = EF (Ď â¨ EXE[Ď U Ď])  E[Ď BâĽk+1 Ď] = EFâ¤k (Ď â¨ EXE[Ď B Ď])  EGâĽk+1 Ď = EFâ¤k EXEGĎ  A[Ď UâĽk+1 Ď] = AGâ¤k (Ď â§ AXA[Ď U Ď])  A[Ď BâĽk+1 Ď] = AGâ¤k (ÂŹĎ â§ AXA[Ď B Ď])  AFâĽk+1 Ď = AGâ¤k AXAFĎ  Moreover, constraints âĽ 0 can be simply omitted due to  the equations E[Ď UâĽ0 Ď] = E[Ď U Ď] and E[Ď BâĽ0 Ď] =  E[Ď B Ď], and EGâĽ0 Ď = EGĎ.  The above equations allow us to split the temporal expressions on the left hand side into a quantitative and a qualitative part. The latter is a simple CTL formula, and can  therefore be directly checked on the Kripke structure that  is obtained by omitting the time constraints of the TKS.  As this is a normal CTL model checking problem, it follows that this can be computed in time O(|R| + |S|). The  other fixpoint, i.e., EFâ¤k . . ., has a time constraint, but this  is now of type â¤. Observe now that EFâ¤k Ď is equivalent to  E[1 U[0,k] Ď], and we already know how to compute that in  time O(|Re | + |Se |), i.e., in time O(ĎĚK (|R| + |S|)).  For the proof, note that the last three equation (starting with A quantifiers are dual to the first three ones,  so that it is sufficient to prove the first three ones. The  third one can be reduced to the first one by the equation  EGâĽk+1 Ď = E[Ď UâĽk+1 0]. Also, the second equation can  be reduced to the first via the equation E[Ď BâĽk+1 Ď] =  E[(ÂŹĎ) UâĽk+1 (Ď â§ ÂŹĎ)]. Hence, we only need to prove  the first equation, or equivalently, the fourth: For this  reason, it is convenient to rewrite the right hand side to  AGâ¤k Ď â§ AGâ¤k AXA[Ď U Ď].  A[Ď UâĽk+1 Ď] holds in a particular state s iff for all  such that  paths Ď starting in s, there is a number i â  P  (j)  (i)  Ď  âĽ  k  +  1,  (2)  K,  Ď  |=  Ď,  and  (3)  âj <  (1) iâ1  j=0 Ď  (j)  |= Ď holds. We may choose for any path Ď the  i. K, Ď  least number i. In particular, let j be the least number for a  considered path Ď such that (1) holds. Then, we have j â¤ i,  and therefore Ď must hold on each state Ď (0) ,. . . , Ď (jâ1) ,  which is captured in the first conjunct (AGâ¤k Ď) of the right  hand side. In state Ď (j) , we must furthermore demand that  A[Ď U Ď] holds, and this is captured by the second conjunct.  Hence, we can now define the following subset JCTLâ¤  of JCTL that consist of the formulas that we have found  to be efficiently checkable so far (we only list E quantified  formulas to avoid too much redundancies).  N  Definition 8 (The Fragment JCTLâ¤ of JCTL) Given a  set of variables V, the set of JCTLâ¤ formulas is the least  set satisfying the following rules, where Ď and Ď denote  are arbitrary  arbitrary JCTLâ¤ formulas, and a, b â  natural numbers, and âźâ {<, â¤, âĽ, >}:  N  â˘  â˘  â˘  â˘  â˘  â˘  â˘  â˘  V â JCTLâ¤ , i.e, any variable is a JCTLâ¤ formula  ÂŹĎ, Ď â§ Ď, Ď â¨ Ď â JCTLâ¤  EX[a,b] Ď â JCTLâ¤  EXâźa Ď â JCTLâ¤  E[Ď Uâźa Ď] â JCTLâ¤  EGâźa Ď â JCTLâ¤  E[Ď U<a Ď] â JCTLâ¤ and E[Ď Uâ¤a Ď] â JCTLâ¤  EF<a Ď â JCTLâ¤ and EFâ¤a Ď â JCTLâ¤  Note that JCTLâ¤ still contains CTL, but we believe that it is  strictly less expressive than JCTL, although we have not yet  a proof for this. As each temporal operator of JCTLâ¤ can  be evaluated in time O(|Re | + |Se |), i.e., O(ĎĚK (|R| + |S|)),  we immediately have the following result:  Theorem 4 (Complexity of JCTLâ¤ ) For any TKS K =  (I, S, R, L) and any JCTLâ¤ formula Ď, there is an algorithm to compute JĎKK in time O(|Ď| ĎĚK (|R| + |S|)), where  ĎĚK is defined as in theorem 2.  In comparison to the complexity of JCTL as given in theorem 2, the factor kĚĎ disappeared. This is due to the fact that  the temporal operators that belong to JCTLâ¤ are all monotonic, so that the iterations can stop at least when all tracks  have been visited once.  The more important part is, however, that the equations  of theorem 3 enable us to reduce a considerable part of the  model checking to qualitative fixpoints. This is due to the  fact, that we can separate between a quantitative and a qualitative aspect in these formulas. Note again, that the qualitative fixpoint is computed on the abstract structure with an  ordinary CTL model checking procedure.  5. Conclusions  We have presented a new real-time temporal logic JCTL  that is directly defined on timed Kripke structures using interpretation I1 . This logic overcomes some semantic problems of previous real-time extensions of CTL and allows us  to use abstractions without loosing quantitative information.  We analysed the complexity of the JCTL model checking  problem and presented a non-trivial fragment JCTLâ¤ that  can be checked more efficiently than JCTL. Our first experimental results are promising and allow to check practical  JCTLâ¤ model checking problems in runtimes that are comparable to CTL model checking.  References  [1] R. Alur, C. Courcoubetis, and D. Dill. Model Checking  in Dense Real-time. Technical report, Stanford University,  University of Crete, 1991.  [2] J. Bengtsson, K. Larsen, F. Larsson, P. Pettersson, and W. Yi.  UPPAAL in 1995. In Tools and Algorithms for the Construction and Analysis of Systems, number 1055 in Lecture Notes In Computer Science, pages 431â434. SpringerVerlag, March 1996.  [3] S. Campos and E. Clarke. Real-Time Symbolic Model  Checking for Discrete Time Models. In T. Rus and C. Rattray, editors, Theories and Experiences for Real-Time System Development, AMAST Series in Computing. World Scientific Press, AMAST Series in Computing, May 1994.  [4] E. Clarke and E. Emerson. Design and Synthesis of Synchronization Skeletons using Branching Time Temporal  Logic. In D. Kozen, editor, Workshop on Logics of Programs, volume 131 of Lecture Notes in Computer Science,  pages 52â71, Yorktown Heights, New York, May 1981.  Springer-Verlag.  [5] E. Clarke, E. Emerson, and A. Sistla. Automatic Verification  of Finite-State Concurrent Systems Using Temporal Logic  Specifications. ACM Transactions on Programming Languages and Systems, 8(2):244â263, April 1986.  [6] E. Clarke, O. Grumberg, and D. Long. Model checking and  abstraction. ACM Transactions on Programming Languages  and systems, 16(5):1512â1542, September 1994.  [7] C. Daws, A. Olivero, S. Tripakis, and S. Yovine. The tool  KRONOS. In Hybrid Systems III, volume 1066 of Lecture  Notes in Computer Science. Springer, 1996.  [8] E. Emerson. Temporal and Modal Logic. In J. van Leeuwen,  editor, Handbook of Theoretical Computer Science, volume B, pages 996â1072, Amsterdam, 1990. Elsevier Science Publishers.  [9] E. Emerson, A. Mok, A. Sistla, and J. Srinivasan. Quantitative Temporal Reasoning. Journal of Real-Time Systems,  4:331â352, 1992.  [10] J. FrĂśĂl, J. Gerlach, and T. Kropf. An Efficient Algorithm  for Real-Time Model Checking. In European Design and  Test Conference (EDTC), pages 15â21, Paris, France, March  1996. IEEE Computer Society Press (Los Alamitos, California).  [11] T. Henzinger, X. Nicollin, J. Sifakis, and S. Yovine. Symbolic Model Checking for Real-Time Systems. In IEEE  Symposium on Logic in Computer Science (LICS), pages  394â406, Santa-Cruz, California, June 1992. IEEE Computer Society Press.  [12] G. Logothetis and K. Schneider. Abstraction from counters:  An application on real-time systems. In Design, Automation and Test in Europe (DATEâ2000), Paris, France, March  2000. IEEE Computer Society Press.  [13] G. Logothetis and K. Schneider. A new approach to the specification and verification of real-time systems. In EUROMICRO Conference on Real-Time Systems. IEEE/ACM, 2001.  http://goethe.ira.uka.de/fmg/ps/LoSc01.ps.gz.  [14] C. Loiseaux, S. Graf, J. Sifakis, A. Bouajjani, and S. Bensalem. Property preserving abstractions for the verification  of concurrent systems. Formal Methods in System Design,  6:1â35, February 1995.  [15] J. Queille and J. Sifakis. Specification and verification of  concurrent systems in CESAR. In International Symposium  in Programming, 1981.  [16] J. Ruf and T. Kropf. Using MTBDDs for discrete timed symbolic model checking. Multiple-Valued Logic â An International Journal, 1998. Special Issue on Decision Diagrams.  [17] F. Somenzi.  CUDD: CU decision diagram package,  release 2.3.0, 1998.  ftp://vlsi.colorado.edu/pub/ and  http://vlsi.Colorado.EDU/. 