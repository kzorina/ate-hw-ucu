Symbolic Model Checking of Real-Time Systems  G. Logothetis and K. Schneider  University of Karlsruhe  Institute for Computer Design and Fault Tolerance (Prof. Dr.-Ing. D. Schmid)  P.O. Box 6980, 76128 Karlsruhe, Germany  email: {logo,schneide}@informatik.uni-karlsruhe.de  http://goethe.ira.uka.de/fmg  Abstract  We present a new real-time temporal logic for the specification and verification of discrete quantitative temporal properties. This logic is an extension of the well-known logic  CTL. Its semantics is defined on discrete time transition systems which are in turn interpreted in an abstract manner  instead of the usual stuttering interpretation. Hence, our  approach directly supports abstractions of real-time systems by ignoring irrelevant qualitative properties, but without loosing any quantitative information. We analyse the  complexity of the presented model checking algorithm and  furthermore present a fragment of the logic that can be efficiently checked.  point of time. It is therefore natural to label the transitions  of the abstract transition system by numbers that denote the  time required to move from one state to another one. In  general, there are two possible interpretations of these timed  transition systems:  1. Introduction  Interpretation I1 : A transition from state s1 to state s2  with label k Ã¢ÂˆÂˆ means that at any time t0 , where we  are in state s1 , we can perform an atomic action that  requires k units of time. The action terminates at time  t0 +k, where we are in state s2 . There is no information  about the intermediate points of time t0 < t < t0 + k.  Interpretation I2 : A transition from state s1 to state s2  with label k > 1 is seen as abbreviation for a stutter1  1  1  1  ing sequence s1 Ã¢Â†Â’ s1,1 Ã¢Â†Â’ . . . Ã¢Â†Â’ s1,kÃ¢ÂˆÂ’1 Ã¢Â†Â’ s2 where  all the states s1,i have the same variable assignment as  state s1 .  Formal verification methods have been developed to reason  about the correctness of a system with respect to a given  specification. In particular, model checking [4, 15] of temporal logics has become one of the most successful verification techniques. Using this technique requires to adequately  model a system by a finite state transition system so that  specifications given in temporal logics [8] can be checked  for that model.  In general, model checking procedures suffer from the  so-called state explosion problem: The size, i.e., the number of states of the system can exponentially grow with the  size of the implementation description. It is therefore often  necessary to use abstraction techniques like those given in  [6, 12, 14] to neglect irrelevant details so that the verification can concentrate on the necessary facts. As sets of states  are thereby collected into abstract states, this means that the  number of transitions to reach a certain state from another  one is changed. As a consequence, however, information  about quantitative time consumption is lost.  Real-time systems must perform certain actions within  limited time bounds or should start actions only after some  Clearly, only interpretation I1 can be used in a setting where  more powerful abstraction techniques than stuttering simulations are used. It is therefore surprising that none of the  previous real-time extensions of CTL is based on interpretation I1 , although this is the more general (expressive) one!  The development of discrete real-time extensions of CTL  has been initiated in [9], where the temporal operators have  been extended by time bounds to limit the number of fixpoint iterations required to evaluate the considered temporal expression. The models used in [9] were still traditional  finite-state transition systems where each transition requires  a single unit of time.  In order to represent real-time systems in a more compact way, [3] introduced timed transition systems, where  transitions are labeled by natural numbers that denote the  time consumption of the action associated with the transition. The meaning of these timed transitions is in our terms  the stuttering interpretation I2 .  In [10] a new real-time temporal logic was introduced,  where both interpretations I1 and I2 were unfortunately  mixed: Different temporal operators of this logic interpret  N  transitions differently, i.e., either according to I1 or I2 . As  the meaning of timed transitions therefore depends on the  context, it is impossible to reason about the meaning of  timed transitions. In particular, it is not possible to define  composition of structures.  Becoming aware of the misleading semantics of [10] (see  page 11 of [16]), another temporal logic that is solely based  on interpretation I2 has been presented in [16]. In principle,  the logic of [16] is defined on unit delay transition systems  that are obtained by expanding (cf. definition 6) a given  timed transition system. However, there are different expansion algorithms that yield in different transition systems  that are not bisimilar to each other. Hence, the verification  results obtained for an expanded structure can not be easily  transferred back to the timed transition system.  To summarize, the mentioned real-time extensions of  CTL have the following drawbacks:  Ã¢Â€Ë˜ None of the previous real-time extensions of CTL is  based on interpretation I1 that is necessary to benefit  from abstraction techniques.  Ã¢Â€Ë˜ None of the previous real-time extensions of CTL has a  time bounded next state operator to express facts about  actions that correspond with a single transition. As a  consequence, facts as the following one can not be expressed: Ã¢Â€Â˜Is there a non-stop flight from New York to  Paris with a duration of at most 9 hours?Ã¢Â€Â™  Ã¢Â€Ë˜ The problem to compute the set of states of a timed  transition system K where a real-time CTL formula  holds, can not be easily translated to an equivalent  CTL model checking problem on a unit delay structure: Expansions of timed transition systems may yield  in different results [13], and furthermore different expansions are not equivalent to each other [13].  Hence, there has been much confusion and misconception  about the definition of a sound and reasonable real-time extension of the famous temporal logic CTL. All mentioned  previous approaches [3, 10, 16] are Ã¢Â€Â“ from a logical perspective Ã¢Â€Â“ questionable.  In [13], we have presented a real-time extension JCTL of  CTL that is based on interpreting timed transition systems  with interpretation I1 . This directly supports abstractions  of real-time systems by ignoring their irrelevant qualitative  properties, but without loosing their quantitative ones. For  example, we can model processes that compute some values within a certain limit of time with a single transition,  that does not state anything about the values of the variables  during the computation. Moreover, JCTL has a next-state  operator equipped with time bounds, so that one can reason  about real-time constraints of atomic actions.  In this paper, we reconsider the logic JCTL and its model  checking algorithm, and analyse its complexity. It turns  out that the complexity to compute the set of states where  a given JCTL formula holds is the same as for previous  approaches like [10]. However, we additionally present a  non-trivial fragment JCTLÃ¢Â‰Â¤ of JCTL that can be more efficiently checked. In particular, less fixpoints need to be  evaluated in this fragment, and the model checking algorithm can ignore the time bounds of the transitions for many  of its computations.  This paper is organized as follows: In the next section,  we define our version of timed transitions systems and our  real-time temporal logic JCTL. We will then proceed with  the definition of a symbolic model checking procedure for  JCTL. After this, we analyze its complexity, and present  the fragment JCTLÃ¢Â‰Â¤ of JCTL that can be checked more  efficiently.  Though not closely related to this paper, we want to finally mention that beneath the real-time extensions of CTL  that are defined on discrete time models, there are also very  successful approaches that are based on a continuous model  of time [1, 11, 7, 2]. These approaches usually rely on timed  automata, i.e., on finite state automata that are endowed by  a finite set of real-valued clocks. Most verification procedures based on timed automata require the construction of  a so-called region graph to reduce the infinite state space of  timed automata to a finite state problem. However, the construction of the region graph is very expensive in practice.  Approaches for discrete time models do not suffer from the  need of such a construction as they directly use finite state  transition systems to model the systems.  2. Syntax and Semantics of the Logic JCTL  2.1. Timed Kripke Structures  We consider systems modeled as timed Kripke structures 1  over some set of variables V. These timed Kripke structures  are formally defined as follows:  Definition 1 (Timed Kripke Structures (TKS)) A timed  Kripke structure over the variables V is a tuple  (I, S, R, L), such that S is a finite set of states, I Ã¢ÂŠÂ† S  is the set of initial states, and R Ã¢ÂŠÂ† S Ä‚Â— Ä‚Â— S is the set of  transitions. For any state s Ã¢ÂˆÂˆ S, the set L(s) Ã¢ÂŠÂ† V is the set  of variables that hold on s. We furthermore demand that for  any (s, t, s0 ) Ã¢ÂˆÂˆ R, we have t > 0 and that for any s Ã¢ÂˆÂˆ S,  there must be a t Ã¢ÂˆÂˆ and a s0 Ã¢ÂˆÂˆ S such that (s, t, s0 ) Ã¢ÂˆÂˆ R  holds.  N  N  Timed Kripke structures may be pictorially drawn as given  in Figure 1, where initial states are drawn with double lines.  1 Timed  transition systems have been introduced by many authors with  different names like timed transitions graphs [3], quantitative temporal  structures [10], or timed temporal structures in [16]. Following the CTL  notations, we prefer the name timed Kripke structures.  4  {}  s1  3  {} s2  1  {p} s3  1  a fixed path ÄÂ€, since we may have more than one transition  between two states that are labeled with different numbers.  The set of paths starting in a state s is furthermore denoted  as PathsK (s).  Definition 3 (Semantics of JCTL) Given a TKS K = (I,  S, R, L), and s Ã¢ÂˆÂˆ S, then the semantics of the logic is  recursively defined as follows:  Figure 1. A Timed Kripke Structure  Some approaches, e.g. [3] label transitions with intervals  [a, b] of time. It is easily seen that our TKSs subsume these  models since we can add for any t Ã¢ÂˆÂˆ [a, b] a new transition  between the considered two states.  It is crucial to understand what is modeled by a TKS.  We use interpretation I1 : A transition from state s to state  s0 with label k Ã¢ÂˆÂˆ means that at any time t0 , where we are  in state s, we can perform an atomic action that requires k  units of time. The action terminates at time t0 +k, where we  are in state s0 . In particular, there is no information about  the intermediate points of time t with t0 < t < t0 + k.  N  2.2. JCTL as a Real-Time Extension of CTL  To write down specifications in a formal way, we use JCTL,  a real-time extension of the temporal logic CTL. For its definition below, we only use a small subset of logical operators that will be extended below by some abbreviations.  Definition 2 (Syntax of JCTL) Given a set of variables V,  the set of JCTL formulas is the least set satisfying the following rules, where ÄÂ• and ÄÂˆ denote arbitrary JCTL formulas, and a, b Ã¢ÂˆÂˆ are arbitrary natural numbers:  N  Ã¢Â€Ë˜  Ã¢Â€Ë˜  Ã¢Â€Ë˜  Ã¢Â€Ë˜  Ã¢Â€Ë˜  Ã¢Â€Ë˜  Ã¢Â€Ë˜  Ã¢Â€Ë˜  V Ã¢ÂŠÂ† JCTL, i.e, any variable is a JCTL formula  Ã‚Å¹ÄÂ•, ÄÂ• Ã¢ÂˆÂ§ ÄÂˆ Ã¢ÂˆÂˆ JCTL  EX[a,b] ÄÂ• Ã¢ÂˆÂˆ JCTL  EXÃ¢Â‰Ä½a ÄÂ• Ã¢ÂˆÂˆ JCTL  E[ÄÂ• U[a,b] ÄÂˆ] Ã¢ÂˆÂˆ JCTL  E[ÄÂ• UÃ¢Â‰Ä½a ÄÂˆ] Ã¢ÂˆÂˆ JCTL  EG[a,b] ÄÂ• Ã¢ÂˆÂˆ JCTL  EGÃ¢Â‰Ä½a ÄÂ• Ã¢ÂˆÂˆ JCTL  The semantics of JCTL is defined with respect to a TKS. For  the definition of the semantics, we need the notion of paths.  A path ÄÂ€ through a timed Kripke structure is a function ÄÂ€ :  Ã¢Â†Â’ S such that Ã¢ÂˆÂ€i Ã¢ÂˆÂˆ .Ã¢ÂˆÂƒt Ã¢ÂˆÂˆ . (ÄÂ€ (i) , t, ÄÂ€ (i+1) ) Ã¢ÂˆÂˆ R  holds (we write the function application with a superscript).  Hence, ÄÂ€ (i) is the (i + 1)th state on path ÄÂ€. For a given path  ÄÂ€, we define an associated time consumption function ÄÂ„ÄÂ€ ,  so that ÄÂ€ and ÄÂ„ÄÂ€ satisfy the condition Ã¢ÂˆÂ€i Ã¢ÂˆÂˆ .Ã¢ÂˆÂƒt Ã¢ÂˆÂˆ . (ÄÂ€ (i) ,  (i)  ÄÂ„ÄÂ€ , ÄÂ€ (i+1) ) Ã¢ÂˆÂˆ R. Note that ÄÂ„ÄÂ€ is not uniquely defined for  N  N  N  N  N  Ã¢Â€Ë˜  Ã¢Â€Ë˜  Ã¢Â€Ë˜  Ã¢Â€Ë˜  K, s |= p iff p Ã¢ÂˆÂˆ L(s) for any p Ã¢ÂˆÂˆ V  K, s |= Ã‚Å¹ÄÂ• iff (K, s) 6|= ÄÂ•  K, s |= ÄÂ• Ã¢ÂˆÂ§ ÄÂˆ iff K, s |= ÄÂ• and K, s |= ÄÂˆ  K, s |= EX[a,b] ÄÂ• iff there is a path ÄÂ€ Ã¢ÂˆÂˆ PathsK (s) with  associated duration function ÄÂ„ÄÂ€ with         a Ã¢Â‰Â¤ ÄÂ„ÄÂ€(0) Ã¢Â‰Â¤ b Ã¢ÂˆÂ§ K, ÄÂ€ (1) |= ÄÂ•  Ã¢Â€Ë˜ K, s |= EXÃ¢Â‰Ä½a ÄÂ• iff there is a path ÄÂ€ Ã¢ÂˆÂˆ PathsK (s) with  associated duration function ÄÂ„ÄÂ€ with         a Ã¢Â‰Â¤ ÄÂ„ÄÂ€(0) Ã¢ÂˆÂ§ K, ÄÂ€ (1) |= ÄÂ•  Ã¢Â€Ë˜ K, s |= E[ÄÂ• U[a,b] ÄÂˆ] iff there is a path ÄÂ€ Ã¢ÂˆÂˆ PathsK (s)  with associated duration function ÄÂ„ÄÂ€ and an i Ã¢ÂˆÂˆ  with  ÄÅÅ›  ÄÅÅ¤  iÃ¢ÂˆÂ’1      X  ÄÅÂ­a Ã¢Â‰Â¤  ÄÂ„ÄÂ€(j) Ã¢Â‰Â¤ bÄÅÂ¸ Ã¢ÂˆÂ§ K, ÄÂ€ (i) |= ÄÂˆ  N  j=0    Ã¢ÂˆÂ§ Ã¢ÂˆÂ€j < i. K, ÄÂ€ (j) |= ÄÂ•    Ã¢Â€Ë˜ K, s |= E[ÄÂ• UÃ¢Â‰Ä½a ÄÂˆ] iff there is a path ÄÂ€ Ã¢ÂˆÂˆ PathsK (s)  with associated duration function ÄÂ„ÄÂ€ and an i Ã¢ÂˆÂˆ  with  ÄÅÅ›  ÄÅÅ¤  iÃ¢ÂˆÂ’1      X  ÄÅÂ­a Ã¢Â‰Â¤  ÄÂ„ÄÂ€(j) ÄÅÂ¸ Ã¢ÂˆÂ§ K, ÄÂ€ (i) |= ÄÂˆ  N  j=0    Ã¢ÂˆÂ§ Ã¢ÂˆÂ€j < i. K, ÄÂ€ (j) |= ÄÂ•    Ã¢Â€Ë˜ K, s |= EG[a,b] ÄÂ• iff there is a path ÄÂ€ Ã¢ÂˆÂˆ PathsK (s)  with associated duration function ÄÂ„ÄÂ€ , such that for all  i Ã¢ÂˆÂˆ , we have  ÄÅÅ›  ÄÅÅ¤  iÃ¢ÂˆÂ’1      X  ÄÅÂ­a Ã¢Â‰Â¤  ÄÂ„ÄÂ€(j) Ã¢Â‰Â¤ bÄÅÂ¸ Ã¢Â†Â’ K, ÄÂ€ (i) |= ÄÂ•  N  j=0  Ã¢Â€Ë˜ K, s |= EGÃ¢Â‰Ä½a ÄÂ• iff there is a path ÄÂ€ Ã¢ÂˆÂˆ PathsK (s) with  associated duration function ÄÂ„ÄÂ€ , such that for all i Ã¢ÂˆÂˆ  , we have  ÄÅÅ›  ÄÅÅ¤  iÃ¢ÂˆÂ’1      X  ÄÅÂ­a Ã¢Â‰Â¤  ÄÂ„ÄÂ€(j) ÄÅÂ¸ Ã¢Â†Â’ K, ÄÂ€ (i) |= ÄÂ•  N  j=0  Ã¢Â€Â“ E[ÄÂ• U>k ÄÂˆ] := E[ÄÂ• UÃ¢Â‰Ä½k+1 ÄÂˆ]  Ã¢Â€Â“ E[ÄÂ• U=k ÄÂˆ] := E[ÄÂ• U[k,k] ÄÂˆ]  Given a TKS K and a JCTL formula ÄÂ•, we denote the set of  states of K where ÄÂ• holds as JÄÂ•KK .  Intuitively, K, s |= EX[a,b] ÄÂ• means that the state s has a  direct successor state s0 that satisfies ÄÂ• and can be reached  in time t Ã¢ÂˆÂˆ [a, b]. K, s |= EXÃ¢Â‰Ä½a ÄÂ• means that the state s has  a direct successor state s0 that satisfies ÄÂ• and can be reached  in time t Ã¢Â‰Ä½ a.  K, s |= E[ÄÂ• U[a,b] ÄÂˆ] means that there is a path ÄÂ€ starting  in ÄÂ€ (0) = s and a number i Ã¢ÂˆÂˆ so that for the first i states  ÄÂ€ (0) , ÄÂ€ (1) , . . . , ÄÂ€ (iÃ¢ÂˆÂ’1) the property ÄÂ• holds, and ÄÂˆ holds on  PiÃ¢ÂˆÂ’1 (j)  ÄÂ€ (i) , and the time t := j=0 ÄÂ„ÄÂ€ required to reach state  ÄÂ€ (i) satisfies the numerical relations a Ã¢Â‰Â¤ t and t Ã¢Â‰Â¤ b.  K, s |= E[ÄÂ• UÃ¢Â‰Ä½a ÄÂˆ] means that there is a path ÄÂ€ starting  in ÄÂ€ (0) = s and a number i Ã¢ÂˆÂˆ so that for the first i states  ÄÂ€ (0) , ÄÂ€ (1) , . . . , ÄÂ€ (iÃ¢ÂˆÂ’1) the property ÄÂ• holds, and ÄÂˆ holds on  PiÃ¢ÂˆÂ’1 (j)  ÄÂ€ (i) , and the time t := j=0 ÄÂ„ÄÂ€ required to reach state  ÄÂ€ (i) satisfies the numerical relation a Ã¢Â‰Â¤ t.  K, s |= EG[a,b] ÄÂ• means that there is a path ÄÂ€ starting in  ÄÂ€ (0) = s, such that for any state ÄÂ€ (i) that is reached within  PiÃ¢ÂˆÂ’1 (j)  a time t := j=0 ÄÂ„ÄÂ€ with t Ã¢ÂˆÂˆ [a, b], we have ÄÂ€ (i) . Hence,  ÄÂ• holds in the interval [a, b].  Finally, K, s |= EGÃ¢Â‰Ä½a ÄÂ• means that there is a path ÄÂ€ starting in ÄÂ€ (0) = s, such that for any state ÄÂ€ (i) that is reached  PiÃ¢ÂˆÂ’1 (j)  (i)  within a time t :=  j=0 ÄÂ„ÄÂ€ with t Ã¢Â‰Ä½ a, we have ÄÂ€ .  Hence, ÄÂ• holds for all states on ÄÂ€ that are reached at time a  or after time a.  In the above definition, we have only used basic operators of the logic. Of course, we must introduce some further  operators to express some properties directly. For this reason, we give the following abbreviations:  N  Ã¢Â€Ë˜ EG Operators:  Ã¢Â€Â“  Ã¢Â€Â“  Ã¢Â€Â“  Ã¢Â€Â“  Ã¢Â€Â“  Ã¢Â€Ë˜ Let ÃÅŸ be any time constraint, i.e., [a, b], Ã¢ÂˆÅº k with Ã¢ÂˆÅºÃ¢ÂˆÂˆ  {<, Ã¢Â‰Â¤, =, Ã¢Â‰Â¤, >}, or the empty constraint. Then, we  define the following operators:  Ã¢Â€Â“  Ã¢Â€Â“  Ã¢Â€Â“  Ã¢Â€Â“  Ã¢Â€Â“  Ã¢Â€Â“  Ã¢Â€Â“  Ã¢Â€Â“  Ã¢Â€Â“  Ã¢Â€Â“  Ã¢Â€Â“  N  Definition 4 (Further Temporal Operators) We define  further temporal operators in JCTL as follows, where p is  an arbitrary variable:  Ã¢Â€Ë˜ Boolean Operators:  Ã¢Â€Â“  Ã¢Â€Â“  Ã¢Â€Â“  Ã¢Â€Â“  1 := p Ã¢ÂˆÂ¨ Ã‚Å¹p  0 := p Ã¢ÂˆÂ§ Ã‚Å¹p  ÄÂ• Ã¢ÂˆÂ¨ ÄÂˆ := Ã‚Å¹(Ã‚Å¹ÄÂ• Ã¢ÂˆÂ§ Ã‚Å¹ÄÂˆ)  ÄÂ• Ã¢Â†Â’ ÄÂˆ := Ã‚Å¹ÄÂ• Ã¢ÂˆÂ¨ ÄÂˆ  Ã¢Â€Ë˜ EX Operators:  Ã¢Â€Â“  Ã¢Â€Â“  Ã¢Â€Â“  Ã¢Â€Â“  Ã¢Â€Â“  EXÄÂ• := EXÃ¢Â‰Ä½0 ÄÂ•  EXÃ¢Â‰Â¤k ÄÂ• := EX[0,k] ÄÂ•  EX<k ÄÂ• := EX[0,kÃ¢ÂˆÂ’1] ÄÂ•  EX>k ÄÂ• := EXÃ¢Â‰Ä½k+1 ÄÂ•  EX=k ÄÂ• := EX[k,k] ÄÂ•  Ã¢Â€Ë˜ E[Ã‚Ë‡ U Ã‚Ë‡] Operators:  Ã¢Â€Â“ E[ÄÂ• U ÄÂˆ] := E[ÄÂ• UÃ¢Â‰Ä½0 ÄÂˆ]  Ã¢Â€Â“ E[ÄÂ• UÃ¢Â‰Â¤k ÄÂˆ] := E[ÄÂ• U[0,k] ÄÂˆ]  Ã¢Â€Â“ E[ÄÂ• U<k ÄÂˆ] := E[ÄÂ• U[0,kÃ¢ÂˆÂ’1] ÄÂˆ]  EGÄÂ• := EGÃ¢Â‰Ä½0 ÄÂ•  EGÃ¢Â‰Â¤k ÄÂ• := EG[0,k] ÄÂ•  EG<k ÄÂ• := EG[0,kÃ¢ÂˆÂ’1] ÄÂ•  EG>k ÄÂ• := EGÃ¢Â‰Ä½k+1 ÄÂ•  EG=k ÄÂ• := EG[k,k] ÄÂ•  AXÃÅŸ ÄÂ• := Ã‚Å¹EXÃÅŸ Ã‚Å¹ÄÂ•  A[ÄÂ•UÃÅŸ ÄÂˆ] := Ã‚Å¹E[(Ã‚Å¹ÄÂˆ) UÃÅŸ Ã‚Å¹(ÄÂ• Ã¢ÂˆÂ¨ ÄÂˆ)]Ã¢ÂˆÂ§Ã‚Å¹EGÃÅŸ Ã‚Å¹ÄÂˆ  EFÃÅŸ ÄÂ• := E[1 UÃÅŸ ÄÂ•]  AFÃÅŸ ÄÂ• := A[1 UÃÅŸ ÄÂ•]  AGÃÅŸ ÄÂ• := Ã‚Å¹EFÃÅŸ (Ã‚Å¹ÄÂ•)  E[ÄÂ• BÃÅŸ ÄÂˆ] := E[(Ã‚Å¹ÄÂˆ) UÃÅŸ (ÄÂ• Ã¢ÂˆÂ§ Ã‚Å¹ÄÂˆ)]  A[ÄÂ• BÃÅŸ ÄÂˆ] := A[(Ã‚Å¹ÄÂˆ) UÃÅŸ (ÄÂ• Ã¢ÂˆÂ§ Ã‚Å¹ÄÂˆ)]  E[ÄÂ• UÃÅŸ ÄÂˆ] := Ã‚Å¹A[(Ã‚Å¹ÄÂ•) BÃÅŸ ÄÂˆ]  A[ÄÂ• UÃÅŸ ÄÂˆ] := Ã‚Å¹E[(Ã‚Å¹ÄÂ•) BÃÅŸ ÄÂˆ]  E[ÄÂ• BÃÅŸ ÄÂˆ] := Ã‚Å¹A[(Ã‚Å¹ÄÂ•) UÃÅŸ ÄÂˆ]  A[ÄÂ• BÃÅŸ ÄÂˆ] := Ã‚Å¹E[(Ã‚Å¹ÄÂ•) UÃÅŸ ÄÂˆ]  The definitions of the further EX, E[Ã‚Ë‡ U Ã‚Ë‡], and EX operators  should be clear. EFÃÅŸ ÄÂ• holds in state s iff a state can be  reached where ÄÂ• holds and that state can be reached within  a time that satisfies the the time constraint ÃÅŸ.  E[ÄÂ•BÃÅŸ ÄÂˆ] means that there must be a path ÄÂ€ and a number  such that ÄÂ• holds on ÄÂ€ (i) , and all states ÄÂ€ (j) with  i Ã¢ÂˆÂˆ  j Ã¢Â‰Â¤ i do not satisfy ÄÂˆ, and the time required to reach ÄÂ€ (i)  satisfies the time constraint ÃÅŸ (hence, ÄÂ• holds before ÄÂˆ).  We also have weak variants E[Ã‚Ë‡ U Ã‚Ë‡] and E[Ã‚Ë‡ B Ã‚Ë‡] of E[Ã‚Ë‡ U Ã‚Ë‡]  and E[Ã‚Ë‡ B Ã‚Ë‡], respectively, that do not demand that the events  that are awaited for must actually occur. E[ÄÂ• UÃÅŸ ÄÂˆ] implies  E[ÄÂ• UÃÅŸ ÄÂˆ], but E[ÄÂ• UÃÅŸ ÄÂˆ] may also hold, if there is a path  ÄÂ€ where ÄÂˆ can not be reached in time. In this case, ÄÂ• must  hold on those states on the path that can be reached within  a time that satisfies the constraint ÃÅŸ. E[Ã‚Ë‡ B Ã‚Ë‡] is defined in a  similar way. Finally, the versions with the A path quantifier  are defined such that the corresponding path property must  hold for all paths leaving the state.  As can be seen, the EG[a,b] operator states that some  property holds for all states that can be reached within [a, b],  while EF[a,b] Ã‚Ë‡ states a property for some point of time in that  interval. Nevertheless, the following lemma holds, which  shows that the EGÃ¢Â‰Â¤k operator is a somehow hybrid operator that makes both a universal and an existential statement  (compare G2 and G3 in the following lemma). This is due  to the fact, that the equation EGÃ¢Â‰Â¤k ÄÂ• = E[ÄÂ• U>k 1] is valid:  N  Lemma 1 (Semantics of EGÃ¢Â‰Â¤k ÄÂ•) Given a JCTL formula  ÄÂ• and a number k Ã¢ÂˆÂˆ . Then, the following properties are  equivalent for any TKS K = (I, S, R, L):  N  (G1 ) K, s |= EGÃ¢Â‰Â¤k ÄÂ•  (G2 ) there is a path ÄÂ€ Ã¢ÂˆÂˆ PathsK (s) starting in state s, such  that  ÄÅÅ› i Ã¢ÂˆÂˆ , we have  ÄÅÅ¤ for all numbers  iÃ¢ÂˆÂ’1      X  ÄÅÂ­  ÄÂ„ÄÂ€(j) Ã¢Â‰Â¤ k ÄÅÂ¸ Ã¢Â†Â’ K, ÄÂ€ (i) |= ÄÂ•  N  j=0  (G3 ) there is a path ÄÂ€ Ã¢ÂˆÂˆ PathsK (s) starting in state s and  aÄÅÅ¤number i Ã¢ÂˆÂˆ such that ÄÅÅ›  iÃ¢ÂˆÂ’1  i      X  X  (j)  ÄÅÂ­  ÄÂ„ÄÂ€ Ã¢Â‰Â¤ k <  ÄÂ„ÄÂ€(j) ÄÅÂ¸ Ã¢ÂˆÂ§ Ã¢ÂˆÂ€j Ã¢Â‰Â¤ i. K, ÄÂ€ (j) |= ÄÂ•  N  j=0  j=0  (G4 ) there is a path ÄÂ€ Ã¢ÂˆÂˆ PathsK (s) starting in state s and  aÄÅÅ¤number i Ã¢ÂˆÂˆ ÄÅÅ›such that  iÃ¢ÂˆÂ’1      X  ÄÅÂ­  ÄÂ„ÄÂ€(j) > k ÄÅÂ¸ Ã¢ÂˆÂ§ Ã¢ÂˆÂ€j < i. K, ÄÂ€ (j) |= ÄÂ•  N  function expand(I, S, R)  Se := {(s, 1) | s Ã¢ÂˆÂˆ S};  Re := {};  for (s, t, s0 ) Ã¢ÂˆÂˆ R do  for i := 2 to t do  Se := Se Ã¢ÂˆÅ {(s, i)};  Re := Re Ã¢ÂˆÅ {((s, i Ã¢ÂˆÂ’ 1), (s, i))};  end for;  Re := Re Ã¢ÂˆÅ {((s, t), (s0 , 1))};  end for;  Ie := {(s, 1) | s Ã¢ÂˆÂˆ I};  return (Ie , Se , Re );  end function  Figure 2. Expansion of TKS to UDS  j=0  (G5 ) K, s |= E[ÄÂ• U>k 1]  The proof of the above lemma is not very difficult. We just  make use of the well-ordering of natural numbers, i.e., if  there is a number with some property, then there is also a  least number with the same property.  2.3. Expansion of TKSs  Normal Kripke structures are special cases of TKS that are  obtained by restricting TKSs so that (s, t, s0 ) Ã¢ÂˆÂˆ R implies  t = 1. To avoid confusion, we call the Ã¢Â€Â˜normal Kripke  structuresÃ¢Â€Â™ unit delay structures in the following:  Definition 5 (Unit Delay Structure (UDS)) A TKS K =  (I, S, R, L) is called to be unit delay structure iff TK :=  {t | (s, t, s0 ) Ã¢ÂˆÂˆ R} = {1}.  The previously mentioned approaches to define real-time  logics that rely on interpretation I2 are forced to expand  TKSs in order to define the semantics of their logics. For  example, the following expansion algorithm could be used  for that purpose:  Definition 6 (Expansion of TKS) Given a TKS K = (I, S,  R, L), we compute (Ie , Se , Re ) = expand(I, S, R) with  the function expand as defined in Figure 2. Moreover, we  define for any (s, u) Ã¢ÂˆÂˆ Se the label function Le ((s, u)) :=  L(s). The expansion of K is then the unit delay structure  Ke := (Ie , Se , Re , Le ).  As can be seen, the expansion relies on interpretation I2 ,  since we defined Le ((s, u)) := L(s), i.e., the states of Ke  have the same variable assignments as the corresponding  states of K. For conciseness, we use the following definition:  Definition 7 (Tracks of a State) Given a TKS K = (I, S,  R, L), its expanded structure Ke := (Ie , Se , Re , Le ), and  a state s Ã¢ÂˆÂˆ S. Then, we define TrackK (s) = {(s0 , u) Ã¢ÂˆÂˆ Se |  s = s0 }.  We emphasize that expansions of TKS can be performed in  many different ways that are not equivalent to each other  [13]. Furthermore, real-time model checking problems can  not be simply reduced to ordinary CTL model checking  problems, although this is widely believed [13]. For this  reason, we must extend the usual CTL model checking procedure to capture JCTL. This is shown in the next section.  3. Real Time Model Checking on TKSs  In this section, we present a model checking algorithm for  our real-time logic JCTL. We have implemented this algorithm in our verification tool JERRY by using the CUDD  BDD library [17]. The underlying algorithms for the basic  operators are given in Figure 4.  The essential idea to reason about the real-time constraints is to move fronts of tracks on a virtual expanded  structure. However, we emphasize that we do never expand  the structure. Furthermore, we do not run into semantic  problems since the result of any evaluation of a logical operator is a set of states instead of a set of tracks. Hence, all  calculations are independent of the virtual expansion. This  is achieved by abstraction of the set of tracks, so that the semantics of the evaluated temporal operator is respected. In  general, there are two possibilities: On the one hand, a state  s belongs to the result if its main track (s, 1) belongs to the  track set, on the other hand it may be sufficient if anyone  of its tracks (s, t) belongs to the track set. The choice between the two possibilities depends on the semantics of the  considered temporal operator (see Figure 4).  The key function for the evaluation of all real-time constraints is the function MoveFront. Given a set of tracks  t0  ÄÂ•  ÄÂ•  s1  s0  t1  ÄÂ•  tnÃ¢ÂˆÂ’2  snÃ¢ÂˆÂ’2  ÄÂ•  tnÃ¢ÂˆÂ’1  snÃ¢ÂˆÂ’1  ÄÂˆ  sn  Figure 3. Correctness of MoveFront  TÄÂˆ and a set of states SÄÂ• , this function computes the set of  tracks that have a path of a certain length through the tracks  SÄÂ• Ä‚Â— . The precise specification is as follows:  N  Lemma 2 (Correctness of MoveFront) Given a TKS K =  (I, S, R, L), a set of states SÄÂ• , and a set of tracks TÄÂˆ , the  function MoveFront as given in Figure 4 satisfies the following equations for Ã¢ÂˆÅºÃ¢ÂˆÂˆ {=, Ã¢Â‰Ä½} (cf. Figure 3):  Ã¢ÂˆÂˆ MoveFront(Ã¢ÂˆÅº, k, SÄÂ• , TÄÂˆ )  (s0 , t) ÄÅÅ¤  Ã¢ÂˆÂƒs1 , . . . , snÃ¢ÂˆÂ’1 Ã¢ÂˆÂˆ SÄÂ• .Ã¢ÂˆÂƒ(sn , d) Ã¢ÂˆÂˆ TÄÂˆ .  ÄÅÅ¹ Ã¢ÂˆÂƒt0 , . . . , tnÃ¢ÂˆÂ’1 Ã¢ÂˆÂˆ .  ÄÅÅ¹  VnÃ¢ÂˆÂ’1  ÄÅÅ¹  )Ã¢ÂˆÂˆRÃ¢ÂˆÂ§  Ã¢Â‡Â”ÄÅÅ¹  i=0(si , ti , si+1  PnÃ¢ÂˆÂ’1   ÄÅÅ¹  kÃ¢ÂˆÅº  ÄÅÂ­  i=0 ti + d Ã¢ÂˆÂ’ t Ã¢ÂˆÂ§  t Ã¢Â‰Â¤ t0  N  ÄÅÅ›  ÄÅË‡  ÄÅË‡  ÄÅË‡  ÄÅË‡  ÄÅË‡  ÄÅÂ¸  Hence, MoveFront(Ã¢ÂˆÅº, k, SÄÂ• , TÄÂˆ ) computes the set of tracks  that have a path through any expanded structure of length `  with ` Ã¢ÂˆÅº k to a track in TÄÂˆ which runs only through tracks  of SÄÂ• Ä‚Â— .  N  Proof: The correctness easily follows by induction on k,  when we observe that our algorithm and the right hand sides  of the above equivalence both satisfy the following recursion equations (note that primitive recursive definitions are  uniquely determined):  Ã¢Â€Ë˜ MoveFront(Ã¢ÂˆÅº, 0, SÄÂ• , TÄÂˆ ) = TÄÂˆ  Ã¢Â€Ë˜ MoveFront(=, k + 1, SÄÂ• , TÄÂˆ )  = (SÄÂ• Ä‚Â— ) Ã¢ÂˆÅ  preTracks(MoveFront(=, k, SÄÂ• , TÄÂˆ ))  Ã¢Â€Ë˜ MoveFront(Ã¢Â‰Ä½,  k + 1, SÄÂ• , TÄÂˆ )      let T0 := MoveFront(Ã¢Â‰Ä½, k, SÄÂ• , TÄÂˆ )  =  in T0 Ã¢ÂˆÅ ((SÄÂ• Ä‚Â— ) Ã¢ÂˆÅ  preTracks(T0 ))  N  N  Using these equations, we can easily prove that T0 =  MoveFront(Ã¢ÂˆÅº, i, SÄÂ• , TÄÂˆ ) is an invariant of the loop in the  algorithm given in Figure 4 for MoveFront. This directly  implies the correctness of the above lemma.  Please note that in the algorithm given in Figure 4 to implement the function MoveFront, we use (i 6= k) Ã¢ÂˆÂ§ (T0 6=  T1 ) as loop condition instead of (i 6= k) (which would  also be correct). The reason for this is that whenever  T0 = T1 holds for an iteration i < k, then it follows  that all fronts MoveFront(Ã¢ÂˆÅº, i, SÄÂ• , TÄÂˆ ), . . . , MoveFront(Ã¢ÂˆÅº  , k, SÄÂ• , TÄÂˆ ) would be identical, so that we already have the  result in this case.  Now consider the function StatesEU[a,b] . We first compute the set of tracks T0 that can reach a track of SÄÂˆ Ä‚Â— {1}  in exactly a steps (where only tracks of the states SÄÂ• are traversed). After this, we move the tracks T0 by further b Ã¢ÂˆÂ’ a  unit delay steps through the tracks of the states SÄÂ• . By the  above lemma, we then obtain  (s00 , t0 ) Ã¢ÂˆÂˆ T1 Ã¢Â‡Â”  ÄÅÅ¤  Ã¢ÂˆÂƒs01 , . . . , s0m Ã¢ÂˆÂˆ SÄÂ• .Ã¢ÂˆÂƒt00 , . . . , t0mÃ¢ÂˆÂ’1 Ã¢ÂˆÂˆ .  ÄÅÅ¹ Ã¢ÂˆÂƒs0 , . . . , snÃ¢ÂˆÂ’1 Ã¢ÂˆÂˆ SÄÂ• .Ã¢ÂˆÂƒt0 , . . . , tnÃ¢ÂˆÂ’1 Ã¢ÂˆÂˆ .  ÄÅÅ¹  ÄÅÅ¹ Ã¢ÂˆÂƒsn Ã¢ÂˆÂˆ SÄÂˆ .Ã¢ÂˆÂƒt Ã¢ÂˆÂˆ .  ÄÅÅ¹ VmÃ¢ÂˆÂ’1 0 0 0  ÄÅÅ¹  i=0 (si , ti , si+1 ) Ã¢ÂˆÂˆ RÃ¢ÂˆÂ§  ÄÅÅ¹  ÄÅÅ¹ (s0m = s0 ) Ã¢ÂˆÂˆ RÃ¢ÂˆÂ§  ÄÅÅ¹ VnÃ¢ÂˆÂ’1  ÄÅÅ¹  ) Ã¢ÂˆÂˆ RÃ¢ÂˆÂ§  ÄÅÅ¹  i=0(si , ti , si+1  PnÃ¢ÂˆÂ’1   ÄÅÅ¹  ÄÅÅ¹ a=  ti + 1 Ã¢ÂˆÂ’ tÃ¢ÂˆÂ§  ÄÅÅ¹    P i=0  P  ÄÅÅ¹  mÃ¢ÂˆÂ’1 0  nÃ¢ÂˆÂ’1  0  ÄÅÂ­ bÃ¢Â‰Ä½  i=0 ti +  i=0 ti + 1 Ã¢ÂˆÂ’ t Ã¢ÂˆÂ§  0  0  t Ã¢Â‰Â¤ t 0 Ã¢ÂˆÂ§ t Ã¢Â‰Â¤ t0  N  N  N  ÄÅÅ›  ÄÅË‡  ÄÅË‡  ÄÅË‡  ÄÅË‡  ÄÅË‡  ÄÅË‡  ÄÅË‡  ÄÅË‡  ÄÅË‡  ÄÅË‡  ÄÅË‡  ÄÅË‡  ÄÅË‡  ÄÅË‡  ÄÅÂ¸   P    P  mÃ¢ÂˆÂ’1 0  nÃ¢ÂˆÂ’1  t  t  +  + 1 Ã¢ÂˆÂ’ t0 is the numNote that  i  i=0 i  i=0  ber of unit delay steps that are required to reach track  (sn , 1) Ã¢ÂˆÂˆ SÄÂˆ Ä‚Â— {1} from track (s00 , t0 ). By the above result, it follows that this time is in the interval [a, b] (consider  the case m = 0, where the second MoveFront went along  a single transition, and the case where m > 0 holds). The  final step is to translate this result (given for tracks) to sets  of states. If (s00 , 1)r Ã¢ÂˆÂˆ T1 holds,zthen we clearly see that  state s0 belongs to E[ÄÂ• U[a,b] ÄÂˆ]  (s00 , t0 )  0  K  . If, on the other hand,  Ã¢ÂˆÂˆ T1 holds for some t > 1, but (s00 , 1) is not included in T1 , then it follows by the above formula that the  0  time r  to reach (sn , 1)  z from (s0 , 1) is larger than b, so that  s00 6Ã¢ÂˆÂˆ E[ÄÂ• U[a,b] ÄÂˆ] .  K  The correctness of EG[a,b] ÄÂ• is seen as follows: T0 is the  set of tracks that have a path of length b Ã¢ÂˆÂ’ a through SÄÂ• Ä‚Â—  in the expanded structure. T1 is the set of tracks of SÄÂ• Ä‚Â—  that can reach T0 while only traversing tracks of SÄÂ• Ä‚Â— .  Hence, T1 is the set of tracks that have a path of length  Ã¢Â‰Ä½ b Ã¢ÂˆÂ’ a through SÄÂ• Ä‚Â— in the expanded structure. Finally,  T2 is the set of tracks of S Ä‚Â— that can reach T1 in exactly  a steps. Clearly, we only should consider those tracks with  time stamp 1 of T2 .  The correctness of the other two functions to evaluate  E[ÄÂ• UÃ¢Â‰Ä½a ÄÂˆ] and EGÃ¢Â‰Ä½a ÄÂ• are proved in a similar way. Therefore, we obtain the following correctness result:  N  N  N  N  N  Theorem 1 (Correctness of Function States) For  any  TKS K = (I, S, R, L) and any JCTL formula ÄÂ•, the  function States given in Figure 4 satisfies the equation  States(ÄÂ•) = JÄÂ•KK .  functionpreStates(S0 )    Ã¢ÂˆÂƒs0 Ã¢ÂˆÂˆ S0 .Ã¢ÂˆÂƒt Ã¢ÂˆÂˆ .  ;  S1 := s Ã¢ÂˆÂˆ S  (s, t, s0 ) Ã¢ÂˆÂˆ R  return S1 ;  end function  N  function preTracks(T )  T1 := {(s, t) | (s, t + 1) Ã¢ÂˆÂˆ T };  T2 := {(s, t) | Ã¢ÂˆÂƒ(s0 , 1) Ã¢ÂˆÂˆ T . (s, t, s0 ) Ã¢ÂˆÂˆ R};  return T1 Ã¢ÂˆÅ T2 ;  end function  function MoveFront(Ã¢ÂˆÅº, k, SÄÂ• , TÄÂˆ )  TÄÂ• := SÄÂ• Ä‚Â— ;  T0 := TÄÂˆ ;  T1 := {};  i := 0;  while (i 6= k) Ã¢ÂˆÂ§ (T0 6= T1 ) do  T1 := T0 ;  T0 := TÄÂ• Ã¢ÂˆÅ  preTracks(T1 );  if equal(Ã¢ÂˆÅº, Ã¢Â‰Ä½) then T0 := T1 Ã¢ÂˆÅ T0 endif;  i := i + 1;  end;  return T0 ;  end function  N  function StatesEU[a,b] (SÄÂ• , SÄÂˆ )  T0 := MoveFront(=, a, SÄÂ• , SÄÂˆ Ä‚Â— {1});  T1 := MoveFront(Ã¢Â‰Ä½, b Ã¢ÂˆÂ’ a, SÄÂ• , T0 );  return {s Ã¢ÂˆÂˆ S | (s, 1) Ã¢ÂˆÂˆ T1 };  end function  function StatesEUÃ¢Â‰Ä½a (SÄÂ• , SÄÂˆ )  T0 := MoveFront(=, a, SÄÂ• , SÄÂˆ Ä‚Â— {1});  S0 := {s Ã¢ÂˆÂˆ S | Ã¢ÂˆÂƒt Ã¢ÂˆÂˆ . (s, t) Ã¢ÂˆÂˆ T0 };  repeat  S1 := S0 ;  S0 := S0 Ã¢ÂˆÅ (SÄÂ• Ã¢ÂˆÅ  preStates(S1 )) ;  until (S0 = S1 );  return S0 ;  end function  N  function StatesEG[a,b] (SÄÂ• )  T0 := MoveFront(=, (b Ã¢ÂˆÂ’ a) + 1, SÄÂ• , S Ä‚Â— {1});  T1 := MoveFront(Ã¢Â‰Ä½, Ã¢ÂˆÂ’1, SÄÂ•, T0 );  T2 := MoveFront(=, a, S, T1 );  return {s Ã¢ÂˆÂˆ S | (s, 1) Ã¢ÂˆÂˆ T2 };  end function  function StatesEGÃ¢Â‰Ä½a (SÄÂ• )  S0 := SÄÂ• ;  repeat  S1 := S0 ;  S0 := SÄÂ• Ã¢ÂˆÅ  preStates(S1 );  until S0 = S1 ;  (Ã¢ÂˆÂ— we now have S0 = JEGÄÂ•KK Ã¢ÂˆÂ—)  T0 := MoveFront(Ã¢Â‰Ä½, a, S, S0 Ä‚Â— {1});  return {s Ã¢ÂˆÂˆ S | (s, 1) Ã¢ÂˆÂˆ T0 };  end function  function States(ÃÅš)  case ÃÅš of  is_var(ÃÅš) : return {s Ã¢ÂˆÂˆ S | ÃÅš Ã¢ÂˆÂˆ L(s)};  Ã‚Å¹ÄÂ•  : SÄÂ• := States(ÄÂ•);  return S \ SÄÂ• ;  ÄÂ•Ã¢ÂˆÂ§ÄÂˆ  : SÄÂ• := States(ÄÂ•); SÄÂˆ := States(ÄÂˆ);  return SÄÂ• Ã¢ÂˆÅ  SÄÂˆ ;  : SÄÂ• :=   States(ÄÂ•);  EX[a,b] ÄÂ•    Ã¢ÂˆÂƒs0 Ã¢ÂˆÂˆ SÄÂ• .Ã¢ÂˆÂƒt Ã¢ÂˆÂˆ [a, b].  ;  S0 := s Ã¢ÂˆÂˆ S  (s, t, s0 ) Ã¢ÂˆÂˆ R  return S0 ;  : SÄÂ• :=   States(ÄÂ•);  EXÃ¢Â‰Ä½a ÄÂ•    Ã¢ÂˆÂƒs0 Ã¢ÂˆÂˆ SÄÂ• .Ã¢ÂˆÂƒt Ã¢Â‰Ä½ a.  ;  S0 := s Ã¢ÂˆÂˆ S  (s, t, s0 ) Ã¢ÂˆÂˆ R  return S0 ;  [a,b]  ÄÂˆ]: SÄÂ• := States(ÄÂ•); SÄÂˆ := States(ÄÂˆ);  E[ÄÂ• U  return StatesEU[a,b] (SÄÂ• , SÄÂˆ );  Ã¢Â‰Ä½a  E[ÄÂ• U ÄÂˆ] : SÄÂ• := States(ÄÂ•); SÄÂˆ := States(ÄÂˆ);  return StatesEUÃ¢Â‰Ä½a (SÄÂ• , SÄÂˆ );  : SÄÂ• := States(ÄÂ•);  EG[a,b] ÄÂ•  return StatesEG[a,b] (SÄÂ• );  Ã¢Â‰Ä½a  : SÄÂ• := States(ÄÂ•);  EG ÄÂ•  return StatesEGÃ¢Â‰Ä½a (SÄÂ• );  end function  Figure 4. Model Checking of JCTL Formulas on a Timed Kripke Structure K = (I, S, R, L)  4. Complexity of JCTL  In this section, we analyze the complexity of the presented  model checking algorithm for JCTL. For this reason, we  first note that there is a model checking procedure for CTL,  e.g. the one given in [5], that runs in time O(|ÄÂ•| (|R|+|S|)).  This procedure is able to evaluate any CTL operator in time  O(|ÄÂ•| (|R| + |S|)).  It is easily seen that if we expand a TKS to a UDS,  the number of states and transition is multiplied with the  maximum delay time ÄÂ„ÄšÂ‚K that appears in K. However, the  runtime of the JCTL model checking procedure is not in  O(ÄÂ„ÄšÂ‚K |ÄÂ•| (|R| + |S|)), since the number of iterations does  also depend on the time constraints of the temporal operators that may enforce more than ÄÂ„ÄšÂ‚K |S| iterations. The crucial part of our complexity analysis is the complexity of the  MoveFront function. To this end, we note that the following  holds:  Lemma 3 (Complexity of MoveFront (I)) Given a TKS  K = (I, S, R, L), a set of states SÄÂ• , and a set of tracks  TÄÂˆ . Let moreover be Ke = (Ie , Se , Re , Le ) the expanded  structure of K according to definition 6, and ÄÂ• and ÄÂˆ formulas so that the equations SÄÂ• Ä‚Â— Ã¢ÂˆÅ  Se = JÄÂ•KKe and  TÄÂˆ = JÄÂˆ KKe hold. Then, we have  N  MoveFront(Ã¢ÂˆÅº, k, SÄÂ• , TÄÂˆ ) = JÃÅš(Ã¢ÂˆÅº, k, ÄÂ•, ÄÂˆ)KKe ,  where the formula ÃÅš(Ã¢ÂˆÅº, k, ÄÂ•, ÄÂˆ) is recursively defined as  follows:  Ã¢Â€Ë˜ ÃÅš(Ã¢ÂˆÅº, 0, ÄÂ•, ÄÂˆ) = ÄÂˆ  Ã¢Â€Ë˜ ÃÅš(=, k + 1, ÄÂ•, ÄÂˆ) = ÄÅÅ¤  ÄÂ• Ã¢ÂˆÂ§ EXÃÅš(=, k, ÄÂ•, ÄÂˆ)  ÄÅÅ›  let y = ÃÅš(Ã¢Â‰Ä½, k, ÄÂ•, ÄÂˆ)  ÄÅÂ¸  Ã¢Â€Ë˜ ÃÅš(Ã¢Â‰Ä½, k + 1, ÄÂ•, ÄÂˆ) = ÄÅÂ­ in y Ã¢ÂˆÂ¨ ÄÂ• Ã¢ÂˆÂ§ EXy  end  Moreover, if common subformulas are shared, it is easily seen that |ÃÅš(Ã¢ÂˆÅº, k, ÄÂ•, ÄÂˆ)| Ã¢ÂˆÂˆ O(k) holds. Hence,  MoveFront(=, k, SÄÂ• , TÄÂˆ ) can be computed in time  O(k(|Re | + |Se |)), and MoveFront(Ã¢Â‰Ä½, k, SÄÂ• , TÄÂˆ ) even in  time O(min{k, |Se |}(|Re | + |Se |)).  The complexity can also be directly derived from the implementation of MoveFront: Note that the value of T0 monotonically grows in function calls of MoveFront(Ã¢Â‰Ä½, k, . . . ),  but not for calls of MoveFront(=, k, . . .). Therefore,  MoveFront(Ã¢Â‰Ä½, k, . . .) runs in time O(min{k, |Se |}(|Re | +  |Se |)), but MoveFront(=, k, . . .) requires time O(k(|Re | +  |Se |)). For this reason, we have the following result:  Theorem 2 (Complexity of JCTL) For any TKS K = (I,  S, R, L) and any JCTL formula ÄÂ•, the function States  given in Figure 4 runs in time O(kÄšÂ‚ÄÂ• |ÄÂ•| ÄÂ„ÄšÂ‚K (|R| + |S|)),  where ÄÂ„ÄšÂ‚K := max{t | Ã¢ÂˆÂƒs, s0 . (s, t, s0 ) Ã¢ÂˆÂˆ R} is the maximum delay time of K, and kÄšÂ‚ÄÂ• is the maximal number used  in time constraints in ÄÂ•.  The proof can be obtained by induction along the JCTL formulas. The induction steps are thereby obtained by the following facts, where Time(f ) denotes the runtime of function f :  Ã¢Â€Ë˜ Time(preStates) Ã¢ÂˆÂˆ O(|R| + |S|)  Ã¢Â€Ë˜ Time(preTracks) Ã¢ÂˆÂˆ O(ÄÂ„ÄšÂ‚K (|R| + |S|))  Ã¢Â€Ë˜ Time(StatesEU[a,b] ) Ã¢ÂˆÂˆ O(kÄÂ„ÄšÂ‚K (|R| + |S|)),  where k := max{a, min{b Ã¢ÂˆÂ’ a, ÄÂ„ÄšÂ‚K |S|}} Ã¢Â‰Â¤ b  Ã¢Â€Ë˜ Time(StatesEUÃ¢Â‰Ä½a ) Ã¢ÂˆÂˆ O(aÄÂ„ÄšÂ‚K (|R| + |S|))  Ã¢Â€Ë˜ Time(StatesEG[a,b] ) Ã¢ÂˆÂˆ O(kÄÂ„ÄšÂ‚K (|R| + |S|)),  where k := max{b Ã¢ÂˆÂ’ a, a, 1} Ã¢Â‰Â¤ b  Ã¢Â€Ë˜ Time(StatesEGÃ¢Â‰Ä½a ) Ã¢ÂˆÂˆ O(kÄÂ„ÄšÂ‚K (|R| + |S|)),  where k := min{a, ÄÂ„ÄšÂ‚K |S| , 1} Ã¢Â‰Â¤ a  Hence, all operators can be evaluated in time O(kÄšÂ‚ÄÂ• ÄÂ„ÄšÂ‚K (|R|+  |S|)). As a formula ÄÂ• may contain |ÄÂ•| operators, the above  theorem follows.  Hence, one key to define a more efficient fragment of  JCTL is to avoid calls of the form MoveFront(=, k, . . . ),  since this is not as efficient as MoveFront(Ã¢Â‰Ä½, k, . . .). Using a specialized algorithm similar to the one given in  [5], we can even improve the complexity for computing  MoveFront(Ã¢Â‰Ä½, k, . . . ):  Lemma 4 (Complexity of MoveFront (II)) Given a TKS  K = (I, S, R, L), a set of states SÄÂ• , and a set of tracks  TÄÂˆ . Let moreover be Ke = (Ie , Se , Re , Le ) the expanded  structure of K according to definition 6, and ÄÂ• and ÄÂˆ formulas so that the equations SÄÂ• Ä‚Â— Ã¢ÂˆÅ  Se = JÄÂ•KKe and  TÄÂˆ = JÄÂˆ KKe hold. Then, there is an algorithm to compute  MoveFront(Ã¢Â‰Ä½, k, SÄÂ• , TÄÂˆ ) in time O(|Re | + |Se |).  N  The specialized algorithm is similar to the one given in [5],  but it needs to additionally take care of the lengths of the  paths that have reached a certain track. For this reason, we  maintain for any track si Ã¢ÂˆÂˆ Se a list Ti = [si,1 ,. . . , si,mi ]  such that (si,j , si ) is a transition in Re . Any track si will  be marked with a number mi later on that is the minimal  length of a path to reach the set TÄÂˆ from si . Furthermore,  we create lists L` during the computations that contain the  tracks that are marked with the number `. The algorithm  performs then the following steps:  Step 1: We eliminate all si,j in each list Ti that does not  belong to TÄÂˆ . This can be done in time O(|Re |), since  we look at each transition once.  Step 2: We mark the tracks TÄÂˆ with the number 0, and list  them in our first list L0 . Let ` := 0. This step is  performed in time O(|Se |), since we look at each track  at most once.  Step 3: For each track si in L` , and each track si,j of Ti ,  we mark si,j with ` + 1 if it is not already marked,  and put si,j in list L`+1 in this case. We eliminate si,j  from Ti . We then increment `, and repeat this step until  ` = k holds or no transitions are left in the lists Ti .  Clearly, the repeated execution of step 3 does look at each  transition at most once, so that O(|Re |) is an upper bound  for its complexity. Hence, we see that the entire algorithm  runs in time O(|Re | + |Se |).  Note that the above sketched algorithm works with a  depth-first search and therefore performs Ã¢Â€Â“ in theory Ã¢Â€Â“ better than breadth-first searches like those used by symbolic  model checking based on BDDs. However, in practice, the  latter approaches are in general superior.  The next step is to define a subset of JCTL that can be  computed without calls MoveFront(=, k, Ã‚Ë‡, Ã‚Ë‡). Clearly, we  must therefore forbid the interval constraints, and therefore are restricted to the basic operators EX[a,b] , EXÃ¢Â‰Ä½a ,  E[Ã‚Ë‡ U[0,a] Ã‚Ë‡], and EGÃ¢Â‰Ä½a only. Of course, we can still use  all macro operators that can be defined from these basic operators like, for example, E[ÄÂ• UÃ¢Â‰Â¤a ÄÂˆ] := E[ÄÂ• U[0,a] ÄÂˆ],  EFÃ¢Â‰Â¤a ÄÂ• := E[1 UÃ¢Â‰Â¤a ÄÂ•], and EGÃ¢Â‰Â¤a ÄÂ• := E[ÄÂ• U>a 1]  (cf. lemma 1). The following interesting theorem allows  us however to further extend this set of formulas:  Theorem 3 The following equations are valid, and therefore allow to reduce Ã¢Â‰Ä½ constraints to Ã¢Â‰Â¤ constraints:  Ã¢Â€Ë˜  Ã¢Â€Ë˜  Ã¢Â€Ë˜  Ã¢Â€Ë˜  Ã¢Â€Ë˜  Ã¢Â€Ë˜  Ã¢Â‰Â¤k  E[ÄÂ• UÃ¢Â‰Ä½k+1 ÄÂˆ] = EF (ÄÂˆ Ã¢ÂˆÂ¨ EXE[ÄÂ• U ÄÂˆ])  E[ÄÂ• BÃ¢Â‰Ä½k+1 ÄÂˆ] = EFÃ¢Â‰Â¤k (ÄÂ• Ã¢ÂˆÂ¨ EXE[ÄÂ• B ÄÂˆ])  EGÃ¢Â‰Ä½k+1 ÄÂ• = EFÃ¢Â‰Â¤k EXEGÄÂ•  A[ÄÂ• UÃ¢Â‰Ä½k+1 ÄÂˆ] = AGÃ¢Â‰Â¤k (ÄÂ• Ã¢ÂˆÂ§ AXA[ÄÂ• U ÄÂˆ])  A[ÄÂ• BÃ¢Â‰Ä½k+1 ÄÂˆ] = AGÃ¢Â‰Â¤k (Ã‚Å¹ÄÂˆ Ã¢ÂˆÂ§ AXA[ÄÂ• B ÄÂˆ])  AFÃ¢Â‰Ä½k+1 ÄÂ• = AGÃ¢Â‰Â¤k AXAFÄÂ•  Moreover, constraints Ã¢Â‰Ä½ 0 can be simply omitted due to  the equations E[ÄÂ• UÃ¢Â‰Ä½0 ÄÂˆ] = E[ÄÂ• U ÄÂˆ] and E[ÄÂ• BÃ¢Â‰Ä½0 ÄÂˆ] =  E[ÄÂ• B ÄÂˆ], and EGÃ¢Â‰Ä½0 ÄÂ• = EGÄÂ•.  The above equations allow us to split the temporal expressions on the left hand side into a quantitative and a qualitative part. The latter is a simple CTL formula, and can  therefore be directly checked on the Kripke structure that  is obtained by omitting the time constraints of the TKS.  As this is a normal CTL model checking problem, it follows that this can be computed in time O(|R| + |S|). The  other fixpoint, i.e., EFÃ¢Â‰Â¤k . . ., has a time constraint, but this  is now of type Ã¢Â‰Â¤. Observe now that EFÃ¢Â‰Â¤k ÄÂ• is equivalent to  E[1 U[0,k] ÄÂ•], and we already know how to compute that in  time O(|Re | + |Se |), i.e., in time O(ÄÂ„ÄšÂ‚K (|R| + |S|)).  For the proof, note that the last three equation (starting with A quantifiers are dual to the first three ones,  so that it is sufficient to prove the first three ones. The  third one can be reduced to the first one by the equation  EGÃ¢Â‰Ä½k+1 ÄÂ• = E[ÄÂ• UÃ¢Â‰Ä½k+1 0]. Also, the second equation can  be reduced to the first via the equation E[ÄÂ• BÃ¢Â‰Ä½k+1 ÄÂˆ] =  E[(Ã‚Å¹ÄÂˆ) UÃ¢Â‰Ä½k+1 (ÄÂ• Ã¢ÂˆÂ§ Ã‚Å¹ÄÂˆ)]. Hence, we only need to prove  the first equation, or equivalently, the fourth: For this  reason, it is convenient to rewrite the right hand side to  AGÃ¢Â‰Â¤k ÄÂ• Ã¢ÂˆÂ§ AGÃ¢Â‰Â¤k AXA[ÄÂ• U ÄÂˆ].  A[ÄÂ• UÃ¢Â‰Ä½k+1 ÄÂˆ] holds in a particular state s iff for all  such that  paths ÄÂ€ starting in s, there is a number i Ã¢ÂˆÂˆ  P  (j)  (i)  ÄÂ„  Ã¢Â‰Ä½  k  +  1,  (2)  K,  ÄÂ€  |=  ÄÂˆ,  and  (3)  Ã¢ÂˆÂ€j <  (1) iÃ¢ÂˆÂ’1  j=0 ÄÂ€  (j)  |= ÄÂ• holds. We may choose for any path ÄÂ€ the  i. K, ÄÂ€  least number i. In particular, let j be the least number for a  considered path ÄÂ€ such that (1) holds. Then, we have j Ã¢Â‰Â¤ i,  and therefore ÄÂ• must hold on each state ÄÂ€ (0) ,. . . , ÄÂ€ (jÃ¢ÂˆÂ’1) ,  which is captured in the first conjunct (AGÃ¢Â‰Â¤k ÄÂ•) of the right  hand side. In state ÄÂ€ (j) , we must furthermore demand that  A[ÄÂ• U ÄÂˆ] holds, and this is captured by the second conjunct.  Hence, we can now define the following subset JCTLÃ¢Â‰Â¤  of JCTL that consist of the formulas that we have found  to be efficiently checkable so far (we only list E quantified  formulas to avoid too much redundancies).  N  Definition 8 (The Fragment JCTLÃ¢Â‰Â¤ of JCTL) Given a  set of variables V, the set of JCTLÃ¢Â‰Â¤ formulas is the least  set satisfying the following rules, where ÄÂ• and ÄÂˆ denote  are arbitrary  arbitrary JCTLÃ¢Â‰Â¤ formulas, and a, b Ã¢ÂˆÂˆ  natural numbers, and Ã¢ÂˆÅºÃ¢ÂˆÂˆ {<, Ã¢Â‰Â¤, Ã¢Â‰Ä½, >}:  N  Ã¢Â€Ë˜  Ã¢Â€Ë˜  Ã¢Â€Ë˜  Ã¢Â€Ë˜  Ã¢Â€Ë˜  Ã¢Â€Ë˜  Ã¢Â€Ë˜  Ã¢Â€Ë˜  V Ã¢ÂŠÂ† JCTLÃ¢Â‰Â¤ , i.e, any variable is a JCTLÃ¢Â‰Â¤ formula  Ã‚Å¹ÄÂ•, ÄÂ• Ã¢ÂˆÂ§ ÄÂˆ, ÄÂ• Ã¢ÂˆÂ¨ ÄÂˆ Ã¢ÂˆÂˆ JCTLÃ¢Â‰Â¤  EX[a,b] ÄÂ• Ã¢ÂˆÂˆ JCTLÃ¢Â‰Â¤  EXÃ¢ÂˆÅºa ÄÂ• Ã¢ÂˆÂˆ JCTLÃ¢Â‰Â¤  E[ÄÂ• UÃ¢ÂˆÅºa ÄÂˆ] Ã¢ÂˆÂˆ JCTLÃ¢Â‰Â¤  EGÃ¢ÂˆÅºa ÄÂ• Ã¢ÂˆÂˆ JCTLÃ¢Â‰Â¤  E[ÄÂ• U<a ÄÂˆ] Ã¢ÂˆÂˆ JCTLÃ¢Â‰Â¤ and E[ÄÂ• UÃ¢Â‰Â¤a ÄÂˆ] Ã¢ÂˆÂˆ JCTLÃ¢Â‰Â¤  EF<a ÄÂ• Ã¢ÂˆÂˆ JCTLÃ¢Â‰Â¤ and EFÃ¢Â‰Â¤a ÄÂ• Ã¢ÂˆÂˆ JCTLÃ¢Â‰Â¤  Note that JCTLÃ¢Â‰Â¤ still contains CTL, but we believe that it is  strictly less expressive than JCTL, although we have not yet  a proof for this. As each temporal operator of JCTLÃ¢Â‰Â¤ can  be evaluated in time O(|Re | + |Se |), i.e., O(ÄÂ„ÄšÂ‚K (|R| + |S|)),  we immediately have the following result:  Theorem 4 (Complexity of JCTLÃ¢Â‰Â¤ ) For any TKS K =  (I, S, R, L) and any JCTLÃ¢Â‰Â¤ formula ÄÂ•, there is an algorithm to compute JÄÂ•KK in time O(|ÄÂ•| ÄÂ„ÄšÂ‚K (|R| + |S|)), where  ÄÂ„ÄšÂ‚K is defined as in theorem 2.  In comparison to the complexity of JCTL as given in theorem 2, the factor kÄšÂ‚ÄÂ• disappeared. This is due to the fact that  the temporal operators that belong to JCTLÃ¢Â‰Â¤ are all monotonic, so that the iterations can stop at least when all tracks  have been visited once.  The more important part is, however, that the equations  of theorem 3 enable us to reduce a considerable part of the  model checking to qualitative fixpoints. This is due to the  fact, that we can separate between a quantitative and a qualitative aspect in these formulas. Note again, that the qualitative fixpoint is computed on the abstract structure with an  ordinary CTL model checking procedure.  5. Conclusions  We have presented a new real-time temporal logic JCTL  that is directly defined on timed Kripke structures using interpretation I1 . This logic overcomes some semantic problems of previous real-time extensions of CTL and allows us  to use abstractions without loosing quantitative information.  We analysed the complexity of the JCTL model checking  problem and presented a non-trivial fragment JCTLÃ¢Â‰Â¤ that  can be checked more efficiently than JCTL. Our first experimental results are promising and allow to check practical  JCTLÃ¢Â‰Â¤ model checking problems in runtimes that are comparable to CTL model checking.  References  [1] R. Alur, C. Courcoubetis, and D. Dill. Model Checking  in Dense Real-time. Technical report, Stanford University,  University of Crete, 1991.  [2] J. Bengtsson, K. Larsen, F. Larsson, P. Pettersson, and W. Yi.  UPPAAL in 1995. In Tools and Algorithms for the Construction and Analysis of Systems, number 1055 in Lecture Notes In Computer Science, pages 431Ã¢Â€Â“434. SpringerVerlag, March 1996.  [3] S. Campos and E. Clarke. Real-Time Symbolic Model  Checking for Discrete Time Models. In T. Rus and C. Rattray, editors, Theories and Experiences for Real-Time System Development, AMAST Series in Computing. World Scientific Press, AMAST Series in Computing, May 1994.  [4] E. Clarke and E. Emerson. Design and Synthesis of Synchronization Skeletons using Branching Time Temporal  Logic. In D. Kozen, editor, Workshop on Logics of Programs, volume 131 of Lecture Notes in Computer Science,  pages 52Ã¢Â€Â“71, Yorktown Heights, New York, May 1981.  Springer-Verlag.  [5] E. Clarke, E. Emerson, and A. Sistla. Automatic Verification  of Finite-State Concurrent Systems Using Temporal Logic  Specifications. ACM Transactions on Programming Languages and Systems, 8(2):244Ã¢Â€Â“263, April 1986.  [6] E. Clarke, O. Grumberg, and D. Long. Model checking and  abstraction. ACM Transactions on Programming Languages  and systems, 16(5):1512Ã¢Â€Â“1542, September 1994.  [7] C. Daws, A. Olivero, S. Tripakis, and S. Yovine. The tool  KRONOS. In Hybrid Systems III, volume 1066 of Lecture  Notes in Computer Science. Springer, 1996.  [8] E. Emerson. Temporal and Modal Logic. In J. van Leeuwen,  editor, Handbook of Theoretical Computer Science, volume B, pages 996Ã¢Â€Â“1072, Amsterdam, 1990. Elsevier Science Publishers.  [9] E. Emerson, A. Mok, A. Sistla, and J. Srinivasan. Quantitative Temporal Reasoning. Journal of Real-Time Systems,  4:331Ã¢Â€Â“352, 1992.  [10] J. FrÄ‚Å›Ä‚ÂŸl, J. Gerlach, and T. Kropf. An Efficient Algorithm  for Real-Time Model Checking. In European Design and  Test Conference (EDTC), pages 15Ã¢Â€Â“21, Paris, France, March  1996. IEEE Computer Society Press (Los Alamitos, California).  [11] T. Henzinger, X. Nicollin, J. Sifakis, and S. Yovine. Symbolic Model Checking for Real-Time Systems. In IEEE  Symposium on Logic in Computer Science (LICS), pages  394Ã¢Â€Â“406, Santa-Cruz, California, June 1992. IEEE Computer Society Press.  [12] G. Logothetis and K. Schneider. Abstraction from counters:  An application on real-time systems. In Design, Automation and Test in Europe (DATEÃ¢Â€Â™2000), Paris, France, March  2000. IEEE Computer Society Press.  [13] G. Logothetis and K. Schneider. A new approach to the specification and verification of real-time systems. In EUROMICRO Conference on Real-Time Systems. IEEE/ACM, 2001.  http://goethe.ira.uka.de/fmg/ps/LoSc01.ps.gz.  [14] C. Loiseaux, S. Graf, J. Sifakis, A. Bouajjani, and S. Bensalem. Property preserving abstractions for the verification  of concurrent systems. Formal Methods in System Design,  6:1Ã¢Â€Â“35, February 1995.  [15] J. Queille and J. Sifakis. Specification and verification of  concurrent systems in CESAR. In International Symposium  in Programming, 1981.  [16] J. Ruf and T. Kropf. Using MTBDDs for discrete timed symbolic model checking. Multiple-Valued Logic Ã¢Â€Â“ An International Journal, 1998. Special Issue on Decision Diagrams.  [17] F. Somenzi.  CUDD: CU decision diagram package,  release 2.3.0, 1998.  ftp://vlsi.colorado.edu/pub/ and  http://vlsi.Colorado.EDU/. 