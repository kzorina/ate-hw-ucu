arXiv:0812.1967v1 [cs.LO] 10 Dec 2008  Decomposition of Decidable First-Order Logics over Integers and Realsâ  Florent Bouchy, Alain Finkel  LSV, ENS Cachan, CNRS  CNRS UMR 8643, Cachan, France  {bouchy,finkel}@lsv.ens-cachan.fr  JĂŠrĂ´me Leroux  Laboratoire Bordelais de Recherche en Informatique  CNRS UMR 5800, Talence, France  leroux@labri.fr  Abstract  we want to be able to use integers as parameters for a  concise representation of pure reals : for instance, reals are  used for the values of clocks and integers for expressing the  parameters in CPDBM.  We tackle the issue of representing infinite sets of realvalued vectors. This paper introduces an operator for combining integer and real sets. Using this operator, we decompose three well-known logics extending Presburger with reals. Our decomposition splits a logic into two parts : one  integer, and one decimal (i.e. on the interval [0, 1[). We also  give a basis for an implementation of our representation.  Fortunately, the first-order additive logic over integers  and reals is decidable. Nevertheless, the algorithmic of  sets combining integers and reals does not seem simple,  even when it is based on finite automata like Real Vector  Automata [13, 16] or weak RVA [8], or based on quantifier  elimination [29].  1 Introduction  For that matter, the algorithmic of Presburger (using  finite automata) and variations of DBM are quite efficient.  Hence, our idea is to reduce the algorithmic difficulty of the  first-order additive logic of integers and reals (and of some  subclasses and decidable extensions) by decomposing a  complex set of integers and reals into a finite union of  sums of integer sets and decimal sets. By decimal, we  mean numbers in the dense inteval [0, 1[ ; then, we define  a new class of sets as follows. Given n sets of integers  (Zi )0â¤iâ¤n and n sets of decimals (Di )0â¤iâ¤n , we introduce  the operator finite union of sums, which builds the finite  unions of the sums Zi + Di . This class is shown stable  under boolean operations, cartesian product, quantification  and reordering if both of the two initial classes are also  stable.  Verification (and model-checking in particular) of  infinite systems like timed automata [1] (and hybrid  systems) and counter systems [5] need good symbolic  representation classes ; by good, we mean having closure  properties (by first-order logic operators) and decidability  results (for testing inclusion and emptiness). Presburger  arithmetic [27, 23] enjoys such good properties, and some  efficient implementations (using finite automata) have  been intensively used for the analysis of counter systems  [6, 20, 14, 15].  Despite the fact that the complete arithmetic on reals  is decidable [28], only some restricted classes of the firstorder additive logic of reals (DBM, CPDBM, finite unions  of convex polyhedra) have been used for the analysis of  timed automata. This is mainly due to the fact that the  algorithmic complexity of DBM is polynomial, which  is the basis of efficient verification algorithms for timed  automata in U PPA AL [11, 25].  One of our aims is then to re-use, in combining the  best representations of these two initial sets (Zi )0â¤iâ¤n  and (Di )0â¤iâ¤n , the best libraries dealing with them to  efficiently handle finite unions of (Zi + Di )0â¤iâ¤n (for  instance : P RES TAF [7] for the integers and PPL [4] for  the reals).  However, we would like to be able to use both integers  and reals, for at least two reasons. First, we want to analyse  timed counter systems [2, 3, 13] in which the reachability  sets contain vectors with both integers and reals. Second,  We show that three of the main classes of mixed integer  and real sets are in fact finite unions of sums of well-known  classes. We prove that finite unions of sums of Presburger  set of integers, and sets definable in the first-order additive  logic of decimals are exactly the sets definable in the  â Work supported by the Agence Nationale de la Recherche, grant  ANR-06-SETIN-001.  1  (ci,j , âşi,j ) means that ri â rj âşi,j ci,j , where ri , rj are  clocks. Thus, each element of a DBM represents a diagonal  constraint (i.e. a bounded difference). Finally, terms that  do not represent any actual constraint are symbolized by  ci,j = +â.  first-order logic of integers and reals. The finite unions  of CPDBM are expressible as the finite unions of sums of  Presburger-definable sets and DBM-definable decimal sets.  Moreover, when we go beyond Presburger by considering  RVA, we show that the class of sets representable by  RVA in basis b is the finite unions of sums of Presburger  extended with a predicate Vb (which gives integer powers  in base b) and the additive logic of decimals extended with  a predicate Wb (which, similarily to Vb , gives negative  powers in base b).  2.2 About extensions of DBM  On the following example taken from [9], the timed automaton features 2 clocks x and y, and a unique location.  The automatonâs behaviour is very simple : y is reset to 0 as  soon as it reaches 1, while x flows continually. In the initial  state, the clocks are both set to 0. Moreover, an invariant in  the location ensures that y never exceeds 1.  2 Representations mixing integers and reals  In this section, we motivate our work with a small  example of timed automaton. We show that extracting  integers from reals can yield more concise formula than  pure reals. Then we introduce an operator combining  integer and real sets of vectors.  y := 0  x := 0  x âĽ 1 â§ y = 1,  y := 0  (y â¤ 1)  2.1 Timed Automata and DBM  The clock diagram associated to the automaton explicitely shows this behaviour :  In order to study real-life systems involving behaviours  that depend on time elapsing, timed automata are probably  the most used and well-known model for such systems.  As described in [1], the basic idea of timed automata is to  add real-valued variables (called clocks) to finite automata.  These clocks model temporal behaviours of the system,  flowing at a universal constant rate ; each clock can be compared to an integer constant, and possibly reset to 0. The  only other guard allowed is called a diagonal constraint,  consisting in comparing the difference of two clocks to  an integer constant. As the clocksâ values are unbounded,  the state-space generated by a timed automaton is infinite ;  therefore, regions are used to model a finite abstraction  of the systemâs behaviour. Practically intractable because  of its size, the region graph is then implemented as zones  in most verification tools [11, 25, 18, 24] modelling such  real-time systems.  y  2  1  0  1  2  3  4  5  x  A classical forward analysis [17] is considered here,  by computing the reachable states (i.e. location Ă  clock values) from the initial one (where x = y = 0).  Then, we build the corresponding zones, each zone being  represented by a DBM ; here, we have an infinite yet countable set of DBM as follows. Note that in this example âş is  always â¤ ; therefore, we will omit it in the matrices.  ďŁą  ďŁ´  ďŁ´  ďŁ˛  Technically, zones are represented by Difference Bound  Matrices (DBM) [12, 21] in these tools. A DBM is a square  matrix representing the constraints between n clocks defining a zone. Here, we see a DBM as a tuple (c, âş), where  c = (ci,j )0â¤i,jâ¤n , âş = (âşi,j )0â¤i,jâ¤n , ci,j â Z âŞ {+â},  and âşi,j â {â¤, <}. Each element of this tuple is an element  of the square matrix, defining a DBM set as follows :  ^  ri â rj âşi,j ci,j }  Rc,âş = {r â Rn |  ďŁ´  ďŁ´  ďŁł  0  0  x  y  ďŁŤ  x  0  âi  ďŁ­i + 1 0  1  âi  y  ďŁś  0  iďŁ¸  0  ďŁź  ďŁ´  ďŁ´  ďŁ˝  ďŁ´  ďŁ´  ďŁž  iâĽ0  In order to make the state-space computable, abstraction  techniques are used to get a finite number of zones. The  abstraction being used in most model-checkers is based on  maximum constants : a clock câs valuation is considered  equal to â as soon as it exceeds the maximal constant to  which c is ever compared. On the example, if a guarded  transition x âĽ 106 leads to another state, then the clock  diagram becomes as follows :  0â¤i,jâ¤n  In order to deal with constraints involving only one clock,  the fictive clock r0 is always set to the value 0. An element  2  y  the union of the following three sums suffices :      {0, . . . , 106 â 1} Ă {0} +    [  {106 } Ă {0} +    [  {106 + 1, . . . , â} Ă {0} +  2  1  0  1  More formally,  of DBM :  ďŁąďŁą  ďŁ´  x  ďŁ´ ďŁŤ 0  ďŁ´  ďŁ´  ďŁ˛0  ďŁ˛ďŁ´  0  âi  ďŁ´ x ďŁ­i + 1 0  ďŁ´  ďŁ´  ďŁ´  ďŁ´  ďŁłďŁł y  1  âi  2  Âˇ Âˇ Âˇ 106  x  this abstraction yields the following set  ďŁź  ďŁ´  ďŁś ďŁ´  ďŁ˝  0  y  0  iďŁ¸ ďŁ´  ďŁ´  ďŁž  0  0â¤iâ¤106  ,  0  ďŁŤ  0  x ďŁ­â  y  1  x  â  0  â106  This latter symbolic representation of such a reachability set is much smaller than DBM. Indeed, representing  zones with DBM implies memorizing a possibly huge  number of matrices, depending on the maximal constant  for the clocks (one million, in this example). However, by  introducing integers to express periodicity, we can reduce  the representation to three small combinations of intervals.  Moreover, we can even get rid of the abstraction, so as  to get an exact representation for the same cost. CPDBM  also have these advantages, but are undecidable because  of the multiplication. Hence, let us specify a little more  what is our representation : we take finite unions of reals,  real numbers being decomposed as sums of integers and  smaller reals (called decimals). These integers and reals  can be defined using quantification, addition, and boolean  operators.  ďŁź  ďŁ´  ďŁśďŁ´  ďŁ´  0 ďŁ˝  âďŁ¸ďŁ´  ďŁ´  ďŁž  0 ďŁ´  y  This set of DBM is finite, but remains huge : 106 + 2  matrices need to be computed and memorized, which  seems exaggerated, a fortiori for such a simple example. In  [9], a more elaborate abstraction is proposed : the clocksâ  maximal constants are no more global to the system,  but location-dependent. Another abstraction technique  is proposed in [10], distinguishing between upper and  lower bounds within maximal constants. To the best of  our knowledge, these are the only zone-based abstraction  techniques ; in each of them, the number of DBM still  heavily depends on maximal constants.  Actually, our approach comes down to representing sets  of real numbers by extracting their integer components ;  the interesting point is that adding integers to real sets can  simplify their representation and ease their handling. One  might think that adding integers to such a first-order real  logic would make it undecidable, but section 3 proves the  opposite. Before that, we need to formalize our representation.  Writing here such an infinite or huge number of DBM  would have been impossible ; therefore, we naturally used a  parametric representation of these DBM. Actually, this idea  is also used by Constrained Parametric DBM (CPDBM)  [2], which is the data structure implemented in the TR E X  [3] model-checker. CPDBM are indeed a more expressive  version of DBM, extended in two steps. First, we consider  PDBM, in which ci,j constants become ti,j arithmetical  terms (the parameters). Such arithmetical terms t are given  by the grammar t ::= 0 | 1 | x | t â t | t + t | t â t,  where x belongs to a set X of real variables. Second, a  PDBM becomes a CPDBM as terms are constrained by  quantifier-free first-order formulas Ď. Such formulas are  defined by Ď ::= t â¤ t | ÂŹĎ | Ď â¨ Ď | Is_int(t) (where the  predicate Is_int(t) is true iff t is an integer). Each of the  two sets of matrices hereinabove is in fact a single CPDBM.  2.3 Composing integers and reals  Notations. The set [0, 1[ is denoted by D in the sequel.  We also call a decimal (number) any d â D, and a  decimal set any D â D. We write x to denote a vector  (x1 , . . . , xn ). Sometimes, in order to be concise, we use  FO (. . . ) to denote the sets represented by this first-order  logic. However, it does not make our statements incorrect,  because we mostly discuss the expressive power of such  logics.  Consider now another way to represent the set of reachable clock values. On the second diagram showing the abstraction, we can see an obvious regular pattern along x,  ,  , and  . We define  defined by three shapes :  = {(x, y) â [0, 1]2 | x = y},  each shape as follows :  = {(x, y) â [0, 1]2 | x âĽ y}, and = {(x, y) â [0, 1]2 }.  If we want to represent the same set as the previous abstracted zones, but without DBM, we can express the periodicity of each pattern with integers. To formalize it, taking  Let Z â P(Zn ) and D â P(Dn ) ; we will assume in  this paper that we are using nâdimensional vectors, with  n â N. We denote by1 Z â D the class of real vectors  p  [  (Zi + Di ), with (Zi , Di ) â Z Ă D  R â Rn s.t. R =  i=1  1 The  symbol â is sometimes used for the disjoint union, but we do not  use such unions in this paper.  3  S  Definition 5. A class R â nâN P(Rn ) is stable if it is  closed under boolean operations, cartesian product, quantification, and reordering.  and p âĽ 1.  Here are some examples of simple sets that might be often used, written as finite unions of sums of integers and  decimals :  Notice that taking the union of two such sets is trivial, as  they are already unions of integer and decimal parts. Then,  observe that (Z1 +D1 )âŠ(Z2 +D2 ) = (Z1 âŠZ2 )+(D1 âŠD2 )  for any Z1 , Z2 â Zn and for any D1 , D2 â Dn ; thus,  the stability by union of Zn â Dn provides the stability by  intersection. From the equality (Z1 + D1 )\(Z2 + D2 ) =  ((Z1 \Z2 ) + D1 ) âŞ (Z1 + (D1 \D2 )) we get the stability by  difference. The stability by cartesian product is provided by  (Z1 + D1 ) Ă (Z2 + D2 ) = (Z1 Ă Z2 ) + (D1 Ă D2 ). The  stability by projection comes from âi R = (âi Z) + (âi D),  where R = Z + D. Finally, the stability by reordering is  obtained thanks to Ď(Z + D) = (ĎZ) + (ĎD). We have  proved the following proposition, which is later used in the  proofs of theorem 7 and proposition 10 :  Example 1. The empty set â is written â + â. The set Rn is  written Zn + Dn . The set Zn is written Zn + {0}.  Example 2. The set R= = {r â R2 | r1 = r2 } is written  {z â Z2 | z1 = z2 } + {d â D2 | d1 = d2 }  Example 3. The set Râ¤ = {r â R2 | r1 â¤ r2 } is written :  {z â Z2 | z1 â¤ z2 } + {d â D2 | d1 â¤ d2 }  [  {z â Z2 | z1 < z2 } + {d â D2 | d1 > d2 }  3  Example  S 4. The set R+ 3= {r â R | r1 + r2 = r3 } is  written câ{0,1} {z â Z | z1 + z2 + c = z3 } + {d â  D3 | d1 + d2 = d3 + c}, where c denotes a carry.  Proposition 6 (Stability). The class Z â D is stable if Z and  D are stable.  The limits of our representation can be seen with  the following counter-example.  Consider the set      â   [  1  {j} +  R =  ; note that we use j + 1  j+1  j=1  3 First-order additive logic over integers and  reals  Using at the same time integers and reals in the whole  arithmetic is known to be undecidable. However, when  multiplication is left apart, the first-order additive logic is  decidable ; its decidability has been suggested by BĂźchi,  then proved by [16] with automata and by [29] using  quantifier elimination. Actually, it can be seen as the  Presburger logic [27] extended to the reals. This firstorder logic FO (R, Z, +, â¤) can encode complex linear constraints combining both integral and real variables. In this  section we prove that sets definable in this logic can be decomposed into finite unions of Z + R where Z is definable in FO (Z, +, â¤) and R is definable in FO (D, +, â¤).  This result proves that complex linear constraints combining integral and real variables can be decomposed into linear constraints over integers, and linear constraints over reals. More precisely, we prove the following decomposition :  (and not simply j) to avoid the case where the decimal part  is 1j = 1 for j = 1 (because it would not be a decimal,  i.e. in [0, 1[). Our representation can not deal with such  a set ; indeed, despite the fact that it is a union of sums  of integers and decimals, we can see that the union is  inherently infinite. We insist on the finiteness of the union  in our representation, mainly for implementability reasons ;  this will be discussed in section 5.  Now, let us consider  S  S the stability of our representation.  We prove2 that if Z â nâN P(Zn ) and D â nâN P(Dn )  are stable by theSclassical first order operations then the  class Z â D = nâN Zn â Dn where Zn = Z âŠ P(Zn )  and Dn = D âŠ P(Dn ) is also stable by these operations.  The operations we consider are : boolean combinations  (union, intersection, difference), cartesian product, quantification, and reordering. We use the following definitions for these last two operations. First, quantification is  done by projecting away variables from the considered vector : âR â Rn , âi R = {(r1 , . . . , riâ1 , ri+1 , . . . , rn ) |  âri (r1 , . . . , riâ1 , ri , ri+1 , . . . , rn ) â R}. Second, a reordering is a mere permutation function Ď of the variables  order in a vector : âR â Rn , ĎR = {(rĎ(1) , . . . , rĎ(n) ) |  (r1 , . . . , rn ) â R}. Then, we introduce a generic definition  for stability :  Theorem 7. FO (R, Z, +, â¤)  FO (D, +, â¤).  =  FO (Z, +, â¤) â  Proof. First of all, observe that any set definable in the  logic FO (Z, +, â¤) â FO (D, +, â¤) is also definable in  FO (R, Z, +, â¤). Conversely, the sets R and Z, the function + : R Ă R â R and the predicate â¤ are definable  in FO (Z, +, â¤) â FO (D, +, â¤) from examples 1, 2, 3, 4.  Thus, stability by first order operations provides the inclusion FO (R, Z, +, â¤) â FO (Z, +, â¤) â FO (D, +, â¤). We  deduce the equality.  2 Here we have to take unions, depending on the number of dimensions,  for a technical purpose : the projection of a component in the vector.  4  formula Ď(x)Sdenoting a set Z â Zn and let us prove that  Z + D is a CP-DBM+ set. Observe that r â Z + D  if and only if there exists z â Z such thatVr â z â D.  The condition r â z â D is equivalent to 0â¤i,jâ¤n ri â  rj âşi,j ci,j +zi âzj . Let us consider the Presburger formula  Ď(p) := âz â Zn pi,j = ci,j + zi â zj and observe that  RĎ,âş = Z + D. We have proved the inclusion â.  For the converse inclusion, let us consider a CP-DBM+  set RĎ,âş . Let Zd = Zn âŠ (RĎ,âş â d) indexed by d â Dn .  Observe that Zd is actually the following set of vectors :  ďŁź  ďŁą  ďŁ˝  ^  [ ďŁ˛  zi â zj âşi,j ci,j + (dj â di )  z â Zn |  Zd =  ďŁž  ďŁł  Now, let us recall that sets definable in the Presburger  logic FO (Z, +, â¤) can be characterized thanks to linear  sets [23]. In fact, a set Z â Zn is definable in this logic if  and only if it is equal to a finite union of linear sets b + P â  finite subset of Zn , and P â denotes  where b â Zn , P is a P  k  the set of finite sums i=1 pi with p1 , . . . , pk â P and  k â N. This geometrical characterization can be extended  to the class of sets definable in FO (Z, +, â¤)âFO (D, +, â¤)  by introducing the class of polyhedral convex sets. A set  C â Rn is said polyhedral convex if C is defined by a finite conjunction of formulas hÎą, xi âş c where Îą â Zn ,  âşâ {â¤, <} and c â Z. Recall that a Fourier-Motzkin quantification elimination proves that a set C â Rn is definable  in FO (R, +, â¤) if and only if it is equal to a finite union of  polyhedral convex sets. In [22], the authors have proved the  following geometrical characterization :  A set R â Rn is definable in FO (R, Z, +, â¤) if and only if  it is equal to a finite union of sets of the form C + P â where  C â Rn is a polyhedral convex set and P is a finite subset  of Zn .  0â¤i,jâ¤n  c|=Ď  Since dj â di â ]â1, 1[ and zi â zj , ci,j â Z we deduce that  zi â zj âşi,j ci,j + (dj â di ) is equivalent to zi â zj â¤ ci,j  if di â dj âşi,j 0 and it is equivalent to zi â zj â¤ ci,j â 1  otherwise. Given a matrix m = (mi,j )0â¤i,jâ¤n such that  mi,j â {0, 1} for any 0 â¤ i, j â¤ n, we denote by Im and  Dm the following sets:  ^  zi â zj â¤ ci,j â mi,j }  Im = {z â Zn | âc Ď(c) â§  3.1 Decomposing DBM-based representations  0â¤i,jâ¤n  In this section,  we characterize an extension of DBM. We  S  denote by DBMD the finite  Sunions of DBM sets which are  included in Dn . Notice that DBMD is stable by first order  operations, thanks to a Fourier-Motzkin quantifier elimination.  Dm = {d â D |  n  ^  (di â dj âşi,j 0 ââ mi,j = 0)}  0â¤i,jâ¤n  Note that  set and Zd = Im for any  S Dm is a DBM  S d â Dm .  n  D  =  From S  we  deduce  that  R  =  D  m  Ď,âş  m  dâDn Zd +  We have proved that RĎ,âş is defin{d} = m Im + Dm . S  able in FO (Z, +, â¤) â DBMD .  A CP-DBML is a DBM where the vector c is no longer a  constant, but a vector of parameters constrained by a formula Ď(c) defined in a logic L. More precisely, a CPDBML is a tuple (Ď, âş) representing a set RĎ,âş s.t. :  [  Rc,âş  RĎ,âş =  4 Beyond Presburger  We have just shown our decomposition to be working on  FO (R, Z, +, â¤) and below. Now, we prove that it can also  be used on more expressive logics. We take the example of  Real Vector Automata (RVA) [16], which is, to the best of  our knowledge, the most expressive decidable implemented  representation for sets of real and integer vectors. RVA are  used in the tool LASH [14, 15]. In this section, the class of  sets representable by RVA is proved decomposable into our  formalism.  c|=Ď  As introduced in [2], CPDBM correspond to CP-DBML  where L is the first-order arithmetic without quantifiers ;  in particular, multiplication is allowed in this formalism.  In this section, we study another variation of DBM :  CP-DBM+ , which is CP-DBML where L is the decidable  Presburger logic FO (Z, +, â¤). That is, CP-DBM+ are  CPDBM with  S quantifiers but without multiplication. We  denote by CP-DBM+ the finite unions of RĎ,âş , i.e. finite  unions of CP-DBM+ sets.  Let b âĽ 2 be an integer called the basis of decomposition.  We denote by ÎŁb = {0, . . . , bâ1} the finite set of digits and  by Sb = {0, b â 1} the set of sign digits. An infinite word  Ď = sa1 . . . ak âak+1 ak+2 . . . over the alphabet ÎŁnb âŞ{â} is  said b-correct if s â Sbn and ai â ÎŁnb for any i âĽ 1. In this  case, Ď is called a most significant digit first decomposition  of the following real vector Ďb (Ď) â Rn :  ďŁś  ďŁŤ  X  s  +  bâi ai ďŁ¸  Ďb (Ď) = bk ďŁ­  1âb  We show that finite unions of CP-DBM+ sets are in fact  a combination of Presburger-definable sets and finite unions  of DBM decimal sets :  S  Proposition  8. We have CP-DBM+ = FO (Z, +, â¤) â  S  DBMD .  Proof. Let us first prove the inclusion â. Let us consider  a DBM (c, âş) denoting a set D â Dn and a Presburger  iâĽ1  5  (i.e. without Wb ). Just remark that FO (R, Z, +, â¤, Vb ) =  FO (Z, +, â¤, Vb ) â FO (D, +, â¤). Finally, note that weak  RVA are used in the tool LIRA [8], whose benchmarks  show very efficient computation times for sets defined in  FO (R, Z, +, â¤).  A Real Vector Automaton (RVA) in basis b is a BĂźchi automaton A over the alphabet ÎŁnb âŞ {â} such that the language Lan(A) recognized by A contains only b-correct  words. The set JAK represented by A is defined by JAK =  {Ďb (Ď) | Ď â Lan(A)}. A set R â Rn is said brecognizable if there exists a RVA A in basis b such that  R = JAK.  5 Towards an implementation  According to [16], the class of b-recognizable sets can be  logically characterized by FO (R, Z, +, â¤, Xb ) where Xb is  an additional predicate. The predicate Xb over R3 is such  that Xb (x, u, a) is true if and only if there exists a most significant digit first decomposition Ď = sa1 . . . ak â ak+1 . . .  of x and an integer i â N such that ai = a and u = bkâi .  From an implementation perspective, our decomposition  has been designed to fit G ENEPIâs requirements. G ENEPI  [26] is a modular framework supporting Presburger-based  solvers and model-checkers, distributed under GNU Public  License. Its core consists of a plugin manager, which  computes generic operations (such as boolean operations, quantification, satisfiability) on sets encoded as the  solutions of Presburger-like formulas. Different implementations of these operations can be used as plugins ;  existing ones include P RES TAF, LIRA, LASH, MONA,  OMEGA, and PPL. We have begun to design a plugin for  our decomposition, which uses two existing plugins : one  for the integer part, and one for the decimal part.  Theorem 9. [16] A set R â Rn is b-recognizable if and  only if it is definable in FO (R, Z, +, â¤, Xb ).  In order to provide a decompostion of  FO (R, Z, +, â¤, Xb ), the predicate Xb is proved expressible  by two valuation functions Vb and Wb where :  â˘ Vb : Z\{0} â Z is the integer valuation function introduced in [19] and defined by Vb (z) = bj , where  j â Z is the greatest integer such that bâj z â Z.  Once this plugin is ready, any combination of two other  plugins is possible : for example, one could try P RES TAF  over integers and PPL over decimals. One could even  be curious and study the efficiency of two instances of  LIRA plugins, each one working on its own part (integer  or decimal). Another benefit, coming from the new decomposition of RVA, would be to use the LASH plugin only  on one part, and manage the other one differently : this  might improve the effectiveness of RVA, which are very  expressive but not really efficient in practice. So far, our  first tests on small conjunctions of linear constraints show  execution times close to the ones of LIRA.  â˘ Wb : D\{0} â D is the decimal valuation function defined by Wb (d) = bj , where j â Z is the least integer  such that bâj d 6â D.  By expressing Xb in FO (R, Z, +, â¤, Vb , Wb )  and Vb , Wb in FO (R, Z, +, â¤, Xb ) we deduce that  FO (R, Z, +, â¤, Xb ) = FO (R, Z, +, â¤, Vb , Wb ). Finally,  from proposition 6 and theorem 7, we get the following  proposition.  Proposition  10.  FO (R, Z, +, â¤, Xb )  FO (Z, +, â¤, Vb ) â FO (D, +, â¤, Wb ).  =  What we need now for an implementation is a unique  way to represent sets. Indeed, in order to avoid unduly  complicated representations of sets, we have to make  our representation canonical. Therefore, let us set the  theoretical framework we use in practice.  Moreover, it is clear that the logic FO (Z, +, â¤, Vb ) â  FO (D, +, â¤, Wb ) extends FO (Z, +, â¤) â FO (D, +, â¤).  However, even if the function Wb is crucial to logically  characterize the class of b-recognizable sets, this predicate  is not used in practice. In fact, in order to get efficient algorithms for manipulating BĂźchi automata (more precisely,  minimization and determinization), we only consider sets  R â Rn that can be represented by a weak RVA [14]. Recall that a BĂźchi automaton A is said weak if any strongly  connected component S satisfies S â F or S âŠ F = â,  where F is the set of accepting states. Unfortunately, the  class of sets R â Rn representable by a weak RVA is  not logically characterized since this class is not stable by  first order operations (because of projection). In practice,  since any set R â Rn definable in FO (R, Z, +, â¤, Vb ) can  be represented by a weak RVA, the RVA symbolic representation is only used for representing sets in this logic  Let Z â P(Zn ) and D â P(Dn ). Notice that if R =  (Z +D1 )âŞ(Z +D2 ), then R = Z +D with D = D1 âŞD2 ;  we will always suppose that D is closed under union wlog.  Then, notice that R â Rn can be represented by a partially  defined function fR such that :  fR : Z ââ D  Zi 7ââ Di  This  functionâs  interpretation  is  defined  as  p     [  Zi + fR (Zi ) , which matches the natuJfR K =  i=1  6  fâ¤ (Zâ¤ ) = Dâ¤ and fâ¤ (Z) = â otherwise where:  ral writing of R introduced in section 2.3. Note that this  representation fR is not unique.  Z< = {z â Z2 | z1 < z2 }  Zâ¤ = {z â Z2 | z1 â¤ z2 }  For technical reasons, we extend fR to a totally defined function fR s.t. fR (Z) = â if Z â  / dom(fR ) and  fR (Z) = fR (Z) otherwise. Moreover, we define the  support of fR as supp(fR ) = {Z | fR (Z) 6= â}. In the  remainder of this paper, we will use without ambiguity the  notation fR instead of fR .  D> = {d â D2 | d1 > d2 }  Dâ¤ = {d â D2 | d1 â¤ d2 }  Example 16. The set R+ = {r â R3 | r1 + r2 = r3 }  is represented by the IDF f+ defined by f+ (Z0 ) = D0 ,  f+ (Z1 ) = D1 , f+ (â) = D3 \(D1 âŞ D2 ) and f+ (Z) = â  otherwise where (intuitively c â {0, 1} denotes a carry) :  Zc = {z â Z3 | z1 + z2 + c = z3 }  Dc = {d â D3 | d1 + d2 = d3 + c}  We are now able to represent the set R with a function  we wish to handle. Therefore, we want to identify fR and  JfR K : in order to do so, this latter interpretation has to be  an injection. Generally, this is not the case : using the previous definitions, we could have different writings of JfR K.  However, if the images by fR are disjoint, then the interpretation JfR K is an injection. Finally, for effectivity reasons,  we will only consider functions whose support is finite. In  the remainder of this section, we formalize this reasoning.  Let FZâD = {f : Z ââ D | supp(f ) is finite}.  Observe that any set in JIDFZn âDn K is in Zn âDn . The  converse is obtained by proving the following proposition :  Proposition 17 (Closure by union). Let R  â  JIDFZn ââDn K. Then, for any Z â Zn and D â Dn , we  also have R âŞ (Z + D) â JIDFZn âDn K.  Proof. We consider an IDF f : Zn ââ Dn such that Jf K =  R and two sets Z â Zn and D â Dn . We must prove that  there exists an IDF f â˛ : Zn ââ Dn such that Jf â˛ K = Râ˛  with Râ˛ = RâŞ(Z+D). We consider the following function:  Definition 11. The interpretation function J.K associates  to every f â FZâD a set   of real vectors defined by  [  Z + f (Z) .  Jf K =  f â˛ : Zn  Z  Zâsupp(f )  Notice that since supp(f ) is finite, FZâD do not suffice to represent every set of real vectors, as shown in the  counter-example on page 4. Let us now restrict ourselves to  the functions we handle :  â˛  ââ   Dn    ââ  f (Z â˛ )\D  [  Z â˛â˛ | Z â˛â˛ âŞZ=Z â˛    f (Z â˛â˛ ) âŠ D    As expected we are going to prove that f â˛ is an IDF such  that Jf â˛ K = Râ˛ .SWe first show that f â˛ is an IDF. First of  all observe that Z â˛ f â˛ (Z â˛ ) = Dn . Next, let Z1â˛ , Z2â˛ â Zn  such that f â˛ (Z1â˛ ) âŠ f â˛ (Z2â˛ ) 6= â then either (f (Z1â˛ )\D) âŠ  (f (Z2â˛ )\D) 6= â or there exists Z1â˛â˛ , Z2â˛â˛ such that Z1â˛â˛ âŞ Z =  Z1â˛ and Z2â˛â˛ âŞ Z = Z2â˛ and (f (Z1â˛â˛ ) âŠ D) âŠ (f (Z2â˛â˛ ) âŠ D) 6= â  since the other cases are not possible. But (f (Z1â˛ )\D) âŠ  (f (Z2â˛ )\D) 6= â implies f (Z1â˛ ) âŠ f (Z2â˛ ) 6= â and since f is  an IDF we get Z1â˛ = Z2â˛ . And (f (Z1â˛â˛ )âŠD)âŠ(f (Z2â˛â˛ )âŠD) 6=  â implies Z1â˛â˛ = Z2â˛â˛ and in particular Z1â˛ = Z2â˛ . We have  proved that f â˛ is an IDF. Finally, equality Jf â˛ K = Râ˛ comes  from:  [  Jf â˛ K = (Z â˛ + f â˛ (Z â˛ ))  Definition 12. An IDF (Integer-Decimal  Function) is a  S  function f â FZâD such that Z f (Z) = Dn and such  that Z 6= Z â˛ =â f (Z) âŠ f (Z â˛ ) = â. We denote them all  by IDFZâD = {f â FZâD | f is an IDF}. We also write  JIDFZâD K = {Jf K | f â IDFZâD }.  The sets from examples 1, 2, 3, 4 are represented by the  following IDF :  Example 13. The empty set â is represented by the IDF fâĽ  defined by fâĽ (Z) = â for any Z 6= â and by fâĽ (â) = Dn .  The set Rn is represented by the IDF fâ¤ (also noted fRn )  defined by fâ¤ (Zn ) = Dn and fâ¤ (Z) = â otherwise. The  set Zn is represented by the IDF fZn defined by fZn (Zn ) =  {0} and fZn (Z) = â otherwise.  Zâ˛  =  [  (Z â˛ + (f (Z â˛ )\D))  Zâ˛  [  Z â˛â˛ | Z â˛â˛ âŞZ=Z â˛  Example 14. The set R= = {r â R2 | r1 = r2 } is  represented by the IDF f= defined by f= (Z= ) = D= ,  f= (â) = D2 \D= and f= (Z) = â otherwise, where:  =    (Z â˛ + (f (Z â˛â˛ ) âŠ D))  [  [  (Z â˛ + (f (Z â˛ )\D)) ((Z â˛â˛ âŞ Z) + (f (Z â˛â˛ ) âŠ D))  Zâ˛  Z â˛â˛  [  = (Z â˛â˛ + ((f (Z â˛â˛ )\D) âŞ (f (Z â˛â˛ ) âŠ D)))  Z= = {z â Z2 | z1 = z2 } D= = {d â D2 | d1 = d2 }  Z â˛â˛  [  âŞ (Z + D âŠ ( f (Z â˛â˛ )))  Example 15. The set Râ¤ = {r â R2 | r1 â¤ r2 } is  represented by the IDF fâ¤ defined by fâ¤ (Z< ) = D> ,  Z â˛â˛  = Jf K âŞ (Z + D)  7  no algorithm computing directly the convex hull of a set  defined in FO (R, Z, +, â¤) ; but thanks to our decomposition, the problem reduces to the computation of the convex  hull of Presburger-definable sets (as automata [19] or as  semi-linear sets [23]), and the convex hull of sets definable  in FO (D, +, â¤) (as finite unions of convex sets, using  Fourier-Motzkin). We can push this reasoning to other  symbolic representations and to other operations, such as  upward or downward closure.  Hence, we have just proved the following proposition :  Proposition 18. Zn â Dn = JIDFZn âDn K  Let us prove that this new representation is canonical :  Proposition 19. For any f1 , f2 â IDFZâD , Jf1 K =  Jf2 K =â f1 = f2 .  Proof. Consider Z1 â Zn and let us prove that f1 (Z1 ) â  f2 (Z1 ). Naturally, we can assume that f1 (Z1 ) 6= â since  otherwise the inclusion is immediate. In this case, there  exists d â f1 (Z1 ). As (f2 (Z))Z forms a sharing of Dn ,  there exists Z2 such that d â f2 (Z2 ). Let us prove that  Z1 â Z2 . We can assume that Z1 6= â. Let z1 â Z1 and  observe that r1 = z1 + d â Jf1 K and from Jf1 K = Jf2 K  we get r1 â Jf2 K. Thus, there exists Z2â˛ such that r1 â  Z2â˛ + f2 (Z2â˛ ). Since Z2â˛ â Zn and f2 (Z2â˛ ) â Dn we get  z1 â Z2â˛ and d â f2 (Z2â˛ ). As (f2 (Z))Z forms a sharing  of Dn and d â f2 (Z2 ) âŠ f2 (Z2â˛ ) we get Z2 = Z2â˛ . In  particular z1 â Z2 and we have proved that Z1 â Z2 . The  other inclusion Z2 â Z1 is obtained symetrically. We have  proved that Z1 = Z2 . Therefore, f1 (Z1 ) â f2 (Z1 ) for any  Z1 . By symmetry we deduce that f1 (Z) = f2 (Z) for any  Z. Therefore f1 = f2 .  Globally, this method of separating integers and reals  would speed up the software development process, because  of the ease of using already existing plugins. As mentioned  above, one can test the combination of any pair of plugins  (provided thereâs at least one working on reals and another  one on integers). Furthermore, a very interesting point is  that a programmer can test his new plugin for real sets  directly in G ENEPI, and then extend its expressivity by  coupling it with P RES TAF or another plugin handling  integer sets. Obviously, the converse (extending an integer plugin to the reals) is also possible in the same fashion.  References  [1] R. Alur and D. L. Dill. A theory of timed automata. Theoretical Computer Science, 126(2):183â235, 1994.  [2] A. Annichini, E. Asarin, and A. Bouajjani. Symbolic techniques for parametric reasoning about counter and clock systems. In Computer Aided Verification, 12th International  Conference, CAV 2000, Chicago, IL, USA, July 15-19, 2000,  Proceedings, volume 1855 of Lecture Notes in Computer  Science, pages 419â434. Springer, 2000.  [3] A. Annichini, A. Bouajjani, and M. Sighireanu. TReX:  A tool for reachability analysis of complex systems. In  Computer Aided Verification, 13th International Conference, CAV 2001, Paris, France, July 18-22, 2001, Proceedings, volume 2102 of Lecture Notes in Computer Science,  pages 368â372. Springer, 2001.  [4] R. Bagnara, P. M. Hill, and E. Zaffanella. The Parma Polyhedra Library: Toward a complete set of numerical abstractions for the analysis and verification of hardware and software systems. Science of Computer Programming, 2008. To  appear.  [5] S. Bardin, A. Finkel, and J. Leroux. FASTer acceleration  of counter automata in practice. In Tools and Algorithms  for the Construction and Analysis of Systems, 10th International Conference, TACAS 2004, Held as Part of the Joint  European Conferences on Theory and Practice of Software,  ETAPS 2004, Barcelona, Spain, March 29 - April 2, 2004,  Proceedings, volume 2988 of Lecture Notes in Computer  Science, pages 576â590. Springer, 2004.  [6] S. Bardin, A. Finkel, J. Leroux, and L. Petrucci. FAST:  Fast Acceleration of Symbolic Transition systems. In Computer Aided Verification, 15th International Conference,  Notice that in practice, this canonicity depends on how  the sets in Z and D are represented. Indeed, if any of these  representations are not canonical, then we can not guarantee  that an IDFZâD will be canonical.  6 Conclusion  We have proposed a decomposition of three known  classes into finite unions of sums of integers and decimals,  providing a new characterization. This decomposition can  be applied to other subsets of real vectors, and possibly  yield an interest in the exploration of decidable subclasses  of the full arithmetic.  Our main goal is to use this representation of real vectors  to verify infinite systems involving counters and clocks.  Indeed, we wish to extend the abilities of the tool FAST  [6] to the reals, so that it can compute exact reachability  sets using acceleration techniques. A first step in such  an implementation is the framework G ENEPI, allowing  to solve mixed integer and real constraints defined in  first-order theories. Thus, our decomposition would allow  working separately on integers and reals.  Another advantage of our decomposition is that we  can now compute operations that we did not know how to  perform on certain logics. For example, there is currently  8  [7]  [8]  [9]  [10]  [11]  [12]  [13]  [14]  [15]  [16]  [17] P. Bouyer, F. Laroussinie, and P.-A. Reynier. Diagonal  constraints in timed automata: Forward analysis of timed  systems. In Formal Modeling and Analysis of Timed Systems, Third International Conference, FORMATS 2005, Uppsala, Sweden, September 26-28, 2005, Proceedings, volume 3829 of Lecture Notes in Computer Science, pages 112â  126. Springer, 2005.  [18] M. Bozga, C. Daws, O. Maler, A. Olivero, S. Tripakis, and  S. Yovine. Kronos: A model-checking tool for real-time  systems. In Computer Aided Verification, 10th International  Conference, CAV â98, Vancouver, BC, Canada, June 28 July 2, 1998, Proceedings, volume 1427 of Lecture Notes in  Computer Science, pages 546â550. Springer, 1998.  [19] V. BruyĂ¨re, G. Hansel, C. Michaux, and R. Villemaire.  Logic and p-recognizable sets of integers. Bulletin of the  Belgian Mathematical Society, 1(2):191â238, 1994.  [20] C. Darlot, A. Finkel, and L. van Begin. About FAST and  TReX accelerations. Electronic Notes in Theoretical Computer Science, 128(6):87â103, 2005.  [21] D. L. Dill. Timing assumptions and verification of finitestate concurrent systems. In Automatic Verification Methods  for Finite State Systems, International Workshop, Grenoble,  France, June 12-14, 1989, Proceedings, volume 407 of Lecture Notes in Computer Science, pages 197â212. Springer,  1989.  [22] A. Finkel and J. Leroux. Presburger functions are piecewise linear. Research Report LSV-08-08, Laboratoire SpĂŠcification et VĂŠrification, ENS Cachan, France, Mar. 2008.  9 pages.  [23] S. Ginsburg and E. H. Spanier. Semigroups, Presburger  formulas, and languages. Pacific Journal of Mathematics,  16(2):285â296, 1966.  [24] F. Laroussinie and K. G. Larsen. CMC: A tool for compositional model-checking of real-time systems. In Formal  Description Techniques and Protocol Specification, Testing  and Verification, FORTE XI / PSTV XVIIIâ98, IFIP TC6  WG6.1 Joint International Conference on Formal Description Techniques for Distributed Systems and Communication  Protocols (FORTE XI) and Protocol Specification, Testing  and Verification (PSTV XVIII), 3-6 November, 1998, Paris,  France, volume 135 of IFIP Conference Proceedings, pages  439â456. Kluwer, 1998.  [25] K. G. Larsen, P. Pettersson, and W. Yi. UPPAAL in a nutshell. International Journal on Software Tools for Technology Transfer (STTT), 1(1-2):134â152, 1997.  [26] J. Leroux and G. Point. The GENEPI Framework, 2006.  http://altarica.labri.fr/wiki/tools:tapas:genepi.  [27] M. Presburger. On the completeness of a certain system of  arithmetic of whole numbers in which addition occurs as the  only operation. Hist. Philos. Logic, 12(2):225â233, 1991.  Translated from the German and with commentaries by Dale  Jacquette.  [28] A. Tarski. A problem concerning the notion of definability.  J. Symb. Log., 13(2):107â111, 1948.  [29] V. Weispfenning. Mixed real-integer linear quantifier elimination. In Symbolic and Algebraic Computation, International Symposium, ISSACâ99, Vancouver BC, Canada, July  28-31, 1999, Proceedings, pages 129â136. ACM, 1999.  CAV 2003, Boulder, CO, USA, July 8-12, 2003, Proceedings, volume 2725 of Lecture Notes in Computer Science,  pages 118â121. Springer, 2003.  S. Bardin, J. Leroux, and G. Point. FAST extended release.  In Computer Aided Verification, 18th International Conference, CAV 2006, Seattle, WA, USA, August 17-20, 2006, Proceedings, volume 4144 of Lecture Notes in Computer Science, pages 63â66. Springer, 2006.  B. Becker, C. Dax, J. Eisinger, and F. Klaedtke. LIRA: Handling constraints of linear arithmetics over the integers and  the reals. In Computer Aided Verification, 19th International  Conference, CAV 2007, Berlin, Germany, July 3-7, 2007,  Proceedings, volume 4590 of Lecture Notes in Computer  Science, pages 307â310. Springer, 2007.  G. Behrmann, P. Bouyer, E. Fleury, and K. G. Larsen. Static  guard analysis in timed automata verification. In Tools and  Algorithms for the Construction and Analysis of Systems,  9th International Conference, TACAS 2003, Held as Part of  the Joint European Conferences on Theory and Practice of  Software, ETAPS 2003, Warsaw, Poland, April 7-11, 2003,  Proceedings, volume 2619 of Lecture Notes in Computer  Science, pages 254â277. Springer, 2003.  G. Behrmann, P. Bouyer, and K. G. Larsen. Lower and upper  bounds in zone-based abstractions of timed automata. International Journal on Software Tools for Technology Transfer  (STTT), 8(3):204â215, 2006.  J. Bengtsson, K. G. Larsen, F. Larsson, P. Pettersson, and  W. Yi. UPPAAL - a tool suite for automatic verification of  real-time systems. In Hybrid Systems III: Verification and  Control, Proceedings of the DIMACS/SYCON Workshop,  October 22-25, 1995, Ruttgers University, New Brunswick,  NJ, USA, volume 1066 of Lecture Notes in Computer Science, pages 232â243. Springer, 1995.  B. Berthomieu and M. Menasche. An enumerative approach for analyzing time Petri nets. In Information Processing, 9th World Computer Congress, IFIPâ83, Paris, France,  September 19-23, 1983, Proceedings, pages 41â46. NorthHolland/IFIP, 1983.  B. Boigelot, L. Bronne, and S. Rassart. An improved reachability analysis method for strongly linear hybrid systems  (extended abstract). In Computer Aided Verification, 9th International Conference, CAV â97, Haifa, Israel, June 22-25,  1997, Proceedings, volume 1254 of Lecture Notes in Computer Science, pages 167â178. Springer, 1997.  B. Boigelot, S. Jodogne, and P. Wolper. On the use of weak  automata for deciding linear arithmetic with integer and real  variables. In Automated Reasoning, First International Joint  Conference, IJCAR 2001, Siena, Italy, June 18-23, 2001,  Proceedings, volume 2083 of Lecture Notes in Computer  Science, pages 611â625. Springer, 2001.  B. Boigelot, S. Jodogne, and P. Wolper. An effective decision procedure for linear arithmetic over the integers and  reals. ACM Trans. Comput. Log., 6(3):614â633, 2005.  B. Boigelot, S. Rassart, and P. Wolper. On the expressiveness of real and integer arithmetic automata (extended abstract). In Automata, Languages and Programming, 25th International Colloquium, ICALPâ98, Aalborg, Denmark, July  13-17, 1998, Proceedings, volume 1443 of Lecture Notes in  Computer Science, pages 152â163. Springer, 1998.  9 