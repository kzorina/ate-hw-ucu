2013 20th International Symposium on Temporal Representation and Reasoning  A New Metric Temporal Logic for Hybrid Systems  Mark Reynolds  School of Computer Science and Software Engineering  The University of Western Australia, Perth  Email: mark.reynolds@uwa.edu.au  AbstractâWe introduce a new way of deďŹning metric temporal  logic over the continuous real model of time. The semantics refer  to a single universal clock in order to impose metric constraints  to any desired precision. Furthermore, the expression of any nonmetric aspects can correctly utilise the full power of continuous  time temporal logic.  Syntactic constructs afford the convenient succinct expression  of many useful and typical constraints while other, more intricate  properties are able to be captured but may require more lengthy  formulation.  A decision procedure is provided via a simple translation into  an existing non-metric temporal logic and this gives a workable  complexity and the possibility of automated reasoning.  There are advantages in expressiveness, naturalness, generality  and amenability to reasoning techniques over the existing metric  temporal logics.  Combining purely continuous with adequate metric aspects  in one language makes the logic very suitable for dealing with  hybrid systems.  The most highly developed version of MTL is based on  what is often called point-wise or discrete semantics [28].  This means that we evaluate formulas over countably inďŹnite  discrete sequences of events at which a system may change  state. This logic may be amenable to automated techniques essentially by conversion to discrete reasoning on the sequences.  Unfortunately, the formulas in this logic have what can only  be seen to be un-intuitive meanings with sub-formulas needing  to be evaluated at state change points only. For example,  F(0,5) F(0,5) p may not be true even if p holds within ten  seconds (because there is no intervening change of state). See  [29], [19].  The other, less common, semantics for MTL is called the  continuous semantics. It allows more natural understanding  of temporal operators [28] and allows more properties to be  expressed [14]. Unfortunately, MTL is highly undecidable over  continuous time semantics [1]. See section II.  In this paper we introduce another seemingly similar but actually quite different metric temporal logic 1CMTL, one clock  metric temporal logic, with a continuous time semantics. The  main difference between 1CMTL and MTL is that 1CMTL is  based on the idea of there being one universal clock available  against which all quantitative measurements are evaluated. The  1CMTL clock is universal in the sense that the clock readings  mentioned in one subformula of a 1CMTL speciďŹcation are  from the same clock as readings mentioned in any other  subformula. This allows fairly straightforward expression of  many typical metric temporal constraints. We will see how to  translate 1CMTL formulas into roughly equivalent MTL ones.  0.25  For example, G0.25  (0,8) (p â qU(0,4.25) r) means that, as measured on a digital clock which changes its display only every  0.25 seconds, for the next 8 seconds, every p event is followed  by q remaining continuously true until r holds, and that will  happen between 0 and 4.25 seconds after the p event.  There are, of course, precursor suggestions allowing imprecision in metric constraints when formalising requirements.  Notable are the imprecise recording of times of state changes  in [4], the approximate properties in [17], the robust timed  automata of [16], the weakening functions of [22] and the  metric interval temporal logic MITL introduced under the idea  of relaxing punctuality [1]. However, our one clock approach  to imprecision seems to be novel and we will see that it has  some advantages.  This paper also tackles the need to reason with 1CMTL.  To that end we show that 1CMTL formulas can actually be  expressed in a simple, somewhat low-level, metric temporal  I. I NTRODUCTION  Metric temporal logic is used for applications involving  speciďŹcation and veriďŹcation of real-time and hybrid systems  [10]. A dense, or speciďŹcally real-numbers, model of time is  used and a formal logical language is employed with the ability  to express metric, or quantitative timing requirements as well  as the relative order and overlap of propositional states and  events. Early approaches include [24] and [26].  Several closely related popular current metric temporal  logics are called MTL for metric temporal logic [24], [2].  They allow convenient expression of metric or quantitative  temporal constraints. For example, we might want to say that  every time a button is pressed, p, then it will be disabled,  q, until the dialogue disappears, r, and that will happen  within 3 seconds. In MTL, our requirement is rendered as  G(0,â) (p â (qU(0,3) r)) where G(0,â) is a temporal operator  quantifying a formula as always holding from now on, and  qU(0,3) r indicates that formula q will hold until formula r does  sometime within the next 3 seconds. Other metric temporal  logics such as TPTL [4], MITL [1] or the Duration Calculus  [9] have since developed and comparisons are not always  straightforward but most subsequent work on metric temporal  logics has been with MTL or fragments of MTL.  The current situation with metric temporal logics is unsatisfactory for several reasons. There are two main versions of  MTL with different semantics. Unfortunately, the version that  is less natural, and less expressive is the version most amenable  to automated reasoning tasks.  1530-1311/13 $26.00 ÂŠ 2013 IEEE  1550-1311/13  DOI 10.1109/TIME.2013.17  63  73  language called MRTL which was recently introduced in [32].  MRTL itself is built on RTL [31] which is a traditional nonmetric temporal logic. RTL is just the propositional temporal  logic of the Until and Since connectives over real-numbers  time. This was developed in [23], shown to be sufďŹciently  expressive [23], shown to be decidable in [8], axiomatized in  [15], [30] and recently shown to be in PSPACE [31]. RTL has  a pure continuous semantics with no ad hoc constraints such as  ďŹnite variability or non-zenoness imposed on the behaviours  of the propositions. We give a few more details about RTL in  section IV.  It is important to note that the purely continuous RTL is a  sublanguage of both MRTL and 1CMTL. Thus its pure continuous version of Until and Since are available for speciďŹcations.  1CMTL is thus not like older translations of continuous  properties into discrete ones [17]. So, for example, density  of a proposition is required by just a simple G(ÂŹ((ÂŹp)U ))  conjunct and this means we do not have intervals of any length  without p holding ( is just truth). Such truly continuous  properties are needed for hybrid systems and faithful capture  of natural language speciďŹcations.  MRTL builds on top of RTL simply by using some propositions to mark the ticking of a single universal clock matching  the standard metric on the reals. These metric, or ticking,  propositions are ďŹxed, or pre-deďŹned in any MRTL structure.  Having a hierarchy of nested ticking propositions allows  simple reference to arbitrarily accurate and arbitrarily extensive constraints. Again, the other non-metric propositions are  completely unconstrained. Interestingly, some simple useful  properties can be easily expressed in MRTL even though they  are known to be beyond any MTL style metric temporal logic  [32].  In [32] we were also able to to show the decidability of  the validity problem for MRTL in a surprising way, namely  by transforming each MRTL formula into a non-metric RTL  formula.  Neither ICMTL nor MRTL can be translated into (traditional discrete time) PLTL. It is true that in any given 1CMTL  formula, there is a most ďŹne precision mentioned and all  metric durations can be assumed to be provided in multiples  of that. Many traditional simple approaches to continuous time  properties rely on such an assumption of ďŹnite variability for  all properties and this allows a trivial translation into discrete  time temporal logics. However, 1CMTL is designed to allow  reasoning about truly continuous aspects of systems as well as  metric constraints and the interrelationships between aspects  of both sorts. Properties related to density, zenoness, accumulations of oscillations, separability, dedekind completeness etc  are able to be truly stated in MRTL, because pure continuous  RTL is a sub-language. There is no apparent way to preserve  them while making a translation to a discrete model of time.  We do not translate 1CMTL reasoning to PLTL reasoning.  The expressivity of the pure continuous semantics of  1CMTL, MRTL and RTL, and the consequent inability to  translate trivially to PLTL, is shared by some other recent  approaches to metric temporal reasoning. However, they seem  to have their own complications. We could mention [20]  with its inďŹnite number of counting modalities and [7] with  its complicated syntactical restrictions and undecidability of  satisďŹability.  As a fairly simple example of the usefulness of having  a pure continuous semantics, consider one of the plausible  (but not actually physically realisable) models of a repeatedly  bouncing ball described in [12]. The ball bounces an inďŹnite  number of times after being dropped but comes to rest within a  ďŹnite period because of the convergence of the sum of shorter  and shorter bounce times (as it loses energy). In reasoning  about a detector capable of sensing when the ball is touching  the ďŹoor, say f , we may want an alarm a to sound within 5  seconds of the ball coming to rest after an episode of such  inďŹnite bouncing. In MTL, MITL, RTL, MRTL and 1CMTL  we can use the Since S operator, the past-time mirror to U , to  describe a bouncing accumulation point via Î˛ = Î˛1 â§ Î˛2 â§ Î˛3  as follows:  Î˛1 = ÂŹ((ÂŹf )S)  Î˛2 = ((ÂŹf )Sf )S  Î˛3 = f U   In MITL (and so in MTL), the overall speciďŹcation for the  alarm system can be given as G(Î˛ â Fâ¤5 a) while in  1CMTL, we just have to also specify a clock precision and  0.125  a). In both languages, the  say, for example, G(Î˛ â F[0,5]  semantics allows truly continuous behaviour, and the speciďŹcations do mean what we say they mean: an alarm sounds  shortly after the end of an accumulation of bounces. The  advantage of the 1CMTL language here, over MITL, is that  1CMTL is decidable: as the bouncing property contravenes  ďŹnite variability, there is no known decision procedure for  handling such speciďŹcations in MITL (or MTL). There are  many more sophisticated and practical examples from the  world of mechanical, electrical and quantum devices which  we hope to illustrate in a future paper.  We note that in other related work [33], [31], [34], [35]  tableau techniques are being developed for reasoning with  RTL. These will carry over directly to MRTL via the abovementioned translation and then thus be available for 1CMTL.  We also show that the two translations give an EXPSPACE  complexity result for 1CMTL in section VII.  Thus 1CMTL is a new metric temporal logic which is very  expressive, can truly capture continuous-time properties, is  natural to use, can be applied in very general situations, affords  a wide range of useful operators, has a decision procedure and  has tableau-based implementable decision procedures under  development. Recall that, in contrast, continuous-time MTL is  undecidable, MITL without ďŹnite variability has no existing  decision procedure and MITL with ďŹnite variability can not  express many truly continuous-time properties.  We will see below that there are also philosophical advantages to using 1CMTL, in addition to that of having a fairly  simple metric language based faithfully, âconservativelyâ, on a  purely continuous model of time. In section II we explain how  the one clock approach has advantages in physical plausibility  74  64  Suppose that we have deďŹned the truth of formulas Îą and Î˛  at all points of R. Then for all points x:  R, x |= p  iff x â h(p), for p atomic;  R, x |= ÂŹÎą  iff R, x |= Îą;  R, x |= Îą â§ Î˛ iff both R, x |= Îą and R, x |= Î˛;  R, x |= Î˛UI Îą iff there is y > x in R such that y â x â I  and R, y |= Îą  and for all z â R such that x < z < y,  we have R, z |= Î˛; and  R, x |= Î˛SI Îą iff there is y < x in R such that x â y â I  and R, y |= Îą  and for all z â R such that y < z < x,  we have R, z |= Î˛.  over speciďŹcation languages such as MTL and MITL which  âinvolveâ an inďŹnite number of inďŹnitely precise stop-clocks.  More generally, in section II we give a short account of  existing metric temporal logics. In section III we describe  our new metric temporal logic 1CMTL. In section IV we  remind the reader of the non-metric RTL and the low-level  metric MRTL. In section VI we show that 1CMTL formulas  can be expressed in MRTL. This allows us to establish the  decidability and complexity of 1CMTL in the next section.  We conclude with a summary and discussion of future work.  II. E XISTING MTL  We have mentioned that there are a wide variety of metric  temporal logics. There are choices in the fundamentals of  the semantics, discrete or continuous, and also in the expressiveness of the language. As we have seen, and as already  noted in [19], the situation is messy with general results about  expressiveness, decidability and complexity being confused by  ad hoc circumstances and these properties being sensitive to  slight differences in the semantics or choice of operators [13].  Thus we only give a brief overview.  Most of the timing work over the last two decades have  been using the discrete (also called pointwise) semantics and  the reasoning algorithms have been built on discrete temporal  techniques such as automata or translations to PLTL. However, such approaches give rise to an un-natural, un-intuitive,  expression of speciďŹcations exempliďŹed by the F(0,5) F(0,5) Îą  situation which we mentioned above. The discrete logics are  also less generally applicable especially as they make strict  assumptions on the behaviour of propositions. Expressiveness  of the approaches is compared in [11].  We will concentrate on the more natural continuous semantics (also called interval-based).  The models are based on boolean signals, i.e. maps which  determine the truth or falsity of propositions at any realnumbers time. We consider signals over the whole real numbers ďŹow, allowing behaviours to have been going on inďŹnitely  into the past. However, it is also common to see the positive  or non-negative reals being used as a frame.  DeďŹnition. [R-structure] Fix a countable set A of atoms. An  R-structure R = (R, <, h) has a frame (R, <), the reals under  the usual irreďŹexive ordering, and a valuation, or boolean  signal, h for the atoms, i.e. for each atom p â A, h(p) â R.  In what follows, (metric) intervals I will be interval subsets  of (0, â) â R with end points in Q âŞ {â}. Again, there  are variants in which the intervals only have natural number  end-points. The language for MTL is generated by the 2-place  connectives UI and SI for each interval I along with classical  ÂŹ and â§. So we deďŹne the set of formulas recursively to  contain the atoms and for formulas Îą and Î˛ we include ÂŹÎą,  Îą â§ Î˛, Î˛UI Îą and Î˛SI Îą.  MTL formulas are evaluated at points in structures R =  (R, <, h). We write R, x |= Îą when Îą is true at the point  x â R. This is deďŹned recursively as in Figure 1.  Abbreviations include FI Îą âĄ IUÎą and GI Îą âĄ ÂŹFI ÂŹÎą.  The unrestricted Until of RTL is also an abbreviation ÎąU Î˛ âĄ  Fig. 1.  Semantics for MTL  ÎąU(0,â) Î˛. Similarly, Since.  Finite variability of the boolean signals is often assumed  (explicitly) in order to obtain technical results about expressibility, decidability or complexity of MTL-like languages.  There are some different ways of deďŹning these restrictions  but essentially we require that every proposition changes truth  value only a ďŹnite number of times in any bounded interval  of time [19].  One aspect of MTL (and MTL-like languages) which is not  often discussed but is relevant for us is the way that actual  observed behaviours may be evaluated against speciďŹcations.  This is important for practical applications, but it also determines whether speciďŹcations in the language can correspond  to some desired property in theory.  MTL has formulas such as G(r â pU[2.5,3.5] q)) saying  that every r event is followed after a period of between 2.5  and 3.5 units (inclusive), by a q event and p holds continuously in between. Checking whether an actual behaviour of a  system satisďŹes an MTL speciďŹcation may thus be physically  impossible. It would seem to need an indeďŹnite number of  stop-watches, one being set off whenever an r event occurs.  Why do we need a lot of stop-watches? Because, the time  limits are strictly deďŹned. There is a non-zero range or interval  in which an event can occur (this means the formula is in  the sub-language MITL that we meet below), but the range  has very precise end points that have to be measured exactly  from when the r event occurs. It is no good trying to use a  global clock unless you are capable of recording the time of  every r event with inďŹnite accuracy. This is because having a  q event 2.49999 units after r and none until the next 1.00002  units after that is not enough to satisfy the speciďŹcation.  MTL (and MITL) languages rely on measuring durations to  inďŹnite accuracy in order to determine whether formulas are  satisďŹed, i.e. whether a particular observed duration lies within  an interval or not. Furthermore, even a short formula (such as  G(r â pU[2.5,3.5] q)) may require an inďŹnite number of such  measurements to be made (as an Until formula may need to  be evaluated at an inďŹnite number of starting points).  Thus we claim in this paper that MTL (and MITL) requires  inďŹnitely many, inďŹnitely accurate clocks.  75  65  MTL-like languages can express a reasonable range of  metric temporal constraints. However, Amir Pnueli suggested  that the modalities of MTL, and similar languages, are not  completely adequate. He presented the following example  speciďŹcation: p and then q will hold within the coming unit  of time. He conjectured that such speciďŹcations can not be  expressed in metric languages like MTL with ďŹnite numbers  of connectives [2], [36]. This is sometimes known as Pnueliâs  conjecture. In [6] it was shown that this example can be  expressed in MTL, but other useful properties can not be and  in [18], [21], HirschďŹeld and Rabinovich proved a stronger  lack of expressiveness result for MITL. It seems that MTL  style languages are not able to express these simple and useful  properties. See also [27].  It has long been known that deciding valid formulas in MTL  over dense time is highly undecidable [3]: there can be no  procedure for determining validity. With some restrictions on  behaviour, the (restricted) logics can be decided [14] and [1]  but the procedures are so complicated that no implementations  exists. Over the much simpler discrete model of time MTL is  decidable with an EXPSPACE complexity [3] and tools do  exist [5]. Over continuous time semantics the best results are  probably for the following two MTL-like languages.  Metric Interval Temporal Logic (MITL) was introduced in  [1] to be the fragment of MTL in which the intervals I on  the operators UI can not be singleton intervals. They showed  that deciding validity MITL (in pointwise time semantics  with ďŹnite variability) is EXPSPACE-complete. MITL was  introduced in a paper on ârelaxing punctualityâ but as we  saw in the example above, the allowed intervals still have  inďŹnitely precise limits as measured from each and every one  trigger event. Thus checking that a behaviour satisďŹes a MITL  formula in general can involve an inďŹnite number of inďŹnitely  precise stop clocks.  QTL, the quantiďŹed temporal logic, was introduced in [19].  It has ordinary non-metric until and since along with just two  new operators âŚ1 Îą meaning that Îą is true within the next  one unit of time (plus mirror image operator). They showed  that QTL is exactly as expressive as MITL over unrestricted  continuous time semantics provided that the intervals in the  MITL syntax only have integer end points. They show that  deciding QTL is PSPACE-complete but note that the language  is not succinct as the expression of any long term constraint  requires repeated nesting of âŚ1 .  R, x |= p  R, x |= ÂŹÎą  R, x |= Îą â§ Î˛  R, x |= Î˛UIe Îą  iff  iff  iff  iff  R, x |= Î˛SIe Îą  iff  Fig. 2.  x â h(p), for p â A;  R, x |= Îą;  both R, x |= Îą and R, x |= Î˛;  there is y > x in R such that  [y]e â [x]e â I and R, y |= Îą  and for all z â R s.t. x < z < y,  we have R, z |= Î˛; and  there is y < x in R such that  [x]e â [y]e â I and R, y |= Îą  and for all z â R s.t. y < z < x,  we have R, z |= Î˛.  Semantic clauses for 1CMTL  The language for 1CMTL is generated by the 2-place  connectives UIe and SIe for each interval I and each clock  granularity e, along with classical ÂŹ and â§. So we deďŹne  the set of formulas recursively to contain the atoms and for  formulas Îą and Î˛ we include ÂŹÎą, Îą â§ Î˛, Î˛UIe Îą and Î˛SIe Îą.  Suppose e = 2âm for some m â ZâĽ0 . This value will  determine the granularity of clock that is used to assess the  metric information. With respect to a clock of granularity e,  we say that the e-clock time of an event which occurs at realtime t â R is the rational value [t]e = e t/e. For example,  [0.367]0.25 = 0.25. Thus we imagine a digital 0.25-clock  showing 0.25 on the display at every time t â [0.25, 0.5).  The termination interval is determined by two non-negative  rational numbers, a, b â Q such that 0 â¤ a â¤ b. In fact, we  will see that we can also suppose that a = [a]e and b = [b]e as  specifying an interval to a greater accuracy is ignored in our  semantics. Thus, expressing a and b in binary needs at most  m places after the binary point.  We now give the semantics for the new two-place connective  e  e  . The formula pU[a,b]  q means that p holds from now, at  U[a,b]  real-time t say, until some future real-time s, such that q holds  at real-time s, and the difference [s]e â [t]e in e-clock time  between now and real-time s lies in the range [a]e to [b]e , i.e.  [a]e â¤ [s]e â [t]e â¤ [b]e . Figure 2 gives the semantic clauses.  Abbreviations include FIe Îą âĄ UIe Îą and GeI Îą âĄ ÂŹFIe ÂŹÎą.  The unrestricted Until of RTL is also an abbreviation ÎąU Î˛ âĄ  1  Î˛ and the reader can check that this is indeed standard  ÎąU[0,â)  Until despite the imprecision of our timing. Unrestricted future  occurrence F , and constant truth into the future G are then  deďŹned in the usual way from U . Similarly, Since is used to  deďŹne PIe Îą âĄ SIe Îą, HIe Îą âĄ ÂŹPIe ÂŹÎą and unrestricted S, P  and H. The combination GHÎą thus means that Îą holds at all  times in the past, present and future.  As an example, suppose that e = 0.25, q holds at time  1.2 and p holds constantly over the open interval (0.1, 1.2).  0.25  q is true at time 0.1. This is despite the fact  Then pU[0.5,1.0]  that q was not true up to 1 unit after the evaluation time and  stayed false a little longer. That is because the clock concerned  showed time 0 when we started the evaluation and still showed  time 1 when q became true.  0.125  q is not true at  In the same situation the formula pU[0.5,1.0]  time 0.1. This is because the (new more accurate clock) shows  III. 1CMTL  In this section we introduce the new metric temporal logic  1CMTL which is the main contribution of the paper.  Semantics is over R-structures just as for the version of  MTL which we introduced above.  Temporal formulas involve a clock granularity, or precision,  which is assumed to be e = 2âm for some m âĽ 0. Following  MTL, (metric) intervals I will be interval subsets of [0, â) â  R with end points in Q âŞ {â}. Note that 0 is allowed to be  in the interval (unlike in MTL).  76  66  time 0 when we start and it shows time 1.125 (and not still  1.0) before q is true.  e  Note that, as mentioned above, the formula ÎąU[a,b]  Î˛ has the  e  same truth conditions as ÎąU[a ,b ] Î˛ whenever [a]e = [a ]e and  [b]e = [b ]e . Thus, we assume for now that we always choose  a and b so that a = [a]e and b = [b]e .  On a similar note, it is recommended, but not required, that  properties are usually formalised using one minimum precision  value in all superscripts. This is intuitively sensible if we are  thinking about timing behaviours against one global clock.  Asking whether p is true within 5 seconds, as measured on the  clock using 1 second precision, but not true within 5 seconds if  using a 0.5 second precision is possible but not a very natural  query. It is better to ask the equivalent query: is p true next  within 4.5 to 5 seconds, as measured on the clock using 0.5  second precision.  For a more complicated example consider the MTL formula  G(pU[2.5,3.5] q). Again, we can not say this exactly in 1CMTL.  However, we can something arbitrarily close to this. Consider  the 1CMTL version of this property as rendered with a clock  0.25  q). The  display updating every 0.25 seconds: it is G(pU[2.5,3.5]  task of assessing whether a particular behaviour satisďŹes this  formula just involves running one global clock with the far  from inďŹnite precision of 0.25 seconds. We do have to note  down the time of each r event, but we only have to note what  the clock saysâ accurate to 0.25 seconds. For example if there  was an r event at time 1.75921 and at time 1.9203 then we  just look at the clock each time and note that it says 1.75 both  times. We then watch p staying true until perhaps we see q true  when the clock says 5.25 and we are done. We do not have  to start off a new inďŹnitely precise stop-watch every time that  an r event occurs as one does in MTL or MITL. In the same  situation for MITL, in contrast, you have to start one inďŹnitely  precise stop-watch when you see r true at time 1.75921 and  another one at time 1.9203. You need to watch very carefully  to see that the q event occurs before 5.25921 seconds after the  3.5 duration elapses from the ďŹrst r. Because inďŹnite precision  matters in MITL âyes, even though the timing intervals have  non-zero durationâ every trigger event needs its own stop  watch in principle.  Thus, we have sketched an expressiveness result along the  lines of the following. For each formula of the form ÎąUI Î˛ of  existing MTL, there is a sense in which we can approximate  the semantics, the meaning, to any desired level of accuracy  with a 1CMTL formula. We leave the rigorous formulation  and proof of a result along these lines for the future.  the ďŹrst-order monadic logic of the real numbers. Later in the  section we will see that there are reasoning techniques for  RTL.  The language L(U, S) is generated by the 2-place connectives U and S along with classical ÂŹ and â§.  Formulas are again evaluated at points in R-structures. The  semantic clauses are as for 1CMTL except that R, x |= Î˛U Îą  iff there is y > x in R such that R, y |= Îą and for all z â R  such that x < z < y, we have R, z |= Î˛ (and Î˛SÎą is the  mirror image).  In [31], we show that, as far as determining validity is  concerned, RTL is just as easy to reason with as PLTL. In  particular, the complexity of the decision problem is PSPACEcomplete. The proof in that paper uses intricate reasoning with  the mosaic techniques in temporal logic. We decide whether  a ďŹnite set of small pieces of models is sufďŹcient to be used  to build a real-numbers model of a given formula.  Mosaic reasoning techniques can often be the foundation  of tableau implementations [25]. The mosaic proof in [31]  suggests a tableau based method for determining RTL validity  but details and subsequent development were left for future  work. In [35] we make further progress in this direction but  there is still much to do.  V. MRTL  In this section we remind the reader of our recently introduced low-level metric temporal logic, MRTL [32].  To deďŹne MRTL we work in RTL but split the set of  propositional atoms L into two disjoint inďŹnite sets and  reserve one of the countable sets of atoms for special metric  purposes leaving the other countable set of atoms for normal  propositions. Suppose L = A âŞ T where A and T are disjoint  countably inďŹnite sets of atoms.  Suppose further that T = {..., !â2 , !â1 , !0 , !1 , !2 , ....}. These  metric propositions are going to represent the ticking of a  clock over time. One element, ! â T , also called !0 , will hold  for an instant on the event of the regular ticking of the clock  every one unit of time. The other propositions in T represent  ďŹner and coarser rates of ticking allowing us to easily refer  to arbitrarily small and arbitrarily large durations of time. We  will informally call ! =!0 a tick, !â1 a sub-tick, !1 a super-tick,  !â2 a sub-sub-tick, !2 a super-super-tick, etc. These are a range  of levels of granularity of ticking. See Figure 3.  The various levels of ticks are propositions indicating the  ticking of one single universal clock. Ticks will occur regularly  across time. Sub-ticks will happen mid-way between ticks as  well as coinciding with each tick: so they are twice as frequent.  Super-ticks happen only at alternative ticks so they are half as  frequent. Sub-sub-ticks will occur on every sub-tick and midway between each adjacent pair of sub-ticks. Super-super-ticks  will only occur once every four ticks. And so on. There is  thus a two-way inďŹnite linear hierarchy of ticking propositions  related to each other by factors of powers of two. Base 10, or  other bases, could equally be used instead.  As we mentioned earlier, we call the clock universal because there is just one clock, albeit with a hierarchy of layers  IV. RTL  As background we outline recent work on a traditional  non-metric temporal logic over real-numbers time. RTL, the  propositional temporal logic over real-numbers time uses the  Until and Since connectives introduced in [23]. We know  from [23] that this logic is sufďŹciently expressive for many  applications: technically it is expressively complete and so at  least as expressive as any other usual temporal logic which  could be deďŹned over real-numbers time and as expressive as  77  67  e  So we sketch the proof that the formula pU[a,b]  q can be  expressed in MRTL.  Recall that we can assume that e = 2âm for some m âĽ 0  and that a = [a]e and b = [b]e .  Say that n = log2 b + 1. Our rendering of the formula  will be a rather long MRTL formula using only the atoms p  n  = {!âm , !âm+1 , ..., !n }.  and q and those in Tâm  The deďŹnitions below assume that n and m are now ďŹxed  in context.  e  Consider pU[a,b]  q being true at some time t0 â R in  n  switch on and off  some MRTL model. The atoms in Tâm  in a certain pattern spread over a length of 2n which repeats  inďŹnitely in both directions. For each j â Z, call the interval  [j.2n , (j + 1).2n ) the jth repeat of the pattern. There are  2n+m + 1 distinct time points during that interval of repeated  pattern of length 2n at which !âm (and possibly some of the  other ticking propositions) are true, including the start and  end point. The jth repeat (which does not include the ďŹnal  end point) is thus divided into 2n+m sub-intervals of the form  Ďkj = [j Âˇ 2n + k Âˇ 2âm , j Âˇ 2n + (k + 1) Âˇ 2âm ) for each  k = 0, 1, ..., 2n+m â 1.  Thus every time point in R belongs to one such sub-interval.  For given n and m, we say that a time point t is in the kth  sector and the jth repeat iff k = ([t]e â [t]2n )/e and j = [t]2n  or equivalently, t â Ďkj for some j. There are 2n+m sectors of  each repeat indexed by k = 0, 1, ..., 2n+m â 1.  e  q into 2n+m differWe will break up the meaning of pU[a,b]  ent disjuncts depending on the sector of the starting position.  For each k = 0, 1, ..., 2n+m â1 we will below make a formula  Ďk . This says that now we are in the kth sector (of some repeat)  2n+m â1  e  e  and ÎąU[a,b]  Î˛ holds. Thus ÎąU[a,b]  Î˛ âĄ k=0  Ďk .  Now consider some ďŹxed k. We will put Ďk = Î¸(Îˇ)  where Îˇ is a MRTL formula and Î¸(r) is a MRTL formula  using a fresh atom r which we later substitute by Îˇ. Let  l = ((k + a/e)mod2n+m ) which is the sector number  at a duration of a after the start of the kth sector and let  l = ((k + b/e)mod2n+m ) which is the sector number at a  duration of b after the start of the kth sector. We will arrange  that Î¸(r) says that p holds from now (during the kth sector)  until the very start of the next lth sector when r holds. And  Îˇ says that p holds from now at the very start of a lth sector  until some time at which q holds and lying at the latest in the  next l th sector.  Let us represent a sector number k = 0, 1, ..., 2n+m â 1  bj (k).2j where each bj (k) â  in binary as k = ÎŁj<n+m  j=0  {0, 1}. We can   say that now we are in a kth sector via  n  Ďk = (ÂŹ!âm )U ( j=âm Î˛j (k + 1)) where Î˛j (k + 1) =!j if  bj (k + 1) = 1 and Î˛j (k + 1) = ÂŹ!j if bj (k + 1) = 0. We thus  look ahead to the start of the k + 1th sector to see what metric  atoms hold then. Note that we could as well have made an  alternative formulation instead looking back to the start of the  kth sector using Since.  Lemma. t â R is in a kth sector iff R, t |= Ďk .  Now, between the kth sector and the next lth sector there  should be no !n true if k < l < 2n+m or exactly one place  where !n is true if l â¤ k. We need to say that in order to limit  of ticking, in the semantics. All references to ticks within  subformulas of an MRTL formula are references to the ticks  in that one hierarchy. We see that this is in contrast to the  semantics of MTL-like languages, where every truth evaluation  of a subformula at every time point sets off its own stopwatch.  So ! will be true in our MRTL structures at the integer  points Z = {..., â2, â1, 0, 1, 2, ...} â R. In general !n will  be true at exactly the points 2n Z = {m Âˇ 2n |m â Z}. So at  time point t = â2 we have all the following propositions true  {..., !â2 , !â1 , !, !1 } in all MRTL structures. See the Figure 1.  To be more rigorous, MRTL-structures R = (R, <, h) will  have the reals as frame and a valuation h for the atoms which  is restricted, i.e. pre-deďŹned, for the atoms in T as follows:  for each n â Z, h(!n ) = 2n Z.  The language is just L(U, S) as for RTL and formulas are  evaluated at points in structures R = (R, <, h) just as for  RTL. Thus we do not set out the semantic clauses yet again  here.  The surprising result from [32] is that reasoning about  validity (or equally satisďŹability) in the metric logic MRTL  can be be accomplished by reasoning (about a slightly different  formula) in the non-metric RTL. This gives a PSPACE decision  procedure for MRTL via what is quite a simple translation to  then use the PSPACE decision procedure for RTL [31]. See  [32] for full details.  VI. 1CMTL INTO MRTL  In this section we show how to translate 1CMTL formulas  into equ-satisďŹable ones in MRTL. Similar ideas allow translation of 1CMTL directly into equivalent MRTL ones but, for  the purposes of deciding satisďŹability, it is better to translate  to shorter equi-satisďŹable formulas of MRTL (which are not  necessarily equivalent).  First, look brieďŹy at an example. How do we translate  0.25  pU[2.5,3.5]  q? Given that we are considering a duration of nearly  4 seconds here and that we want to work at a granularity of  0.25 seconds one way of deďŹning this property in MRTL is  to use 4/0.25 = 16 different conjuncts for the 16 different  intervals between sub-sub-ticks lying between adjacent supersuper-ticks. Each of these conjuncts is to capture the situation  if the starting time point lies in that interval. For example, one  conjunct might say (roughly) that the starting point (modulo 4)  is in [1.25, 1.5) and q holds from then until an end point where  p holds at a time (modulo 4) in either the next interval [3.75, 4)  or the next interval [0, 1.0). Saying that a time modulo 4 lies  in a particular interval such as [1.25, 1.5) can be accomplished  by checking the truth of the various ticks at the end point. For  example, (ÂŹ!â2 )U (!â2 â§!â1 â§ÂŹ!0 â§(ÂŹ!0 )U (!1 â§ÂŹ!2 )) says that  a time (modulo 4) lies within the interval [1.25, 1.5).  To return to the proof now, our ďŹrst, and most complicated,  task is to show how simple 1CMTL formulas can be translated  into MRTL. Later we will show how to work on more complicated formulas by breaking them down. We will just consider  e  q for 0 < a < b. Other  the case of a formula of the form pU[a,b]  e  e  e  e  q and pS[a,b]  q are  formulas such as pU(a,b] q, pU(0,b] q, pU[a,â)  similar and we do not present the details.  78  68  !1  !0  !0  !â1 !â1 !â1 !â1  .  .  .4  !  !3  !2  !1  !1  !0  !0  !0  !0  !â1 !â1 !â1 !â1 !â1 !â1 !â1 !â1  !2  !1  !1  !0  !0  !0  !0  !â1 !â1 !â1 !â1 !â1 !â1 !â1 !â1  !3  !2  !1  !0  !â1  â2  0  4  8  â1  1  2  Fig. 3.  3  5  6  7  MRTL pre-deďŹned atoms  the range of the until operator to just the next lth sector (not  any later ones).  Î¸(r) = Ďk â§ (ÂŹ!n â§ p)U (Ďl â§ r) if k < l and Î¸(r) =  Ďk â§ (ÂŹ!n â§ p)U (!n â§ p â§ (ÂŹ!n â§ p)U Ďl â§ r) if l â¤ k.  Lemma. p holds from now (during the kth sector) until the  start of the next lth sector when r holds iff R, t |= Î¸(r).  Similar considerations allow us to deďŹne Îˇ to mean that p  holds from now (at the start of an lth sector) until some time  at which q holds before the start of the next (l + 1)th sector.  Thus, pU q holds and we do not have ÂŹq holding constantly  until the start of the next (l + 1)th sector. So we put Îˇ =  (pU q) â§ ÂŹ(ÂŹq â§ ÂŹ!n )U (Ďl +1 ) if l < l and Îˇ = (pU q) â§  ÂŹ(ÂŹq â§ ÂŹ!n )U (ÂŹqâ§!n â§ (ÂŹq â§ ÂŹ!n )U Ďl +1 ) if l â¤ l.  Lemma. p holds from now at the start of a lth sector until  some time at which q holds and lying at the latest in the next  l th sector iff R, t |= Îˇ.  So ďŹnally we can deďŹne Ďk = Î¸(Îˇ) and we get our result.  Lemma. p holds from now (during the kth sector) until  the start of the next lth sector and further until some time at  which q holds and lying at the latest in the next l th sector iff  R, t |= Ďk .  2n+m â1  e  Lemma. R, t |= k=0  Ďk iff R, t |= ÎąU[a,b]  Î˛.  As we have said, we are not going to go through the details  for other variations on simple 1CMTL formulas as they are  similar and similarly intricate.  It remains to show how to translate a more complicated formula, Ď say, from 1CMTL into MRTL. This is accomplished  by a very straightforward induction based on using fresh atoms  for each of the direct subformulas. For example, to translate  e  ÎąU[a,b]  Î˛ we choose fresh atoms pÎą and pÎ˛ and assuming the  e  translation function is T , we put T (ÎąU[a,b]  Î˛)  answering correctly whether the formula is valid in RTL or  not, and (3) the space taken for machine to do its job is bound  by a polynomial in terms of the size of the input formula.  It is important to be careful about what we mean by the size  of the input formula when we consider complexity results for  decision procedures for formal languages. In [31] we showed  that for RTL we could consider the length of the input to be  the same as the number of symbols in the formula. This is  despite the fact that we could not use an input alphabet which  has a separate symbol for each atom as there are inďŹnitely  many atoms.  We will see that things are different for MRTL and 1CMTL.  In [32] we deďŹne the length of a formula of MRTL to be  the number of symbols in the formula (counting repeated  appearances) with the integer numbers in the superscripts of  !Âąn being in unary notation. That is the length of !n is 2 + |n|.  For example, Ď3 =!3 â§ (((ÂŹ!3 )U !3 ) â§ ((ÂŹ!3 )S!3 )) has length  31.  The use of unary for the superscripts was justiďŹed on the  basis that those superscripts will be used to support durations  speciďŹed in binary as we will see below. In essence, the use  of !5 , for example, is to encode a duration given as 32 = 25 :  thus the length of the duration, input as a binary number is 5.  Using that deďŹnition of length we get a PSPACE decision  procedure for MRTL via the translation into RTL [32].  Now consider 1CMTL.  We would want to assume that the binary rational numbers attached to connectives and specifying durations can be  0.5  entered in binary. For example, in pU(0,32)  q, meaning that p  will hold until q is true and that happens before a clock with  precision 0.5 units reaches 32 units more than what it displays  now. Consider the 32 unit duration. It will be convenient for  such a measure to be entered in binary. Thus this formula  would be input into an algorithm in binary as something like  p UË0.1_(0,100000)q of length 18 symbols. When we  translate such a formula into low-level MRTL there is an  exponential expansion into a formula involving levels of ticks  from !â1 up to !5 . So, by writing the 32 in binary using six  symbols we have effectively made use of a reference to !5 .  We have seen in the last section that a 1CMTL formula  of length n translates into an equally-satisďŹable formula of  MRTL of length 2n (and using only metric atoms !k for  ân â¤ k â¤ n). Inputting such a formula into the PSPACE  = T (pÎą U pÎ˛ ) â§ GH(pÎą â T (Îą)) â§ GH(pÎ˛ â T (Î˛)).  Lemma. The length of the equi-satisďŹable MRTL formula  to 1CMTL formula Îą of length n is less than 24n .  VII. C OMPLEXITY  In this section we consider the complexity of the decision  procedure which we have just outlined.  The main work of the procedure is done by the RTL  decision procedure which we know from [31] is in PSPACE.  This means that (1) there is a Turing machine which can  accept formulas of RTL as input, (2) for any formula it halts  79  69  [9] Zhou Chaochen. Duration calculus, a logical approach to real-time  systems. In Armando Martin Haeberer, editor, AMAST, volume 1548  of Lecture Notes in Computer Science, pages 1â7. Springer, 1998.  [10] J. Davoren and A. Nerode. Logics for hybrid systems. Proceedings of  the IEEE, 88(7):985â1010, 2000.  [11] Deepak DâSouza and Pavithra Prabhakar. On the expressiveness of mtl  in the pointwise and continuous semantics. STTT, 9(1):1â4, 2007.  [12] E. Falcon, C. Laroche, S. Fauve, and C. Coste. Behaviour of one inelastic  ball bouncing repeatedly off the ground. The European Physical Journal  B, B(3):45â57, 1998.  [13] Carlo A. Furia and Matteo Rossi. On the expressiveness of mtl variants  over dense time. In Jean-FrancĚ§ois Raskin and P. S. Thiagarajan, editors,  FORMATS, volume 4763 of LNCS, pages 163â178. Springer, 2007.  [14] Carlo A. Furia and Matteo Rossi. Mtl with bounded variability:  Decidability and complexity. In Franck Cassez and Claude Jard, editors,  FORMATS, volume 5215 of Lecture Notes in Computer Science, pages  109â123. Springer, 2008.  [15] D. M. Gabbay and I. M. Hodkinson. An axiomatisation of the temporal  logic with until and since over the real numbers. Journal of Logic and  Computation, 1(2):229 â 260, 1990.  [16] V. Gupta, T. Henzinger, and R. Jagadeesan. Robust timed automata.  In Proceedings of the International Workshop on Hybrid and Real-Time  Systems (HART), volume 1201 of LNCS, pages 331â345. Springer, 1997.  [17] T. A. Henzinger, Z. Manna, and A. Pnueli. What good are digital  clocks? In the 19th International Colloquium on Automata, Languages,  and Prog. (ICALP), vol. 623 of LNCS, pages 545â558. Springer, 1992.  [18] Yoram Hirshfeld and Alexander Moshe Rabinovich. A framework for  decidable metrical logics. In JirÄąĚ Wiedermann, Peter van Emde Boas,  and Mogens Nielsen, editors, ICALP, volume 1644 of Lecture Notes in  Computer Science, pages 422â432. Springer, 1999.  [19] Yoram Hirshfeld and Alexander Moshe Rabinovich. Logics for real  time: Decidability and complexity. Fundam. Inform., 62(1):1â28, 2004.  [20] Y. Hirshfeld and A. Rabinovich. An expressive temporal logic for real  time. MFCS, 2006.  [21] Y. Hirshfeld and A. Rabinovich. Expressiveness of metric modalities  for continuous time. Logical Methods in Computer Science, 3(1), 2007.  [22] J. Huang, J. Voeten and M. Geilen. Real-time property preservation  in approximation of timed systems. 1st ACM and IEEE International  Conference on Formal Methods and Models for Co-Design, 2003.  [23] H. Kamp. Tense logic and the theory of linear order. PhD thesis,  University of California, Los Angeles, 1968.  [24] Ron Koymans. Specifying real-time properties with metric temporal  logic. Real-Time Syst., 2(4):255â299, 1990.  [25] M. Marx, S. Mikulas, and M. Reynolds. The mosaic method for  temporal logics. In R. Dyckhoff, editor, Automated Reasoning with  Analytic Tableaux and Related Methods, Proceedings of International  Conference, TABLEAUX 2000, Saint Andrews, Scotland, July 2000,  LNAI 1847, pages 324â340. Springer, 2000.  [26] J. S. Ostroff. Temporal Logic for Real-Time Systems. Advanced Software  Development Series. John Wiley and Sons, 1989.  [27] J. Ouaknine and J. Worrell. On the decidability of metric temporal logic.  In Proceedings of the 20th Annual Symposium on Logic in Computer  Science (LICSâ05), pages 188â197. IEEE Comp. Soc. Press, July 2005.  [28] JoeĚl Ouaknine and James Worrell. Some recent results in metric  temporal logic. In FORMATS â08: Proceedings of the 6th international  conference on Formal Modeling and Analysis of Timed Systems, pages  1â13, Berlin, Heidelberg, 2008. Springer-Verlag.  [29] J. Raskin. Logics, Automata and Classical Theories for Deciding Real  Time. PhD thesis, UniversiteĚ de Namur, Belgium, 1999.  [30] M. Reynolds. An axiomatization for Until and Since over the reals  without the IRR rule. Studia Logica, 51:165â193, May 1992.  [31] M. Reynolds. The complexity of the temporal logic over the reals.  Annals of Pure and Applied Logic, 161(8):1063â1096, 2010.  [32] M. Reynolds. Metric temporal reasoning with less than 2 clocks. Journal  of Applied Non-classical Logics, 20:437â455, 2010.  [33] M. Reynolds. Dense time reasoning via mosaics. In TIME â09, pages  3â10, Washington, DC, USA, 2009. IEEE Comp. Soc.  [34] Mark Reynolds. A tableau for until and since over linear time. In TIME  2011, pages 41â48, 2011.  [35] Mark Reynolds. A tableau for general linear temporal logic. J of Logic  and Computation, 2013.  [36] Thomas Wilke. Specifying timed state sequences in powerful decidable  logics and timed automata (extended abstract). In LNCS 863, pages  694â715. Springer-Verlag, 1994.  decision procedure for MRTL will answer our 1CMTL satisďŹability query and the computation space will be bound by  some exponential in n:  Lemma. 1CMTL is in EXPSPACE.  VIII. C ONCLUSION  In this paper we have presented a new paradigm for metric  temporal logics.  We have introduced the simple metric temporal logic  1CMTL which is based on the idea of referring temporal  constraints to the reading on an arbitrarily, but not inďŹnitely  precise single universal clock. This contrasts with existing  metric temporal logics which require speciďŹcations of inďŹnite  accuracy, or at least speciďŹcations which put inďŹnitely accurate  end points on ranges. Existing metric temporal logics also  allow speciďŹcations which are unrealistic to check because  they seem to require the setting off of an inďŹnite number of  inďŹnitely accurate stop-watches.  1CMTL is a general metric temporal logic being able to  handle arbitrary boolean signals over real-numbers time. There  are no ďŹnite variability assumptions on the behaviour of the  signals.  1CMTL is superďŹcially similar to existing MTL but the  semantics are quite different in several ways. Nevertheless,  1CMTL is an expressive language able to specify a wide  range of metric temporal constraints. It captures adequately  approximately all MTL formulas.  We have proved the decidability of 1CMTL by showing  how it it can be translated via the low-level metric MRTL into  the non-metric dense-time temporal logic RTL. This gives an  EXPSPACE decision procedure. This contrasts with the undecidability of MTL and (more than) matches the complexity of  common sub-languages of MTL used for metric speciďŹcations.  Future work will concentrate on reasoning tasks. Work is  underway [35] on developing tableau techniques for languages  like RTL. Hopefully, that can be extended to MRTL and  1CMTL. There are currently no implementations for decision  procedures for MTL-like languages.  R EFERENCES  [1] R. Alur, T. Feder, and T. A. Henzinger. The beneďŹts of relaxing  punctuality. J. ACM, 43(1):116â146, 1996.  [2] Rajeev Alur and Thomas A. Henzinger. Logics and models of real time:  A survey. In J. W. de Bakker, Cornelis Huizing, Willem P. de Roever,  and Grzegorz Rozenberg, editors, REX Workshop, volume 600 of Lecture  Notes in Computer Science, pages 74â106. Springer, 1991.  [3] Rajeev Alur and Thomas A. Henzinger. Real-time logics: Complexity  and expressiveness. Inf. Comput., 104(1):35â77, 1993.  [4] R. Alur and T. Henzinger. A really temporal logic. J. ACM, 41(1):181â  203, 1994.  [5] Domenico Bianculli, Paola Spoletini, Angelo Morzenti, Matteo Pradella,  and Pierluigi San Pietro. Model checking temporal metric speciďŹcations  with trio2promela. In In FSENâ07, 2007.  [6] P. Bouyer, F. Chevalier, and N. Markey. On the expressiveness of TPTL  and MTL. In FSTTCS 2005, pages 432â443. Springer, 2005.  [7] P. Bouyer, N. Markey, J. Ouaknine, J. Worrell. On Expressiveness and  Complexity in Real-Time Model Checking. ICALP (2), pages 124â135,  2008.  [8] J. P. Burgess and Y. Gurevich. The decision problem for linear temporal  logic. Notre Dame J. Formal Logic, 26(2):115â128, 1985.  80  70 