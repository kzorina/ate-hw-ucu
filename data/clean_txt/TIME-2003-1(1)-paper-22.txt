QuantiďŹed Propositional Temporal Logic with Repeating States  Tim French  School of Computer Science and Software Engineering  University of Western Australia  tim@cs.uwa.edu.au  Abstract  QuantiďŹed Propositional Temporal Logic (QPTL) is a  linear temporal logic that allows quantiďŹcation over propositional variables. In the usual semantics for QPTL, a  model is an inďŹnite discrete linear sequence of states, with  each state having some propositional interpretation. The  effect of this is that the interpretation of a proposition at  one point in time is independent from its interpretation at  another point in time. In this paper we examine the expressivity and decidability of an of QPTL, given generalizations  of the usual semantics that do not have this restriction. We  introduce the repeating semantics (QPTL ), which allows  states to be repeated throughout a model. While this semantic interpretation does not affect the unquantiďŹed fragment  of QPTL it signiďŹcantly increases the expressive power in  the presence of propositional quantiďŹcation. In the main  result of this paper we show that QPTL makes the satisďŹability problem highly undecidable through a complicated  encoding of a tiling problem. We also investigate two less  expressive semantics which still allow states to be repeated.  We prove the satisďŹability problem for one is undecidable,  and decidable for the other.  1. Introduction  QuantiďŹed Propositional Temporal Logic (QPTL) [14],  extends traditional propositional linear temporal logic,  PLTL [12], and has the ability to quantify over propositional atoms. The set of formulas of QPTL is built up recursively from the atoms via classical negation and disjunction,  temporal next-time and future-always connectives (from the  standard PLTL) along with quantiďŹcation over atoms. The  formulas are evaluated over a linear sequence of states, with  each atom being true or false at each state. The logic is  expressively equivalent to Buchiâs monadic second-order  logic of one successor (Ă Â˝Ă ) and consequently it has been  shown to be decidable (albeit non-elementary).  In this paper we deďŹne new semantic interpretations  (QPTL , QPTL , QPTL ) of QPTL by removing the restriction that the model be a linear sequence of states. We do  however retain the basic concept of a linear model by distinguishing the states of the model from âtemporal momentsâ,  (the time at which a state is visited). That is, the temporal operators of the language are interpreted with respect to  countable, discrete, linear moments in time; while the atoms  are interpreted with respect to the (possibly recurring) states  of the model. We cannot assume that the interpretation of  an atom at one temporal moment is independent of its interpretation at another moment. This way we can allow the  temporal proposition ânow will never happen againâ to be  false, (however to avoid confusion is is best not to associate  the states with such temporal notions as now).  Our motivation for doing this is largely to investigate the  expressive power of propositional quantiďŹcation in modal  structures. This has been studied extensively in the context  of branching modal structures [4], [3], [5], and also in the  context of strictly linear structures [14], [10]. In this paper we investigate languages which neither have branching  operators, nor a strictly linear structure. Effectively this allows us to apply quantiďŹcation over the states of the model,  which results in a dramatic increase in the expressive power  of QPTL.  The language QPTL has been used to reason about ďŹnite  state machines and automata. By associating a state of the  model with a state of the machine the repeating semantics  allows us to succinctly reason about properties of ďŹnite state  machines, without having to assign an atom to each state of  the machine. For example, the repeating semantics allows  us to detect if a machine will loop inďŹnitely in a single state,  independant of what the actual state is.  Another possible application of such a language would  be reasoning about a trajectory of an agent through some  environment. The states of a model would represent spatial entities, and the temporal moments represent time. The  language can express such concepts as whether the trajectory of the agent is eventually periodic, or whether there are  some states that the agent will only visit once.  Proceedings of the 10th International Symposium on Temporal Representation and Reasoning and  Fourth International Conference on Temporal Logic (TIME-ICTLâ03) 1530-1311/03 $17.00 ÂŠ 2003 IEEE  2. Semantics for QPTL  follows.  The language QPTL consists of an inďŹnite set of atomic  variables   Âź  Â˝  , the boolean operations  ,  (not and or respectively) and the future temporal operators  (next and generally respectively), along with the    quantiďŹer  (for all). We will use the convention that all  unary operators (including ) bind weaker than binary operators, unless otherwise indicated by brackets. A formula  of QPTL is deďŹned inductively as follows.   For all  , is a formula.   If  and  are formulas then so are      .  and     If  is a formula and  then   is also a formula.  We will deďŹne additional operators in terms of those  are well  above. The propositional operators    known to be expressible in terms of  and . We will also  consider the formulas  (respectively âtrueâ and âfalseâ)  to be abbreviations for, respectively  Âź   Âź  and  Âź    Âź  and we will use  as an abbreviation for Âź   where   Âź   . The other abbreviations in QPTL  are:             U             Ă   Ă          where    for the least  such that  does not appear in   or  . These operators will be referred to as, respectively:  existential quantiďŹcation, future, waiting, and until.  We will next present the deďŹnition of a structure  that  evaluates a formula in the language QPTL. This semantic interpretation will be referred to as QPTL and is more  general than the one given in [6].  A structure,  , is given by the tuple         . Given  we say the structure  Âź    Âź   is an  -variant of  for some ďŹnite   , if      Âź   .  We say a structure       is a QPTL model if  is a bijection. In this case we usually let  be an inďŹnite   . In this paper we  sequence Âź  Â˝   where   investigate the general case, where there is no restriction on  the function . This is the only difference between QPTL  and QPTL , and the semantic interpretation of the formulas  is this same for both languages.  Given some structure  we deďŹne the   moment of  be  the tuple    for   and inductively deďŹne a formula   to âholdâ at the   moment of  (denoted    ) as                         for all             Â˝  Âž     Â˝ or    Âž                                   for all -variants       ) if    . If  Âź  Âź  We say  is a model of (written    for every structure  and for every   we have    ,  we say  is valid (written  ), and if  is not valid, we  say  is satisďŹable.  We can see the function maintains the relationship between the temporal moments and the states of the structure. Given a structure      we can see some state   could be repeated if there is some    such that      . However the actual moment   will  never be repeated. The interpretation of formulas is derived  from the moment , and only the interpretation of atoms are     derived from the state. For example, if   then     if and only if     , however it may be  while      .  that     The language QPTL is decidable, though nonelementarily complex. The process to determine the satisďŹability of some formula  involves constructing a nondeterministic -automaton that accepts exactly the models  that satisfy . The satisďŹability of  is therefore equivalent  to the non-emptiness of the automaton. For details on an  optimal decision procedure for QPTL, see [13] or [6].  We will refer to these generalized semantics as the repeating semantics (QPTL ). The states are the elements of  , and the temporal moments are the pairs   . The most  basic example of the expressive difference between QPTL  and QPTL if the formula:          (1)  which appeared as an axiom in [6] and is equivalent to the  statement ânow will never happen againâ. This is a validity  , is satisďŹable in  of QPTL but its negation,    any model  where there is some    such that    .  Another example of the expressive difference is being  able to succinctly express such concepts as whether the  model is deterministic (i.e. every state in the model will  always be followed by the same state):               (2)  3. Undecidability  We prove that QPTL is highly undecidable by showing  that QPTL can encode a highly undecidable tiling problem. This technique was used in [8] to prove undecidability  Proceedings of the 10th International Symposium on Temporal Representation and Reasoning and  Fourth International Conference on Temporal Logic (TIME-ICTLâ03) 1530-1311/03 $17.00 ÂŠ 2003 IEEE  of modal logics and has since been used in many similar  scenarios [15], [5], [11], [7]. The important step in encoding a tiling is to specify the model to be grid-like, and  all these approaches use branching or bi-modal languages.  This proof is unique in that it only uses non-branching temporal operators.  Tiling Problem is as follows: We are given  The  a ďŹnite set         of tiles. Each tile   has four coloured sides: left, right, top and bottom, written           and   . Each side can be one of  colours  for      . Given any set of these tiles, we would like to  with these tiles such  know if we can cover the plane  that adjacent sides share the same colour.  DEFINITION 1 Given some set of tiles, , we say   is a tiling function for if for all      1.           2.          .  If such a function exists we say    24  33  23  3    15  8    22  3      6    0  THEOREM 1 The satisďŹability problem for QPTL is  highly undecidable.  Given the set of tiles we give a formula,   , of  QPTL that is satisďŹable given the QPTL semantics if and  only if recurrently tiles the plane. As with many approaches, to show the satisďŹability problem for a language  is highly undecidable it is enough to show that there is a  formula that speciďŹes the under-lying Kripke structure to  be âgrid-likeâ. This is exactly what we will do here. What  makes this approach different is that the language is syntactically a one dimensional language: we do not so much as  specify the properties of the under-lying Kripke structure,  as we specify the properties of a path through the structure.  Examples of the properties of the path we will be specifying  are:  whether we have visited a state before;  how many times have we visited a state;  30    11      29    18    19  5  1  Key.  b  y  a  x    20  12  0  tiles the plane.  31  21  2  0    13  7  1    32  14  2    Given some ďŹnite set of tiles , the tiling problem is  to decide whether or not tiles the plane. This problem  was shown to be ÂźÂ˝ -complete (the complement of the recursively enumerable set, or co-RE) [2].  We will also use the  Recurrent Tiling Problem,  tiling problem with the  which is the same as the  following additional requirement: The tile Âź must occur  inďŹnitely often in the bottom row (i.e.     Âź for inďŹnitely many ). In such a case we say recurrently tiles  the plane. In [9] this problem was shown to be highly undecidable, or Â˝Â˝ .      4  28  10  4  1    27  17    9  2    3  26    16  4  Figure 1. An illustration of the function  where           25    5  ,  how many time have we visited some state since we  last visited some other state.  These properties could in fact be represented in a weaker semantic than QPTL , and we discuss this later. The properties mentioned above will be used to âwrapâ a path through  a grid. To describe how that is done we must ďŹrst describe  a new pairing function.  DEFINITION 2 We deďŹne the function      recursively as for all   , Âž     and for all ,  Âž      Âž  1.              2.                otherwise.  We also deďŹne  Âˇ      Âˇ     by      if   ,         The function  is illustrated in Figure 3. This is a relatively  complicated pairing function, however it has a number of  useful properties which will allow us to encode this function in QPTL . These properties are given in the following  deďŹnition.  DEFINITION 3 Let be some set and let  be some function. Given any    let Â˝  integers such that Â˝   Âž   , or  integer exists. We say is a grid-path if    Proceedings of the 10th International Symposium on Temporal Representation and Reasoning and  Fourth International Conference on Temporal Logic (TIME-ICTLâ03) 1530-1311/03 $17.00 ÂŠ 2003 IEEE      Âž be two  if no such  :  1. there are exactly two integers,   Â˝   Âž  ,  2.  Â˝  is even if and only if  3. for all    modulo 2:  (a)  Â˝  (b)  Â˝    Âž  and  Âž,  Â˝  Â˝  Â˝ are congruent   Â˝ ;  Âž  Âž ;  Âž  4. if there exists   such that Â˝  Â˝   then there  is some   such that Â˝    Âž ,  5. there exists     The proof for  follows from the fact that  given Âž  Â˝    Âž  , Âˇ Â˝   .  This can be seen from the fact that Âž    Âž  and therefore   Âˇ Â˝   Âˇ Âž   . The  same reasoning applies to Â˝ so we can deduce  that Â˝    Âž (from the fact that Âˇ Â˝    Âˇ Â˝ ). Therefore Âˇ Â˝     so the same  reasoning will show Â˝    Âž for some  .  The proof for   follows trivially from the  proof given for  .   such that  is even,  such that   Âž  Â˝    Â˝  Âž   Â˝  such that Â˝    Âž  .  We will refer to the ďŹve conditions in DeďŹnition 3 as      .  LEMMA 1 The function  is a grid path.  PROOF:  We will show that all the conditions of DeďŹnition 3 are satisďŹed  For  , it can be seen from Figure 3 that if  Âž     Âž , then Âˇ     .  Suppose     . For all , if        and Âž    then  or   , and if    Âž then  or   . Therefore  Âˇ    implies   ,       and  Âˇ      implies   ,      .  It follows that there is at most one    such  that      .  To prove that there is at least one   such  that       suppose, without loss of generalization, that Âž     Âž and Âˇ    . Then it can be seen that        (the calculation is left to the reader).  The condition   follows trivially from the  proof for  , and the fact that         .  Having proven the ďŹrst two conditions, for all     we let Â˝ be the least integer such that   Â˝   , and let Âž be the greatest such integer.  For the ďŹrst part of  , it can be shown that  if Â˝ and Âž are congruent modulo 2 then there is  some  such that Â˝  Âž  Âž . Similarly since  Âž and Â˝ are congruent modulo 2 there is some   such that Âž   Âž  Â˝ . Therefore Âˇ Â˝     Âˇ  and    for all  Â˝ . Therefore Âž  Â˝ .  For the second part of  , suppose Âž        Âž and (without loss of generalization)  Âˇ   Âˇ     . Then the result follows  from the fact that           (from  the proof for  ).  The following proof is required to show that any gridpath represents a grid structure in exactly the same way   does.  LEMMA 2 Given some set  there is a bijection Ă   Ă     .  ,      and a grid-path       such that   PROOF:  Given any integer , let the subset Ă  be  the set        Âž      .  We prove the lemma by induction over  where  the induction hypothesis is:  Given any integer , there is some bijection  ĂĂ   Ă     such that for all    Âž ,  ĂĂ     .  We begin with   . This is trivial, as  Âź    and all that is required is to deďŹne  ĂĂÂź     .  For the inductive step, suppose that for some    integer  there is a bijection ĂĂ Ă  such that for all     Âž , ĂĂ      .  We construct ĂĂ as follows. Let ĂĂÂˇÂ˝    ĂĂ  for all  Ă . We would like to de   Âž ,  ďŹne ĂĂÂˇÂ˝ such that for all  ĂĂÂˇÂ˝     , however we must ensure  that if      for     Âž , then       .  For all ,   Âž     Âž we note  that Âˇ     and furthermore, if      if and only if Âˇ    Â˝ for some    . Therefore we are required to show that for  all such if Âˇ      then for all    we have      , and if Âˇ    then  there is some    such that      and      . This is proven in Lemma 3 below.  Therefore we can deďŹne the bijection ĂĂÂˇÂ˝  such that for all     Âž , ĂĂÂˇÂ˝      . Furthermore, by construction, the bijection ĂĂÂˇÂ˝ agrees with ĂĂ over the set Ă so by  induction there is some bijection Ă such that for  all , Ă     .   Proceedings of the 10th International Symposium on Temporal Representation and Reasoning and  Fourth International Conference on Temporal Logic (TIME-ICTLâ03) 1530-1311/03 $17.00 ÂŠ 2003 IEEE    ,  Below is a technical sub-lemma required to complete the  proof of Lemma 2.  LEMMA 3 Suppose that there is some bijection Ă     such that for all   Âž Ă    .    Then for all  where   Âž     Âž :                 1.  Âˇ        2.  Âˇ                                    PROOF:  We will prove the lemma by strong induction.  As the base case, let     Âž . Therefore Âˇ      and we must show for  all   ,    . Suppose for contradiction that there is some    such that    . If Âˇ    then      implies    Âž , and since Ă  is a bijection we would have        contradicting DeďŹnition 3.1. Since     Âž we  have Âˇ    . By the construction of  we  can see that Âˇ  is even if and only if  is even.  Therefore  is even if and only if  is odd, contradicting DeďŹnition 3.2 and thus for all   ,    . This completes the base case of  the induction.  We will now prove the inductive step. Suppose that for some     Âž , we have deďŹned Ă ÂˇÂ˝   for all   . If Âˇ     ,  then by the construction of , Âˇ    . By  the induction hypothesis there exists      such that     , and consequently by  DeďŹnition 3.5 for all   ,    . This  completes the proof of the ďŹrst case.  For the second case of the inductive step,  suppose for some     Âž we have deďŹned Ă ÂˇÂ˝   for all    and Âˇ    . To continue with the strong induction, we  must include another base case, corresponding  to     Âž  . For such a case we  must show that there is some    such that    . In this case Âˇ        so          . Also,  Âˇ     and      Âž so         . Therefore by  DeďŹnition 3.4 there must be some    such  that    .  We will complete the induction in two steps.  Âž  First we will show that for any       Âˇ  with     there is some    such that    . The next step will be to show that  in such a case,    .                                        There are exactly    distinct     Âž  such that Âˇ    , and since Ă  is a bijection we can see that for each such  there is no     Âž such that    . By DeďŹnition 3.1, for each such  there must exist some  Âž such that     ,      unique  and    and   Âž   are congruent  modulo 2 (since Âˇ    Âˇ   Âˇ     Âž    ). We now apply DeďŹnition 3.3.a,  where   Â˝ ,   Âž , Âž      Â˝ and   Âž . Therefore we must have   Âž    .  Since there is such a for each of the     distinct  , there must exist Âź   such that  Âž      Âź  Â˝        Âž where  Âž  Âž  ÂˇÂ˝  . Since          ,  it must be that    for some , and thus there  is some    such that    .  It remains to show that Ă ÂˇÂ˝   .  Suppose that for some  ,      but    . By the induction hypothesis,  Ă ÂˇÂ˝      and there is some     such that    .  If   then by DeďŹnition 3.3.b for any    such that    we must have   .  However if    then by the induction hypothesis     implies        contradicting the fact the  is a grid-path.  then by DeďŹnition 3.3.b for any   If   such that     we must have   .  However if   then by the induction hypothesis     implies        contradicting the fact the  is a grid path (DeďŹnition 3.1..          To complete the proof of undecidability we must encode  the tiling. This relies on some convenient properties of the  function . With respect to QPTL , the main property that  we are interested in is that if a state occurs twice in a model,  its interpretation with respect to propositional variables remains unchanged. We wish to create a formula which forces  the model to have a grid path, and then use propositions to  represent the different tiles in . We can then make sure  that the sides of adjacent tiles match up.  We begin by deďŹning the formula   . This consists  of two parts: the ďŹrst   is true at the initial state in a  model       if and only if  is a grid-path; and the  second  ensures that the sides of adjacent tiles agree.      DEFINITION 4 Let the formula     and    . The formula   is given by the  following deďŹnitions:      Proceedings of the 10th International Symposium on Temporal Representation and Reasoning and  Fourth International Conference on Temporal Logic (TIME-ICTLâ03) 1530-1311/03 $17.00 ÂŠ 2003 IEEE                                                                                                                     In this deďŹnition we use the variable  to mark even  states. That is there is some -variant of  ,  Âź such that    Âź  if and only if there is some even  such that    . The formula also enforces that   Âź  if  and only if there is some odd  such that    . This  is enough to enforce DeďŹnition 3.2. It can also be seen that       if and only if for all    ,     .  Otherwise for any -variant  Âź of  ,    Âź   if and  only if    Âź  .  LEMMA 4 Let      . Then     and only if  is a grid-path.    if  if there is some    such that      then      .  Suppose       . Since we know  from the proof of Lemma 2 that either      or     . We also know     if  and only if there is some    such that     . Therefore if    , then        and hence      ,  (from DeďŹnition 2). The case for       is similar.        be the set of tiles, and for each          and      .  Finally let !   ! be propositions corresponding to the  tiles in .  Let   let    We will now deďŹne the formula  such that if     , then the function     is a  recurrent tiling function, where     if and only  if    Ă   . To do this we require the following  lemma which associates horizontal and vertical directions  in the grid with properties deďŹnable in QPTL.  LEMMA 5 Given a model       where  is a gridpath, let Ă     be some bijection such that for all  , Ă  . For all , let Ă     . Then  if for all       ,       ,     then        if there is some    such that         and    .      and   then  PROOF:  Since Ă is a bijection and for all ,  Ă  , all we have to show is that  given      if for all   ,     then       ,    !    "#  $  #    "  DEFINITION 5 The formula  PROOF:  This follows directly from the semantic deďŹnitions given in Section 2, and comparison with  DeďŹnition 3.       !                    "               is given as  !     !                "# $       #     LEMMA 6 The formula " is satisďŹable if and only if  recurrently tiles the plane.  PROOF:  Suppose there is some function      satisfying the properties of a tiling. We deďŹne a  model ,  , of " as follows. Let       , where !   if and only if    .  Since  is a grid-path (Lemma 1), we have      (Lemma 4).  For all  there is some unique such that      , and hence for all  , !     for some unique , so  will always be satisďŹed.  Suppose that !    for some , and  !   . By Lemma 5, if       then    and if     then    , so "# and $ will be satisďŹed.  Finally, for inďŹnitely many ,     .  From the proof of Lemma 3 we know that      only if      and    , so  it follows that    # and thus    " .  Proceedings of the 10th International Symposium on Temporal Representation and Reasoning and  Fourth International Conference on Temporal Logic (TIME-ICTLâ03) 1530-1311/03 $17.00 ÂŠ 2003 IEEE  Now suppose there is some model     such that    . We construct  a recurrent tiling function as follows.  As    , it follows from  Lemma 4 that  is a grid-path. Therefore, by  Lemma 2, there is some bijection Ă        such that Ă   . We deďŹne the tiling  function        by     if and only if    Ă    . Since      , is well deďŹned.   , and    . By  Suppose     examination of the function  we can see             . Let      . Since  is a grid-path, it follows  Ă  from the deďŹnition of and the proof of Lemma 3  that       . It therefore follows that      . Hence    for some   Âž       , so    . Since  , and         we ďŹnd that        ,  and thus           .  Now suppose that      . We apply a      similar process to show    provided     . If     we must  have    ,      and      .  By the proof of Lemma 1 we must have        , and hence    so there is no  tile to the left. This can be seen by inspection of  Figure 3.   , we must have  Finally, since            for inďŹnitely many  . If       we must have      for some . Therefore      , and      , thus    for inďŹnitely  many x.   Ă  We have shown that QPTL with repeating states is undecidable when we allow the function      to be  arbitrary and thus we have proven Theorem 1. The repeating semantics are too expressive to to allow any form of  automated deduction. However, we can see that the result  could be stronger, since we only required  to belong to a  class of functions that could represent a grid-path (for example, the class of functions where each state is repeated  only a ďŹnite number of times). The satisďŹability problem  for QPTL could be even harder than  .  4. QPTL with ďŹnite repeating states  We will now examine a class of functions which does not  allow  to be a grid-path. We deďŹne the semantic interpretation QPTL to be the same as the semantic interpretation  QPTL , except now we require that the range of  be ďŹnite (i.e. there are only a ďŹnite number of states). These  semantics retain much of the expressive power of QPTL ,  however the set of states is no longer an inďŹnite domain.  Formulas such as (2) are still expressible and meaningful.  However it is worth noting that these semantics are not a  generalization of the usual semantic interpretation QPTL .  In fact, every model of QPTL is disallowed in QPTL  since the model will necessarily have an inďŹnite number of  states. Consequently, contradictions in QPTL might be validities in QPTL , such as            (3)  Since the models for QPTL can be enumerated, we  might expect the satisďŹability problem to be recursively  enumerable. However, we will now show that the validity  problem (determining whether a formula is valid) is undecidable, and consequently the satisďŹability problem remains  undecidable.  To show that QPTL is undecidable given the interpretation, QPTL , we will use the    tiling problem. Since  the range of  is ďŹnite, we cannot represent the entire plane.  However, we can use the following deďŹnition and lemma to  get around this problem.  DEFINITION 6 The th corner of the plane,    , is the  set           . We say a set of tiles, , tiles    if there is some function      such that for all    where     ,               2.       LEMMA 7 A set of tiles, , satisďŹes the   tiling problem, if and only if for all   ,  tiles the  corner of the  1.              th  plane.  PROOF:  If there is some tiling function,        , then restricting the domain of to   will  show that  tiles   .  Now suppose that for all    ,  is a tiling  function for   . We will deďŹne a tiling function,        by induction over . We ďŹrst deďŹne       to be some function such that        for inďŹnitely many . Clearly  such a function exists. For the inductive step suppose that we have deďŹned       such that  there are inďŹnitely many  where for all    ,       . We deďŹne  such that:  1.           ;  2. for inďŹnitely many , for all       .  Proceedings of the 10th International Symposium on Temporal Representation and Reasoning and  Fourth International Conference on Temporal Logic (TIME-ICTLâ03) 1530-1311/03 $17.00 ÂŠ 2003 IEEE      ,  4  3  2  1                           31 Ă 27            23       29  15  22 32           14  21    8  13  20 30      7  12  19      3  6  11  18 28  25  33  24  2  0  0  5  1  0    10  4  1    17    9  2  3    4    It is a consequence of Ramseyâs theorem that   must exist. We deďŹne the funcsome such     by         , and  tion  it is not hard to see that is a tiling function.      We can now generalize the results of the previous section  to apply only to the th corner of the plane. We deďŹne the  function       by    if   and    otherwise. We deďŹne      by     where is deďŹned in DeďŹnition 2. The  restricts the gridpath the the th corner of the  function  plane and is illustrated in Figure 4.              We can now proceed as we did in the previous section.  For reasons of brevity we will not reproduce the full proofs,  but rather skip straight to encoding the restricted grid-path     (grid-path  in QPTL. We will deďŹne the formula  corner) which forces the structure to represent a grid-path  up to some arbitrary point, and all other states in the gridpath are collapsed to a single point, the ďŹnal state. We will  use the free variable to mark the ďŹnal state. We retain the  deďŹnitions      and   given in DeďŹnition 4. We also add two new conditions. The ďŹrst requires  that be true at only one state, and the second requires that  after the ďŹrst occurrence of , only states that have previously appeared in the model can be used. Although the ďŹnal  state appears inďŹnitely often in the model, the formula    will always be true at the ďŹnal state, simply because it is not  the last occurrence of that state.  DEFINITION 7 The formula        is given by the fol-                                                                                                                                                       26  16  Figure 2. An illustration of the function  ,  where   lowing deďŹnitions:                  Proofs similar to those given in the previous section will  show that if     is satisďŹed by some model, that model  will act like a grid-path until is true. Particularly, if     for all     , then it follows that   deďŹnes a grid-path over the  corner of the plane. The  only difference between   and   is that we do not  require the tiling to continue after the ďŹrst moment that is  true.  We can now deďŹne the formula  , which is similar  to the formula  , however it is not required to encode a  recurrent tiling. Again, a proof of soundness can be inferred  from the previous section.    DEFINITION 8 The formula   is given as                                                                                                  We can now sketch a proof of the undecidability of the  satisďŹability problem. The form of the proof is slightly different since given any satisďŹaible formula, we can always  show it is satisďŹable by enumerating all QPTL models.  However this process will not halt if the formula is unsatisďŹable. Several technical sub-lemmaâs are omitted, however these results are similar to results given in the previous  section and are not hard to reproduce in the context of this  section.  LEMMA 8  validity.    can tile the plane if and only if   is a  Proceedings of the 10th International Symposium on Temporal Representation and Reasoning and  Fourth International Conference on Temporal Logic (TIME-ICTLâ03) 1530-1311/03 $17.00 ÂŠ 2003 IEEE    PROOF:  If can tile the plane, then will clearly be  able to tile any portion of the plane. The formula   requires that the model be a grid-path up  to some point, and all moments after that point  share a single state. Since tiles the plane we  can easily ďŹnd an assignment of the atoms in  that will satisfy the formula Âž . Since this process  can be repeated for any assignment of  satisfying    , it must be that Âž is a validity.  If             is a  validity, then it must be true for every model. It  thus follows that can tile the  corner of the  plane for every , and thus can tile the plane.  Âź Â˝  Âź  Âź Â˝              Âź                ÂˇÂ˝      ÂˇÂ˝        Âź   ÂˇÂ˝        We have shown that even with ďŹnite models these semantic interpretations make QPTL too expressive to be axiomatized. We will now examine one more semantic deďŹnition  which is more general than the linear models allowed by  QPTL , but has a decidable satisďŹability problem.  5. QPTL with deterministic successors  We now examine the semantic QPTL , a restriction of  QPTL which allows states to be repeated throughout a  model, however it restricts the successor function to be deterministic. The semantic interpretation QPTL is the same  as the semantic interpretation QPTL except that we now  require to be deďŹned such that if    , then        . These semantics allow all models of  QPTL, however they also allow models that loop inďŹnitely.  The resulting theory is decidable as we show below.  The cost of this decidability is expressivity. We ďŹnd that  QPTL is only slightly less restrictive than QPTL (in fact  we show a QPTL is satisďŹable by translating formulas and  models to agree with QPTL ). This semantic still allows us  to examine periodic models, and formulate such concepts  as the period of cycle for an automata. Importantly, the  complexity of satisďŹability problem for QPTL is no harder  than the satisďŹability problem for QPTL , so any increase  in expressivity is an increase we get for free.  We will show that the satisďŹability problem for QPTL  is reducible to the satisďŹability problem for QPTL , and  hence decidable. To do this we simply unwind the QPTL  model and allow the variable Âź to mark the beginning and  the end of the loop.  DEFINITION 9 Given any QPTL model     ,  we say    is the ďŹrst looping state if there exists integers    such that       and for all   ,     implies   .  The  -marked version of is the QPTL model  Âź   Âź    Âź  Âź  where  Âź  Figure 3. An illustration of  of .  1.           Âź  Âź  Âź  if  state,  2.         Âź  Âź  , the  -version   is a ďŹrst looping  Âź  otherwise.  This is illustrated in Figure 5, where    , Âź     , and  and ÂˇÂ˝ are marked with Âź .  For formulas without quantiďŹcation or the variable Âź , it  is clear that satisďŹability is preserved in the  -marked version of the model. To extend this to include formulas containing quantiďŹers we must transform the formula so that it  only refers to moments up to (and including) the last moment in the loop, and infers all inďŹnite behavior from that  ďŹnite set of moments. This is done in the following deďŹnition.  DEFINITION 10 The  -version of  is deďŹned in the following stages. First we deďŹne a translation for the subformulas of . For every sub-formula,  , of  let  describe a unique variable that does not appear in . Furthermore, suppose that the variable Âź does not appear in  . We deďŹne by induction:                 Âź     Âź            Ă   Âź                                1. Given     , some sub-formula of , deďŹne the      formula:    2. Given   formula:               Âź                 (4)   , some sub-formula of , deďŹne the        Proceedings of the 10th International Symposium on Temporal Representation and Reasoning and  Fourth International Conference on Temporal Logic (TIME-ICTLâ03) 1530-1311/03 $17.00 ÂŠ 2003 IEEE      Âź                (5)  Finally we enumerate all the sub-formulas of  the form  or  , as       . Then  ÂŁ  Â˝      which have         (6)  The deďŹnition of ÂŁ requires the temporal operators to  be modiďŹed so they never refer to the same state at different  moments. This way ÂŁ can be interpreted in a linear model  (i.e. a QPTL model), however it will simulate the looping  behavior of a QPTL model. The variable  is used to  mark the start and end of the loop (if there is a loop). The  atoms,  , are used to reference what formulas have been  true at, or since the start of the loop. All sub-formulas of ÂŁ  only refer to moments up to the end of the loop and infer  the inďŹnite behavior of the the model from those moments.  For every sub-formula,  , of the interpretation of  the operator  will remain unchanged at all moments except for the moment before the second occurrence of  . At  does not  this moment we must ensure that the operator  refer to the next moment, but rather the ďŹrst moment that   was true. This way we can ensure that the properties of the       loop are maintained. For example if  and   , to make ÂŁ satisďŹable in QPTL we must ensure that  can refer to previous moments. The formula    allows us to refer to previous moments by ensuring  that   is true in all moments after the ďŹrst moment   was true if and only if  was true at that moment. Just before the second moment  is true,  does not refer to the  next state in the model (since  is true there). Instead ÂŁ  âinterpretsâ  as true if and only if   is true, which is  true if and only if  was true at the start of the loop. In this  way ÂŁ behaves the same way on the  -marked version of  a model, as behaves on the model itself.   , of the interpretation of  For every sub-formula,  the operator  is altered so it only refers to moments up  to the end of the loop (the moment before  is true for the  second time). The formula   will ensure that the atom    is true at some moment if and only if  has been true  at every moment since the ďŹrst moment  was true. The  formula  is then interpreted to be true if and only if  is  true up to the end of the loop, and   is true at the end of    the loop also. This will only happen if  was true at every  moment in the loop, and would therefore for true at every  subsequent moment in the QPTL model. Note that since  the interpretation of  is deďŹned in terms of the operator  , the interpretation remains valid even for models where   is false for every moment.  It is now a simple matter to show the satisďŹability problem is decidable. We will give a sketch of the proof below.  Ă  LEMMA 9 Suppose    . Then is satisďŹed by  some QPTL model if and only if ÂŁ is satisďŹed by the  -marked version of .  PROOF:  The reasoning above can be applied inducis satisďŹed by some  tively to show that if  QPTL model , then ÂŁ will be satisďŹed by the  -marked version of .  If ÂŁ is satisďŹed by some QPTL model ,  where  is true for at most one moment, then  clearly will also be a model for . If ÂŁ is sat   , where   isďŹed by some model,  is true for at least two moments, we can ďŹnd a  QPTL model of by deďŹning a function Âź that  agrees with up to (but not including) the second  moment that  is true and loops back to the ďŹrst  state where  was true. Since the successor function is deterministic, this is enough to deďŹne the  model. A simple inductive argument will show  that will be satisďŹed by the model    .   Consequently is satisďŹable in QPTL if and only if ÂŁ  is satisďŹable in QPTL. Since the size of ÂŁ is polynomial  in the size of the complexity of the decision procedure is  roughly equivalent (bearing in mind that the decision procedure for QPTL is non-elementary [13]). From this we can  infer an optimal decision procedure for QPTL .  It is also worth noting that a recent, complete axiomatization of QPTL, [6] speciďŹed the axiom QX0, (given as the  equation 1), which is not necessarily valid in QPTL . However all the other axioms and rules given in that axiomatization are sound for QPTL , and the models of QPTL which  are not models of QPTL are exactly the models, , such  that  . It is therefore worth considering whether  that axiomatization, without the axiom QX0, is complete  for QPTL . However the proof of completeness for QPTL  was very complicated given the QPTL semantics, and a  proof of completeness given the QPTL semantics has not  yet been investigated.  6. Conclusion  In this paper we have investigated several alternative  semantics for QPTL which allow states to be repeated  throughout a model. These semantics were generated by  varying the properties of the function , which maps moments of time to the states of the model. While we have not  systematically investigated the decidability of all possible  variations of , we have identiďŹed three semantics which  give a good indication of the relationship between the restrictions on and the complexity of the satisďŹability problem.  For the least restrictive semantic, QPTL , we have  shown that the satisďŹability problem is highly undecidable,  via an encoding of the recurrent tiling problem. While this  is enough to show that the language is too expressive to  Proceedings of the 10th International Symposium on Temporal Representation and Reasoning and  Fourth International Conference on Temporal Logic (TIME-ICTLâ03) 1530-1311/03 $17.00 ÂŠ 2003 IEEE  be of practical use, it only scratches the surface of the true  complexity of the language. When encoding the tiling problem we only required the function to allow a state to be  repeated twice, rather than arbitrarily. Also, the formulation of the tiling problem only required the nesting of three  propositional quantiďŹers. The effect of quantiďŹer depth on  the satisďŹability problem and the true complexity of QPTL  are also worth investigating.  We have also shown that the satisďŹability problem is coRE complete when the models are restricted to have a ďŹnite  number of states (QPTL ). It should be noted the same  proof will sufďŹce to show that the satisďŹability problem is  co-RE complete when is restricted to have a ďŹnite number  of states, and each state can have at most two successors,  (i.e.        implies either     ,         or       ). This shows  that even quite strong restrictions on are not enough to  make the satisďŹability problem for QPTL decidable.  The last semantic we investigated was QPTL which required the successor function to be deterministic. The satisďŹability problem was shown to be decidable, and a decision  procedure was given. There are still some semantics that  are less restrictive than QPTL and are not known to be decidable, however these are quite artiďŹcial and we will not go  into them here.  Finally it is worth noting some comparisons with work  done in hybrid logic. We have seen that allowing repeating  states allows us to quantify not only propositional atoms,  but also the states of the model. Quantifying the states of a  model has been studied extensively in hybrid logic [1], [7].  The proof of undecidability given in this paper is comparable to the one given in [7], since it essentially uses propositional quantiďŹcation to simulate Gorankoâs reference pointers. The signiďŹcance of the proof given here, is that it uses a  syntactically linear language, and does not rely on branching modal operators.  [7] V. Goranko. Hierarchies of modal and temporal logics with  reference pointers. Journal of Logic Language and Information, 5(1):1â24, 1996.  [8] D. Harel. Recurring dominoes: making the highly undecidable highly understandable. In Proc. of the Conference on  Foundations of Computing Theory, pages 177â194, 1983.  [9] D. Harel. Effective transformations on inďŹnite trees, with  applications to high undecidability, dominoes, and fairness.  Journal A.C.M., 33(1):224â248, 1986.  [10] Y. Kesten and A. Pnueli. A complete proof systems for  QPTL. In Proceedings, Tenth Annual IEEE Symposium on  Logic in Computer Science, pages 2â12, 1995.  [11] M. Marx and M. Reynolds. Undecidability of compass logic.  Journal of Logic and Computation, 9(6):897â914, 1999.  [12] A. Pnueli. The temporal logic of programs. In Proceedings  of the Eighteenth Symposium on Foundations of Computer  Science, pages 46â57, 1977.  [13] A. Sistla, M. Vardi, and P. Wolper. The complementation  problem for Buchi automata with applications to temporal  logic. Theoretical Computer Science, 49:217â237, 1987.  [14] A. P. Sistla. Theoretical Issues in the Design and VeriďŹcation of Distributed Systems. PhD thesis, Harvard University,  1983.  [15] E. Spaan. Complexity of Modal Logics. PhD thesis, Universiteit van Amsterdam, 1993.  References  [1] C. Areces, P. Blackburn, and M. Marx. The computational  complexity of hybrid temporal logics. L.J. of the IGPL,  8(5):653â679, 2000.  [2] R. Berger. The undecidability of the dominoe problem.  Mem. Amer. Math. Soc., 66, 1966.  [3] K. Englehardt, R. van der Meyden, and Y. Moses. Knowledge and the logic of local propositions. In Theoretical Aspects of Rationality and Knowledge, Proceedings of the Seventh Conference, pages 29â41, 1998.  [4] K. Fine. Propositional quantiďŹers in modal logic. Theoria,  36:336â346, 1970.  [5] T. French. Decidability of quantiďŹed propositional branching time logics. In Proceedings of the 14th Australian Joint  Conference on ArtiďŹcial Intelligence, pages 165â176, 2001.  [6] T. French and M. Reynolds. A sound and complete proof  system for qptl. In Proceedings of AiML 2002, to appear.  Proceedings of the 10th International Symposium on Temporal Representation and Reasoning and  Fourth International Conference on Temporal Logic (TIME-ICTLâ03) 1530-1311/03 $17.00 ÂŠ 2003 IEEE 