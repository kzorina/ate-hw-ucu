QuantiÄÅ¹Âed Propositional Temporal Logic with Repeating States  Tim French  School of Computer Science and Software Engineering  University of Western Australia  tim@cs.uwa.edu.au  Abstract  QuantiÄÅ¹Âed Propositional Temporal Logic (QPTL) is a  linear temporal logic that allows quantiÄÅ¹Âcation over propositional variables. In the usual semantics for QPTL, a  model is an inÄÅ¹Ânite discrete linear sequence of states, with  each state having some propositional interpretation. The  effect of this is that the interpretation of a proposition at  one point in time is independent from its interpretation at  another point in time. In this paper we examine the expressivity and decidability of an of QPTL, given generalizations  of the usual semantics that do not have this restriction. We  introduce the repeating semantics (QPTL ), which allows  states to be repeated throughout a model. While this semantic interpretation does not affect the unquantiÄÅ¹Âed fragment  of QPTL it signiÄÅ¹Âcantly increases the expressive power in  the presence of propositional quantiÄÅ¹Âcation. In the main  result of this paper we show that QPTL makes the satisÄÅ¹Âability problem highly undecidable through a complicated  encoding of a tiling problem. We also investigate two less  expressive semantics which still allow states to be repeated.  We prove the satisÄÅ¹Âability problem for one is undecidable,  and decidable for the other.  1. Introduction  QuantiÄÅ¹Âed Propositional Temporal Logic (QPTL) [14],  extends traditional propositional linear temporal logic,  PLTL [12], and has the ability to quantify over propositional atoms. The set of formulas of QPTL is built up recursively from the atoms via classical negation and disjunction,  temporal next-time and future-always connectives (from the  standard PLTL) along with quantiÄÅ¹Âcation over atoms. The  formulas are evaluated over a linear sequence of states, with  each atom being true or false at each state. The logic is  expressively equivalent to BuchiÃ¢Â€Â™s monadic second-order  logic of one successor (Ä‚Â‹ Ã‚ËÄ‚Â‹ ) and consequently it has been  shown to be decidable (albeit non-elementary).  In this paper we deÄÅ¹Âne new semantic interpretations  (QPTL , QPTL , QPTL ) of QPTL by removing the restriction that the model be a linear sequence of states. We do  however retain the basic concept of a linear model by distinguishing the states of the model from Ã¢Â€Âœtemporal momentsÃ¢Â€Â,  (the time at which a state is visited). That is, the temporal operators of the language are interpreted with respect to  countable, discrete, linear moments in time; while the atoms  are interpreted with respect to the (possibly recurring) states  of the model. We cannot assume that the interpretation of  an atom at one temporal moment is independent of its interpretation at another moment. This way we can allow the  temporal proposition Ã¢Â€Âœnow will never happen againÃ¢Â€Â to be  false, (however to avoid confusion is is best not to associate  the states with such temporal notions as now).  Our motivation for doing this is largely to investigate the  expressive power of propositional quantiÄÅ¹Âcation in modal  structures. This has been studied extensively in the context  of branching modal structures [4], [3], [5], and also in the  context of strictly linear structures [14], [10]. In this paper we investigate languages which neither have branching  operators, nor a strictly linear structure. Effectively this allows us to apply quantiÄÅ¹Âcation over the states of the model,  which results in a dramatic increase in the expressive power  of QPTL.  The language QPTL has been used to reason about ÄÅ¹Ânite  state machines and automata. By associating a state of the  model with a state of the machine the repeating semantics  allows us to succinctly reason about properties of ÄÅ¹Ânite state  machines, without having to assign an atom to each state of  the machine. For example, the repeating semantics allows  us to detect if a machine will loop inÄÅ¹Ânitely in a single state,  independant of what the actual state is.  Another possible application of such a language would  be reasoning about a trajectory of an agent through some  environment. The states of a model would represent spatial entities, and the temporal moments represent time. The  language can express such concepts as whether the trajectory of the agent is eventually periodic, or whether there are  some states that the agent will only visit once.  Proceedings of the 10th International Symposium on Temporal Representation and Reasoning and  Fourth International Conference on Temporal Logic (TIME-ICTLÃ¢Â€Â™03) 1530-1311/03 $17.00 Ã‚Å  2003 IEEE  2. Semantics for QPTL  follows.  The language QPTL consists of an inÄÅ¹Ânite set of atomic  variables   Ã‚Åº  Ã‚Ë  , the boolean operations  ,  (not and or respectively) and the future temporal operators  (next and generally respectively), along with the    quantiÄÅ¹Âer  (for all). We will use the convention that all  unary operators (including ) bind weaker than binary operators, unless otherwise indicated by brackets. A formula  of QPTL is deÄÅ¹Âned inductively as follows.   For all  , is a formula.   If  and  are formulas then so are      .  and     If  is a formula and  then   is also a formula.  We will deÄÅ¹Âne additional operators in terms of those  are well  above. The propositional operators    known to be expressible in terms of  and . We will also  consider the formulas  (respectively Ã¢Â€ÂœtrueÃ¢Â€Â and Ã¢Â€ÂœfalseÃ¢Â€Â)  to be abbreviations for, respectively  Ã‚Åº   Ã‚Åº  and  Ã‚Åº    Ã‚Åº  and we will use  as an abbreviation for Ã‚Åº   where   Ã‚Åº   . The other abbreviations in QPTL  are:             U             Ä‚Â   Ä‚Â          where    for the least  such that  does not appear in   or  . These operators will be referred to as, respectively:  existential quantiÄÅ¹Âcation, future, waiting, and until.  We will next present the deÄÅ¹Ânition of a structure  that  evaluates a formula in the language QPTL. This semantic interpretation will be referred to as QPTL and is more  general than the one given in [6].  A structure,  , is given by the tuple         . Given  we say the structure  Ã‚Åº    Ã‚Åº   is an  -variant of  for some ÄÅ¹Ânite   , if      Ã‚Åº   .  We say a structure       is a QPTL model if  is a bijection. In this case we usually let  be an inÄÅ¹Ânite   . In this paper we  sequence Ã‚Åº  Ã‚Ë   where   investigate the general case, where there is no restriction on  the function . This is the only difference between QPTL  and QPTL , and the semantic interpretation of the formulas  is this same for both languages.  Given some structure  we deÄÅ¹Âne the   moment of  be  the tuple    for   and inductively deÄÅ¹Âne a formula   to Ã¢Â€ÂœholdÃ¢Â€Â at the   moment of  (denoted    ) as                         for all             Ã‚Ë  Ã‚Å¾     Ã‚Ë or    Ã‚Å¾                                   for all -variants       ) if    . If  Ã‚Åº  Ã‚Åº  We say  is a model of (written    for every structure  and for every   we have    ,  we say  is valid (written  ), and if  is not valid, we  say  is satisÄÅ¹Âable.  We can see the function maintains the relationship between the temporal moments and the states of the structure. Given a structure      we can see some state   could be repeated if there is some    such that      . However the actual moment   will  never be repeated. The interpretation of formulas is derived  from the moment , and only the interpretation of atoms are     derived from the state. For example, if   then     if and only if     , however it may be  while      .  that     The language QPTL is decidable, though nonelementarily complex. The process to determine the satisÄÅ¹Âability of some formula  involves constructing a nondeterministic -automaton that accepts exactly the models  that satisfy . The satisÄÅ¹Âability of  is therefore equivalent  to the non-emptiness of the automaton. For details on an  optimal decision procedure for QPTL, see [13] or [6].  We will refer to these generalized semantics as the repeating semantics (QPTL ). The states are the elements of  , and the temporal moments are the pairs   . The most  basic example of the expressive difference between QPTL  and QPTL if the formula:          (1)  which appeared as an axiom in [6] and is equivalent to the  statement Ã¢Â€Âœnow will never happen againÃ¢Â€Â. This is a validity  , is satisÄÅ¹Âable in  of QPTL but its negation,    any model  where there is some    such that    .  Another example of the expressive difference is being  able to succinctly express such concepts as whether the  model is deterministic (i.e. every state in the model will  always be followed by the same state):               (2)  3. Undecidability  We prove that QPTL is highly undecidable by showing  that QPTL can encode a highly undecidable tiling problem. This technique was used in [8] to prove undecidability  Proceedings of the 10th International Symposium on Temporal Representation and Reasoning and  Fourth International Conference on Temporal Logic (TIME-ICTLÃ¢Â€Â™03) 1530-1311/03 $17.00 Ã‚Å  2003 IEEE  of modal logics and has since been used in many similar  scenarios [15], [5], [11], [7]. The important step in encoding a tiling is to specify the model to be grid-like, and  all these approaches use branching or bi-modal languages.  This proof is unique in that it only uses non-branching temporal operators.  Tiling Problem is as follows: We are given  The  a ÄÅ¹Ânite set         of tiles. Each tile   has four coloured sides: left, right, top and bottom, written           and   . Each side can be one of  colours  for      . Given any set of these tiles, we would like to  with these tiles such  know if we can cover the plane  that adjacent sides share the same colour.  DEFINITION 1 Given some set of tiles, , we say   is a tiling function for if for all      1.           2.          .  If such a function exists we say    24  33  23  3    15  8    22  3      6    0  THEOREM 1 The satisÄÅ¹Âability problem for QPTL is  highly undecidable.  Given the set of tiles we give a formula,   , of  QPTL that is satisÄÅ¹Âable given the QPTL semantics if and  only if recurrently tiles the plane. As with many approaches, to show the satisÄÅ¹Âability problem for a language  is highly undecidable it is enough to show that there is a  formula that speciÄÅ¹Âes the under-lying Kripke structure to  be Ã¢Â€Âœgrid-likeÃ¢Â€Â. This is exactly what we will do here. What  makes this approach different is that the language is syntactically a one dimensional language: we do not so much as  specify the properties of the under-lying Kripke structure,  as we specify the properties of a path through the structure.  Examples of the properties of the path we will be specifying  are:  whether we have visited a state before;  how many times have we visited a state;  30    11      29    18    19  5  1  Key.  b  y  a  x    20  12  0  tiles the plane.  31  21  2  0    13  7  1    32  14  2    Given some ÄÅ¹Ânite set of tiles , the tiling problem is  to decide whether or not tiles the plane. This problem  was shown to be Ã‚ÅºÃ‚Ë -complete (the complement of the recursively enumerable set, or co-RE) [2].  We will also use the  Recurrent Tiling Problem,  tiling problem with the  which is the same as the  following additional requirement: The tile Ã‚Åº must occur  inÄÅ¹Ânitely often in the bottom row (i.e.     Ã‚Åº for inÄÅ¹Ânitely many ). In such a case we say recurrently tiles  the plane. In [9] this problem was shown to be highly undecidable, or Ã‚ËÃ‚Ë .      4  28  10  4  1    27  17    9  2    3  26    16  4  Figure 1. An illustration of the function  where           25    5  ,  how many time have we visited some state since we  last visited some other state.  These properties could in fact be represented in a weaker semantic than QPTL , and we discuss this later. The properties mentioned above will be used to Ã¢Â€ÂœwrapÃ¢Â€Â a path through  a grid. To describe how that is done we must ÄÅ¹Ârst describe  a new pairing function.  DEFINITION 2 We deÄÅ¹Âne the function      recursively as for all   , Ã‚Å¾     and for all ,  Ã‚Å¾      Ã‚Å¾  1.              2.                otherwise.  We also deÄÅ¹Âne  Ã‚Ë‡      Ã‚Ë‡     by      if   ,         The function  is illustrated in Figure 3. This is a relatively  complicated pairing function, however it has a number of  useful properties which will allow us to encode this function in QPTL . These properties are given in the following  deÄÅ¹Ânition.  DEFINITION 3 Let be some set and let  be some function. Given any    let Ã‚Ë  integers such that Ã‚Ë   Ã‚Å¾   , or  integer exists. We say is a grid-path if    Proceedings of the 10th International Symposium on Temporal Representation and Reasoning and  Fourth International Conference on Temporal Logic (TIME-ICTLÃ¢Â€Â™03) 1530-1311/03 $17.00 Ã‚Å  2003 IEEE      Ã‚Å¾ be two  if no such  :  1. there are exactly two integers,   Ã‚Ë   Ã‚Å¾  ,  2.  Ã‚Ë  is even if and only if  3. for all    modulo 2:  (a)  Ã‚Ë  (b)  Ã‚Ë    Ã‚Å¾  and  Ã‚Å¾,  Ã‚Ë  Ã‚Ë  Ã‚Ë are congruent   Ã‚Ë ;  Ã‚Å¾  Ã‚Å¾ ;  Ã‚Å¾  4. if there exists   such that Ã‚Ë  Ã‚Ë   then there  is some   such that Ã‚Ë    Ã‚Å¾ ,  5. there exists     The proof for  follows from the fact that  given Ã‚Å¾  Ã‚Ë    Ã‚Å¾  , Ã‚Ë‡ Ã‚Ë   .  This can be seen from the fact that Ã‚Å¾    Ã‚Å¾  and therefore   Ã‚Ë‡ Ã‚Ë   Ã‚Ë‡ Ã‚Å¾   . The  same reasoning applies to Ã‚Ë so we can deduce  that Ã‚Ë    Ã‚Å¾ (from the fact that Ã‚Ë‡ Ã‚Ë    Ã‚Ë‡ Ã‚Ë ). Therefore Ã‚Ë‡ Ã‚Ë     so the same  reasoning will show Ã‚Ë    Ã‚Å¾ for some  .  The proof for   follows trivially from the  proof given for  .   such that  is even,  such that   Ã‚Å¾  Ã‚Ë    Ã‚Ë  Ã‚Å¾   Ã‚Ë  such that Ã‚Ë    Ã‚Å¾  .  We will refer to the ÄÅ¹Âve conditions in DeÄÅ¹Ânition 3 as      .  LEMMA 1 The function  is a grid path.  PROOF:  We will show that all the conditions of DeÄÅ¹Ânition 3 are satisÄÅ¹Âed  For  , it can be seen from Figure 3 that if  Ã‚Å¾     Ã‚Å¾ , then Ã‚Ë‡     .  Suppose     . For all , if        and Ã‚Å¾    then  or   , and if    Ã‚Å¾ then  or   . Therefore  Ã‚Ë‡    implies   ,       and  Ã‚Ë‡      implies   ,      .  It follows that there is at most one    such  that      .  To prove that there is at least one   such  that       suppose, without loss of generalization, that Ã‚Å¾     Ã‚Å¾ and Ã‚Ë‡    . Then it can be seen that        (the calculation is left to the reader).  The condition   follows trivially from the  proof for  , and the fact that         .  Having proven the ÄÅ¹Ârst two conditions, for all     we let Ã‚Ë be the least integer such that   Ã‚Ë   , and let Ã‚Å¾ be the greatest such integer.  For the ÄÅ¹Ârst part of  , it can be shown that  if Ã‚Ë and Ã‚Å¾ are congruent modulo 2 then there is  some  such that Ã‚Ë  Ã‚Å¾  Ã‚Å¾ . Similarly since  Ã‚Å¾ and Ã‚Ë are congruent modulo 2 there is some   such that Ã‚Å¾   Ã‚Å¾  Ã‚Ë . Therefore Ã‚Ë‡ Ã‚Ë     Ã‚Ë‡  and    for all  Ã‚Ë . Therefore Ã‚Å¾  Ã‚Ë .  For the second part of  , suppose Ã‚Å¾        Ã‚Å¾ and (without loss of generalization)  Ã‚Ë‡   Ã‚Ë‡     . Then the result follows  from the fact that           (from  the proof for  ).  The following proof is required to show that any gridpath represents a grid structure in exactly the same way   does.  LEMMA 2 Given some set  there is a bijection Ä‚Â†   Ä‚Â†     .  ,      and a grid-path       such that   PROOF:  Given any integer , let the subset Ä‚Â’  be  the set        Ã‚Å¾      .  We prove the lemma by induction over  where  the induction hypothesis is:  Given any integer , there is some bijection  Ä‚Â†Ä‚Â‹   Ä‚Â’     such that for all    Ã‚Å¾ ,  Ä‚Â†Ä‚Â‹     .  We begin with   . This is trivial, as  Ã‚Åº    and all that is required is to deÄÅ¹Âne  Ä‚Â†Ä‚Â‹Ã‚Åº     .  For the inductive step, suppose that for some    integer  there is a bijection Ä‚Â†Ä‚Â‹ Ä‚Â’  such that for all     Ã‚Å¾ , Ä‚Â†Ä‚Â‹      .  We construct Ä‚Â†Ä‚Â‹ as follows. Let Ä‚Â†Ä‚Â‹Ã‚Ë‡Ã‚Ë    Ä‚Â†Ä‚Â‹  for all  Ä‚Â’ . We would like to de   Ã‚Å¾ ,  ÄÅ¹Âne Ä‚Â†Ä‚Â‹Ã‚Ë‡Ã‚Ë such that for all  Ä‚Â†Ä‚Â‹Ã‚Ë‡Ã‚Ë     , however we must ensure  that if      for     Ã‚Å¾ , then       .  For all ,   Ã‚Å¾     Ã‚Å¾ we note  that Ã‚Ë‡     and furthermore, if      if and only if Ã‚Ë‡    Ã‚Ë for some    . Therefore we are required to show that for  all such if Ã‚Ë‡      then for all    we have      , and if Ã‚Ë‡    then  there is some    such that      and      . This is proven in Lemma 3 below.  Therefore we can deÄÅ¹Âne the bijection Ä‚Â†Ä‚Â‹Ã‚Ë‡Ã‚Ë  such that for all     Ã‚Å¾ , Ä‚Â†Ä‚Â‹Ã‚Ë‡Ã‚Ë      . Furthermore, by construction, the bijection Ä‚Â†Ä‚Â‹Ã‚Ë‡Ã‚Ë agrees with Ä‚Â†Ä‚Â‹ over the set Ä‚Â’ so by  induction there is some bijection Ä‚Â† such that for  all , Ä‚Â†     .   Proceedings of the 10th International Symposium on Temporal Representation and Reasoning and  Fourth International Conference on Temporal Logic (TIME-ICTLÃ¢Â€Â™03) 1530-1311/03 $17.00 Ã‚Å  2003 IEEE    ,  Below is a technical sub-lemma required to complete the  proof of Lemma 2.  LEMMA 3 Suppose that there is some bijection Ä‚Â†     such that for all   Ã‚Å¾ Ä‚Â†    .    Then for all  where   Ã‚Å¾     Ã‚Å¾ :                 1.  Ã‚Ë‡        2.  Ã‚Ë‡                                    PROOF:  We will prove the lemma by strong induction.  As the base case, let     Ã‚Å¾ . Therefore Ã‚Ë‡      and we must show for  all   ,    . Suppose for contradiction that there is some    such that    . If Ã‚Ë‡    then      implies    Ã‚Å¾ , and since Ä‚Â†  is a bijection we would have        contradicting DeÄÅ¹Ânition 3.1. Since     Ã‚Å¾ we  have Ã‚Ë‡    . By the construction of  we  can see that Ã‚Ë‡  is even if and only if  is even.  Therefore  is even if and only if  is odd, contradicting DeÄÅ¹Ânition 3.2 and thus for all   ,    . This completes the base case of  the induction.  We will now prove the inductive step. Suppose that for some     Ã‚Å¾ , we have deÄÅ¹Âned Ä‚Â† Ã‚Ë‡Ã‚Ë   for all   . If Ã‚Ë‡     ,  then by the construction of , Ã‚Ë‡    . By  the induction hypothesis there exists      such that     , and consequently by  DeÄÅ¹Ânition 3.5 for all   ,    . This  completes the proof of the ÄÅ¹Ârst case.  For the second case of the inductive step,  suppose for some     Ã‚Å¾ we have deÄÅ¹Âned Ä‚Â† Ã‚Ë‡Ã‚Ë   for all    and Ã‚Ë‡    . To continue with the strong induction, we  must include another base case, corresponding  to     Ã‚Å¾  . For such a case we  must show that there is some    such that    . In this case Ã‚Ë‡        so          . Also,  Ã‚Ë‡     and      Ã‚Å¾ so         . Therefore by  DeÄÅ¹Ânition 3.4 there must be some    such  that    .  We will complete the induction in two steps.  Ã‚Å¾  First we will show that for any       Ã‚Ë‡  with     there is some    such that    . The next step will be to show that  in such a case,    .                                        There are exactly    distinct     Ã‚Å¾  such that Ã‚Ë‡    , and since Ä‚Â†  is a bijection we can see that for each such  there is no     Ã‚Å¾ such that    . By DeÄÅ¹Ânition 3.1, for each such  there must exist some  Ã‚Å¾ such that     ,      unique  and    and   Ã‚Å¾   are congruent  modulo 2 (since Ã‚Ë‡    Ã‚Ë‡   Ã‚Ë‡     Ã‚Å¾    ). We now apply DeÄÅ¹Ânition 3.3.a,  where   Ã‚Ë ,   Ã‚Å¾ , Ã‚Å¾      Ã‚Ë and   Ã‚Å¾ . Therefore we must have   Ã‚Å¾    .  Since there is such a for each of the     distinct  , there must exist Ã‚Åº   such that  Ã‚Å¾      Ã‚Åº  Ã‚Ë        Ã‚Å¾ where  Ã‚Å¾  Ã‚Å¾  Ã‚Ë‡Ã‚Ë  . Since          ,  it must be that    for some , and thus there  is some    such that    .  It remains to show that Ä‚Â† Ã‚Ë‡Ã‚Ë   .  Suppose that for some  ,      but    . By the induction hypothesis,  Ä‚Â† Ã‚Ë‡Ã‚Ë      and there is some     such that    .  If   then by DeÄÅ¹Ânition 3.3.b for any    such that    we must have   .  However if    then by the induction hypothesis     implies        contradicting the fact the  is a grid-path.  then by DeÄÅ¹Ânition 3.3.b for any   If   such that     we must have   .  However if   then by the induction hypothesis     implies        contradicting the fact the  is a grid path (DeÄÅ¹Ânition 3.1..          To complete the proof of undecidability we must encode  the tiling. This relies on some convenient properties of the  function . With respect to QPTL , the main property that  we are interested in is that if a state occurs twice in a model,  its interpretation with respect to propositional variables remains unchanged. We wish to create a formula which forces  the model to have a grid path, and then use propositions to  represent the different tiles in . We can then make sure  that the sides of adjacent tiles match up.  We begin by deÄÅ¹Âning the formula   . This consists  of two parts: the ÄÅ¹Ârst   is true at the initial state in a  model       if and only if  is a grid-path; and the  second  ensures that the sides of adjacent tiles agree.      DEFINITION 4 Let the formula     and    . The formula   is given by the  following deÄÅ¹Ânitions:      Proceedings of the 10th International Symposium on Temporal Representation and Reasoning and  Fourth International Conference on Temporal Logic (TIME-ICTLÃ¢Â€Â™03) 1530-1311/03 $17.00 Ã‚Å  2003 IEEE                                                                                                                     In this deÄÅ¹Ânition we use the variable  to mark even  states. That is there is some -variant of  ,  Ã‚Åº such that    Ã‚Åº  if and only if there is some even  such that    . The formula also enforces that   Ã‚Åº  if  and only if there is some odd  such that    . This  is enough to enforce DeÄÅ¹Ânition 3.2. It can also be seen that       if and only if for all    ,     .  Otherwise for any -variant  Ã‚Åº of  ,    Ã‚Åº   if and  only if    Ã‚Åº  .  LEMMA 4 Let      . Then     and only if  is a grid-path.    if  if there is some    such that      then      .  Suppose       . Since we know  from the proof of Lemma 2 that either      or     . We also know     if  and only if there is some    such that     . Therefore if    , then        and hence      ,  (from DeÄÅ¹Ânition 2). The case for       is similar.        be the set of tiles, and for each          and      .  Finally let !   ! be propositions corresponding to the  tiles in .  Let   let    We will now deÄÅ¹Âne the formula  such that if     , then the function     is a  recurrent tiling function, where     if and only  if    Ä‚Â†   . To do this we require the following  lemma which associates horizontal and vertical directions  in the grid with properties deÄÅ¹Ânable in QPTL.  LEMMA 5 Given a model       where  is a gridpath, let Ä‚Â†     be some bijection such that for all  , Ä‚Â†  . For all , let Ä‚Â†     . Then  if for all       ,       ,     then        if there is some    such that         and    .      and   then  PROOF:  Since Ä‚Â† is a bijection and for all ,  Ä‚Â†  , all we have to show is that  given      if for all   ,     then       ,    !    "#  $  #    "  DEFINITION 5 The formula  PROOF:  This follows directly from the semantic deÄÅ¹Ânitions given in Section 2, and comparison with  DeÄÅ¹Ânition 3.       !                    "               is given as  !     !                "# $       #     LEMMA 6 The formula " is satisÄÅ¹Âable if and only if  recurrently tiles the plane.  PROOF:  Suppose there is some function      satisfying the properties of a tiling. We deÄÅ¹Âne a  model ,  , of " as follows. Let       , where !   if and only if    .  Since  is a grid-path (Lemma 1), we have      (Lemma 4).  For all  there is some unique such that      , and hence for all  , !     for some unique , so  will always be satisÄÅ¹Âed.  Suppose that !    for some , and  !   . By Lemma 5, if       then    and if     then    , so "# and $ will be satisÄÅ¹Âed.  Finally, for inÄÅ¹Ânitely many ,     .  From the proof of Lemma 3 we know that      only if      and    , so  it follows that    # and thus    " .  Proceedings of the 10th International Symposium on Temporal Representation and Reasoning and  Fourth International Conference on Temporal Logic (TIME-ICTLÃ¢Â€Â™03) 1530-1311/03 $17.00 Ã‚Å  2003 IEEE  Now suppose there is some model     such that    . We construct  a recurrent tiling function as follows.  As    , it follows from  Lemma 4 that  is a grid-path. Therefore, by  Lemma 2, there is some bijection Ä‚Â†        such that Ä‚Â†   . We deÄÅ¹Âne the tiling  function        by     if and only if    Ä‚Â†    . Since      , is well deÄÅ¹Âned.   , and    . By  Suppose     examination of the function  we can see             . Let      . Since  is a grid-path, it follows  Ä‚Â  from the deÄÅ¹Ânition of and the proof of Lemma 3  that       . It therefore follows that      . Hence    for some   Ã‚Å¾       , so    . Since  , and         we ÄÅ¹Ând that        ,  and thus           .  Now suppose that      . We apply a      similar process to show    provided     . If     we must  have    ,      and      .  By the proof of Lemma 1 we must have        , and hence    so there is no  tile to the left. This can be seen by inspection of  Figure 3.   , we must have  Finally, since            for inÄÅ¹Ânitely many  . If       we must have      for some . Therefore      , and      , thus    for inÄÅ¹Ânitely  many x.   Ä‚Â  We have shown that QPTL with repeating states is undecidable when we allow the function      to be  arbitrary and thus we have proven Theorem 1. The repeating semantics are too expressive to to allow any form of  automated deduction. However, we can see that the result  could be stronger, since we only required  to belong to a  class of functions that could represent a grid-path (for example, the class of functions where each state is repeated  only a ÄÅ¹Ânite number of times). The satisÄÅ¹Âability problem  for QPTL could be even harder than  .  4. QPTL with ÄÅ¹Ânite repeating states  We will now examine a class of functions which does not  allow  to be a grid-path. We deÄÅ¹Âne the semantic interpretation QPTL to be the same as the semantic interpretation  QPTL , except now we require that the range of  be ÄÅ¹Ânite (i.e. there are only a ÄÅ¹Ânite number of states). These  semantics retain much of the expressive power of QPTL ,  however the set of states is no longer an inÄÅ¹Ânite domain.  Formulas such as (2) are still expressible and meaningful.  However it is worth noting that these semantics are not a  generalization of the usual semantic interpretation QPTL .  In fact, every model of QPTL is disallowed in QPTL  since the model will necessarily have an inÄÅ¹Ânite number of  states. Consequently, contradictions in QPTL might be validities in QPTL , such as            (3)  Since the models for QPTL can be enumerated, we  might expect the satisÄÅ¹Âability problem to be recursively  enumerable. However, we will now show that the validity  problem (determining whether a formula is valid) is undecidable, and consequently the satisÄÅ¹Âability problem remains  undecidable.  To show that QPTL is undecidable given the interpretation, QPTL , we will use the    tiling problem. Since  the range of  is ÄÅ¹Ânite, we cannot represent the entire plane.  However, we can use the following deÄÅ¹Ânition and lemma to  get around this problem.  DEFINITION 6 The th corner of the plane,    , is the  set           . We say a set of tiles, , tiles    if there is some function      such that for all    where     ,               2.       LEMMA 7 A set of tiles, , satisÄÅ¹Âes the   tiling problem, if and only if for all   ,  tiles the  corner of the  1.              th  plane.  PROOF:  If there is some tiling function,        , then restricting the domain of to   will  show that  tiles   .  Now suppose that for all    ,  is a tiling  function for   . We will deÄÅ¹Âne a tiling function,        by induction over . We ÄÅ¹Ârst deÄÅ¹Âne       to be some function such that        for inÄÅ¹Ânitely many . Clearly  such a function exists. For the inductive step suppose that we have deÄÅ¹Âned       such that  there are inÄÅ¹Ânitely many  where for all    ,       . We deÄÅ¹Âne  such that:  1.           ;  2. for inÄÅ¹Ânitely many , for all       .  Proceedings of the 10th International Symposium on Temporal Representation and Reasoning and  Fourth International Conference on Temporal Logic (TIME-ICTLÃ¢Â€Â™03) 1530-1311/03 $17.00 Ã‚Å  2003 IEEE      ,  4  3  2  1                           31 Ä‚Â† 27            23       29  15  22 32           14  21    8  13  20 30      7  12  19      3  6  11  18 28  25  33  24  2  0  0  5  1  0    10  4  1    17    9  2  3    4    It is a consequence of RamseyÃ¢Â€Â™s theorem that   must exist. We deÄÅ¹Âne the funcsome such     by         , and  tion  it is not hard to see that is a tiling function.      We can now generalize the results of the previous section  to apply only to the th corner of the plane. We deÄÅ¹Âne the  function       by    if   and    otherwise. We deÄÅ¹Âne      by     where is deÄÅ¹Âned in DeÄÅ¹Ânition 2. The  restricts the gridpath the the th corner of the  function  plane and is illustrated in Figure 4.              We can now proceed as we did in the previous section.  For reasons of brevity we will not reproduce the full proofs,  but rather skip straight to encoding the restricted grid-path     (grid-path  in QPTL. We will deÄÅ¹Âne the formula  corner) which forces the structure to represent a grid-path  up to some arbitrary point, and all other states in the gridpath are collapsed to a single point, the ÄÅ¹Ânal state. We will  use the free variable to mark the ÄÅ¹Ânal state. We retain the  deÄÅ¹Ânitions      and   given in DeÄÅ¹Ânition 4. We also add two new conditions. The ÄÅ¹Ârst requires  that be true at only one state, and the second requires that  after the ÄÅ¹Ârst occurrence of , only states that have previously appeared in the model can be used. Although the ÄÅ¹Ânal  state appears inÄÅ¹Ânitely often in the model, the formula    will always be true at the ÄÅ¹Ânal state, simply because it is not  the last occurrence of that state.  DEFINITION 7 The formula        is given by the fol-                                                                                                                                                       26  16  Figure 2. An illustration of the function  ,  where   lowing deÄÅ¹Ânitions:                  Proofs similar to those given in the previous section will  show that if     is satisÄÅ¹Âed by some model, that model  will act like a grid-path until is true. Particularly, if     for all     , then it follows that   deÄÅ¹Ânes a grid-path over the  corner of the plane. The  only difference between   and   is that we do not  require the tiling to continue after the ÄÅ¹Ârst moment that is  true.  We can now deÄÅ¹Âne the formula  , which is similar  to the formula  , however it is not required to encode a  recurrent tiling. Again, a proof of soundness can be inferred  from the previous section.    DEFINITION 8 The formula   is given as                                                                                                  We can now sketch a proof of the undecidability of the  satisÄÅ¹Âability problem. The form of the proof is slightly different since given any satisÄÅ¹Âaible formula, we can always  show it is satisÄÅ¹Âable by enumerating all QPTL models.  However this process will not halt if the formula is unsatisÄÅ¹Âable. Several technical sub-lemmaÃ¢Â€Â™s are omitted, however these results are similar to results given in the previous  section and are not hard to reproduce in the context of this  section.  LEMMA 8  validity.    can tile the plane if and only if   is a  Proceedings of the 10th International Symposium on Temporal Representation and Reasoning and  Fourth International Conference on Temporal Logic (TIME-ICTLÃ¢Â€Â™03) 1530-1311/03 $17.00 Ã‚Å  2003 IEEE    PROOF:  If can tile the plane, then will clearly be  able to tile any portion of the plane. The formula   requires that the model be a grid-path up  to some point, and all moments after that point  share a single state. Since tiles the plane we  can easily ÄÅ¹Ând an assignment of the atoms in  that will satisfy the formula Ã‚Å¾ . Since this process  can be repeated for any assignment of  satisfying    , it must be that Ã‚Å¾ is a validity.  If             is a  validity, then it must be true for every model. It  thus follows that can tile the  corner of the  plane for every , and thus can tile the plane.  Ã‚Åº Ã‚Ë  Ã‚Åº  Ã‚Åº Ã‚Ë              Ã‚Åº                Ã‚Ë‡Ã‚Ë      Ã‚Ë‡Ã‚Ë        Ã‚Åº   Ã‚Ë‡Ã‚Ë        We have shown that even with ÄÅ¹Ânite models these semantic interpretations make QPTL too expressive to be axiomatized. We will now examine one more semantic deÄÅ¹Ânition  which is more general than the linear models allowed by  QPTL , but has a decidable satisÄÅ¹Âability problem.  5. QPTL with deterministic successors  We now examine the semantic QPTL , a restriction of  QPTL which allows states to be repeated throughout a  model, however it restricts the successor function to be deterministic. The semantic interpretation QPTL is the same  as the semantic interpretation QPTL except that we now  require to be deÄÅ¹Âned such that if    , then        . These semantics allow all models of  QPTL, however they also allow models that loop inÄÅ¹Ânitely.  The resulting theory is decidable as we show below.  The cost of this decidability is expressivity. We ÄÅ¹Ând that  QPTL is only slightly less restrictive than QPTL (in fact  we show a QPTL is satisÄÅ¹Âable by translating formulas and  models to agree with QPTL ). This semantic still allows us  to examine periodic models, and formulate such concepts  as the period of cycle for an automata. Importantly, the  complexity of satisÄÅ¹Âability problem for QPTL is no harder  than the satisÄÅ¹Âability problem for QPTL , so any increase  in expressivity is an increase we get for free.  We will show that the satisÄÅ¹Âability problem for QPTL  is reducible to the satisÄÅ¹Âability problem for QPTL , and  hence decidable. To do this we simply unwind the QPTL  model and allow the variable Ã‚Åº to mark the beginning and  the end of the loop.  DEFINITION 9 Given any QPTL model     ,  we say    is the ÄÅ¹Ârst looping state if there exists integers    such that       and for all   ,     implies   .  The  -marked version of is the QPTL model  Ã‚Åº   Ã‚Åº    Ã‚Åº  Ã‚Åº  where  Ã‚Åº  Figure 3. An illustration of  of .  1.           Ã‚Åº  Ã‚Åº  Ã‚Åº  if  state,  2.         Ã‚Åº  Ã‚Åº  , the  -version   is a ÄÅ¹Ârst looping  Ã‚Åº  otherwise.  This is illustrated in Figure 5, where    , Ã‚Åº     , and  and Ã‚Ë‡Ã‚Ë are marked with Ã‚Åº .  For formulas without quantiÄÅ¹Âcation or the variable Ã‚Åº , it  is clear that satisÄÅ¹Âability is preserved in the  -marked version of the model. To extend this to include formulas containing quantiÄÅ¹Âers we must transform the formula so that it  only refers to moments up to (and including) the last moment in the loop, and infers all inÄÅ¹Ânite behavior from that  ÄÅ¹Ânite set of moments. This is done in the following deÄÅ¹Ânition.  DEFINITION 10 The  -version of  is deÄÅ¹Âned in the following stages. First we deÄÅ¹Âne a translation for the subformulas of . For every sub-formula,  , of  let  describe a unique variable that does not appear in . Furthermore, suppose that the variable Ã‚Åº does not appear in  . We deÄÅ¹Âne by induction:                 Ã‚Åº     Ã‚Åº            Ä‚Â   Ã‚Åº                                1. Given     , some sub-formula of , deÄÅ¹Âne the      formula:    2. Given   formula:               Ã‚Åº                 (4)   , some sub-formula of , deÄÅ¹Âne the        Proceedings of the 10th International Symposium on Temporal Representation and Reasoning and  Fourth International Conference on Temporal Logic (TIME-ICTLÃ¢Â€Â™03) 1530-1311/03 $17.00 Ã‚Å  2003 IEEE      Ã‚Åº                (5)  Finally we enumerate all the sub-formulas of  the form  or  , as       . Then  Ã‚Å  Ã‚Ë      which have         (6)  The deÄÅ¹Ânition of Ã‚Å requires the temporal operators to  be modiÄÅ¹Âed so they never refer to the same state at different  moments. This way Ã‚Å can be interpreted in a linear model  (i.e. a QPTL model), however it will simulate the looping  behavior of a QPTL model. The variable  is used to  mark the start and end of the loop (if there is a loop). The  atoms,  , are used to reference what formulas have been  true at, or since the start of the loop. All sub-formulas of Ã‚Å  only refer to moments up to the end of the loop and infer  the inÄÅ¹Ânite behavior of the the model from those moments.  For every sub-formula,  , of the interpretation of  the operator  will remain unchanged at all moments except for the moment before the second occurrence of  . At  does not  this moment we must ensure that the operator  refer to the next moment, but rather the ÄÅ¹Ârst moment that   was true. This way we can ensure that the properties of the       loop are maintained. For example if  and   , to make Ã‚Å satisÄÅ¹Âable in QPTL we must ensure that  can refer to previous moments. The formula    allows us to refer to previous moments by ensuring  that   is true in all moments after the ÄÅ¹Ârst moment   was true if and only if  was true at that moment. Just before the second moment  is true,  does not refer to the  next state in the model (since  is true there). Instead Ã‚Å  Ã¢Â€ÂœinterpretsÃ¢Â€Â  as true if and only if   is true, which is  true if and only if  was true at the start of the loop. In this  way Ã‚Å behaves the same way on the  -marked version of  a model, as behaves on the model itself.   , of the interpretation of  For every sub-formula,  the operator  is altered so it only refers to moments up  to the end of the loop (the moment before  is true for the  second time). The formula   will ensure that the atom    is true at some moment if and only if  has been true  at every moment since the ÄÅ¹Ârst moment  was true. The  formula  is then interpreted to be true if and only if  is  true up to the end of the loop, and   is true at the end of    the loop also. This will only happen if  was true at every  moment in the loop, and would therefore for true at every  subsequent moment in the QPTL model. Note that since  the interpretation of  is deÄÅ¹Âned in terms of the operator  , the interpretation remains valid even for models where   is false for every moment.  It is now a simple matter to show the satisÄÅ¹Âability problem is decidable. We will give a sketch of the proof below.  Ä‚Â  LEMMA 9 Suppose    . Then is satisÄÅ¹Âed by  some QPTL model if and only if Ã‚Å is satisÄÅ¹Âed by the  -marked version of .  PROOF:  The reasoning above can be applied inducis satisÄÅ¹Âed by some  tively to show that if  QPTL model , then Ã‚Å will be satisÄÅ¹Âed by the  -marked version of .  If Ã‚Å is satisÄÅ¹Âed by some QPTL model ,  where  is true for at most one moment, then  clearly will also be a model for . If Ã‚Å is sat   , where   isÄÅ¹Âed by some model,  is true for at least two moments, we can ÄÅ¹Ând a  QPTL model of by deÄÅ¹Âning a function Ã‚Åº that  agrees with up to (but not including) the second  moment that  is true and loops back to the ÄÅ¹Ârst  state where  was true. Since the successor function is deterministic, this is enough to deÄÅ¹Âne the  model. A simple inductive argument will show  that will be satisÄÅ¹Âed by the model    .   Consequently is satisÄÅ¹Âable in QPTL if and only if Ã‚Å  is satisÄÅ¹Âable in QPTL. Since the size of Ã‚Å is polynomial  in the size of the complexity of the decision procedure is  roughly equivalent (bearing in mind that the decision procedure for QPTL is non-elementary [13]). From this we can  infer an optimal decision procedure for QPTL .  It is also worth noting that a recent, complete axiomatization of QPTL, [6] speciÄÅ¹Âed the axiom QX0, (given as the  equation 1), which is not necessarily valid in QPTL . However all the other axioms and rules given in that axiomatization are sound for QPTL , and the models of QPTL which  are not models of QPTL are exactly the models, , such  that  . It is therefore worth considering whether  that axiomatization, without the axiom QX0, is complete  for QPTL . However the proof of completeness for QPTL  was very complicated given the QPTL semantics, and a  proof of completeness given the QPTL semantics has not  yet been investigated.  6. Conclusion  In this paper we have investigated several alternative  semantics for QPTL which allow states to be repeated  throughout a model. These semantics were generated by  varying the properties of the function , which maps moments of time to the states of the model. While we have not  systematically investigated the decidability of all possible  variations of , we have identiÄÅ¹Âed three semantics which  give a good indication of the relationship between the restrictions on and the complexity of the satisÄÅ¹Âability problem.  For the least restrictive semantic, QPTL , we have  shown that the satisÄÅ¹Âability problem is highly undecidable,  via an encoding of the recurrent tiling problem. While this  is enough to show that the language is too expressive to  Proceedings of the 10th International Symposium on Temporal Representation and Reasoning and  Fourth International Conference on Temporal Logic (TIME-ICTLÃ¢Â€Â™03) 1530-1311/03 $17.00 Ã‚Å  2003 IEEE  be of practical use, it only scratches the surface of the true  complexity of the language. When encoding the tiling problem we only required the function to allow a state to be  repeated twice, rather than arbitrarily. Also, the formulation of the tiling problem only required the nesting of three  propositional quantiÄÅ¹Âers. The effect of quantiÄÅ¹Âer depth on  the satisÄÅ¹Âability problem and the true complexity of QPTL  are also worth investigating.  We have also shown that the satisÄÅ¹Âability problem is coRE complete when the models are restricted to have a ÄÅ¹Ânite  number of states (QPTL ). It should be noted the same  proof will sufÄÅ¹Âce to show that the satisÄÅ¹Âability problem is  co-RE complete when is restricted to have a ÄÅ¹Ânite number  of states, and each state can have at most two successors,  (i.e.        implies either     ,         or       ). This shows  that even quite strong restrictions on are not enough to  make the satisÄÅ¹Âability problem for QPTL decidable.  The last semantic we investigated was QPTL which required the successor function to be deterministic. The satisÄÅ¹Âability problem was shown to be decidable, and a decision  procedure was given. There are still some semantics that  are less restrictive than QPTL and are not known to be decidable, however these are quite artiÄÅ¹Âcial and we will not go  into them here.  Finally it is worth noting some comparisons with work  done in hybrid logic. We have seen that allowing repeating  states allows us to quantify not only propositional atoms,  but also the states of the model. Quantifying the states of a  model has been studied extensively in hybrid logic [1], [7].  The proof of undecidability given in this paper is comparable to the one given in [7], since it essentially uses propositional quantiÄÅ¹Âcation to simulate GorankoÃ¢Â€Â™s reference pointers. The signiÄÅ¹Âcance of the proof given here, is that it uses a  syntactically linear language, and does not rely on branching modal operators.  [7] V. Goranko. Hierarchies of modal and temporal logics with  reference pointers. Journal of Logic Language and Information, 5(1):1Ã¢Â€Â“24, 1996.  [8] D. Harel. Recurring dominoes: making the highly undecidable highly understandable. In Proc. of the Conference on  Foundations of Computing Theory, pages 177Ã¢Â€Â“194, 1983.  [9] D. Harel. Effective transformations on inÄÅ¹Ânite trees, with  applications to high undecidability, dominoes, and fairness.  Journal A.C.M., 33(1):224Ã¢Â€Â“248, 1986.  [10] Y. Kesten and A. Pnueli. A complete proof systems for  QPTL. In Proceedings, Tenth Annual IEEE Symposium on  Logic in Computer Science, pages 2Ã¢Â€Â“12, 1995.  [11] M. Marx and M. Reynolds. Undecidability of compass logic.  Journal of Logic and Computation, 9(6):897Ã¢Â€Â“914, 1999.  [12] A. Pnueli. The temporal logic of programs. In Proceedings  of the Eighteenth Symposium on Foundations of Computer  Science, pages 46Ã¢Â€Â“57, 1977.  [13] A. Sistla, M. Vardi, and P. Wolper. The complementation  problem for Buchi automata with applications to temporal  logic. Theoretical Computer Science, 49:217Ã¢Â€Â“237, 1987.  [14] A. P. Sistla. Theoretical Issues in the Design and VeriÄÅ¹Âcation of Distributed Systems. PhD thesis, Harvard University,  1983.  [15] E. Spaan. Complexity of Modal Logics. PhD thesis, Universiteit van Amsterdam, 1993.  References  [1] C. Areces, P. Blackburn, and M. Marx. The computational  complexity of hybrid temporal logics. L.J. of the IGPL,  8(5):653Ã¢Â€Â“679, 2000.  [2] R. Berger. The undecidability of the dominoe problem.  Mem. Amer. Math. Soc., 66, 1966.  [3] K. Englehardt, R. van der Meyden, and Y. Moses. Knowledge and the logic of local propositions. In Theoretical Aspects of Rationality and Knowledge, Proceedings of the Seventh Conference, pages 29Ã¢Â€Â“41, 1998.  [4] K. Fine. Propositional quantiÄÅ¹Âers in modal logic. Theoria,  36:336Ã¢Â€Â“346, 1970.  [5] T. French. Decidability of quantiÄÅ¹Âed propositional branching time logics. In Proceedings of the 14th Australian Joint  Conference on ArtiÄÅ¹Âcial Intelligence, pages 165Ã¢Â€Â“176, 2001.  [6] T. French and M. Reynolds. A sound and complete proof  system for qptl. In Proceedings of AiML 2002, to appear.  Proceedings of the 10th International Symposium on Temporal Representation and Reasoning and  Fourth International Conference on Temporal Logic (TIME-ICTLÃ¢Â€Â™03) 1530-1311/03 $17.00 Ã‚Å  2003 IEEE 