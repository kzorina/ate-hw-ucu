Analysis of Timed Recursive State Machines  Massimo Benerecetti  UniversitaĚ degli studi di Napoli  Federico II  Napoli, Italy  bene@na.infn.it  Stefano Minopoli  UniversitaĚ degli studi di Napoli  Federico II  Napoli, Italy  minopoli@na.infn.it  AbstractâThe paper proposes a temporal extension of Recursive State Machines (RSMs), called Timed RSMs (TRSMs).  A TRSM is an indexed collection of Timed Automata allowed to  invoke other Timed Automata (procedural calls). The classes  of TRSMs are related to an extension of Pushdown Timed  Automata, called EPTAs, where an additional stack, coupled  with the standard control stack, is used to store temporal  valuations of clocks. A number of subclasses of TRSMs and  EPTAs are considered and compared through bisimulation of  their timed LTSs. It is shown that EPTAs and TRSMs can be  used to recognize classes of timed languages exhibiting contextfree properties not only in the untimed âcontrolâ part, but also  in the associated temporal dimension. The reachability problem  for both TRSMs and EPTAs is investigated, showing that the  problem is undecidable in the general case, but decidable for  meaningful subclasses. The complexity is stated for a TRSMs  subclass.  Keywords-Recursive State Machines; Timed Automata; Real  Time Systems; Context Free Languages.  I. I NTRODUCTION  The formalism of Recursive State Machines (RSMs) has  been introduced in [1] to model control flow in typical  sequential imperative programming languages with recursive procedure calls. A RSM is an indexed collection of  finite state machines (components). Components enhance  the power of ordinary state machines by allowing vertices  which correspond to invocations of other components in  a potentially recursive manner. As shown in [1], RSMs  are closely related to Pushdown Systems (PDSs). While  PDSs have been widely studied in the literature within  the field of program verification, RSMs seem to be more  appropriate for visual modeling. In the context of statetransition formalisms, Timed Automata (TA) [2] are the  reference framework to model real time systems. In this  paper we consider a real time extension of RSMs (Timed  RSMs or TRSMs), which allows to model real time recursive systems. Roughly speaking, a TRSM is an indexed  collection of Timed Automata, with the additional ability  of allowing states corresponding to invocations of other  timed components. All the timed components refer to a  1 Partially supported by Italian MIUR Project âIntegrating automated  reasoning in model checking: towards push-button formal verification of  large-scale and infinite-state systems.â  Adriano Peron  UniversitaĚ degli studi di Napoli  Federico II  Napoli, Italy  peron@na.infn.it  common set of clocks used to constrain the behavior. Within  a timed component, the only explicit update of clocks is the  standard operation of clock reset. In addition, clock updates  occur when transitions, corresponding to invocations of other  components or returns from components, are performed. In  particular, at invocation time one can choose the subset of  clocks to reset, and at return time one can choose to restore  a subset of clocks to the values they had at invocation time.  The idea of extending formalisms which implicitly allow to  model recursive systems (e.g., PDSs) with real time features  has already been proposed in the literature (e.g., [7], [4]).  For instance, [4] proposes the formalism of Pushdown Timed  Automata (PTA), which are Timed Automata augmented  with a pushdown control stack. However, besides that fact  that TRSMs, similarly to RSMs, are more appropriate than  PTAs for visual modeling, it seems that PTAs are not  expressive enough to account for storing and restoring clock  values. Indeed, the control stack of PTAs allows to trace  the history of component invocation but cannot be exploited  to record the history of clock values stored at invocation  time and which are needed at the matching returns for  restoration. For instance, the store/restore of clock values in  correspondence of invocations and returns allows to model  in a very natural way a notion of time local to a component. In other words, TRSMs can manage an evolution of  time within a component, abstracting away the elapse of  time within the invoked components. Since the number of  recursive invocation can be unbounded, it seems that this  notion of local time cannot be modeled by PTAs without  an unbounded number of clocks. In the paper we also lift  to the timed setting the correspondence between RSMs and  PDSs, as stated in [1]. Since PTAs are not expressive enough  to account for TRSMs, we propose Extended PTAs, which  augment PTAs with an additional stack. The additional stack  is used to save/restore clock valuations. The two stacks are  independent, in the sense that the control stack is used to  save control symbols and the valuation stack is used only for  storing clock valuations. As a consequence, ETPAs, besides  the standard clock reset operations, also allows for store  and restore operations on clock valuations. We shall prove  that TRSMs are equivalent (via weak timed bisimulation)  to a syntactic restriction of EPTAs (i.e. : EPTA 2). It is  interesting to notice that EPTAs seem to be also a suitable  framework to study timed languages exhibiting contextfree properties both in the untimed âcontrolâ part and in  the associated timestamps. For instance, we shall provide  an example of a context-free timed language with mirror  distribution of symbols and of temporal delays between  consecutive symbols.  The main technical contributions of the paper are decidability and complexity results for the reachability problem  in TRSMs and EPTAs. In particular, we show that the  problem is undecidable for the general classes of TRSMs  and EPTAs. However, decidability can be recovered by  forcing to restore all the clock values at return time. The  class of TRSMs satisfying this restriction is called TRSM 1.  The equivalent class of EPTAs, which can be characterized  with suitable syntactical restrictions, is denoted by EPTA 1.  The complexity of reachability is given for the subclass  TRSM 0 of TRSM 1, which further forces to reset all  the clock values at invocation time. For this class, the  reachability problem is shown to be PSPACE-complete, as  in classical TA. The paper also provides a comprehensive  picture of the expressive hierarchy and equivalence among  TRSMs and EPTAs.  The structure of the paper is as follows. Section 1 defines  syntax and the semantics of TRSMs. Section 2 introduces  syntax and semantics of EPTAs. Section 3 establishes the  correspondence between subclasses of TRSMs and EPTAs.  Section 4 is devoted to the decidability and complexity  analysis of the reachability problem for TRSMs and EPTAs.  II. T IMED R ECURSIVE S TATE M ACHINES  In this section we define syntax and semantics of TRSMs.  A TRSM is an indexed collection of Timed Automata,  with the additional ability of distinguishing ordinary states  (nodes) and states corresponding to invocation of other timed  components (boxes). We preliminary recall some standard  notions of Timed Automata.  A dense clock is a variable over a dense domain DâĽ0  (as usual non negative reals RâĽ0 or rationals QâĽ0 ). A clock  valuation is a function v : X â DâĽ0 . For a set of clocks X,  the set of clock constraints C(X) is defined by the following  grammar:  Ď:=x âź c | x â y âź c | Ď â§ Ď | Ď â¨ Ď  where x, y â X, c â QâĽ0 and âź â {<, â¤, =, 6=, âĽ, >}.  Following [2], we write v â Ď when the clock valuation  v satisfies the clock constraint Ď â C(X). The notion of  constraint satisfaction by a clock valuation is defined in the  standard way (e.g., see [2]). For t â DâĽ0 , v+t denotes the  valuation v0 such that v 0 (x)=v(x) + t, for all x â X (clock  progress). Given r â X, v âr denotes the valuation resulting  from the reset of the clocks in r, namely:  (  0 if i â r  (v âr )(i) =  v(i) otherwise.  Moreover, given the valuations v, v and a set r â X, v â(r,v)  denotes the valuation resulting from the update of the clocks  in r, according to v, namely:  (  v(i) if i â r  (v â(r,v) )(i) =  v(i) otherwise.  We can now define Timed Recursive State Machines  (TRSMs). A TRSM is an indexed collection of components  which share a set of clocks X. The set of states of each  component is partitioned into a set of nodes and a set of  boxes. Boxes correspond to invocation and are associated  with an index of a component. There are four kinds of  transitions: (i) internal transitions connecting nodes of the  same component; (ii) call transitions which lead to a box  and an entry node of the called component; (iii) return  transitions which lead from a box and an exit node of the  callee to a node of the caller; (iv) return-and-call transitions  which combines a return and a call transitions. Transitions  are decorated with clock constraints as in TA. Internal  transitions can only reset clocks as in TA. Call transitions  can reset a subset of clocks at invocation time. Return  transitions can update a subset of clocks by restoring the  values they had at invocation time, and reset a possibily  different subset of clocks.  Definition 1: For an alphabet ÎŁ, a TRSM is a tuple hA1 ,  . . ., An , Xi where, for all 1 â¤ i â¤ n, Ai is a component  S  and X is a finite set of clocks. A component Ai is hNi Bi ,  Yi , Eni , Exi , Î´i i, where:  â˘ Ni and Bi are the disjoint sets of nodes and boxes,  respectively;  â˘ Yi : Bi â {1,. . . , n} assigns to every box the index of  a component;  â˘ Eni â Ni , Exi â Ni are the sets of entry and exit  nodes, respectively;  â˘ Î´i  â (Ni âŞ Retnsi ) Ă ÎŁ âŞ {Ď } Ă C(X) Ă  2X Ă 2X Ă (Ni âŞ Callsi ) is the transition relation, where Callsi ={(b,en): b â Bi , en â EnYi (b) },  Retnsi ={(b,ex): b â Bi , ex â ExYi (b) }.  For each transition hu1 ,Ď,Ď,r1 ,r2 ,u2 i â Î´i :  â u1 (resp. : u2 ) are the source (resp. : target) of the  transition;  â Ď â ÎŁâŞ{Ď } is an input symbol or the silent action;  â Ď â C(X) is a constraint over the clocks in X;  â r1 (resp. : r2 ) is the subset of clocks to reset (resp. :  restore).  S  We  use  the  followingSabbreviations: N =  S  S i Ni , Calls =  Si Callsi , Retns = i Retnsi , En = i Eni and Ex =  i Exi . In order to avoid confusion with the empty stack  symbol, we use the symbol Ď to represent the internal silent  action (usually called -transition). We assume that only  return and return-and-call transitions can have a non empty  set r2 of restored clocks.  A global state of a TRSM T =hA1 , . . ., An , Xi is a tuple  gs=hb1 , . . ., bs , u, v1 , . . ., vs , vi, where b1 , . . ., bs are  boxes, u is a node and v1 , . . ., vs , v are clock valuations.  Intuitively, b1 , . . ., bs represent the history of the invoked  components, v1 , . . ., vs are the corresponding valuations  stored at invocation time, u is the current node, and v is  the current clock valuation. A global state gs=hb1 , . . ., bs ,  u, v1 , . . ., vs , vi such that bi â Bji , for 1 â¤ i â¤ r and  u â Nj is well-formed if Yji (bi )=ji+1 for 1 â¤ i < r and  Yjs (bs )=j. The set of well-defined global states is denoted  by GS.  The semantics of a TRSM over the alphabet ÎŁ is given  by the timed Labelled Transition System (timed LTS) hGS,  âĽ0  GS0 , ÎŁD  , âi, where:  Ď  GS0 â GS is the set of states of the form h, u, v0 i,  with u â En1 and v0 (x)=0, for all x â X;  S  S  D âĽ0  â˘ ÎŁĎ  is the set ÎŁ {Ď } {Ď (t)|t â DâĽ0 }, where ÎŁ  and DâĽ0 are disjoint;  D âĽ0  Ă GS is the transition relation. For  â˘ â â GS Ă ÎŁĎ  gs=hb1 , . . ., bs , u, v1 , . . ., vs , vi, with u â Nj and bs â  Bm , hgs,Ď,gs0 i â â whenever one of the following  holds:  1) progress transition: Ď = Ď (t) and gs0 = hb1 ,  . . ., bs , u, v1 , . . ., vs , v0 i, with v0 = v + t and  t â DâĽ0 ;  2) reset transition: if hu,Ď,Ď,r1 ,â,u0 i â Î´j , with u0  â Nj , and v â Ď, then gs0 = hb1 , . . ., bs , u0 , v1 ,  . . ., vs , v0 i, with v0 = v âr1 ;  3) call transition: if hu,Ď,Ď,r1 ,â,(b0 ,en)i â Î´j , with  b0 â Bj , and v â Ď, then gs0 = hb1 , . . ., bs , b0 ,  en, v1 , . . ., vs , v, v0 i, with v0 = v âr1 ;  4) return transition: if h(bs , u),Ď,Ď,r1 ,r2 ,u0 i â Î´m ,  with u0 â Nm , u â Exj , and v â Ď, then gs0 =  hb1 , . . ., bsâ1 , u0 , v1 , . . ., vsâ1 , v0 i, with v0 =  v â(r2 ,vs )âr1 ;  5) return-and-call  transition:  if  h(bs ,  u),Ď,Ď,r1 ,r2 ,(b0 , en)i â Î´m , with b0 â Bm ,  u â Exj and v â Ď, then gs0 = hb1 , . . ., bsâ1 , b0 ,  en, v1 , . . ., vsâ1 , vs0 , v0 i, with vs0 = v â(r2 ,vs )  and v0 = vs0 âr1 .  A progress transition occurs when the control remains  in the same vertex and there is only a clock progress. A  reset transition occurs when there is an internal transition  inside a component, which can possibly reset a subset of  clocks. A call transition occurs when a box is entered and  a component is invoked. In this case the current clock  valuation is stored and a subset of clocks are possibly  reset. A return transition occurs when the control returns  to the invoking component. In this case, the valuation at  invocation time may be restored for that subset of clocks  â˘  specified in the restore set decorating the transition, the  constraint must be satisfied by the current clock valuation  and, finally, some clocks may be reset. A return-and-call  transition combines the effect of return and call in a single  step. Notice that the above timed LTS, besides symbols in  ÎŁ, also has symbols representing the elapse of time, and  satisfies the usual properties of temporal determinism, time  additivity and 0-delay as defined in [3].  A run ÎťT of T is a (possibly infinite) path in the LTS  âĽ0  Ď  hGS, GS0 , ÎŁĎD , âi for T having the form ÎťT =gs0 â0  Ďi  Ďi  Ď1  gs1 â gs2 . . . gsi â . . . , where gsi â gsi+1 â â, for all  i âĽ 0. It is an initial path, if gs0 â S0 . By ÎT we denote  the set of all paths of T . For any two gsi , gsj â GS, gsj  is reachable from gsi , written gsi ââ gsj , if there is a run  Ďjâ1  Ďi+1  Ď  ÎťT =gsi âi gsi+1 â gsi+2 . . . gsjâ1 â gsj .  Notice that an RSM can be seen as a TRSM with an  empty set of clocks, and where the only clock constraint is  T rue. From the semantic point of view, the clock valuations  occurring in a global state are meaningless, and progress  transitions are omitted in the LTS.  Example 1: In Fig. 1 we show a TRSM whose behavior  is triggered by a timed sequence of symbols having the form  (a,t1 ). . . (a, tn )(b,tn+1 ) . . . (b,t2n ), such that â2nâi+1 +âi â¤  k, with k a fixed constant value, and, taking t0 = 0, âi =  ti âtiâ1 . Notice that the untimed part of the sequence above  describes a context-free language (i.e., L={an bn : n âĽ 1}).  The TRSM consists of a single component, which may be  invoked recursively. The local behavior inside a component  consists of a transition triggered by a symbol a followed by  a symbol b. The transition triggered by b may be delayed  by a recursive invocation. The component uses the clocks x  and y: the first is reset at invocation time while the second  is reset when the symbol b occurs. Both clocks are restored  at return. The enforced requirement is, therefore, that the  local behavior is performed within time k, abstracting away  the time possibly spent by the recursive computation. It is  meaningful to observe that even though a PTA can model  invocations and returns by using its control stack, it could not  guarantee the temporal requirement above, since, in order to  check â2nâi+1 + âi â¤ k, it would require an unbounded  number of clocks, one for each recursive call.  We introduce now two subclasses of TRSMs obtained by  suitably constraining the ability of resetting and restoring  clocks associated with transitions. These subclasses will be  compared in Sections 3 and 4 with respect to expressive  A  a, T rue, {x}, â  b1 : A  Ď , y = 0, â, X  a, T rue, â, â  b, x â¤ k, {y}, â  Figure 1.  An example of TRSM  b, x â¤ k, {y}, â  power and decidability properties.  TRSM 1: the class of TRSMs, where return and returnand-call transitions are of the form h(b, ex), Ď, Ď,  r1 , X, u2 i, with u2 â N âŞ Calls (the whole set  of clocks is restored at every return);  TRSM 0: the class of TRSM 1, where call and returnand-call transitions are of the form hu1 , Ď, Ď, X,  â, (b, en)i and h(b0 ,ex), Ď, Ď, X, X, (b, en)i,  respectively (the whole set of clocks is reset at  every call).  Unlike the general TRSMs class, where subsets of clock values can be restored, in the TRSM 1 and TRSM 0 subclasses  the entire set of clocks are restored at return time from the  invoked component. Therefore, the clock valuations at return  time are the same clock valuations at invocation time. This  allows to model in a very natural way a notion of time  local to a component, abstracting away the elapse of time  within an invoked component. In the TRSM 0 class this  abstraction is even stronger, because all clocks are reset at  invocation time. Notice that, despite the fact that TRSM 1  and TRSM 0 abstract away the time spent into the invoked  components, it does not seems possible to model them with  PTAs. Indeed, since the number of recursive invocation can  be unbounded, an unbounded number of clocks would be  necessary.  Notice that the TRSM of Example 1 belongs to the class  TRSM 0.  III. E XTENDED P USHDOWN T IMED AUTOMATA  In this section we introduce syntax and semantics of  Extended Pushdown Timed Automata (EPTAs). An EPTA  is a Pushdown Automaton enriched with a set of clocks  and with an additional stack used to store/restore clock  valuations. 1  Definition 2: An EPTA P over ÎŁ âŞ {Ď } is a tuple hQ,  q0 , X, Î, T i, where:  â˘ Q is a finite set of states and q0 â Q is the initial state;  â˘ X is a finite set of clocks and Î is a finite stack  alphabet;  S S 2  â˘ T â Q Ă ÎŁ âŞ {Ď } Ă Î âŞ {} Ă ({}  Î Î )Ă  C(X) Ă 2X Ă Op Ă Q is the transition relation, with  Op={Reset, Store, Restore}.  Intuitively, for each transition of the form hq1 , Ď, Îł1 , Îł2 ,  Ď, r, op, q2 i â T , q1 (resp. : q2 ) is the source (resp. : the  target) state; Ď is the input symbol; Îł1 is the symbol on top  of the control stack ( denotes the empty stack); Îł2 is the  string (of length at most 2) which replaces the symbol on  top of the control stack; Ď â C(X) is a clock constraint;  op is the operation requested on the set r of clocks. If op â  {Reset, Store}, then r indicates the set of clocks to reset. In  addition, if op = Store, the current clock valuation is stored  1 Actually an EPTA is a PTA (see [4]) for a syntactical definition where  the control stack is coupled with a second stack for the clock valuations.  on top of the valuation stack. If op = Restore, r indicates  the set of clocks to restore, using the clock valuation on top  of the valuation stack.  A configuration of an EPTA P is a tuple hq,v,w,di, where  q â Q is the current control state, v is the current clock  valuation, w â Îâ is the content of the control stack, and d  â (X â DâĽ0 )â is the content of the valuations stack. The  set of all configurations is denoted by GC.  The semantics of EPTAs is given by a timed LTS hGC,  âĽ0  GC0 , ÎŁĎD , âi, where:  â˘  â˘  GC0 is {hq0 ,v0 ,,i}, with v0 (x)= 0, for every x â X;  âĽ0  â â GC Ă ÎŁĎD Ă GC is the transition relation. For  gc = hq,v,w,vs Âˇ di, hgc,Ď,gc0 i â â whenever one of  the following holds:  1) progress transition: Ď = Ď (t) and gc0 =  hq,v0 ,w,vs Âˇ di, with v0 = v + t and t â DâĽ0 ;  2) reset transition: if hq, Ď, a, Îł, Ď, r, Reset, q 0 i  â T , with v â Ď and w = a Âˇ w00 , then gc0 =  hq 0 ,v0 ,Îłw00 ,vs Âˇ di with v0 = v âr ;  3) store transition: if hq, Ď, a, Îł, Ď, r, Store, q 0 i  â T , with v â Ď and w = a Âˇ w00 , then gc0 =  hq 0 ,v0 ,Îłw00 ,v Âˇ vs Âˇ di with v0 = v âr ;  4) restore transition: if hq, Ď, a, Îł, Ď, r, Restore,  q 0 i â T , with v â Ď, w = a Âˇ w00 , then gc0 =  hq 0 ,v0 ,Îłw00 ,di, with v0 = v âr,vs .  When a progress transition occurs, there is only a clock  progress; the control remains in the same state and the two  stacks are left unchanged. A reset transition pops a symbol  from the control stack, pushes a string of symbols on the  control stack, and resets a set of clocks, while the valuation  stack is left unchanged. A store transition behaves as a  reset transition, except that, in addition, it pushes the current  clock valuation on the valuation stack. A restore transition  pops a control symbol from the stack, pushes a string on  the control stack, and pops a valuation from the valuation  stack, restoring a subset of the clock values according to  the popped clock valuation. The notions of (initial) run and  reachability among pairs of states can be defined exactly  as in the case of TRSMs. ÎP denotes the set of runs and  gc ââP gc0 denotes a pair of reachable states.  Example 2: In Fig. 2 we show an EPTA whose behavior  is triggered by a timed sequence of symbols having the  form: (a,t1 ). . . (a, tn )(b,tn+1 ). . . (b,t2n ) such that â2nâi =âi ,  with âi = ti+1 â ti . Notice that the untimed part of  the sequence above describes a context-free language (i.e.  L={an bn : n âĽ 1}). As for the timed part, the sequence is  required to satisfy a mirror distribution of the delays between  consecutive symbols. Notice that, the timed language above  exhibits a context-free property both in the untimed part  and in the temporal sequence of timestamps. This shows the  main difference with respect to PTAs ([4]) where there is  no mean to check context free properties on times.  As in the case of TRSMs, we introduce three subclasses  of EPTAs by suitably constraining the operations associated  with transitions. These subclasses will be naturally related  with the subclasses of the TRSMs defined in the previous  section. The restrictions tightly couple the type of operations  performed on the control stack and on the valuation stack.  EPTA 2 is the subclass of EPTAs where:  â˘ reset transitions have the form hq1 , Ď, a1 , a2 ,  Ď, r, Reset, q2 i, with a1 â Î âŞ {}, a2 â Î  (only a swap on the top of the control stack is  allowed);  â˘ store transitions have the form hq1 , Ď, a, Îł, Ď,  r, Store, q2 i with a â Î âŞ {} and Îł â Î2  (only a swap followed by a push is allowed on  the control stack);  â˘ restore transitions have the form hq1 , Ď, a, ,  Ď, r, Restore, q2 i, with a â Î (only a pop  operation is allowed on the control stack);  EPTA 1 is the subclass of EPTA 2 where:  â˘ restore transitions have the form hq1 , Ď, a, ,  Ď, X, Restore, q2 i, with a â Î (the whole  set of clocks is restored);  EPTA 0 is the subclass of EPTA 1 where:  â˘ store transitions have the form hq1 , Ď, a, Îł, Ď,  X, Store, q2 i, with a â Î âŞ {}, Îł â Î2 (the  whole set of clocks is reset);  Notice that the EPTA of the Example 2 belongs to the class  EPTA 2.  IV. R ELATIONSHIP BETWEEN TRSM S AND EPTA S  In this section we investigate the relationship between  TRSMs and EPTAs and their subclasses. In order to show  such a correspondence, we shall use the standard notion of  (timed) weak bisimulation between timed LTS. The general  picture is reported in Table I.  For the definition of weak bisimilarity for timed LTSs we  follows the approach in [3]. Notice that bisimulation for  Timed LTS is a nontrivial generalization of the untimed case,  and requires some additional technicalities. Formally an LTS  L=hS,S0 ,ÎŁ, âi simulates a transition system L0 =hS 0 ,S00 ,ÎŁ,  â0 i if there exists a simulation relation âşâ S Ă S 0 defined  as follows:  q0  a, , , T rue, {x}, Reset  b, , , T rue, {y}, Reset  q1  q2  a, , , T rue, {x}, Store  Ď , , , (x = y) â§ (z = 0), {y}, Reset  q4  Figure 2.  b, , , T rue, {z}, Reset  Ď , , , z = 0, {x}, Restore  An example of EPTA  q3  initialization: for all s0 â S0 , there is a s00 â S00 , with  s0 âş s00 ;  Ď  0  â˘ propagation: for all Ď â ÎŁ, if s1 âş s1 and s1 â s2 ,  Ď  then there exists s02 â S 0 such that s01 â s02 and s2 âş  s02 .  If the relation âşâ1 , defined as x âşâ1 y â y âş x, is  also a simulation relation, then âş is a called a bisimulation  relation. Two LTSs L and L0 are strongly bisimilar, written  L âĄs L0 , if there is a bisimulation relation between L and  L0 .  In order to introduce a notion of weak bisimulation we  suitably transform a timed transition system by abstracting  sequences of Ď -transitions. For a timed LTS L, a delay  Ďn  Ď  Ď  sn , such  execution is a run of the form s0 â1 s1 â2 s2 . . . â  that, for every 1 â¤ i â¤ n, either Ďi = Ď or Ďi = Ď (ti ), for  some ti â DâĽ0 . The abstract transition system associated  âĽ0  to L is Labs = hS, S0 , ÎŁĎD \ {Ď }, âi, where:  a  Ď â 00 a  0  00  â˘ s â s if a â ÎŁ and there exists s â S, s â s â  s0 ;  Ď (t) 0  Ď1  â˘ s â s if there exists a delay execution s = s0 â s1  P  Ď2  Ďn  â s2 . . . â sn = s0 such that t = {ti | Ďi = Ď (ti )}.  Ď â  The relation â denotes the reflexive and transitive  Ď  closure of â. The transition system Labs abstracts all the  Ď (0)  Ď â  silent actions of L. The relation â thus corresponds to â .  a  Notice also that the relation â only abstracts silent actions  that can be done before a. Of course, if L is the timed LTS  of a TRSM or of a EPTA without silent actions, then L and  Labs are identical.  Two LTS L and L0 are weakly bisimilar, written L âĄw L0 ,  if there exists a bisimulation relation between Labs and L0abs .  The following theorem shows the tight corresponding  between TRSMs and EPTAs and their subclasses.  Theorem 1: For any TRSM (resp. : TRSM 1, TRSM 0)  T , there exists a weakly similar EPTA 2 (resp. : EPTA 1,  EPTA 0) P and vice versa.  Proof:  We first show the bisimulation relation between TRSM  and EPTA 2.  Given a TRSM T =hA1 , . . ., An , Xi over an alphabet  ÎŁ, we first S  give the construction of an EPTA 2 P over the  alphabet ÎŁ {Ď } that is weakly bisimilar to a T . (The idea  of the construction is similar to the one presented in [1] to  encode RSMs into pushdown systems).  S In the following we  assume that Ai has the form hNi Bi , Yi , Eni , Exi , Î´i i.  P=hQ, q0 , X âŞ {x0 }, Î, T i, is defined as follows:  (k)  â˘ Q={q0 } âŞ {q(i,u) | 1 â¤ i â¤ nex , 1 â¤ k â¤ kmax and  u â N âŞ Calls}, where nex is the greatest number of  â˘  Table I  E XPRESSIVENESS RELATIONS AMONG TRSM S AND EPTA S .  EPTA 0  âĄw  TRSM 0  â  â  EPTA 1  âĄw  TRSM 1  â  â  EPTA 2  âĄw  TRSM  â  EPTA  â˘  â˘  exit nodes of all component machines and kmax is the  greatest number of return transitions exiting from every  ex â Ex;  S  Î={(j,u) | 1 â¤ j â¤ n, u â Nj  Bj }. A pair (j,u)  gives the index of a component and the current box or  node in the component;  T is defined as follows:  â for every pair (j,exi )â Î with exi â Exj , hq0 , Ď ,  (j,exi ), (j,exi ), T rue, {x0 }, Reset, q0 i â T ;  â for every reset transition of the form hu, Ď, Ď, r1 , â,  u0 i â Î´j , where u â  / Retns and u0 â  / Calls, there  is a transition hq0 , Ď, (j,u), (j,u0 ), Ď, r1 , Reset,  q0 i â T ;  â for every call transition hu, Ď, Ď, r1 , â, (b, en)i  â Î´j where u â  / Retns, b â Bj , Yj (b)=j 0 and  en â Enj 0 , there is a transition hq0 , Ď, (j,u),  (j 0 ,en)Âˇ(j,b), Ď, r1 , Store, q0 i â T ;  â if h(b,exi ), Ďk , Ďk , r1k , r2k , ui â Î´j is the kth return transition from the exit node exi , with  u â Nj , Yj (b)=j 0 , then there are the following  transitions:  1) hq0 , Ďk , (j 0 ,exi ),, Ďk â§(x0 = 0), r2k , Restore,  (k)  q(i,u) i â T ;  (k)  2) hq(i,u) , Ď , (j,b), (j,u), x0 = 0, r1k , Reset, q0 i â  T;  â if h(b,exi ), Ďk , Ďk , r1k , r2k , (b0 ,en)i â Î´j is the  k-th return-and-call transition from the exit node  exi , with Yj (b)=j 0 and Yj (b0 )=j 00 , then there are  the following transitions:  1) hq0 , Ďk , (j 0 ,exi ),, Ďk â§(x0 = 0), r2k , Restore,  (k)  q(i,(b0 ,en)) i â T ;  (k)  2) hq(i,(b0 ,en)) , Ď , (j,b),(j 00 ,en)Âˇ(j,b0 ), x0 = 0, r1k ,  Store, q0 i â T .  The weak bisimulation relation âş between LT and LP is  defined as follows. For gs â GS and gc â GC, gs âş gc if  and only if one of the following holds:  1) gs = hb1 , . . ., bs , u, v1 , . . ., vs , vs+1 i and gc =  hq0 , vs+1 , (j, u)(js , bs ). . . (j1 ,b1 ), vs . . . v1 i, where  vk (x) = vk (x) for all x â X and 1 â¤ k â¤ s + 1;  2) gs = hb1 , . . ., bs , u, v1 , . . ., vs , vs+1 i and gc =  (n)  hq(i,u) , vs+1 , (js+1 , bs+1 ). . . (j1 ,b1 ), vs . . . v1 i, with  vk (x) = vk (x), for all x â X and 1 â¤ k â¤ s, and  vs+1 (x) = vs+1 (x) for all x â X \ r1n , where r1n  is the set of clocks reset by the n-th return transition  from (bs+1 , exi ) to u and vs+1 (x0 ) = 0;  3) gs = hb1 , . . ., bs , u, v1 , . . ., vs , vs+1 i, with u â  En and vs+1 = vs âr1 n , where r1n is the set of  clocks reset by the n-th return-and-call transition from  (n)  (bs0 , exi ) to (bs , u) and gc = hq(i,(bs ,u)) , vs , (js0 ,  bs0 ). . . (j1 ,b1 ), vsâ1 . . . v1 i, with vk (x) = vk (x), for  all x â X and 1 â¤ k â¤ s.  We show now that âş is a bisimulation.  Let us consider the initialization requirement. An initial  state of T has the form gs0 =hen, , v0 i, with en â En1 .  The initial state of P has the form gc0 =hq0 , v0 , (1,en), i.  By definition of âş, it is immediate to show that gs0 âş gc0  and gc0 âşâ1 gs0 .  Let us consider now the propagation requirement. Let us  assume that gs âş gc. There are the following cases:  â˘ Let gs = hb1 , . . ., bs , u, v1 , . . ., vs , vs+1 i be a  global state and gc = hq0 , vs+1 , (j, u)(js , bs ). . . (j1 ,b1 ),  vs . . . v1 i, where vk (x) = vk (x) for all x â X and  1 â¤ k â¤ s + 1, be a configuration. By definition, gs âş  gs. Now we show all the possible transitions in Labs (T )  having gs as source:  t  â (progress transition): gs â gs0 , for some t â  âĽ0  0  D , where gs = hb1 , . . ., bs , u, v1 , . . ., vs ,  vs+1 +ti. Then there exists in Labs (P) the progress  t  transition gc â gc0 , where gc0 = hq0 , vs+1 + t,  (j,u)(js ,bs ). . . (j1 ,b1 ), vs . . . v1 i. By definition, gs0  âş gc0 ;  Ď  â (reset transition): gs â gs0 , where gs0 = hb1 , . . .,  bs , u0 , v1 , . . ., vs , vs+1 âr i, hu, Ď, Ď, r, â, u0 i  â Î´j and vs+1 â Ď. Then there exists in Labs (P)  Ď  the transition gc â gc0 , where gc0 = hq0 , vs+1 âr ,  (j,u0 )(js ,bs ). . . (j1 ,b1 ), vs . . . v1 i and hq0 , Ď, (j,u),  (j,u0 ), Ď, r, Reset, q 0 i â T . By definition, gs0 âş  gc0 ;  Ď  â (call transition): gs â gs0 , where gs0 = hb1 , . . .,  bs , bs+1 , en, v1 , . . ., vs+1 , vs+1 âr1 i, hu, Ď, Ď, r1 ,  â,(bs+1 , en)i â Î´j and vs+1 â Ď. Then there exists  Ď  in Labs (P) the transition gc â gc0 , where gc0 =  hq0 , vs+1 âr1 , (j 0 , en)(js+1 ,bs+1 ) . . . (j1 ,b1 ),  vs+1 . . . v1 i and hq0 , Ď, (j,u), (j 0 ,en)Âˇ(js+1 ,bs+1 ),  Ď, r1 , Store, q0 i â T . By definition, gs0 âş gc0 ;  Ďn  â (return transition): gs â  gs0 , where gs0 = hb1 ,  0  . . ., bsâ1 , u , v1 , . . ., vsâ1 , (vs+1 â(r2n ,vs ) ) âr1n i,  h(bs , u), Ďn , Ďn , r1n , r2n , u0 i â Î´j is the k â th  return transition from u (u=exi ) to u0 and vs+1  â Ď. Then there exists in Labs (P) the transition  Ďn  (n)  gc â  gc0 , where gc0 = hq(i,u0 ) , vs+1 â(r2n ,vs ) ,  (js ,bs ). . . (j1 ,b1 ), vsâ1 . . . v1 i and hq0 , Ďn , (j,exi ),  (n)  , Ďn â§ (x0 = 0), r2n , Restore, q(i,u0 ) i in T . By  0  0  definition, gs âş gc ;  Ď  â (return-and-call transition): gs â gs0 , where  0  gs = hb1 , . . ., bsâ1 , bs+1 , en, v1 , . . ., vs ,  vs+1 â(r2n ,vs ) ,vs+1 â(r2n ,vs ) âr1n i, h(bs , u), Ďn ,  Ďn , r1n , r2n , (bs+1 ,en)i â Î´j is the n â th  return-and-call transition from (bs , u) (u = exi )  to (bs+1 , en) and vs+1 â Ď. Then there exists in  Ďn  Labs (P) the transition gc â  gc0 , where gc0 =  (n)  hq(i,(bs+1 ,en) , vs+1 â(r2n ,vs ) , (js ,bs ). . . (j1 ,b1 ),  vsâ1 . . . v1 i and hq0 , Ďn , (j,exi ),, Ďn â§ (x0 = 0),  (n)  r2n , Res!tore, q(i,(bs+1 ,en) i in T . By definition,  gs0 âş gc0 .  Ď  Now we show all the possible transitions in Labs (P)  having gc as source:  t  â (progress transition): gc â gc0 , for some t â DâĽ0 ,  where gc0 = hq0 , vs+1 + t, (j,u)(js ,bs ). . . (j1 ,b1 ),  vs . . . v1 i. Then there exists in Labs (T ) the  t  progress transition gs â gs0 , where gs0 = hb1 ,  . . ., bs , u, v1 , . . ., vs , vs+1 + ti. By definition, gc0  âşâ1 gs0 ;  Ď  â (reset transition): gc â gc0 , where gc0 = hq0 ,  vs+1 âr , (j,u0 )(js ,bs ). . . (j1 ,b1 ), vs . . . v1 i, hq0 , Ď,  (j,u),(j,u0 ),Ď,r,Reset,q 0 i â T and vs+1 â Ď. Then  Ď  there exists Labs (T ) the transition gs â gs0 , where  gs0 = hb1 , . . ., bs , u0 , v1 , . . ., vs , vs+1 âr i and  hu, Ď, Ď, r, â, u0 i â Î´j . By definition, gc0 âşâ1  gs0 ;  Ď  â (store transition): gc â gc0 , where gc0 =  hq0 , vs+1 âr1 , (j 0 , en) (js+1 ,bs+1 ) . . . (j1 ,b1 ),  vs+1 . . . v1 i, hq0 , Ď, (j,u), (j 0 ,en)Âˇ(js+1 ,bs+1 ), Ď,  r1 , Store, q0 i â T and vs+1 â Ď. Then there  Ď  exists in Labs (T ) the transition gs â gs0 , where  gs0 = hb1 , . . ., bs , bs+1 , en, v1 , . . ., vs+1 ,  vs+1 âr1 i and hu, Ď, Ď, r1 , â,(bs+1 , en)i â Î´j .  By definition, gc0 âşâ1 gs0 ;  Ďn  (n)  â (restore transition): gc â  gc0 , where gc0 = hq(i,u0 ) ,  vs+1 â(r2n ,vs ) , (js ,bs ) . . . (j1 ,b1 ), vsâ1 . . . v1 i,  hq0 , Ďn , (j,exi ),, Ďn â§ (x0 = 0), r2n , Restore,  (n)  q(i,u0 ) i in T and vs+1 â Ď. Then there exists in  Ďn  Labs (T ) the transition gs â  gs0 , where gs0 = hb1 ,  0  . . ., bsâ1 , u , v1 , . . ., vsâ1 , (vs+1 â(r2n ,vs ) ) âr1n i  and h(bs , u), Ďn , Ďn , r1n , r2n , u0 i â Î´j is the  k â th return transition from u (u=exi ) to u0 . By  definition, gc0 âşâ1 gs0 ;  Ď [t]  â (progress with Ď ): gc â gc0 (possible only when  u=exi â Exj ), abstracting the Ď transition hq0 ,  Ď , (j,exi ), (j,exi ), T rue, {x0 }, Reset, q0 i â T  and the clock progress of t â DâĽ0 units of time.  The resulting configuration is gc0 = hq0 ,vs+1 â{x0 }  +t,(j,exi ). . . (j1 ,b1 ),vsâ1 . . . v1 i. Then there exists  t  in Labs (T ) the transition gs â gs0 , where gs0 =  hb1 , . . ., bs , u, v1 , . . ., vs , vs+1 +ti. By definition,  gc0 âşâ1 gs0 ;  Ďn  â (restore with Ď ): gc â  gc0 (possible only when  u=exi â Exj ), abstracting the following transitions:  â hq0 , Ď , (j,exi ), (j,exi ), T rue, {x0 }, Reset,  q0 i â T ;  â hq0 , Ďn , (j,exi ),, Ďn â§ x0 = 0, r2n , Restore,  (n)  q(i,u0 i in T .  n  The resulting configuration is gc0 = hq(i,u  0),  vs+1  â{x0 } â(r2n ,vs ) , (js ,bs ) . . . (j1 ,b1 ),  vsâ1 . . . v1 i, with vs â Ďn â§ x0 = 0 and  u0 â N âŞ Calls. Then there exists in Labs (T )  â˘  n  gs0 , where gs0 = hb1 , . . .,  the transition gs â  bsâ1 , u0 , v1 , . . ., vsâ1 , vs+1 â(r2n ,vs ) âr1n i and  h(bs , exi ), Ďn , Ďn , r1n , r2n , u0 i â Î´j is the  k â th return (or return-and-call) transition from  u (u=exi ) to u0 . By definition, gc0 âşâ1 gs0 .  Let gs = hb1 , . . ., bs , u, v1 , . . ., vs , vs+1 i be a global  (n)  state and gc = hq(i,u) , vs+1 , (js+1 , bs+1 ). . . (j1 ,b1 ),  vs . . . v1 i, with vk (x) = vk (x), for all x â X and  1 â¤ k â¤ s, and vs+1 (x) = vs+1 (x) for all x â X \  r1n , where r1n is the set of clocks reset by the n-th  return transition from (bs+1 , exi ) to u and vs+1 (x0 ) =  0. By definition, gs âş gs. Now we show all the possible  transitions in Labs (T ) having gs as source:  t  â (progress transition): gs â gs0 , for some t â DâĽ0 ,  where gs0 = hb1 , . . ., bs , u, v1 , . . ., vs , vs+1 + ti.  Ď [t]  Then there exists in Labs (P) the transition gc â  gc0 , abstracting the following transitions:  (n)  1) hq(i,u) , Ď , (js+1 ,bs+1 ), (j,u), x0 = 0, r1n ,  Reset, q0 i and  2) the progress transition in q0 of an amount of t  units of time.  The resulting configuration is gc0 = hq0 ,  (vs+1 âr1n ) + t, (j,u)Âˇ (js ,bs ) . . . (j1 ,b1 ), vs . . .  v1 i. By definition, gs0 âş gc0 ;  Ď  â (reset transition): gs â gs0 , where gs0 = hb1 , . . .,  bs , u0 , v1 , . . ., vs , vs+1 âr i, hu, Ď, Ď, r, â, u0 i  in Î´j and vs â Ď. Then there exists in Labs (P)  Ď  the transition gc â gc0 , abstracting the following  transitions:  (n)  1) hq(i,u) , Ď , (js+1 ,bs+1 ), (j,u),x0 = 0, r1n ,  Reset, q0 i;  2) hq0 , Ď, (j,u),(j,u0 ),Ď,r,Reset,q 0 i  The resulting configuration is gc0 = hq0 ,  (vs+1 âr1n ) âr , (j,u0 )Âˇ(js ,bs ) . . . (j1 ,b1 ), vs . . .  v1 i. By definition, gs0 âş gc0 ;  Ď  â (call transition): gs â gs0 , where gs0 = hb1 , . . .,  bs+1 , en, v1 , . . ., vs+1 , vs+1 âr1n i and hu, Ď,  Ď, r, â, (bs+1 , en)i â Î´j and vs â Ď. Then there  Ď  exists in P the transition gc â gc0 , abstracting the  following transitions:  (n)  â hq(i,u) , Ď , (js ,bs ), (j,u), x0 = 0, r1n , Reset,  q0 i â T ;  â hq0 , Ď, (j,u),(j 0 , en) Âˇ (js+1 , bs+1 ), Ď, r, Store,  q0 i in T .  The resulting configuration is gc0 = hq0 ,  vs+1 â{x0 }âŞr , (j 0 , en) Âˇ (js+1 , bs+1 ) . . . (j1 , b1 ),  vs . . . v1 i. By definition, gs0 âş gc0 .  Ď  â (return transition): gs âk gs0 , where gs0 = hb1 ,  . . ., bsâ1 , u0 , v1 , . . ., vsâ1 , vs+1 â(r2k ,vs ) âr1k i,  h(bs , u), Ďk , Ďk , r1k , r2k , u0 i in Î´j and vs+1 â  Ďk . Then there exists in Labs (P) the transition gc  Ď  â gc0 , abstracting the following transitions:  (n)  â hq0 , Ď, (j,u),(j 0 , en) Âˇ (js+1 , bs+1 ), Ď, r, Store,  q0 i in T .  The resulting configuration is gc0 = hq0 ,  vs+1 â{x0 }âŞr ,(j 0 , en) Âˇ (js+1 , bs+1 ) . . . (j1 , b1 ), vs  . . . v1 i, with vs+1 â{x0 } â Ď. Then there exists in  Ď  P the transition gs â gs0 , where gs0 = hb1 , . . .,  bs+1 , en, v1 , . . ., vs+1 , vs+1 âr1n i and hu, Ď, Ď,  r, â, (bs+1 , en)i â Î´j . By definition, gc0 âşâ1 gs0 ;  Ď  â (restore transition with Ď ): gc â gc0 , abstracting  the following transitions:  (n)  1) hq(i,u) , Ď , (js+1 ,bs+1 ), (j,u), x0 = 0, r1n ,  Reset, q0 i;  2) hq0 , Ď , (j,u), (j,u), T rue, {x0 }, Reset, q0 i;  3) hq0 , Ďk , (j,u), , Ďk â§ (x0 = 0), r2k , Restore,  (k)  q(i,u0 ) i  1) hq(i,u) , Ď , (js+1 ,bs+1 ), (j,u), x0 = 0, r1n ,  Reset, q0 i;  2) hq0 , Ď , (j,u), (j,u), T rue, {x0 }, Reset, q0 i;  3) hq0 , Ďk , (j,u), , Ďk â§ (x0 = 0), r2k , Restore,  (k)  q(i,u0 ) i  (k)  The resulting configuration is gc0 = hq(i,u0 ) ,  vs+1 âr1n âŞ{x0 }âŞr1n , (js ,bs ) . . . (j1 ,b1 ), vs . . . v1 i.  By definition, gs0 âş gc0 .  Ď  â (return-and-call transition): gs âk gs0 , where gs0 =  hb1 , . . ., bsâ1 , bs0 , en, v1 , . . ., vsâ1 , vs+1 ,  vs+1 â(r2k ,vs ) âr1k i, h(bs , u), Ďk , Ďk , r1k , r2k ,  (bs0 , en)i in Î´j and vs+1 â Ďk . Then there exists  Ď  in Labs (P) the transition gc â gc0 , abstracting the  following transitions:  (n)  1) hq(i,u) , Ď , (js , bs ), (j,u), x0 = 0, r1n , Reset,  q0 i;  2) hq0 , Ď, (j, u), (j 0 , u0 ) Âˇ (js0 , bs0 ), Ď, r, Store,  q0 i  The resulting configuration is gc0 = hq0 ,  vs+1 âr1n âŞr1k , (js0 , bs0 ) Âˇ (js , bs ) . . . (j1 , b1 ), vs+1  . . . v1 i. By definition, gs0 âş gc0 .  Now we show all the possible transitions in Labs (P)  having gc as source:  Ď [t]  â (progress transition with Ď ): gc â gc0 , abstracting  the following transitions:  (n)  1) hq(i,u) , Ď , (js+1 ,bs+1 ), (j,u), x0 = 0, r1n ,  Reset, q0 i and  2) the progress transition in q0 of an amount of t  units of time.  The resulting configuration is gc0 = hq0 ,  (vs+1 âr1n ) + t, (j, u) Âˇ (js , bs ) . . . (j1 , b1 ), vs . . .  v1 i. By definition, gs0 âş gc0 . Then there exists  t  in Labs (T ) the transition gs â gs0 , for some t  âĽ0  0  â D , where gs = hb1 , . . ., bs , u, v1 , . . ., vs ,  vs+1 + ti. By definition, gc0 âşâ1 gs0 ;  Ď  â (reset transition with Ď ): gc â gc0 , abstracting the  following transitions:  (n)  1) hq(i,u) , Ď , (js+1 ,bs+1 ), (j,u),x0 = 0, r1n ,  Reset, q0 i;  2) hq0 , Ď, (j,u),(j,u0 ),Ď,r,Reset,q 0 i  The resulting configuration is gc0 = hq0 ,  (vs+1 âr1n ) âr , (j, u0 ) Âˇ (js , bs ) . . . (j1 , b1 ), vs  . . . v1 i, with vs+1 âr1n â Ď. By definition, gs0 âş  gc0 . Then there exists in Labs (T ) the transition gs  Ď  â gs0 , where gs0 = hb1 , . . ., bs , u0 , v1 , . . ., vs ,  vs+1 âr i, hu, Ď, Ď, r, â, u0 i in Î´j . By definition,  gc0 âşâ1 gs0 ;  Ď  â (store transition with Ď ): gc â gc0 , abstracting the  following transitions:  (n)  â hq(i,u) , Ď , (js ,bs ), (j,u), x0 = 0, r1n , Reset,  q0 i â T ;  (k)  â˘  The resulting configuration is gc0 = hq(i,u0 ) ,  vs+1 âr1n âŞ{x0 } â(r2k ,vs ) , (js , bs ) . . . (j1 , b1 ),  vs . . . v1 i, with vs+1 âr1n âŞ{x0 } â Ďk . Then  Ď  there exists in Labs (P) the transition gs âk gs0 ,  0  0  where gs = hb1 , . . ., bsâ1 , u , v1 , . . ., vsâ1 ,  vs+1 â(r2k ,vs ) âr1k i, h(bs , u), Ďk , Ďk , r1k , r2k , u0 i  in Î´j and vs+1 â Ďk . By definition, gc0 âşâ1 gs0 ;  Let gs = hb1 , . . ., bs , u, v1 , . . ., vs , vs+1 i, with u â En  and vs+1 = vs âr1 n , where r1n is the set of clocks reset  by the n-th return-and-call transition from (bs0 , exi ) to  (n)  (bs , u), a global state and gc = hq(i,(bs ,u)) , vs , (js0 ,  bs0 ). . . (j1 ,b1 ), vsâ1 . . . v1 i, with vk (x) = vk (x), for  all x â X and 1 â¤ k â¤ s. By definition, gs âş gc. Now  we show all the possible transitions in Labs (T ) having  gs as source:  t  â (progress transition): gs â gs0 , for some t â DâĽ0 ,  where gs0 = hb1 , . . ., bs , u, v1 , . . ., vs , vs+1 + ti.  Ď [t]  Then there exists in Labs (P) the transition gc â  gc0 , abstracting the following transitions:  (n)  1) hq(i,(bs ,u) , Ď , (js0 , bs0 ), (j, u) Âˇ (js , bs ), x0 = 0,  r1n , Store, q0 i and  2) the progress transition in q0 of an amount of t  units of time.  The resulting configuration is gc0 = hq0 , vs âr1n  +t, (j,u)(js ,bs ). . . (j1 ,b1 ), vs . . . v1 i. By definition,  gs0 âş gc0 ;  Ď  â (reset transition): gs â gs0 , where gs0 = hb1 , . . .,  bs , u0 , v1 , . . ., vs , vs+1 âr i, hu, Ď, Ď, r, â, u0 i  in Î´j and vs+1 â Ď. Then there exists in Labs (P)  Ď  the transition gc â gc0 , abstracting the following  transitions:  (n)  1) hq(i,(bs ,u)) , Ď , (js0 , bs0 ), (j, u) Âˇ (js , bs ), x0 = 0,  r1n , Store, q0 i;  2) hq0 , Ď, (j,u),(j,u0 ),Ď,r,Reset,q 0 i  The resulting configuration is gc0 = hq0 ,  vs+1 âr1n âr , (j,u0 )(js ,bs ). . . (j1 ,b1 ), vs . . . v1 i. By  definition, gs0 âş gc0 ;  Ď  â (call transition): gs â gs0 , where gs0 = hb1 , . . .,  bs+1 , en, v1 , . . ., vs , vs+1 , vs+1 âr i, hu, Ď, Ď,  r, â, (bs+1 , en)i â Î´j and vs+1 â Ď. Then there  Ď  exists in P the transition gc â gc0 , abstracting the  following transitions:  (n)  â hq(i,(bs ,u)) , Ď , (js0 , bs0 ), (j, u) Âˇ (js , bs ), x0 = 0,  r1n , Store, q0 i â T ;  â hq0 , Ď, (j,u),(j 0 , en) Âˇ (js+1 , bs+1 ), Ď, r, Store,  q0 i in T .  The resulting configuration is gc0 = hq0 ,  vs âr1n âr , (j 0 , en) Âˇ (js+1 , bs+1 ) . . . (j1 , b1 ),  vs . . . v1 i. By definition, gs0 âş gc0 .  Now we show all the possible transitions in Labs (P)  having gc as source:  Ď [t]  â (progress transition): gc â gc0 , abstracting the  following transitions:  (n)  1) hq(i,(bs ,u) , Ď , (js0 , bs0 ), (j, u) Âˇ (js , bs ), x0 = 0,  r1n , Store, q0 i and  2) the progress transition in q0 of an amount of t  units of time.  The resulting configuration is gc0 = hq0 , vs âr1n  +t, (j,u)(js ,bs ). . . (j1 ,b1 ), vs . . . v1 i. By definition,  gs0 âş gc0 . Then there exists in Labs (T ) the trant  sition gc â gc0 , where gs0 = hb1 , . . ., bs , u, v1 ,  . . ., vs , vs+1 + ti. By definition, gc0 âşâ1 gs0 ;  Ď  â (reset transition): gc â gc0 , abstracting the following transitions:  (n)  1) hq(i,(bs ,u)) , Ď , (js0 , bs0 ), (j, u) Âˇ (js , bs ), x0 = 0,  r1n , Store, q0 i;  2) hq0 , Ď, (j,u),(j,u0 ),Ď,r,Reset,q 0 i  The resulting configuration is gc0 = hq0 ,  vs+1 âr1n âr , (j,u0 )(js ,bs ). . . (j1 ,b1 ), vs . . . v1 i,  with vs+1 â Ď. Then there exists in Labs (T ) the  Ď  transition gs â gs0 , where gs0 = hb1 , . . ., bs , u0 ,  v1 , . . ., vs , vs+1 âr i, hu, Ď, Ď, r, â, u0 i in Î´j and  vs+1 â Ď. By definition, gc0 âşâ1 gs0 ;  Ď  â (call transition): gc â gc0 , abstracting the following transitions:  (n)  â hq(i,(bs ,u)) , Ď , (js0 , bs0 ), (j, u) Âˇ (js , bs ), x0 = 0,  r1n , Store, q0 i â T ;  â hq0 , Ď, (j,u),(j 0 , en) Âˇ (js+1 , bs+1 ), Ď, r, Store,  q0 i in T .  The resulting configuration is gc0 = hq0 ,  vs âr1n âr , (j 0 , en) Âˇ (js+1 , bs+1 ) . . . (j1 , b1 ),  vs . . . v1 i, with vs âr1n â Ď. Then there exists in  Ď  Labs (T ) the transition gs â gs0 , where gs0 = hb1 ,  . . ., bs+1 , en, v1 , . . ., vs , vs+1 , vs+1 âr i, hu, Ď, Ď,  r, â, (bs+1 , en)i â Î´j and vs+1 â Ď. By definition,  gc0 âşâ1 gs0 .  Given the EPTA 2 P = hQ, q0 , X, Î, T i over the  alphabet ÎŁ, we define the TRSM T = hA1 , Xi over the  alphabet ÎŁ âŞ {Ď } (with Ď â  / ÎŁ. For every pair (q,a) with  q â Q and a â Î, the component A1 has an entries node  en(q,a) and an exit node ex(q,a) . There is a box ba for each  stack symbol a â Î, and all boxes are mapped to A1 (i.e.  Y1 (ba )= 1, for all ai â Î). The transitions in Î´1 are the  following:  â˘ for every reset transition of the form hq1 , Ď, a1 , a2 , Ď,  r, Reset, q2 i â T , there are the transitions hen(q1 ,a1 ) ,  Ď, Ď, r, â, en(q2 ,a2 ) i â Î´1 , and hex(q1 ,a1 ) , Ď, Ď, r, â,  ex(q2 ,a2 ) i â Î´1 ;  â˘ for every store transition of the form hq1 , Ď, a, a1 a2 , Ď,  r, Store, q2 i â T , there are the transitions hen(q1 ,a) ,  Ď, Ď, r, â, (ba2 ,en(q2 ,a1 ) )i â Î´1 and hex(q1 ,a) , Ď, Ď, r,  â, (ba2 ,en(q2 ,a1 ) )i â Î´1 ;  â˘ if hq1 , Ď, a, , Ď, r, Restore, q2 i â T , then there are  the following transitions:  1) hen(q1 ,a) , Ď , T rue, â, â, ex(q1 ,a) i â Î´1 ;  2) h(ba0 , ex(q1 ,a) ), Ď, Ď, â, r, en(q2 ,a0 ) i â Î´1 , for  every box ba0 and each box exit (ba0 ,exq1 );  The weak bisimulation relation âş between LP and LT is  defined as follows. For gc â GC and gs â GS, gc âş gs if  and only if:  1) gc = hq, vs , as Âˇ asâ1 . . . a1 , vsâ1 . . . v1 i and gs =  hba1 , . . ., basâ1 , u, v1 , . . ., vsâ1 , vs i, with u â  {en(q,as ) , ex(q,as ) }.  We show now that âş is a bisimulation.  Let us consider the initialization requirement. The initial  state of P has the form gc0 =hq0 , v0 , a, i. An initial state  of T has the form gs0 =hen(q,a) , , v0 i, with en(q,a) â En1 .  By definition of âş, it is immediate to show that gc0 âş gs0  and gs0 âşâ1 gc0 .  Let us consider now the propagation requirement. Let us  assume that gc âş gs, there are the following cases:  â˘ Let gc = hq, vs , as Âˇ asâ1 . . . a1 , vsâ1 . . . v1 i a  configuration and gs = hba1 , . . ., basâ1 , u, v1 , . . .,  vsâ1 , vs i, with u â {en(q,as ) , ex(q,as ) } a global state.  By definition, gc âş gs. Now we show all the possible  transitions in Labs (P) having gc as source:  t  â (progress transition): gc â gc0 , where gc0 = hq,  vs + t, as Âˇ asâ1 . . . a1 , vsâ1 . . . v1 i and t â  DâĽ0 . Then there exists in Labs (T ) the transition  t  gs â gs0 , where gs0 = hba1 , . . ., basâ1 , u, v1 , . . .,  vsâ1 , vs + ti. By definition, gc0 âş gs0 ;  Ď  â (reset transition): gc â gc0 , where gc0 = hq 0 ,  0  vs âr , a Âˇ asâ1 . . . a1 ,vsâ1 . . . v1 i, hq, Ď, as , a0 ,  Ď, r, Reset, q 0 i in T and vs â Ď. Then there  Ď  exists in Labs (T ) the transition gs â gs0 , where  0  0  gs = hba1 , . . ., basâ1 , u ,v1 , . . ., vsâ1 , vs âr i, hu,  Ď, Ď, r, â, u0 i in T and u0 â {en(q0 ,a0 ) , ex(q0 ,a0 ) }.  By definition, gc0 âş gs0 ;  Ď  â (store transition): gc â gc0 , where gc0 = hq 0 ,  0 00  vs âr , a a asâ1 . . . a1 ,vs . . . v1 i, hq, Ď, as , a0 a00 ,  Ď, r, Store, q 0 i in T and vs â Ď. Then there  Ď  exists in Labs (T ) the transition gs â gs0 , where  gs0 = hba1 , . . ., basâ1 , ba00 , u0 , v1 , . . ., vsâ1 ,  vs âr i, hu, Ď, Ď, r, â, (ba0 ,u0 )i in T and u0 â  {en(q0 ,a0 ) , ex(q0 ,a0 ) }. By definition, gc0 âş gs0 ;  Ď  â (restore transition): gc â gc0 , where gc0 = hq 0 ,  vs â(r,vsâ1 , asâ1 . . . a1 , vsâ2 . . . v1 i, hq, Ď,  as , , Ď, r, Restore, q 0 i in T and vs â Ď.  If u=en(q,as ) then there exists in Labs (T ) the  Ď  transition gs â gs0 in Labs (T ) that abstracting  the following transitions:  â the reset transition hu, Ď , T rue, â, â, ex(q,as ) i  in Î´1 ;  â the return transition h(basâ1 , ex(q,as ) ), Ď, Ď, â,  r, en(q0 ,asâ1 ) i â Î´1 .  If u=ex(q,as ) then there exists in Labs (T ) the  Ď  transition gs â gs0 in Labs (T ), corresponding to  the return transition h(basâ1 , ex(q,as ) ), Ď, Ď, â, r,  en(q0 ,asâ1 ) i â Î´1 .  The resulting global state is gs0 = hba1 , . . ., basâ2 ,  u,v1 , . . ., vsâ2 , vs â(r,vsâ1 i. By definition, gc0 âş  gs0 ;  Now we show all the possible transitions in Labs (T )  having gs as source.  t  â (progress transition): gs â gs0 , where gs0 = hba1 ,  . . ., basâ1 , u, v1 , . . ., vsâ1 , vs + ti and t â  DâĽ0 . Then there exists in Labs (P) the transit  tion gc â gc0 , where gc0 = hq, vs + t, as Âˇ  asâ1 . . . a1 ,vsâ1 . . . v1 i. By definition, gs0 âşâ1  gc0 ;  Ď [t]  â (progress transition with Ď ): (u â En). gs â gs0 ,  where gs0 = hba1 , . . ., basâ1 , u0 , v1 , . . ., vsâ1 ,  vs + ti, u0 â Ex and t â DâĽ0 . Then there exists  t  in Labs (P) the transition gc â gc0 , where gc0 = hq,  vs + t, as Âˇ asâ1 . . . a1 ,vsâ1 . . . v1 i. By definition,  gs0 âşâ1 gc0 ;  Ď  â (reset transition): gs â gs0 , where gs0 = hba1 , . . .,  0  basâ1 , u ,v1 , . . ., vsâ1 , vs âr i, hu, Ď, Ď, r, â,  u0 i in T , vs â Ď and u0 â En âŞ Ex. Then there  Ď  exists in Labs (P) the transition gc â gc0 , where  0  0  0  gc = hq , vs âr , a Âˇ asâ1 . . . a1 ,vsâ1 . . . v1 i, hq,  Ď, as , a0 , Ď, r, Reset, q 0 i in T and vs â Ď. By  definition, gs0 âşâ1 gs0 ;  Ď [t]  â (reset transition with Ď ): (u â En). gs â gs0 ,  where gs0 = hba1 , . . ., basâ1 , u0 ,v1 , . . ., vsâ1 ,  vs âr i, hu, Ď, Ď, r, â, u0 i in T , vs âr â Ď  and u0 â Ex. Then there exists in Labs (P) the  Ď  transition gc â gc0 , where gc0 = hq 0 , vs âr ,  0  a Âˇ asâ1 . . . a1 ,vsâ1 . . . v1 i, hq, Ď, as , a0 , Ď, r,  Reset, q 0 i in T and vs â Ď. By definition, gs0  âşâ1 gc0 ;  Ď  â (call transition): gs â gs0 , where gs0 = hba1 , . . .,  basâ1 , ba00 , u0 , v1 , . . ., vsâ1 , vs âr i, hu, Ď, Ď, r,  â, (ba0 ,u0 )i in T , vs â Ď and u0 â En âŞ Ex. Then  Ď  there exists in Labs (P) the transition gc â gc0 ,  where gc0 = hq 0 , vs âr , a0 a00 asâ1 . . . a1 ,vs . . . v1 i,  hq, Ď, as , a0 a00 , Ď, r, Store, q 0 i in T and vs â Ď.  By definition, gs0 âşâ1 gc0 ;  Ď  â (call transition with Ď ): (u â En). gs â gs0 , where  gs0 = hba1 , . . ., basâ1 , ba00 , u0 , v1 , . . ., vsâ1 , vs âr  i, hu, Ď, Ď, r, â, (ba0 ,u0 )i in T and vs â Ď. Then  Ď  there exists in Labs (P) the transition gc â gc0 ,  where gc0 = hq 0 , vs âr , a0 a00 asâ1 . . . a1 ,vs . . . v1 i,  hq, Ď, as , a0 a00 , Ď, r, Store, q 0 i in T and vs â Ď.  By definition, gs0 âşâ1 gc0 ;  Ď  â (return transition): (u â Ex). gs â gs0 , where  gs0 = hba1 , . . ., basâ2 , u,v1 , . . ., vsâ2 , vs â(r,vsâ1  i and vs â Ď. Then there exists in Labs (P)  Ď  the transition gc â gc0 , where gc0 = hq 0 ,  vs â(r,vsâ1 , asâ1 . . . a1 ,vsâ2 . . . v1 i, hq, Ď, as , ,  Ď, r, Restore, q 0 i in T and vs â Ď. By definition,  gs0 âşâ1 gc0 ;  Ď  â (return transition with Ď ): (u â En). gs â gs0 ,  0  where gs = hba1 , . . ., basâ2 , u,v1 , . . ., vsâ2 ,  vs â(r,vsâ1 i and vs â Ď. Then there exists in  Ď  Labs (P) the transition gc â gc0 , where gc0 = hq 0 ,  vs â(r,vsâ1 , asâ1 . . . a1 ,vsâ2 . . . v1 i, hq, Ď, as , ,  Ď, r, Restore, q 0 i in T and vs â Ď. By definition,  gs0 âşâ1 gc0 .  We now show the bisimulation relation between TRSM 1  and EPTA 1.  Let us consider a TRSM T in the class of TRSM 1, it  is easy to see that the EPTA P simulating T as defined  in the construction of Theorem 1, is actually an EPTA 1.  Conversely, let us consider an EPTA P in the class of  EPTA 1, it is easy to see that the TRSM T simulating P  as defined in the construction of Theorem 1, is actually a  TRSM 1.  Analogues arguments can be used to prove the correspondence between EPTA 0 and TRSM 0.  V. T HE REACHABILITY PROBLEM : DECIDABILITY AND  COMPLEXITY RESULTS  In this section we study the problem of reachability for  TRSMs and EPTAs. In particular, we prove that the problem  is undecidable for the general class of TRSMs and EPTAs,  but that is decidable for TRSM 1 and EPTA 1. We state also  the complexity of the problem for the class of TRSM 0 (and  EPTA 0).  Given a global state gs = hb1 , . . . , bs , u, v1 , . . . , vs , vi  of a TRSM T , we call the tuple hb1 , . . . , bs , ui an untimed  global state of T . The reachability problem for an untimed  global state hb1 , . . . , bs , ui is to determine whether, for some  clock valuations v1 , . . ., vs , v, the global state hb1 , . . ., bs ,  u, v1 , . . ., vs , vi is reachable from an initial configuration  state. A similar notion of reachability can be given for  EPTAs.  The undecidability for TRSMs is stated by showing the  undecidability of the reachability problem for the class  EPTA 2. In fact, it is possible to show (see the complete  work) that EPTA 2s allow to simulate increment and decrement of clocks. For instance, Fig. 3 shows an EPTA 2 which  decrements the clock z, leaving the clock y unchanged (z  and y can be viewed as the two counters). The path leading  from (p, q0â ) to (p, q3â ), is used to store the value of x  into x00 , while y maintains the original value. In the next  step, these values are stored in the valuation stack, and after  an amount of time equal to x00 â 1 is elapsed, the original  value of y is restored. In this way, it is possible to define  an EPTA 2 which simulates a two counter machine (clocks  with increment and decrement can be used as counters). This  allows to reduce the halting problem of two counter Minsky  machine, which is known to be undecidable [5], to the  reachability problem for an EPTA 2.  Theorem 2: The reachability problem for EPTA 2 is  undecidable.  Proof:  We recall that a two counter machine is a finite set of  labeled instructions over two counters c1 and c2 . There are  two type of instructions:  â˘ increment of x â {c1 , c2 }, of the form  p : x := x + 1; goto q;  â˘ decrement of x â {c1 , c2 }, of the form  p : if x > 0 then x:=x - 1; goto q1 else goto q2  The machine starts at an instruction labeled p0 with  c1 =c2 =0 and stops at a special instruction labeled HALT .  The halting problem for a two counter machine consists  in deciding whether the machine reaches the instruction  HALT .  The idea is that the two counters can be simulated by  two clocks, and the instructions of increment and decrement  can be simulated by sequences of transitions of an EPTA 2  which exploit the ability of storing and restoring clock valuations on the valuation stack. The states of the automaton  are the labels of the instruction augmented with additional  Ď , , , x0 = 0, â, Store  (p,q0â )  Ď , , , T rue, X \ {x00 }, Restore  (p,q1â )  (p,q2â )  Ď , , , (x00 â z = 0) â§ (x0 = 0), {z}, Reset  0  (p,q5â ) Ď , , , T rue, X \ {z}, Restore (p,q4â ) Ď , , , x = 0, â, Store (p,q3â )  control states, used to simulated increments and decrements.  We denote by C(+) (resp. : C(â) ) the set of the labels  associated to increment (resp. : decrement) instructions.  Given a machine with two counters x and y, the simulating EPTA 2 is hQ, (p0 , s), X, Î, T i, where  S  â˘ Q=C(+) Ă{q0+ , q1+ , q2+ }  C(â) Ă{qiâ : 0 â¤ i â¤ 6}  S  {Halt};  â˘ s=q0+ if p0 â C(+) and s=q0â if p0 â C(â) ;  0  00  â˘ X={x, y, x , x } and Î={Îł};  â˘ for every p â C(+) associated with the increment of  the counter z â {x, y}, T has the transitions:  1) h(p, q0+ ), Ď , , Îł, x0 = 0, â, Store, (p, q1+ )i;  2) h(p, q1+ ), Ď , , Îł, x0 = 1, X \ {z}, Restore,  (p, q2+ )i;  3) let q be the target label of the goto instruction,  then  a) if q â C(+) , then h(p, q2+ ), Ď , , , x0 = 0,  {x00 }, Reset, (q, q0+ )i;  b) if q â C(â) , then h(p, q2+ ), Ď , , , x0 = 0,  {x00 }, Reset, (q, q0â )i;  c) if q=Halt, then h(p, q2+ ), Ď , , , x0 = 0,  {x00 }, Reset, Halti;  â˘ for every p â C(â) associated with the decrement of  the counter z â {x, y} (see also Figure 3), T has the  transitions:  1) h(p, q0â ), Ď , , Îł, x0 = 0 â§ z âĽ 1, â, Store,  (p, q1â )i;  2) h(p, q1â ), Ď , Îł, , T rue, X \ {x00 }, Restore,  (p, q2â )i;  3) h(p, q2â ), Ď , , , x00 â z = 0 â§ x0 = 0, {z},  Reset, (p, q3â )i;  4) h(p, q3â ), Ď , , Îł, x0 = 0, â, Store, (p, q4â )i;  5) h(p, q4â ), Ď , Îł, , T rue, X \ {z}, Restore,  (p, q5â )i;  6) h(p, q5â ), Ď , , , x00 â z=1â§ x0 = 0, {x0 ,x00 },  Reset, (p, q6â )i;  7) let q be the target label pointed by the goto  instruction (it depends on the chosen branch), then  a) if q â C(+) , then h(p, q6â ), Ď , , , x0 = 0,  {x00 }, Reset, (q, q0+ )i and h(p, q0â ), Ď , , ,  x0 = 0 â§ z < 1, {x00 }, Reset, (q, q0+ )i;  b) if q â C(â) , then h(p, q6â ), Ď , , , x0 = 0,  {x00 }, Reset, (q, q0â )i and h(p, q0â ), Ď , , ,  x0 = 0 â§ z < 1, {x00 }, Reset, (q, q0â )i;  c) if q=Halt, then h(p, q6â ), Ď , , , x0 = 0,  {x0 , x00 }, Reset, Halti and h(p, q0â ), Ď , , ,  x0 = 0 â§ z < 1, {x0 , x00 }, Reset, Halti.  Ď , , , (z â x00 = 1) â§ (x0 = 0), {x0 , x00 }, Reset  (p,q6â )  Figure 3.  EPTA for the decrement of the clock z  As consequence of Theorem 1 we have the following  corollary.  Corollary 1: The reachability problem for TRSMs is  undecidable.  We shall now prove that the reachability problem for  TRSM 1 is decidable. The proof combines two techniques:  the former is the standard regionalization technique, used to  prove reachability in Timed Automata [2], while the latter is  derived from the algorithm, based on a fix point construction,  proposed in [1] to solve the reachability problem for RSMs.  Let us first recall the notion of clock region and region  automaton of a Timed Automaton. Following the standard  construction [6], we assume that constants occurring in the  clock constraints of the automaton are integers. For any t â  DâĽ0 , hti denotes the fractional part of t, and btc denotes the  integral part of t (i.e. t=btc+hti). For each clock x â X, let  cx be the largest integer constant c such that x is compared  with c in some clock constraint appearing in a transition. The  equivalence relation âź  =, (region equivalence), is defined over  the set of clock valuations for X. For two clock valuations  v1 and v2 , we write v1 âź  = v2 iff the following conditions  hold:  1) for all clocks x â X, either bv1 (x)c and bv2 (x)c are  the same, or both v1 (x) and v2 (x) exceed cx ;  2) for all clocks x, y with v1 (x) â¤ cx and v1 (y) â¤ cy ,  hv1 (x)i â¤ hv1 (y)i iff hv2 (x)i â¤ hv2 (y)i;  3) for all clocks x â X with v1 (x) â¤ cx , hv1 (x)i = 0 iff  hv2 (x)i = 0.  A clock region is an equivalence class of clock valuations  induced by âź  =.  QIf k is the number of the clocks, there are at  most k! Âˇ 4k Âˇ xâX (cx + 1) regions (see [6]). We denote by  Reg the set of all regions with respect to the set of clocks  X and an indexed family {cx }xâX .  A clock region reg 0 is a time successor of a clock region  reg if and only if, for all clock valuations v â reg, there  exists a t â DâĽ0 such that v+t â reg 0 . Let Ď â C(X) be a  clock constraint, we write reg â Ď if and only if v â Ď, for  all v â reg. Note that for a clock constraint Ď of a TA, if  vâź  = v0 , then v â Ď iff v0 â Ď. Let r â X a set of clocks,  reg âr = {v âr |v â reg} denotes the region resulting from  reg by resetting the clocks in r.  It is well known that the reachability problem of a Timed  Automaton can be reduced to the reachability problem over  its region automaton, namely the automaton whose states  are obtained by coupling control states and regions, and  transitions are obtained by suitably coupling the transition  relation of the timed automaton and the successor relation  defined on regions.  Given a TRSM T =hA  S1 , . . ., An , Xi belonging to  TRSM 1, with Ai = hNi Bi , Yi , Eni , Exi , Î´i i, in order  to compute reachability in T we build a region RSM R for  T , over the alphabet ÎŁ, whose components are the region  automata obtained from the components of the original  TRSM. More formally, R = hA01 , . . ., A0n i, where:  S  A0i = h(Ni Ă Reg) Bi , Yi ,Eni Ă Reg, Exi Ă Reg,Î´i0 i,  with 1 â¤ i â¤ n  and Reg is the finite set of regions for the set of clocks X  and the indexed family {cx }xâX , where cx is the maximal  constant c which is compared with clock x in some clock  constraint Ď decorating a transition of T . R is computed as  the fix point of an iterative process, which builds a chain of  region RSMs R(0) , . . ., R(k) . The idea is that, for the sake  of reachability, given a run of a TRSM 1, it is possible  to abstract away all the sub-runs bounded by matching  pairs of call and return transitions. This abstraction can be  performed by augmenting the region RSM R with summary  transitions, which can be used, during the reachability  analysis, to skip the invocation of and the return from the  component, provided that the exit node of the component is  actually reachable from the corresponding entry node. The  process described below iteratively computes these summary  transitions.  (0)  (0)  The initial RSM is R0 = hA0 1 , . . ., A0 n i, where  S  (0)  (0)  A0 i =h(Ni Ă Reg) Bi ,Reg,Yi ,En0i , Ex0i , Î´i i, with 1 â¤  (0)  i â¤ n. The transitions in Î´i are:  1) h(u1 ,reg1 ),Ď,(u1 ,reg2 )i, if reg2 is a time successor of  reg1 ;  2) h(u1 ,reg1 ),Ď,(u2 ,reg2 )i, if hu1 , Ď, Ď, r1 , â, u2 i â Î´i ,  reg1 â Ď and reg2 = reg1 âr1 ;  3) h(u1 ,reg1 ),Ď,(b, (u2 ,reg2 )i, if hu1 , Ď, Ď, r1 , â, (b, u2 )i  â Î´i , reg1 â Ď and reg2 = reg1 âr1 ;  (0)  Notice that Î´i does not contain return transitions. At  (k+1)  the (k + 1)-th iteration (k âĽ 0), we compute Î´i  , by  adding appropiate summary transitions. Suppose that there  is a call transition in the i-th component from a node u1  to a box b invoking the j-th component into the entry node  en, and there is a return transition from the exit node ex  of the j-th component to a node u2 of the i-th component.  In order to add a summary transition from (u1 , reg1 ) to  (u2 , reg2 ), we need to know whether (ex, reg 00 ) is locally  reachable (i.e. without exploiting call or return transitions)  from (en, reg 0 ) in the j-th component of R(k) , where reg 0  is the region resulting from reg1 after resetting the clocks  according the call transition, reg2 is the region resulting  from reg1 after resetting the clocks according the return  transition in the TRSM and reg 00 satisfy the constraint in  the return transition.  (k+1)  (k)  Formally, the relation transition Î´i  is Î´i augumented with the following transitions. For each entry  node (b,(en,reg 0 )), where j=Yi (b), and for each exit node  (k)  (k)  (ex,reg 00 ) â A0 j , reachable from (en, reg 0 ) in A0 j , if  (k)  there is a transition h(u1 , reg1 ), Ď1 , (b, (en, reg 0 ))i in Î´i  (k+1)  we add to Î´i  the transitions:  â˘  h(u1 , reg1 ), Ď1 , (u2 , reg1 âr )i, whenever h(b, ex), Ď2 ,  Ď, r, X, u2 i â Î´i and reg 00 â Ď.  The iterative construction terminates when it is not possible to add new transitions. Termination of the procedure is  ensured since the number of the states of R and the number  of the transitions in each Î´i is finite.  The region RSM R, resulting from the construction, can  be proved equivalent, from the reachability viewpoint, to the  original TRMS (see the complete work). Since the reachability problem for RMSs is decidable [1], this establishes  decidability of reachability for the class TRSM 1.  Theorem 3: The reachability problem for the class  TRSM 1 is decidable.  Proof:  Given a TRSM 1 T =hA1 , . . ., An , Xi, the region RSM  R for T , over the alphabet ÎŁ, is R=hA01 , . . S  ., A0n i, where  0  for all (1 â¤ i â¤ n), Ai is a tuple h(Ni Ă Reg) Bi , Yi ,En0i ,  Ex0i , Î´i0 i and:  â˘ Reg is the finite set of all regions with respect to the set  of the clocks X of T and the indexed family {cx }xâX ,  where cx is the maximal values c such that the clock  x â X is compared with c in some clock constraint  appearing in a guard Ď of all Î´i ;  0  â˘ Eni = Eni Ă Reg, is the set of initial states;  0  â˘ Exi = Eni Ă Reg, is the set of final states;  The desired RSM R is built as the limit of a (finite)  (0)  sequence of RSM R(i) (i âĽ 0), where R(0) =hA0 1 , . . .,  0 (0)  0 (0)  A n i and, for all (1 â¤ i â¤ n), A i is the tuple  S  (0)  h(Ni Ă Reg) Bi ,Reg,Yi ,En0i , Ex0i , Î´i i. The transitions  (0)  in Î´i are of the form:  1) h(u1 ,reg1 ),Ď,(u1 ,reg2 )i, where reg2 is a time successor of reg1 ;  2) h(u1 ,reg1 ),Ď,(u2 ,reg2 )i, where hu1 , Ď, Ď, r1 , â, u2 i â  Î´i and reg2 is such that for all clock valuation v â  reg1 with v â Ď and v âr1 â reg2 ;  3) h(u1 ,reg1 ),Ď,(b, (u2 ,reg2 )i, where hu1 , Ď, Ď, r1 , â, (b,  u2 )i â Î´i and reg2 is such that for all clock valuation  v â reg1 with v â Ď and v âr1 â reg2 ;  (k+1)  (k+1)  Given R(k) , with k âĽ 0, R(k+1) =hA0 1  ,. . ., A0 n  i,  0 (k+1)  where for all 1 â¤ i â¤ n, A i  is the tuple h(Ni Ă  S  (k+1)  Reg) Bi ,Yi ,Eni , Exi , Î´i  i. The relation transition  (k+1)  (k)  Î´i  is Î´i augumented with the following transitions.  For each enter node (b,(en,reg)), where j=Yi (b), and for  (k)  each exit node (ex,reg 0 ) â A0 j , reachable from (en, reg)  (k)  in A0 j , if there is a transition h(u0 , reg 00 ), Ď, (b, (en, reg))i  (k)  (k+1)  in Î´i we add to Î´i  the transitions:  0  00  â˘ h(u , reg ), Ď, (u, reg2 )i for all the transitions h(b, ex),  Ď1 , Ď, r1 , X, ui â Î´i , where reg2 is such that for all  clock valuation v â reg 00 , with v â Ď, v âr1 â reg2 ;  The iterative construction terminates when it is not possible to add new transitions, and we obtain the relations Î´i0  (termination is ensured since the number of the states and  the number of the transitions in Î´i is finite, for all i).  For proving the Theorem 3 we preliminary state the  following property:  Let hb1 , . . ., bs , ui be an untimed global state of T , the  global state hb1 , . . ., bs , u, v1 , . . ., vs , vi is reachable from  an initial global state, for some clock evaluations v1 , . . .,  vs , v, iff the global state hb1 , . . ., bs , (u, reg)i of R is  reachable from an initial global state of R, for some reg  and v â reg.  Lemma 1: For all b1 , . . ., bs , b01 , . . ., b0k â B, for all clock  evaluations v1 , . . ., vs , v10 , . . ., vk0 , with 0 â¤ s â¤ k, for all  reg, reg 0 â Reg and for all u, u0 â Ni , such that hb1 , . . .,  bs , u,v1 , . . ., vs , vi, hb1 , . . ., bs , (u, reg)i, hb01 , . . ., b0k , u,  v10 , . . ., vk0 , vi and hb01 , . . ., b0k , (u0 , reg 0 )i are well-defined  global states: if hb1 , . . ., bs , u,v1 , . . ., vs , vi ââT hb1 , . . .,  bs , u0 , v1 , . . ., vs , v0 i, then hb01 , . . ., b0k , u, v10 , . . ., vk0 , vi  ââT !hb01 , . . ., b0k , u0 , v10 , . . ., vk0 , v0 i; if hb1 , . . ., bs , (u, reg)i  ââR hb1 , . . ., bs , (u0 , reg 0 )i, then hb01 , . . ., b0k , (u, reg)i ââR  hb01 , . . ., b0k , (u0 , reg 0 )i.  Proof:  We starting proving the Lemma for the TRSM T .  The prove is by induction on the length k of the run  ÎťT = hb1 , . . ., bs , u, v1 , . . ., vs , vi ââT hb1 , . . ., bs , u0 ,  v1 , . . ., vs , v0 i.  (Base case, k = 0). Immediate.  (Inductive step, k âĽ 0). Let us suppose that the property  holds for the run of lenght k. Let hb1 , . . ., bs , u, v1 , . . ., vs ,  (k+1)  vi âT  hb1 , . . ., bs , uk+1 , v1 , . . ., vs , vk+1 i be a run  of lenght k + 1. The (k + 1) â th transition can have one of  the following forms:  â˘  â˘  â˘  (progress transition): hb1 , . . ., bs , uk , v1 , . . ., vs , vk i  âT hb1 , . . ., bs , uk+1 , v1 , . . ., vs , vk+1 i, where  uk+1 = uk , vk+1 = vk + t and t â DâĽ0 . By inductive  hypothesis, we have that hb01 , . . ., b0k , u, v10 , . . ., vk0 ,  (k)  vi âT hb01 , . . ., b0k , uk , v10 , . . ., vk0 , vk i and there is  the progress transition hb01 , . . ., b0k , uk , v10 , . . ., vk0 , vk i  âT hb01 , . . ., b0k , uk , v10 , . . ., vk0 , vk + ti;  (reset transition): hb1 , . . ., bs , uk , v1 , . . ., vs , vk i  âT hb1 , . . ., bs , uk+1 , v1 , . . ., vs , vk+1 i, where  huk ,Ď,Ď,r1 ,â,uk+1 i â Î´i , vk â Ď, vk+1 = vk âr1 .  By inductive hypothesis, we have that hb01 , . . ., b0k , u,  (k)  v10 , . . ., vk0 , vi âT hb01 , . . ., b0k , uk , v10 , . . ., vk0 , vk i  and, has an the effect of the reset transition, we have  that hb01 , . . ., b0k , uk , v10 , . . ., vk0 , vk i âT hb01 , . . ., b0k ,  uk+1 , v10 , . . ., vk0 , vk+1 i;  (return transition): hb1 , . . ., bs+1 , uk , v1 , . . ., vs+1 ,  vk i âT hb1 , . . ., bs , uk+1 , v1 , . . ., vs , vk+1 i, where  h(bs+1 , uk ), Ď, Ď, r1 , X, uk+1 i â Î´i , vs+1 â Ď,  vk+1 = vs+1 âr1 . In the run there is the matching  call transition hb1 , . . ., bs , uk0 , v1 , . . ., vs , vs+1 i âT  hb1 , . . ., bs+1 , en0 , v1 , . . ., vs+1 , vs+1 âr10 i, where  huk0 , Ď 0 , Ď0 , r10 , â, (bs+1 , en0 )i â Î´i and vs+1 â Ď0 .  By inductive hypothesis, there is the run hb01 , . . .! , b0k ,  (k0 )  u, v10 , . . ., vk0 , vi âT hb01 , . . ., b0k , uk0 , v10 , . . ., vk0 ,  vs+1 i (k 0 < k). Has an effect of the call transition, we  have that hb01 , . . ., b0k , uk0 , v10 , . . ., vk0 , vs+1 i âT hb01 ,  . . ., b0k , bs+1 , en0 , v10 , . . ., vk0 , vs+1 , vs+1 âr10 i. By  induction hypothesis there is the run hb01 , . . ., b0k , bs+1 ,  en0 , v10 , . . ., vk0 , vs+1 , vs+1 âr10 i ââT hb01 , . . ., b0k ,  bs+1 , uk , v10 , . . ., vk0 , vs+1 , vk i, and as a consequence  of the return transition, we have hb01 , . . ., b0k , bs+1 , uk ,  v10 , . . ., vk0 , vs+1 , vk i âT hb01 , . . ., b0k , uk+1 , v10 , . . .,  vk0 , vk+1 i.  Now we prove the Lemma for the RSM R.  The prove is by induction on the length k of the run  ÎťR = hb1 , . . ., bs , (u, reg)i ââR hb1 , . . ., bs , (u0 , reg 0 )i.  (Base case, k = 0). Immediate.  (Inductive step, k âĽ 0). Suppose that the property holds  for the run of lenght k. Let us suppose hb1 , . . ., bs ,  (uk , regk )i ââR hb1 , . . ., bs , (uk+1 , regk+1 )i be a run of  lenght k + 1. The (k + 1) â th transition can have one of  the following forms:  â˘ hb1 ,  . . ., bs , (uk , regk )i âR hb1 , . . ., bs ,  (uk+1 , regk+1 )i, where uk+1 = uk . By inductive  (k)  hypothesis, we have that hb01 , . . ., b0k , (u, reg)i âR  0  0  hb1 , . . ., bk , (uk , regk )i and there is the transition hb01 ,  . . ., b0k , (uk , regk )i âR hb01 , . . ., b0k , (uk , regk+1 )i;  â˘ hb1 ,  . . ., bs , (uk , regk )i âR hb1 , . . ., bs ,  (uk+1 , regk+1 i, where huk ,Ď,Ď,r1 ,â,uk+1 i â Î´i .  By inductive hypothesis, we have that hb01 , . . ., b0k ,  (k)  (u, reg)i âR hb01 , . . ., b0k , (uk , regk )i and has an  effect of the reset transition we have that hb01 , . . ., b0k ,  (uk , regk )i âR hb01 , . . ., b0k , (uk+1 , regk+1 )i.  Ď  Ď  Ď  Definition 3: Let ÎťT =gs0 â0 T gs1 â1 T . . . â0 T gsi be  a run of the TRSM T . The nesting depth of ÎťT is defined  as the maximum s such that gsj = hbj1 , . . ., bjs , u, vj1 , . . .,  vjs , vj i for some 0 â¤ j â¤ i.  Lemma 2: Let u, u0 â Nj , then h(u, reg)i ââA0  j  h(u0 , reg 0 )i iff for all v â reg there is v0 â reg 0 and hu, vi  ââT hu0 , v0 i.  Proof:  (â).  Let ÎťT = hu1 , v1 i ââT hun , vn i be a run of T , with  u1 , un â Nj , v1 â reg1 and vn â regn . The proof is by  induction on nesting depth k of ÎťT .  (Base case, k = 0). In this case, every transition hui , vi i  âT hui+1 , vi+1 i in ÎťT , with 1 â¤ i â¤ n and ui , ui+1 â  Nj , can be only either a progress or a reset transition:  â˘ (progress transition): ui+1 = ui , vi+1 = vi + t, with  t â DâĽ0 . By construction of R, there is the transition  h(ui , regi )i âA0j h(ui , regi+1 )i, where h(ui , regi ), Ď,  (0)  Î´j  â˘  (ui , regi+1 )i â  â Î´j0 , vi â regi and vi+1 â  regi+1 ;  (reset transition): vi+1 = vi âr1 , where hui , Ďi , Ďi , ri ,  â, ui+1 i â Î´j and vi â Ďi . By construction of R, there  is the transition h(ui , regi )i âA0j h(ui+1 , regi+1 )i,  (0)  where h(ui , regi ), Ďi , (ui+1 , regi+1 )i â Î´j â Î´j0 , vi  â regi , vi+1 â regi+1 and regi â Ďi .  (Inductive step, k > 0). Let us suppose that the nesting  depth of the run hu1 , v1 i ââT hun , vn i is k + 1. The run  can have two kind of sub-runs. The first one of the form hui ,  vi i ââT hui0 , vi0 i, with nesting depth s â¤ k and i < i0 â¤ n.  All sub-runs of this form have, by inductive hypothesis, the  corresponding sub-runs h(ui , regi )i ââA0 h(ui0 , regi0 )i, with  j  vi â regi and vi0 â regi0 . The second one of the form hui ,  vi i ââT hui0 , vi0 i with nesting depth k + 1 and i < i0 â¤ n.  Any such run, can be split in the following way:  hui , vi i âT hb, en, vi , v0 i ââT hb, ex, vi , v00 i âT hui0 ,  vi0 i. Therefore:  0  â˘ since hui , vi i âT hb, en, vi , v i is in L(T ), then  the call transition hui , Ď1 , Ď1 , r1 , â, (b, en)i is in Î´j ,  with Yj (b) = i, en â Eni , vi â Ď1 , v0 = vi âr1 .  By construction of Î´j0 , we have that h(ui , regi ), Ď1 ,  (b, (en, reg 0 ))i â Î´j0 , with vi â regi and v0 â reg 0 ;  00  â˘ since hb, ex, vi , v i âT hui0 , vi0 i is in L(T ), then  the return transition h(b, ex), Ď2 , Ď2 , r2 , X, ui0 i is in  Î´j , with v00 â Ď2 and vi0 = vi âr2 and v00 â Ď2 .  0  â  00  â˘ from hb, en, vi , v i âT hb, ex, vi , v i. By Lemma  00  0  â  1, we can write hen, v i âT hex, v i. By inductive  hypothesis, we have h(en, reg 0 )i ââA0 h(ex, reg 00 )i,  i  with v00 â reg 00 .  Since ex is reachable from en (locally in the component  machine A0i ) and there are a call and a return transitions  as above (in T ), by construction of R there is a summary  transition h(ui , regi ), Ď1 , (ui0 , regi0 )i â Î´j0 and the we can  write h(ui , regi )i âA0j h(ui0 , regi0 )i.  (â).  The proof is by induction on the index k of the transition  (k)  relations Î´j .  (0)  (Base case, k = 0). Immediate, by construction, since Î´j  0  â Î´j .  (Inductive step, k > 0). Let us suppose, by inductive hypothesis, that the property holds for the run that have all the  (k)  transitions in Î´j . Let ÎťA0j =h(u1 , reg1 )i ââA0 h(un , regn )i  j  (k+1)  be a run where at least one transition belongs to Î´j  \  (k)  Î´j . For all the transitions of the form h(ui , regi )i âA0j  h(ui+1 , regi+1 )i â ÎťA0j , with h(ui , regi ), Ď, (ui+1 , regi+1 i  (k)  â Î´j , by inductive hypothesis we can write hui , vi i ââT  hui+1 , vi+1 i, with vi â regi and vi+1 â regi+1 .  For all the transitions of the form h(ui , regi )i âA0j  h(ui+1 , regi+1 )i â ÎťA0j , with h(ui , regi ), Ď, (ui+1 , regi+1 i  (k+1)  â Î´j  â˘  â˘  (k)  (k+1)  \ Î´j , by construction of Î´j  we have that:  there is in T a call transition hui , Ď1 , Ď1 , r1 , â, (b, en)i  â Î´j , with Yj (b) = i, en â Eni and regi â Ďi . Taking  a clock valuation vi â regi , we have hui , vi i âT hb,  en, vi , vi âr1 i;  there is a sub-run h(en, regi âr1 )i ââ (k) h(ex, reg 0 )i  Ai  and then there is the sub-run h(en, regi âr1 )i ââA0  i  h(ex, reg 0 )i. By inductive hypothesis, we can write hen,  vi âr1 ââT hex, v0 i, with v0 â reg 0 . By Lemma 1, we  have that hb, en, vi , vi âr1 i ââT hb, ex, vi , v0 i;  â˘  there is in T the matching-return transition h(b, ex), Ď2 ,  Ď2 , r2 , X, ui+1 i â Î´j , with ex â Exj and reg 0 â Ď2  (then v0 â Ď2 ). Then, we can write hb, ex, vi , v0 i âT  hui+1 , vi âr2 i.  Combining the facts above, we have that hu1 , v1 i ââT  hun , vn i.  Now, we show that, for an untimed global state hb1 , . . .,  bs , ui of T , the global state hb1 , . . ., bs , u, v1 , . . ., vs ,  vi is reachable from an initial global state, for some clock  evaluations v1 , . . ., vs , v, iff the global state hb1 , . . ., bs ,  (u, reg)i of R is reachable from an initial global state of  R, for some region reg with v â reg.  Proof:  (â).  By induction on the lenght k of the run.  (Base case, k = 0). Immediate.  (Inductive step, k > 0). Let ÎťT = hen, v0 i ââT hb1 ,  . . ., bs , u, v1 , . . ., vs , vs+1 i, with u â Nj , be a run of  lenght k + 1. The (k + 1) â th transition can have one of  the following forms:  â˘  â˘  â˘  (progress transition): hb1 , . . ., bs , u, v1 , . . ., vs , v0 i  âT hb1 , . . ., bs , u, v1 , . . ., vs , vs+1 i, with vs+1 =  v0 + t for some t â DâĽ0 . By construction of R, there  is h(u, reg), Ď, (u, regs+1 )i â Î´j0 , with v0 â reg and  vs+1 â regs+1 (regs+1 is a time successor of reg). By  inductive hypothesis, we can write h(en, reg0 )i ââR  hb1 , . . ., bs , (u, reg)i. By the effect of the transition  above, we have hb1 , . . ., bs , (u, reg)i âR hb1 , . . ., bs ,  (u, regs+1 )i. Therefore, we can conclude h(en, reg0 )i  ââR hb1 , . . ., bs , (u, regs+1 )i;  (reset transition): hb1 , . . ., bs , u0 , v1 , . . ., vs , v0 i  âT hb1 , . . ., bs , u, v1 , . . ., vs , vs+1 i, with hu0 , Ď,  Ď, r, â, ui â Î´i , v0 â Ď, vs+1 = v0 âr and u0  â Nj . By construction of R, there is the transition  h(u0 , reg), Ď, (u, regs+1 )i â Î´j0 , with v0 â reg and  vs+1 â regs+1 (regs+1 = reg âr ). By inductive  hypothesis, we can write h(en, reg0 )i ââR hb1 , . . ., bs ,  (u0 , reg)i. By the effect of the transition above, we have  hb1 , . . ., bs , (u0 , reg)i âR hb1 , . . ., bs , (u, regs+1 )i.  Therefore, we can conclude h(en, reg0 )i ââR hb1 , . . .,  bs , (u, regs+1 )i;  (call transition): hb1 , . . ., bsâ1 , u0 , v1 , . . ., vsâ1 , vs i  âT hb1 , . . ., bs , u, v1 , . . ., vs , vs+1 i, with hu0 , Ď,  Ď, r, â, (bs , u)i â Î´i , Yi (bs ) = j, vs â Ď, vs+1 =  vs âr and u0 â Ni . By construction, there is in R  a call transition h(u0 , reg), Ď, (bs , (u, regs+1 ))i, with  vs â reg and vs+1 â regs+1 (regs+1 = reg âr ). By  inductive hypothesis, we can write h(en, reg0 )i ââR  hb1 , . . ., bsâ1 , (u0 , reg)i. By the effect of the transition  above, we have hb1 , . . ., bs , (u0 , reg)i âR hb1 , . . ., bs ,  (u, regs+1 )i. Therefore, we can conclude h(en, reg0 )i  ââR hb1 , . . ., bs , (u, regs+1 )i;  (return transition): if the (k + 1) â th transition is a  return transition, then we can split the run ÎťT in the  following way  1) a sub-run of lenght k 0 â¤ k in the form hen, v0 i  ââT hb1 , . . ., bs , u0 , v1 , . . ., vs , v0 i, with u0 â  Nj . By inductive hypothesis, we have h(en, reg0 )  ââR hb1 , . . ., bs , (u0 reg 0 )i, with v0 â reg0 and  v0 â reg 0 ;  2) hb1 , . . ., bs , u0 , v1 , . . ., vs , v0 i âT hb1 , . . ., bs+1 ,  en0 , v1 , . . ., vs , v0 , v00 i, where hu0 , Ď1 , Ď1 , r1 , â,  (bs+1 , en0 )i â Î´j is a call transition, Yj (bs+1 ) = i,  en0 â Eni , v0 â Ď1 and v00 = v0 âr1 . By construction of R, there is the transition h(u0 , reg 0 ),  Ď1 , (bs+1 , (en0 , reg 00 )i, with v0 â reg 0 , v00 â  reg 00 (reg 00 = reg 0 âr1 ) and (since for a clock  constraint Ď belongs to a transition in T , if v âź  =  v0 , then v â Ď iff v0 â Ď) reg 0 â Ď1 ;  3) hb1 , . . ., bs+1 , en0 , v1 , . . ., vs , v0 , v00 i ââT hb1 ,  . . ., bs+1 , ex0 , v1 , . . ., vs , v0 , v000 i, with ex0  â Exi . By Lemma 1, we have that hen0 , v00 i  ââT hex0 , v000 i. By Lemma 2, h(en0 , reg 00 )i ââA0  i  h(ex0 , reg 000 )i, with v000 â reg 000 , namely the exit  node (ex0 , reg 000 ) is reachable from the enter node  (en0 , reg 00 ) in the component A0i ;  4) hb1 , . . ., bs+1 , ex0 , v1 , . . ., vs , v0 , v000 i âT hb1 ,  . . ., bs , u, v1 , . . ., vs , vs+1 i, where h(bs+1 , ex0 ),  Ď2 , Ď2 , r2 , X, ui â Î´j is a return transition, v000  â Ď2 (then reg 000 â Ď2 ), vs+1 = v0 âr2 and vs+1  â regs+1 .  By construction of R, as a consequence of the  three points above, there exists a summary transition  h(u0 , reg 0 ), Ď1 , (u, regs+1 )i â Î´j0 . Combining this transition with the inductive hypothesis as above, we can  conclude h(en, reg0 )i ââR hb1 , . . ., bs , (u, regs+1 )i  (â).  The prove is by induction on the lenght k of the run.  (Base case, k = 0). Immediate.  (Inductive step, k âĽ 0). Let ÎťR = h(en, reg0 )i ââR hb1 ,  . . ., bs , (u, regs+1 )i be a run of lenght k + 1, with u â Ni .  The (k + 1) â th transition can have one of the following  forms:  â˘ hb1 , . . ., bs , (u, reg)i âR hb1 , . . ., bs , (u, regs+1 )i,  where h(u, reg), Ď, (u, reg)i â Î´i0 and regs+1 is a time  successor of reg. By construction of R, there exists in  L(T ) (LTS of T ) a progress transition hb1 , . . ., bs , u,  v1 , . . ., vs , v0 i âT hb1 , . . ., bs , u, v1 , . . ., vs , vs+1 i,  with vs+1 = v0 + t, t â Dâ¤0 , v0 â reg and vs+1 â  regs+1 . Combining the facts above with the inductive  hypothesis, we can conclude hen, v0 i ââT hb1 , . . ., bs ,  u, v1 , . . ., vs , vs+1 )i;  0  â˘ hb1 , . . ., bs , (u , reg)i âR hb1 , . . ., bs , (u, regs+1 )i,  0  where h(u , reg), Ď, (u, regs+1 )i â Î´i0 . By construction  of R, there exists in L(T ) a reset transition hb1 , . . .,  â˘  â˘  â˘  bs , u0 , v1 , . . ., vs , v0 i âT hb1 , . . ., bs , u, v1 , . . ., vs ,  vs+1 i, with hu0 , Ď, Ď, r, â, ui â Î´i , v0 â Ď, vs+1 =  v0 âr , v0 â reg and vs+1 â regs+1 and regs+1 =  reg âr . Combining the previous facts with the inductive  hypothesis, we can conclude hen, v0 i ââT hb1 , . . ., bs ,  u, v1 , . . ., vs , vs+1 )i;  hb1 , . . ., bsâ1 , (u0 , reg)i âR hb1 , . . ., bs , (u, regs+1 )i,  where h(u0 , reg), Ď, (bs , (u, regs+1 ))i is a call transition in Î´i0 . By construction of R, there exists in L(T ) a  call transition hb1 , . . ., bsâ1 , u0 , v1 , . . ., vsâ1 , vs i âT  hb1 , . . ., bs , u, v1 , . . ., vs , vs+1 i, with hu0 , Ď, Ď, r, â,  (bs , u)i â Î´i , vs â Ď, vs+1 = vs âr , vs â reg, vs+1 â  regs+1 , and regs+1 = reg âr . Combining the previous  fact with the inductive hypothesis, we can conclude  hen, v0 i ââT hb1 , . . ., bs , u, v1 , . . ., vs , vs+1 )i;  (summary transition): if the (k+1)âth transition is the  summary transition hb1 , . . ., bs , (u0 , reg)i âR hb1 , . . .,  bs , (u, regs+1 )i then the summary transition h(u0 , reg),  Ď1 , (u, regs+1 )i is in Î´i0 . By inductive hypothesis, we  have hen, v0 i ââT hb1 , . . ., bs , u0 , v1 , . . ., vs , vi,  with v â reg. By constraction of R, there exists a  call transition hu0 , Ď1 , Ď1 , r1 , â, (bs+1 , en0 )i â Î´i ,  with Yi (bs+1 ) = j and, therefore, the call transition  h(u0 , reg), Ď1 , (bs+1 , (en0 , reg 0 ))i â Î´i0 , with reg 0 =  reg âr1 and reg â Ď1 . In addition, since v â reg, v  â Ď1 and, therefore, the call transition hb1 , . . ., bs , u0 ,  v1 , . . ., vs , vi ââT hb1 , . . ., bs+1 , en0 , v1 , . . ., vs , v,  v0 i, with v0 = v âr1 , is in L(T ).  Again, by constraction of R, there exists the return  transition h(bs+1 , ex0 ), Ď2 , Ď2 , r2 , X, ui â Î´i , and  h(en0 , reg 0 )i ââA0 h(ex0 , reg 000 )i, with reg 000 â Ď2 . By  j  Lemma 2, we have hen0 , v0 i ââT hex0 , v000 i, with v0  â reg 0 and v000 â reg 000 . Since v000 â reg 000 and reg 000  â Ď2 , then v000 â Ď2 . By Lemma 1, we have hb1 , . . .,  bs+1 , en0 , v1 , . . ., vs , v, v0 i ââT hb1 , . . ., bs+1 , ex0 ,  v1 , . . ., vs , v, v000 i. Since v000 â Ď2 , then the following  transition hb1 , . . ., bs+1 , ex0 , v1 , . . ., vs , v, v000 i ââT  hb1 , . . ., bs , u, v1 , . . ., vs , vs+1 i, where vs+1 = v âr2  is in L(T ).  We can finally conclude hen, v0 i ââT hb1 , . . ., bs , u,  v1 , . . ., vs , vs+1 )i.  This end the proof.  As a consequence of Theorem 1, that estabilish an effective equivalence of TRSM and EPTA 2, and of Theorems 2  and 3, we can state the following expressiveness results.  Corollary 2: TRSM 1 (resp. EPTA 1) is a proper subclass of TRSM (resp. EPTA 2).  We conclude the section by considering the complexity  of the reachability problem, by showing that the problem  is PSPACE-complete for the subclass TRSM 0. Notice that,  the construction above shows that the reachability problem  for TRSM 1 can be solved using exponential space, since  the size of the region RSM R is exponential in the size of  the TRSM T . At the moment we have no results concerning  a strict lower bound for TRSM 1.  The idea underlying the construction for reachability in a  TRSM 0 T , is similar to the construction given above for  TRSM 1. In this case, however, we do not need to build  the region graph for T , as we can add summary transitions  directly to T . Indeed, any call transition in a TRSM 0  resets all the clocks when entering the invoked component.  Hence, the only relevant local reachability problem from an  enter to an exit node in the invoked component is the one  which assumes the clock valuation set to zero at the entry  node. This is the main difference with respect to TRSM 1,  where different clock valuations for the entry node have to  be considered, thus forcing to explicitly take into account  regions in the definition of a summary transition.  Since the number of summary transitions for TRSM 0  is clearly polynomial in the number of transitions of T ,  and local reachability in a component boils down to reachability in a Timed Automaton, which is known to be a  PSPACE-complete problem [2], we can construct, using only  polynomial space, a TRSM 0 T 0 equivalent to T from the  reachability viewpoint (see the complete work). This is done,  again, using a fix point construction, which builds a chain of  TRSM 0 T (0) , . . ., T (m) , with T (0) = T , and the transition  (k+1)  (k)  relation Î´i  (k âĽ 0) is Î´i augmented with summary  transitions as follows.  For every box b â Bi , with Yi (b) = j, for every entry node  en â Enj and for every return transition tex = h(b, ex), Ď2 ,  Ď2 , r2 , X, u2 i â Î´i , we first build the component machine  (k)  Aj âtex =hNj âŞ Bj âŞ {u0 }, Yj , Enj , {u0 }, Î´j0 i, where:  â˘  (k)  Î´j0 = Î´j  âŞ {hex, Ď2 , Ď2 , â, â, u0 i}, and u0 â  / Nj .  Notice that, for any clock valuation v, hen, v0 i ââ (k)  Aj âtex  hu0 , vi if and only if hen, v0 i ââAj hex, vi and v â Ď2 .  (k)  Therefore, local reachability of u0 in Aj âtex ensures both  (k)  that ex is locally reachable in Aj and that tex is enabled  at the exit node, since the constraint Ď2 , occurring in tex , is  satisfied by the reached clock valuation.  (k)  Then, if u0 is locally reachable from en in Aj âtex , then  for all call transition hu1 , Ď1 , Ď1 , X, â, (b, en)i â Î´i , the  (k+1)  summary transition hu1 , Ď1 , Ď1 , r2 , â, u2 i is added to Î´i  .  Once computed T 0 , the reachability problem for an untimed global state hb1 , . . ., bs , ui in T can be solved by  checking reachability of hb1 , . . ., bs , ui in T 0 , according to  the following procedure.  Let Ai0 , Ai1 , . . ., Ais be the sequence of the invoked  components, with i0 = 1 and Yijâ1 (bj ) = ij . We start by  guessing a sequence of entry nodes en0 , . . ., ens , with enj â  Enij . For each j âĽ 0, we then check whether (bj+1 , enj+1 )  is locally reachable from enj in the component Aij , where,  for the sake of local reachability, call transitions are treated  as reset transitions. Finally, we check whether u is locally  reachable from ens in the component Ais . If all the checks  are fulfilled, then reachability is ensured. Notice that each  local reachability check is a reachability analysis in a Timed  Automaton, which can be done using polynomial space.  Hence, we can conclude the following theorem:  Theorem 4: The reachability problem for TRSM 0 is  PSPACE-complete.  Proof:  Let us consider a TRSM 0 T  S = hA1 , . . ., An , Xi where,  for all 1 â¤ i â¤ n, Ai = hNi Bi , Yi , Eni , Exi , Î´i i. We  define an algorithm which enriched the transition relation  by adding summary transition. We that prove that, if T 0 is  the output of the below reported algorithm, then T 0 and T  are equivalent for reachability viewpoint. The algorithm for  augmentid T with summary transitions is the following:  REPEAT  summarized = FALSE  FOR ALL Ai  FOR ALL b â Bi  j = Yi (b)  FOR ALL en â Enj  FOR ALL tex = h(b, ex), Ď2 , Ď2 , r2 , X, u2 i â Î´i  Î´j0 = Î´j âŞ {hex, Ď2 , Ď2 , â, â, u2 i}  Aj âtex = hNj âŞ Bj âŞ {u0 }, Yj , Enj , {u0 }, Î´j0 i,  0  (u â  / Nj )  IF treach(Aj âtex , en, u0 )  summarized = TRUE  FOR ALL ten = hu1 , Ď1 , Ď1 , X, â, (b, en)i â  Î´i  Î´i = Î´i âŞ {hu1 , Ď1 , Ď1 , r2 , â, u2 i}  UNTIL ÂŹ summarized  In the algorithm, the function treach is the standard  procedure for the reachability problem for a Timed Automata: for instance, if exists a clock valuation v such  that the configuration hu0 , vi is reachable from the initial  configuration hen, v0 i in the Timed Automaton Aj âtex ,  then the output of treach(Aj âtex , en, u0 ) is T RU E; else  the output is F ALSE.  Let T a TRSM 0 and T 0 the TRSM 0 output of the  algorithm. In order to prove that T 0 is equivalent to T for  reachability, we need to show the following lemma.  Lemma 3: hu, vi ââT hu0 , v0 i, with u, u0 â Nj , iff hu,  vi ââA0 hu0 ,v0 i.  j  Proof:  (â).  The proof is by induction on nesting depth k of the run  ÎťT = hu1 , v1 i ââT hun , vn i.  (Base case, k = 0). In this case, every transition hui , vi i  âT hui+1 , vi+1 i in ÎťT , with 1 â¤ i â¤ n, can be only either  a progress or a reset transition:  â˘  (progress transition): we have that ui+1 = ui â Nj ,  vi+1 = vi + t, with t â DâĽ0 . By construction of A0j ,  there is a progress transition hui , vi )i âA0j hui ,vi+1 )i;  (reset transition): we have that vi+1 = vi âr1 , with hui ,  Ď1 , Ď1 , r1 , â, ui+1 i â Î´j and vi â Ď1 . By construction  of A0j , there is a reset transition hui ,vi i âA0j hui+1 ,  vi+1 i.  (Inductive step, k > 0). Let us suppose that the nesting  depth of the run hu1 , v1 i ââT hun , vn i is k + 1. The run  can have two kinds of sub-runs. The first one has the form  hui , vi i ââT hui0 , vi0 i, with nesting depth s â¤ k and 1 â¤  i < i0 â¤ n. All sub-runs of this form have, by inductive  hypothesis, the corresponding sub-runs hui , vi i ââA0 hui0 ,  j  vi0 i. The last one has the form hui , vi i ââT hui0 , vi0 i with  nesting depth k + 1 and 1 â¤ i < i0 â¤ n. It is possible to  split all sub-runs of this form in such a way that:  â˘ a call transition hui , vi i âT hb, en, vi , vi âr1 i, with  hui , Ď1 , Ď1 , r1 , â, (b, en)i â Î´j , Yj (b) = i, en â Eni  and vi â Ď1 . By construction of Î´j0 , hui , Ď1 , Ď1 , r1 , â,  (b, en)i â Î´j0 ;  â  â˘ a sub-run having the form hb, en, vi , vi âr1 i âT hb,  00  ex, vi , v i, with ex â Exi . By Lemma 1, we can write  hen, vi âr1 i ââT hex, v00 i, with nesting depth s = k.  By inductive hypothesis there is a corresponding subrun hen, vi âr1 i ââA0 hex, v00 i, with all transitions in  â˘  (k)  i  Î´i ;  00  â˘ a return transition tex = hb, ex, vi , v i âT hui0 , vi0 i,  with h(b, ex), Ď2 , Ď2 , r2 , X, ui+1 i â Î´j , vi0 = vi âr2  and v00 â Ď2 .  As a consequence of the facts above, by construction  (k)  of Ai  âtex = hNj âŞ Bj âŞ {u0 }, Yj , Enj , {u0 }, Î´i0 i,  since ex is reachable from en and v00 â Ď2 , we have  that u0 is reachable from en (since the valuation v00 in ex  satisfies the constraint Ď of the return transition tex ) and  then treach(Ai âtex , en, u0 ) = T RU E. By construction of  T 0 there is a summary transition hui , Ď1 , Ď1 , ui0 i â Î´j0 and  then we can write hui , vi i âA0j hui0 , vi0 i.  Combining the facts above, we have that hu1 , v1 i âT 0  hun , vn i.  (â).  (k)  The proof is by induction on the index k of Î´j .  (Base case, k = 0). If k = 0, there is no summary  (0)  transition in Î´j , and the property holds immediately.  (Inductive step, k > 0). Let hu1 , v1 i ââA0 hus , vs i be a  j  0  (k+1)  run with at least one transition belonging to Î´j  The run ÎťA0j can be split as follows:  â˘  (k)  .  for each sub-run hui , vi i ââA0 hui0 , vi0 i, with 1 â¤  j  â˘  0  \ Î´j  0  (k)  i < i0 â¤ s and all transitions in Î´j , by inductive  hypothesis we have that hui , vi i ââT hui0 , vi0 i;  for each summary transition hui , Ď1 , Ď1 , r, â, ui+1 i  0  (k+1)  â Î´j  , such that hui , vi i âA0j hui+1 , vi âr i, with  1 â¤ i < s, we have that:  â there is a call transition hui , Ď1 , Ď1 , X, â, (b, en)i  â Î´j , with Yj (b) = j 0 , such that vi â Ď1 ;  â there is a return transition tex = h(b, ex), Ď2 , Ď2 ,  r, X, ui+1 i â Î´j ;  â treach(Aj 0 âtex , en, u0 ) is T RU E, namely hen,  v0 i ââAj0 âtex hex, vi âAj0 âtex hu0 , vi, for some  clock valuation v such that v â Ď2 . By construction of Aj 0 âtex and by induction, we have that  hen, v0 i ââT hui+1 , vi âr i.  As a consequence of the facts above, we have that hu, vi  ââT hu0 , v0 i.  Now we can show that, for an untimed global state hb1 ,  . . ., bs , ui of T , the global state hb1 , . . ., bs , u, v1 , . . ., vs ,  vi is reachable, in T , from an initial global state, for some  clock evaluations v1 , . . ., vs , v, iff the global state hb1 , . . .,  bs , ui of T 0 is reachable from the initial global state of T 0 .  Proof:  (â).  The proof is by induction on the lenght of the run ÎťT =  hen, v0 i ââT hb1 , . . ., bs , u, v1 , . . ., vs , vs+1 i, with u â  Ni .  (Base case, k = 0). Immediate.  (Inductive step, k âĽ 0). Let ÎťT be a run of lenght k + 1.  The (k + 1) â th transition can have one of the following  forms:  â˘  â˘  â˘  â˘  (progress transition): hb1 , . . ., bs , u, v1 , . . ., vs , v0 i âT  hb1 , . . ., bs , u, v1 , . . ., vs , vs+1 i, with vs+1 = v0 + t,  t â DâĽ0 . By construction we have that hb1 , . . ., bs ,  u, v1 , . . ., vs , v0 i âT 0 hb1 , . . ., bs , u, v1 , . . ., vs ,  vs+1 i. Combining the previous fact with the inductive  hypothesis, we have hen, v0 i ââT 0 hb1 , . . ., bs , u, v1 ,  . . ., vs , vs+1 i;  (reset transition): hb1 , . . ., bs , u0 , v1 , . . ., vs , v0 i âT  hb1 , . . ., bs , u, v1 , . . ., vs , vs+1 i, with hu0 , Ď, Ď, r,  â, ui â Î´i , u0 â Ni , v0 â Ď and vs+1 = v0 âr . By  construction of T 0 , hu0 , Ď, Ď, r, â, ui â Î´i0 . Combining  this transition with the inductive hypothesis, we have  hen, v0 i ââT 0 hb1 , . . ., bs , u, v1 , . . ., vs , vs+1 i;  (call transition): hb1 , . . ., bsâ1 , u0 , v1 , . . ., vsâ1 , vs i  âT hb1 , . . ., bs , u, v1 , . . ., vs , vs+1 i, with hu0 , Ď, Ď,  X, â, (bs , u)i â Î´j , Yj (bs ) = i, u0 â Nj , vs â Ď and  vs+1 = vs âX = v0 . By construction of T 0 , hu0 , Ď, Ď,  X, â, (bs , u)i â Î´j0 . Combining this transition with the  inductive hypothesis, we have hen, v0 i ââT 0 hb1 , . . .,  bs , u, v1 , . . ., vs , vs+1 i;  (return transition): if the (k + 1) â th transition is a  return transition (tex0 ), then we can split the run ÎťT in  the following way:  1) a sub-run of lenght k 0 â¤ k in the form hen, v0 i  ââT hb1 , . . ., bs , u0 , v1 , . . ., vs , v0 i, with u0 â  Ni . By inductive hypothesis we can write hen,  v0 i ââT 0 hb1 , . . ., bs , u0 , v1 , . . ., vs , v0 i;  2) a matching call transition hb1 , . . ., bs , u0 , v1 , . . .,  vs , v0 i âT hb1 , . . ., bs , bs+1 , en0 , v1 , . . ., vs ,  v0 , v00 i, where hu0 , Ď1 , Ď1 , X, â, (bs+1 , en0 )i â  Î´i , Yi (bs+1 ) = j, en0 âEnj , v0 â Ď1 and v00 =  v0 âX = v0 ;  3) a sub-run hb1 , . . ., bs+1 , en0 , v1 , . . ., vs , v0 , v0 i  ââT hb1 , . . ., bs+1 , ex0 , v1 , . . ., vs , v0 , v000 i, with  ex0 â Exj . By Lemma 1 we have that hen0 , v0 i  ââT hex0 , v000 i and by Lemma 3 we have that  hen0 , v0 i ââAj ât 0 hex0 , v000 i;  ex  4) a return transition hb1 , . . ., bs+1 , ex0 , v1 , . . ., vs ,  v0 , v000 i ââT hb1 , . . ., bs , u, v1 , . . ., vs , vs+1 i,  where tex0 = h(bs+1 , ex0 ), Ď2 , Ď2 , r2 , X, ui â Î´i  is a return transition, v000 â Ď2 and vs+1 = v0 âr2 .  By construction of Aj âtex0 , hex, Ď2 , Ď2 , â, â, u00 i  â Î´j0 , with u00 â  / N . Since hen0 , v0 i ââAj ât 0  ex  0  000  hex , v i (see the point above) and v000 â Ď2 , we  can write hen0 , v0 i âAj ât 0 hu00 , v000 i. But this  ex  implies that treach(Aj âtex0 , en, u00 ) is T RU E.  As consequence of the facts above, we have that there  exists in T 0 a summary transition hu0 , Ď1 , Ď1 , r2 , â, ui, and  then, we can write hen, v0 i ââT 0 hb1 , . . ., bs , u, v1 , . . ., vs ,  vs+1 i.  (â).  The proof is by induction on the lenght of the run ÎťT 0 =  hen, v0 i ââT 0 hb1 , . . ., bs , u, v1 , . . ., vs , vs+1 i, with u â  Ni .  (Base case, k = 0). Immediate.  (Inductive step, k âĽ 0). Let ÎťT 0 = hen, v0 i ââT 0 hb1 ,  . . ., bs , u, v1 , . . ., vs , vs+1 i be a run of lenght k + 1. The  (k + 1) â th transition can have one of the following forms:  â˘  â˘  â˘  â˘  (progress transition): hb1 , . . ., bs , u, v1 , . . ., vs , v0 i  âT 0 hb1 , . . ., bs , u, v1 , . . ., vs , vs+1 i, with vs+1 =  v0 + t, t â DâĽ0 . By construction we have that hb1 , . . .,  bs , u, v1 , . . ., vs , v0 i âT hb1 , . . ., bs , u, v1 , . . ., vs ,  vs+1 i. Combining the previous fact with the inductive  hypothesis, we have hen, v0 i ââT hb1 , . . ., bs , u, v1 ,  . . ., vs , vs+1 i;  (reset transition): hb1 , . . ., bs , u0 , v1 , . . ., vs , v0 i âT 0  hb1 , . . ., bs , u, v1 , . . ., vs , vs+1 i, with hu0 , Ď, Ď, r,  â, ui â Î´i0 , u0 â Ni , v0 â Ď and vs+1 = v0 âr . By  construction of T 0 , hu0 , Ď, Ď, r, â, ui â Î´i . Combining  this transition with the inductive hypothesis, we have  hen, v0 i ââT hb1 , . . ., bs , u, v1 , . . ., vs , vs+1 i;  (call transition): hb1 , . . ., bsâ1 , u0 , v1 , . . ., vsâ1 , vs i  âT 0 hb1 , . . ., bs , u, v1 , . . ., vs , vs+1 i, with hu0 , Ď, Ď,  X, â, (bs , u)i â Î´j0 , Yj (bs ) = i, u0 â Nj , vs â Ď and  vs+1 = vs âX = v0 . By construction of T 0 , hu0 , Ď, Ď,  X, â, (bs , u)i â Î´j . Combining this transition with the  inductive hypothesis, we have hen, v0 i ââT hb1 , . . .,  bs , u, v1 , . . ., vs , vs+1 i;  (summary transition): if the (k + 1) â th transition is  a summary transition hb1 , . . ., bs , u0 , v1 , . . ., vs , v0 i  âT 0 hb1 , . . ., bs , u, v1 , . . ., vs , vs+1 i, where hu0 , Ď1 ,  Ď1 , r2 , â, ui â Î´i0 , u0 â Ni , v0 â Ď1 and vs+1 = v0 âr2 ,  then by construction of T 0 , we have that:  1) there is a call transition hu0 , Ď1 , Ď1 , X, â,  (bs+1 , en0 )i â Î´i0 , with Yi (bs+1 ) = j and en0 â  Enj . Since v0 â Ď1 (see above), we have that hb1 ,  . . ., bs , u0 , v1 , . . ., vs , v0 i âT hb1 , . . ., bs+1 , en0 ,  v1 , . . ., vs , v0 , v0 i;  2) treach(Aj âtex0 ) = T RU E, where Aj âtex0 =  hNj âŞ Bj âŞ {u00 }, Yj , Enj , {u00 }, Î´j0 i and  tex0 = h(bs+1 , ex0 ), Ď2 , Ď2 , r2 , â, ui â Î´i . But  treach(Aj âtex0 ) = T RU E implies that ex0 is  reachable from the configuration hen0 , v0 i with  some clock valuation v, with v â Ď2 . Then,  we can write hen0 , v0 i ââAj ât 0 hex0 , vi. By  ex  Lemma 3, we can write hen0 , v0 i ââT hex0 , vi.  By Lemma 1, we have that hb1 , . . ., bs+1 , en0 , v1 ,  . . ., vs v0 , v0 i ââT hb1 , . . ., bs+1 , en0 , v1 , . . .,  vs v0 , vi;  3) since v â Ď2 , we can write hb1 , . . ., bs+1 , ex0 ,  v1 , . . ., vs v0 , vi âT hb1 , . . ., bs , u, v1 , . . ., vs  vs+1 i, by the effect of the return transition tex0 ,  with vs+1 = v0 âr2 .  As a consequence, by applying the inductive hypothesis, we can write hen, v0 i ââT hb1 , . . ., bs , v1 , . . ., vs ,  vs+1 i.  Once computed T 0 , the reachability problem for an untimed global state hb1 , . . ., bs , ui in T can be solved by  checking reachability of hb1 , . . ., bs , ui in T 0 , according to  the following procedure.  Let Ai0 , Ai1 , . . ., Ais be the sequence of the invoked  components, with i0 = 1 and Yijâ1 (bj ) = ij . We start by  guessing a sequence of enter nodes en0 , . . ., ens , with enj â  Enij . For each j âĽ 0, we then check whether (bj+1 , enj+1 )  is locally reachable from enj in the component Aij , where,  for the sake of local reachability, call transitions are treated  as reset transitions. Finally, we check whether u is locally  reachable from ens in the component Ais . If all the checks  are fulfilled, then reachability is ensured. Notice that each  local reachability check is a reachability analysis in a Timed  Automaton, which can be done using polynomial space.  VI. C ONCLUSION  In this paper we have introduced TRSMs, a real time  extension of RSMs, able to model real time recursive  systems. We have shown that TRSMs allow to specify  interesting context-free properties, both on the untimed and  the timed dimensions. Though reachability of the general  framework is undecidable, we have shown that the problem  is still decidable for the meaningful classes TRSM 1 and  TRSM 0, and that it is PSPACE-complete for the class  TRSM 0, the same complexity of reachability in standard  Timed Automata.  A number of interesting issues are still to be investigated.  In particular, tight complexity results for the reachability  problem in TRSM 1 are yet to be established.  The paper focuses on the relationship with the most  related formalisms, namely PTAs and RSMs. On the other  hand, a comparison with other related formalisms need  to be settled. In particular, the undecidability proof for  EPTAs shows that they are able to simulate clock updates  (increment and decrement) similar to those provided by  Updatable Timed Automata [3]. Also the formalisms of  Stopwatch Automata [8] requires a comparison. It seems  that Stopwatch Automata can be simulated by the class  EPTA 2, while the opposite seems not to hold. Another  relevant issue concerns the study of the class of context-free  timed languages accepted by EPTAs and by their subclasses.  R EFERENCES  [1] Alur R., Benedikt, M., Etessami, K., Godefroid, P. Reps, T.  and Yannakakis, M.: Analysis of Recursive State Machines. In:  13th International Conference on Computer-aided Verification  (CAVâ01), pp. 207â220.  [2] Alur R., and Dill D. L.: A Theory of Timed Automata. In:  Theoretical Computer Science, Volume 126, pages 183â235,  1994.  [3] Bouyer P., Dufourd C., Fleury E. and Petit A.: Updatable timed  automata, Theoretical Computer Science, vol. 321, number 2â  3, pages 291â345, 2004.  [4] Dang Z.: Pushdown timed automata: a binary reachability characterization and safety verification. In: Theoretical Computer  Science, Volume 302 , Issue 1-3, pages 93â121, 2003.  [5] Minsky M. L.: Computation: finite and infinite machines,  Prentice-Hall Inc., Upper Saddle River, NJ, USA., 1967.  [6] Alur R., Parthasathy M.: Decision Problems for Timed Automata: A Survey. In: Proceedings of the 4th International  School on Formal Methods for the Design of Computer,  Communication and Software System: Real Time (SFM-RT  2004), pp. 1â24.  [7] Bouajjani A., Echahed R., Robbana R.: On the Automatic Verification of Systems with Continuous Variables and Unbounded  Discrete Data Structures. In: Proc. Hybrid System II, LNCS  999, 1995.  [8] Cassez F. and Larsen K.: The Impressive Power of Stopwatches. In Proc. of CONCUR 2000: Concurrency Theory, pp.  138â152, LNCS 1877, 2000. 