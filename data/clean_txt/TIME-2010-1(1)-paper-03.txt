Analysis of Timed Recursive State Machines  Massimo Benerecetti  UniversitaÄšÂ€ degli studi di Napoli  Federico II  Napoli, Italy  bene@na.infn.it  Stefano Minopoli  UniversitaÄšÂ€ degli studi di Napoli  Federico II  Napoli, Italy  minopoli@na.infn.it  AbstractÃ¢Â€Â”The paper proposes a temporal extension of Recursive State Machines (RSMs), called Timed RSMs (TRSMs).  A TRSM is an indexed collection of Timed Automata allowed to  invoke other Timed Automata (procedural calls). The classes  of TRSMs are related to an extension of Pushdown Timed  Automata, called EPTAs, where an additional stack, coupled  with the standard control stack, is used to store temporal  valuations of clocks. A number of subclasses of TRSMs and  EPTAs are considered and compared through bisimulation of  their timed LTSs. It is shown that EPTAs and TRSMs can be  used to recognize classes of timed languages exhibiting contextfree properties not only in the untimed Ã¢Â€ÂœcontrolÃ¢Â€Â part, but also  in the associated temporal dimension. The reachability problem  for both TRSMs and EPTAs is investigated, showing that the  problem is undecidable in the general case, but decidable for  meaningful subclasses. The complexity is stated for a TRSMs  subclass.  Keywords-Recursive State Machines; Timed Automata; Real  Time Systems; Context Free Languages.  I. I NTRODUCTION  The formalism of Recursive State Machines (RSMs) has  been introduced in [1] to model control flow in typical  sequential imperative programming languages with recursive procedure calls. A RSM is an indexed collection of  finite state machines (components). Components enhance  the power of ordinary state machines by allowing vertices  which correspond to invocations of other components in  a potentially recursive manner. As shown in [1], RSMs  are closely related to Pushdown Systems (PDSs). While  PDSs have been widely studied in the literature within  the field of program verification, RSMs seem to be more  appropriate for visual modeling. In the context of statetransition formalisms, Timed Automata (TA) [2] are the  reference framework to model real time systems. In this  paper we consider a real time extension of RSMs (Timed  RSMs or TRSMs), which allows to model real time recursive systems. Roughly speaking, a TRSM is an indexed  collection of Timed Automata, with the additional ability  of allowing states corresponding to invocations of other  timed components. All the timed components refer to a  1 Partially supported by Italian MIUR Project Ã¢Â€ÂœIntegrating automated  reasoning in model checking: towards push-button formal verification of  large-scale and infinite-state systems.Ã¢Â€Â  Adriano Peron  UniversitaÄšÂ€ degli studi di Napoli  Federico II  Napoli, Italy  peron@na.infn.it  common set of clocks used to constrain the behavior. Within  a timed component, the only explicit update of clocks is the  standard operation of clock reset. In addition, clock updates  occur when transitions, corresponding to invocations of other  components or returns from components, are performed. In  particular, at invocation time one can choose the subset of  clocks to reset, and at return time one can choose to restore  a subset of clocks to the values they had at invocation time.  The idea of extending formalisms which implicitly allow to  model recursive systems (e.g., PDSs) with real time features  has already been proposed in the literature (e.g., [7], [4]).  For instance, [4] proposes the formalism of Pushdown Timed  Automata (PTA), which are Timed Automata augmented  with a pushdown control stack. However, besides that fact  that TRSMs, similarly to RSMs, are more appropriate than  PTAs for visual modeling, it seems that PTAs are not  expressive enough to account for storing and restoring clock  values. Indeed, the control stack of PTAs allows to trace  the history of component invocation but cannot be exploited  to record the history of clock values stored at invocation  time and which are needed at the matching returns for  restoration. For instance, the store/restore of clock values in  correspondence of invocations and returns allows to model  in a very natural way a notion of time local to a component. In other words, TRSMs can manage an evolution of  time within a component, abstracting away the elapse of  time within the invoked components. Since the number of  recursive invocation can be unbounded, it seems that this  notion of local time cannot be modeled by PTAs without  an unbounded number of clocks. In the paper we also lift  to the timed setting the correspondence between RSMs and  PDSs, as stated in [1]. Since PTAs are not expressive enough  to account for TRSMs, we propose Extended PTAs, which  augment PTAs with an additional stack. The additional stack  is used to save/restore clock valuations. The two stacks are  independent, in the sense that the control stack is used to  save control symbols and the valuation stack is used only for  storing clock valuations. As a consequence, ETPAs, besides  the standard clock reset operations, also allows for store  and restore operations on clock valuations. We shall prove  that TRSMs are equivalent (via weak timed bisimulation)  to a syntactic restriction of EPTAs (i.e. : EPTA 2). It is  interesting to notice that EPTAs seem to be also a suitable  framework to study timed languages exhibiting contextfree properties both in the untimed Ã¢Â€ÂœcontrolÃ¢Â€Â part and in  the associated timestamps. For instance, we shall provide  an example of a context-free timed language with mirror  distribution of symbols and of temporal delays between  consecutive symbols.  The main technical contributions of the paper are decidability and complexity results for the reachability problem  in TRSMs and EPTAs. In particular, we show that the  problem is undecidable for the general classes of TRSMs  and EPTAs. However, decidability can be recovered by  forcing to restore all the clock values at return time. The  class of TRSMs satisfying this restriction is called TRSM 1.  The equivalent class of EPTAs, which can be characterized  with suitable syntactical restrictions, is denoted by EPTA 1.  The complexity of reachability is given for the subclass  TRSM 0 of TRSM 1, which further forces to reset all  the clock values at invocation time. For this class, the  reachability problem is shown to be PSPACE-complete, as  in classical TA. The paper also provides a comprehensive  picture of the expressive hierarchy and equivalence among  TRSMs and EPTAs.  The structure of the paper is as follows. Section 1 defines  syntax and the semantics of TRSMs. Section 2 introduces  syntax and semantics of EPTAs. Section 3 establishes the  correspondence between subclasses of TRSMs and EPTAs.  Section 4 is devoted to the decidability and complexity  analysis of the reachability problem for TRSMs and EPTAs.  II. T IMED R ECURSIVE S TATE M ACHINES  In this section we define syntax and semantics of TRSMs.  A TRSM is an indexed collection of Timed Automata,  with the additional ability of distinguishing ordinary states  (nodes) and states corresponding to invocation of other timed  components (boxes). We preliminary recall some standard  notions of Timed Automata.  A dense clock is a variable over a dense domain DÃ¢Â‰Ä½0  (as usual non negative reals RÃ¢Â‰Ä½0 or rationals QÃ¢Â‰Ä½0 ). A clock  valuation is a function v : X Ã¢Â†Â’ DÃ¢Â‰Ä½0 . For a set of clocks X,  the set of clock constraints C(X) is defined by the following  grammar:  ÄÂ•:=x Ã¢ÂˆÅº c | x Ã¢ÂˆÂ’ y Ã¢ÂˆÅº c | ÄÂ• Ã¢ÂˆÂ§ ÄÂ• | ÄÂ• Ã¢ÂˆÂ¨ ÄÂ•  where x, y Ã¢ÂˆÂˆ X, c Ã¢ÂˆÂˆ QÃ¢Â‰Ä½0 and Ã¢ÂˆÅº Ã¢ÂˆÂˆ {<, Ã¢Â‰Â¤, =, 6=, Ã¢Â‰Ä½, >}.  Following [2], we write v Ã¢ÂˆÂˆ ÄÂ• when the clock valuation  v satisfies the clock constraint ÄÂ• Ã¢ÂˆÂˆ C(X). The notion of  constraint satisfaction by a clock valuation is defined in the  standard way (e.g., see [2]). For t Ã¢ÂˆÂˆ DÃ¢Â‰Ä½0 , v+t denotes the  valuation v0 such that v 0 (x)=v(x) + t, for all x Ã¢ÂˆÂˆ X (clock  progress). Given r Ã¢ÂŠÂ† X, v Ã¢Â†Â“r denotes the valuation resulting  from the reset of the clocks in r, namely:  (  0 if i Ã¢ÂˆÂˆ r  (v Ã¢Â†Â“r )(i) =  v(i) otherwise.  Moreover, given the valuations v, v and a set r Ã¢ÂŠÂ† X, v Ã¢Â†Â‘(r,v)  denotes the valuation resulting from the update of the clocks  in r, according to v, namely:  (  v(i) if i Ã¢ÂˆÂˆ r  (v Ã¢Â†Â‘(r,v) )(i) =  v(i) otherwise.  We can now define Timed Recursive State Machines  (TRSMs). A TRSM is an indexed collection of components  which share a set of clocks X. The set of states of each  component is partitioned into a set of nodes and a set of  boxes. Boxes correspond to invocation and are associated  with an index of a component. There are four kinds of  transitions: (i) internal transitions connecting nodes of the  same component; (ii) call transitions which lead to a box  and an entry node of the called component; (iii) return  transitions which lead from a box and an exit node of the  callee to a node of the caller; (iv) return-and-call transitions  which combines a return and a call transitions. Transitions  are decorated with clock constraints as in TA. Internal  transitions can only reset clocks as in TA. Call transitions  can reset a subset of clocks at invocation time. Return  transitions can update a subset of clocks by restoring the  values they had at invocation time, and reset a possibily  different subset of clocks.  Definition 1: For an alphabet ÃÅ, a TRSM is a tuple hA1 ,  . . ., An , Xi where, for all 1 Ã¢Â‰Â¤ i Ã¢Â‰Â¤ n, Ai is a component  S  and X is a finite set of clocks. A component Ai is hNi Bi ,  Yi , Eni , Exi , ÃÂ´i i, where:  Ã¢Â€Ë˜ Ni and Bi are the disjoint sets of nodes and boxes,  respectively;  Ã¢Â€Ë˜ Yi : Bi Ã¢Â†Â’ {1,. . . , n} assigns to every box the index of  a component;  Ã¢Â€Ë˜ Eni Ã¢ÂŠÂ† Ni , Exi Ã¢ÂŠÂ† Ni are the sets of entry and exit  nodes, respectively;  Ã¢Â€Ë˜ ÃÂ´i  Ã¢ÂŠÂ† (Ni Ã¢ÂˆÅ Retnsi ) Ä‚Â— ÃÅ Ã¢ÂˆÅ {ÄÂ„ } Ä‚Â— C(X) Ä‚Â—  2X Ä‚Â— 2X Ä‚Â— (Ni Ã¢ÂˆÅ Callsi ) is the transition relation, where Callsi ={(b,en): b Ã¢ÂˆÂˆ Bi , en Ã¢ÂˆÂˆ EnYi (b) },  Retnsi ={(b,ex): b Ã¢ÂˆÂˆ Bi , ex Ã¢ÂˆÂˆ ExYi (b) }.  For each transition hu1 ,ÄÂƒ,ÄÂ•,r1 ,r2 ,u2 i Ã¢ÂˆÂˆ ÃÂ´i :  Ã¢Â€Â“ u1 (resp. : u2 ) are the source (resp. : target) of the  transition;  Ã¢Â€Â“ ÄÂƒ Ã¢ÂˆÂˆ ÃÅÃ¢ÂˆÅ{ÄÂ„ } is an input symbol or the silent action;  Ã¢Â€Â“ ÄÂ• Ã¢ÂˆÂˆ C(X) is a constraint over the clocks in X;  Ã¢Â€Â“ r1 (resp. : r2 ) is the subset of clocks to reset (resp. :  restore).  S  We  use  the  followingSabbreviations: N =  S  S i Ni , Calls =  Si Callsi , Retns = i Retnsi , En = i Eni and Ex =  i Exi . In order to avoid confusion with the empty stack  symbol, we use the symbol ÄÂ„ to represent the internal silent  action (usually called -transition). We assume that only  return and return-and-call transitions can have a non empty  set r2 of restored clocks.  A global state of a TRSM T =hA1 , . . ., An , Xi is a tuple  gs=hb1 , . . ., bs , u, v1 , . . ., vs , vi, where b1 , . . ., bs are  boxes, u is a node and v1 , . . ., vs , v are clock valuations.  Intuitively, b1 , . . ., bs represent the history of the invoked  components, v1 , . . ., vs are the corresponding valuations  stored at invocation time, u is the current node, and v is  the current clock valuation. A global state gs=hb1 , . . ., bs ,  u, v1 , . . ., vs , vi such that bi Ã¢ÂˆÂˆ Bji , for 1 Ã¢Â‰Â¤ i Ã¢Â‰Â¤ r and  u Ã¢ÂˆÂˆ Nj is well-formed if Yji (bi )=ji+1 for 1 Ã¢Â‰Â¤ i < r and  Yjs (bs )=j. The set of well-defined global states is denoted  by GS.  The semantics of a TRSM over the alphabet ÃÅ is given  by the timed Labelled Transition System (timed LTS) hGS,  Ã¢Â‰Ä½0  GS0 , ÃÅD  , Ã¢ÂˆÂ†i, where:  ÄÂ„  GS0 Ã¢ÂŠÂ† GS is the set of states of the form h, u, v0 i,  with u Ã¢ÂˆÂˆ En1 and v0 (x)=0, for all x Ã¢ÂˆÂˆ X;  S  S  D Ã¢Â‰Ä½0  Ã¢Â€Ë˜ ÃÅÄÂ„  is the set ÃÅ {ÄÂ„ } {ÄÂ„ (t)|t Ã¢ÂˆÂˆ DÃ¢Â‰Ä½0 }, where ÃÅ  and DÃ¢Â‰Ä½0 are disjoint;  D Ã¢Â‰Ä½0  Ä‚Â— GS is the transition relation. For  Ã¢Â€Ë˜ Ã¢ÂˆÂ† Ã¢ÂŠÂ† GS Ä‚Â— ÃÅÄÂ„  gs=hb1 , . . ., bs , u, v1 , . . ., vs , vi, with u Ã¢ÂˆÂˆ Nj and bs Ã¢ÂˆÂˆ  Bm , hgs,ÄÂƒ,gs0 i Ã¢ÂˆÂˆ Ã¢ÂˆÂ† whenever one of the following  holds:  1) progress transition: ÄÂƒ = ÄÂ„ (t) and gs0 = hb1 ,  . . ., bs , u, v1 , . . ., vs , v0 i, with v0 = v + t and  t Ã¢ÂˆÂˆ DÃ¢Â‰Ä½0 ;  2) reset transition: if hu,ÄÂƒ,ÄÂ•,r1 ,Ã¢ÂˆÂ…,u0 i Ã¢ÂˆÂˆ ÃÂ´j , with u0  Ã¢ÂˆÂˆ Nj , and v Ã¢ÂˆÂˆ ÄÂ•, then gs0 = hb1 , . . ., bs , u0 , v1 ,  . . ., vs , v0 i, with v0 = v Ã¢Â†Â“r1 ;  3) call transition: if hu,ÄÂƒ,ÄÂ•,r1 ,Ã¢ÂˆÂ…,(b0 ,en)i Ã¢ÂˆÂˆ ÃÂ´j , with  b0 Ã¢ÂˆÂˆ Bj , and v Ã¢ÂˆÂˆ ÄÂ•, then gs0 = hb1 , . . ., bs , b0 ,  en, v1 , . . ., vs , v, v0 i, with v0 = v Ã¢Â†Â“r1 ;  4) return transition: if h(bs , u),ÄÂƒ,ÄÂ•,r1 ,r2 ,u0 i Ã¢ÂˆÂˆ ÃÂ´m ,  with u0 Ã¢ÂˆÂˆ Nm , u Ã¢ÂˆÂˆ Exj , and v Ã¢ÂˆÂˆ ÄÂ•, then gs0 =  hb1 , . . ., bsÃ¢ÂˆÂ’1 , u0 , v1 , . . ., vsÃ¢ÂˆÂ’1 , v0 i, with v0 =  v Ã¢Â†Â‘(r2 ,vs )Ã¢Â†Â“r1 ;  5) return-and-call  transition:  if  h(bs ,  u),ÄÂƒ,ÄÂ•,r1 ,r2 ,(b0 , en)i Ã¢ÂˆÂˆ ÃÂ´m , with b0 Ã¢ÂˆÂˆ Bm ,  u Ã¢ÂˆÂˆ Exj and v Ã¢ÂˆÂˆ ÄÂ•, then gs0 = hb1 , . . ., bsÃ¢ÂˆÂ’1 , b0 ,  en, v1 , . . ., vsÃ¢ÂˆÂ’1 , vs0 , v0 i, with vs0 = v Ã¢Â†Â‘(r2 ,vs )  and v0 = vs0 Ã¢Â†Â“r1 .  A progress transition occurs when the control remains  in the same vertex and there is only a clock progress. A  reset transition occurs when there is an internal transition  inside a component, which can possibly reset a subset of  clocks. A call transition occurs when a box is entered and  a component is invoked. In this case the current clock  valuation is stored and a subset of clocks are possibly  reset. A return transition occurs when the control returns  to the invoking component. In this case, the valuation at  invocation time may be restored for that subset of clocks  Ã¢Â€Ë˜  specified in the restore set decorating the transition, the  constraint must be satisfied by the current clock valuation  and, finally, some clocks may be reset. A return-and-call  transition combines the effect of return and call in a single  step. Notice that the above timed LTS, besides symbols in  ÃÅ, also has symbols representing the elapse of time, and  satisfies the usual properties of temporal determinism, time  additivity and 0-delay as defined in [3].  A run ÃÅ¥T of T is a (possibly infinite) path in the LTS  Ã¢Â‰Ä½0  ÄÂƒ  hGS, GS0 , ÃÅÄÂ„D , Ã¢ÂˆÂ†i for T having the form ÃÅ¥T =gs0 Ã¢Â†Â’0  ÄÂƒi  ÄÂƒi  ÄÂƒ1  gs1 Ã¢Â†Â’ gs2 . . . gsi Ã¢Â†Â’ . . . , where gsi Ã¢Â†Â’ gsi+1 Ã¢ÂˆÂˆ Ã¢ÂˆÂ†, for all  i Ã¢Â‰Ä½ 0. It is an initial path, if gs0 Ã¢ÂˆÂˆ S0 . By ÃÂ›T we denote  the set of all paths of T . For any two gsi , gsj Ã¢ÂˆÂˆ GS, gsj  is reachable from gsi , written gsi Ã¢Â†Â’Ã¢ÂˆÂ— gsj , if there is a run  ÄÂƒjÃ¢ÂˆÂ’1  ÄÂƒi+1  ÄÂƒ  ÃÅ¥T =gsi Ã¢Â†Â’i gsi+1 Ã¢Â†Â’ gsi+2 . . . gsjÃ¢ÂˆÂ’1 Ã¢Â†Â’ gsj .  Notice that an RSM can be seen as a TRSM with an  empty set of clocks, and where the only clock constraint is  T rue. From the semantic point of view, the clock valuations  occurring in a global state are meaningless, and progress  transitions are omitted in the LTS.  Example 1: In Fig. 1 we show a TRSM whose behavior  is triggered by a timed sequence of symbols having the form  (a,t1 ). . . (a, tn )(b,tn+1 ) . . . (b,t2n ), such that Ã¢ÂˆÂ†2nÃ¢ÂˆÂ’i+1 +Ã¢ÂˆÂ†i Ã¢Â‰Â¤  k, with k a fixed constant value, and, taking t0 = 0, Ã¢ÂˆÂ†i =  ti Ã¢ÂˆÂ’tiÃ¢ÂˆÂ’1 . Notice that the untimed part of the sequence above  describes a context-free language (i.e., L={an bn : n Ã¢Â‰Ä½ 1}).  The TRSM consists of a single component, which may be  invoked recursively. The local behavior inside a component  consists of a transition triggered by a symbol a followed by  a symbol b. The transition triggered by b may be delayed  by a recursive invocation. The component uses the clocks x  and y: the first is reset at invocation time while the second  is reset when the symbol b occurs. Both clocks are restored  at return. The enforced requirement is, therefore, that the  local behavior is performed within time k, abstracting away  the time possibly spent by the recursive computation. It is  meaningful to observe that even though a PTA can model  invocations and returns by using its control stack, it could not  guarantee the temporal requirement above, since, in order to  check Ã¢ÂˆÂ†2nÃ¢ÂˆÂ’i+1 + Ã¢ÂˆÂ†i Ã¢Â‰Â¤ k, it would require an unbounded  number of clocks, one for each recursive call.  We introduce now two subclasses of TRSMs obtained by  suitably constraining the ability of resetting and restoring  clocks associated with transitions. These subclasses will be  compared in Sections 3 and 4 with respect to expressive  A  a, T rue, {x}, Ã¢Âˆ  b1 : A  ÄÂ„ , y = 0, Ã¢ÂˆÂ…, X  a, T rue, Ã¢ÂˆÂ…, Ã¢Âˆ  b, x Ã¢Â‰Â¤ k, {y}, Ã¢Âˆ  Figure 1.  An example of TRSM  b, x Ã¢Â‰Â¤ k, {y}, Ã¢Âˆ  power and decidability properties.  TRSM 1: the class of TRSMs, where return and returnand-call transitions are of the form h(b, ex), ÄÂƒ, ÄÂ•,  r1 , X, u2 i, with u2 Ã¢ÂˆÂˆ N Ã¢ÂˆÅ Calls (the whole set  of clocks is restored at every return);  TRSM 0: the class of TRSM 1, where call and returnand-call transitions are of the form hu1 , ÄÂƒ, ÄÂ•, X,  Ã¢ÂˆÂ…, (b, en)i and h(b0 ,ex), ÄÂƒ, ÄÂ•, X, X, (b, en)i,  respectively (the whole set of clocks is reset at  every call).  Unlike the general TRSMs class, where subsets of clock values can be restored, in the TRSM 1 and TRSM 0 subclasses  the entire set of clocks are restored at return time from the  invoked component. Therefore, the clock valuations at return  time are the same clock valuations at invocation time. This  allows to model in a very natural way a notion of time  local to a component, abstracting away the elapse of time  within an invoked component. In the TRSM 0 class this  abstraction is even stronger, because all clocks are reset at  invocation time. Notice that, despite the fact that TRSM 1  and TRSM 0 abstract away the time spent into the invoked  components, it does not seems possible to model them with  PTAs. Indeed, since the number of recursive invocation can  be unbounded, an unbounded number of clocks would be  necessary.  Notice that the TRSM of Example 1 belongs to the class  TRSM 0.  III. E XTENDED P USHDOWN T IMED AUTOMATA  In this section we introduce syntax and semantics of  Extended Pushdown Timed Automata (EPTAs). An EPTA  is a Pushdown Automaton enriched with a set of clocks  and with an additional stack used to store/restore clock  valuations. 1  Definition 2: An EPTA P over ÃÅ Ã¢ÂˆÅ {ÄÂ„ } is a tuple hQ,  q0 , X, ÃÂ“, T i, where:  Ã¢Â€Ë˜ Q is a finite set of states and q0 Ã¢ÂˆÂˆ Q is the initial state;  Ã¢Â€Ë˜ X is a finite set of clocks and ÃÂ“ is a finite stack  alphabet;  S S 2  Ã¢Â€Ë˜ T Ã¢ÂŠÂ† Q Ä‚Â— ÃÅ Ã¢ÂˆÅ {ÄÂ„ } Ä‚Â— ÃÂ“ Ã¢ÂˆÅ {} Ä‚Â— ({}  ÃÂ“ ÃÂ“ )Ä‚Â—  C(X) Ä‚Â— 2X Ä‚Â— Op Ä‚Â— Q is the transition relation, with  Op={Reset, Store, Restore}.  Intuitively, for each transition of the form hq1 , ÄÂƒ, ÃÅ‚1 , ÃÅ‚2 ,  ÄÂ•, r, op, q2 i Ã¢ÂˆÂˆ T , q1 (resp. : q2 ) is the source (resp. : the  target) state; ÄÂƒ is the input symbol; ÃÅ‚1 is the symbol on top  of the control stack ( denotes the empty stack); ÃÅ‚2 is the  string (of length at most 2) which replaces the symbol on  top of the control stack; ÄÂ• Ã¢ÂˆÂˆ C(X) is a clock constraint;  op is the operation requested on the set r of clocks. If op Ã¢ÂˆÂˆ  {Reset, Store}, then r indicates the set of clocks to reset. In  addition, if op = Store, the current clock valuation is stored  1 Actually an EPTA is a PTA (see [4]) for a syntactical definition where  the control stack is coupled with a second stack for the clock valuations.  on top of the valuation stack. If op = Restore, r indicates  the set of clocks to restore, using the clock valuation on top  of the valuation stack.  A configuration of an EPTA P is a tuple hq,v,w,di, where  q Ã¢ÂˆÂˆ Q is the current control state, v is the current clock  valuation, w Ã¢ÂˆÂˆ ÃÂ“Ã¢ÂˆÂ— is the content of the control stack, and d  Ã¢ÂˆÂˆ (X Ã¢Â†Â’ DÃ¢Â‰Ä½0 )Ã¢ÂˆÂ— is the content of the valuations stack. The  set of all configurations is denoted by GC.  The semantics of EPTAs is given by a timed LTS hGC,  Ã¢Â‰Ä½0  GC0 , ÃÅÄÂ„D , Ã¢ÂˆÂ†i, where:  Ã¢Â€Ë˜  Ã¢Â€Ë˜  GC0 is {hq0 ,v0 ,,i}, with v0 (x)= 0, for every x Ã¢ÂˆÂˆ X;  Ã¢Â‰Ä½0  Ã¢ÂˆÂ† Ã¢ÂŠÂ† GC Ä‚Â— ÃÅÄÂ„D Ä‚Â— GC is the transition relation. For  gc = hq,v,w,vs Ã‚Ë‡ di, hgc,ÄÂƒ,gc0 i Ã¢ÂˆÂˆ Ã¢ÂˆÂ† whenever one of  the following holds:  1) progress transition: ÄÂƒ = ÄÂ„ (t) and gc0 =  hq,v0 ,w,vs Ã‚Ë‡ di, with v0 = v + t and t Ã¢ÂˆÂˆ DÃ¢Â‰Ä½0 ;  2) reset transition: if hq, ÄÂƒ, a, ÃÅ‚, ÄÂ•, r, Reset, q 0 i  Ã¢ÂˆÂˆ T , with v Ã¢ÂˆÂˆ ÄÂ• and w = a Ã‚Ë‡ w00 , then gc0 =  hq 0 ,v0 ,ÃÅ‚w00 ,vs Ã‚Ë‡ di with v0 = v Ã¢Â†Â“r ;  3) store transition: if hq, ÄÂƒ, a, ÃÅ‚, ÄÂ•, r, Store, q 0 i  Ã¢ÂˆÂˆ T , with v Ã¢ÂˆÂˆ ÄÂ• and w = a Ã‚Ë‡ w00 , then gc0 =  hq 0 ,v0 ,ÃÅ‚w00 ,v Ã‚Ë‡ vs Ã‚Ë‡ di with v0 = v Ã¢Â†Â“r ;  4) restore transition: if hq, ÄÂƒ, a, ÃÅ‚, ÄÂ•, r, Restore,  q 0 i Ã¢ÂˆÂˆ T , with v Ã¢ÂˆÂˆ ÄÂ•, w = a Ã‚Ë‡ w00 , then gc0 =  hq 0 ,v0 ,ÃÅ‚w00 ,di, with v0 = v Ã¢Â†Â‘r,vs .  When a progress transition occurs, there is only a clock  progress; the control remains in the same state and the two  stacks are left unchanged. A reset transition pops a symbol  from the control stack, pushes a string of symbols on the  control stack, and resets a set of clocks, while the valuation  stack is left unchanged. A store transition behaves as a  reset transition, except that, in addition, it pushes the current  clock valuation on the valuation stack. A restore transition  pops a control symbol from the stack, pushes a string on  the control stack, and pops a valuation from the valuation  stack, restoring a subset of the clock values according to  the popped clock valuation. The notions of (initial) run and  reachability among pairs of states can be defined exactly  as in the case of TRSMs. ÃÂ›P denotes the set of runs and  gc Ã¢Â†Â’Ã¢ÂˆÂ—P gc0 denotes a pair of reachable states.  Example 2: In Fig. 2 we show an EPTA whose behavior  is triggered by a timed sequence of symbols having the  form: (a,t1 ). . . (a, tn )(b,tn+1 ). . . (b,t2n ) such that Ã¢ÂˆÂ†2nÃ¢ÂˆÂ’i =Ã¢ÂˆÂ†i ,  with Ã¢ÂˆÂ†i = ti+1 Ã¢ÂˆÂ’ ti . Notice that the untimed part of  the sequence above describes a context-free language (i.e.  L={an bn : n Ã¢Â‰Ä½ 1}). As for the timed part, the sequence is  required to satisfy a mirror distribution of the delays between  consecutive symbols. Notice that, the timed language above  exhibits a context-free property both in the untimed part  and in the temporal sequence of timestamps. This shows the  main difference with respect to PTAs ([4]) where there is  no mean to check context free properties on times.  As in the case of TRSMs, we introduce three subclasses  of EPTAs by suitably constraining the operations associated  with transitions. These subclasses will be naturally related  with the subclasses of the TRSMs defined in the previous  section. The restrictions tightly couple the type of operations  performed on the control stack and on the valuation stack.  EPTA 2 is the subclass of EPTAs where:  Ã¢Â€Ë˜ reset transitions have the form hq1 , ÄÂƒ, a1 , a2 ,  ÄÂ•, r, Reset, q2 i, with a1 Ã¢ÂˆÂˆ ÃÂ“ Ã¢ÂˆÅ {}, a2 Ã¢ÂˆÂˆ ÃÂ“  (only a swap on the top of the control stack is  allowed);  Ã¢Â€Ë˜ store transitions have the form hq1 , ÄÂƒ, a, ÃÅ‚, ÄÂ•,  r, Store, q2 i with a Ã¢ÂˆÂˆ ÃÂ“ Ã¢ÂˆÅ {} and ÃÅ‚ Ã¢ÂˆÂˆ ÃÂ“2  (only a swap followed by a push is allowed on  the control stack);  Ã¢Â€Ë˜ restore transitions have the form hq1 , ÄÂƒ, a, ,  ÄÂ•, r, Restore, q2 i, with a Ã¢ÂˆÂˆ ÃÂ“ (only a pop  operation is allowed on the control stack);  EPTA 1 is the subclass of EPTA 2 where:  Ã¢Â€Ë˜ restore transitions have the form hq1 , ÄÂƒ, a, ,  ÄÂ•, X, Restore, q2 i, with a Ã¢ÂˆÂˆ ÃÂ“ (the whole  set of clocks is restored);  EPTA 0 is the subclass of EPTA 1 where:  Ã¢Â€Ë˜ store transitions have the form hq1 , ÄÂƒ, a, ÃÅ‚, ÄÂ•,  X, Store, q2 i, with a Ã¢ÂˆÂˆ ÃÂ“ Ã¢ÂˆÅ {}, ÃÅ‚ Ã¢ÂˆÂˆ ÃÂ“2 (the  whole set of clocks is reset);  Notice that the EPTA of the Example 2 belongs to the class  EPTA 2.  IV. R ELATIONSHIP BETWEEN TRSM S AND EPTA S  In this section we investigate the relationship between  TRSMs and EPTAs and their subclasses. In order to show  such a correspondence, we shall use the standard notion of  (timed) weak bisimulation between timed LTS. The general  picture is reported in Table I.  For the definition of weak bisimilarity for timed LTSs we  follows the approach in [3]. Notice that bisimulation for  Timed LTS is a nontrivial generalization of the untimed case,  and requires some additional technicalities. Formally an LTS  L=hS,S0 ,ÃÅ, Ã¢ÂˆÂ†i simulates a transition system L0 =hS 0 ,S00 ,ÃÅ,  Ã¢ÂˆÂ†0 i if there exists a simulation relation Ã¢Â‰ÅŸÃ¢ÂŠÂ† S Ä‚Â— S 0 defined  as follows:  q0  a, , , T rue, {x}, Reset  b, , , T rue, {y}, Reset  q1  q2  a, , , T rue, {x}, Store  ÄÂ„ , , , (x = y) Ã¢ÂˆÂ§ (z = 0), {y}, Reset  q4  Figure 2.  b, , , T rue, {z}, Reset  ÄÂ„ , , , z = 0, {x}, Restore  An example of EPTA  q3  initialization: for all s0 Ã¢ÂˆÂˆ S0 , there is a s00 Ã¢ÂˆÂˆ S00 , with  s0 Ã¢Â‰ÅŸ s00 ;  ÄÂƒ  0  Ã¢Â€Ë˜ propagation: for all ÄÂƒ Ã¢ÂˆÂˆ ÃÅ, if s1 Ã¢Â‰ÅŸ s1 and s1 Ã¢Â†Â’ s2 ,  ÄÂƒ  then there exists s02 Ã¢ÂˆÂˆ S 0 such that s01 Ã¢Â†Â’ s02 and s2 Ã¢Â‰ÅŸ  s02 .  If the relation Ã¢Â‰ÅŸÃ¢ÂˆÂ’1 , defined as x Ã¢Â‰ÅŸÃ¢ÂˆÂ’1 y Ã¢Â‡Â” y Ã¢Â‰ÅŸ x, is  also a simulation relation, then Ã¢Â‰ÅŸ is a called a bisimulation  relation. Two LTSs L and L0 are strongly bisimilar, written  L Ã¢Â‰Ä„s L0 , if there is a bisimulation relation between L and  L0 .  In order to introduce a notion of weak bisimulation we  suitably transform a timed transition system by abstracting  sequences of ÄÂ„ -transitions. For a timed LTS L, a delay  ÄÂƒn  ÄÂƒ  ÄÂƒ  sn , such  execution is a run of the form s0 Ã¢Â†Â’1 s1 Ã¢Â†Â’2 s2 . . . Ã¢Â†Â’  that, for every 1 Ã¢Â‰Â¤ i Ã¢Â‰Â¤ n, either ÄÂƒi = ÄÂ„ or ÄÂƒi = ÄÂ„ (ti ), for  some ti Ã¢ÂˆÂˆ DÃ¢Â‰Ä½0 . The abstract transition system associated  Ã¢Â‰Ä½0  to L is Labs = hS, S0 , ÃÅÄÂ„D \ {ÄÂ„ }, Ã¢Â‡Â’i, where:  a  ÄÂ„ Ã¢ÂˆÂ— 00 a  0  00  Ã¢Â€Ë˜ s Ã¢Â‡Â’ s if a Ã¢ÂˆÂˆ ÃÅ and there exists s Ã¢ÂˆÂˆ S, s Ã¢Â†Â’ s Ã¢Â†Â’  s0 ;  ÄÂ„ (t) 0  ÄÂƒ1  Ã¢Â€Ë˜ s Ã¢Â‡Â’ s if there exists a delay execution s = s0 Ã¢Â†Â’ s1  P  ÄÂƒ2  ÄÂƒn  Ã¢Â†Â’ s2 . . . Ã¢Â†Â’ sn = s0 such that t = {ti | ÄÂƒi = ÄÂ„ (ti )}.  ÄÂ„ Ã¢ÂˆÂ—  The relation Ã¢Â†Â’ denotes the reflexive and transitive  ÄÂ„  closure of Ã¢Â†Â’. The transition system Labs abstracts all the  ÄÂ„ (0)  ÄÂ„ Ã¢ÂˆÂ—  silent actions of L. The relation Ã¢Â†Â’ thus corresponds to Ã¢Â‡Â’ .  a  Notice also that the relation Ã¢Â‡Â’ only abstracts silent actions  that can be done before a. Of course, if L is the timed LTS  of a TRSM or of a EPTA without silent actions, then L and  Labs are identical.  Two LTS L and L0 are weakly bisimilar, written L Ã¢Â‰Ä„w L0 ,  if there exists a bisimulation relation between Labs and L0abs .  The following theorem shows the tight corresponding  between TRSMs and EPTAs and their subclasses.  Theorem 1: For any TRSM (resp. : TRSM 1, TRSM 0)  T , there exists a weakly similar EPTA 2 (resp. : EPTA 1,  EPTA 0) P and vice versa.  Proof:  We first show the bisimulation relation between TRSM  and EPTA 2.  Given a TRSM T =hA1 , . . ., An , Xi over an alphabet  ÃÅ, we first S  give the construction of an EPTA 2 P over the  alphabet ÃÅ {ÄÂ„ } that is weakly bisimilar to a T . (The idea  of the construction is similar to the one presented in [1] to  encode RSMs into pushdown systems).  S In the following we  assume that Ai has the form hNi Bi , Yi , Eni , Exi , ÃÂ´i i.  P=hQ, q0 , X Ã¢ÂˆÅ {x0 }, ÃÂ“, T i, is defined as follows:  (k)  Ã¢Â€Ë˜ Q={q0 } Ã¢ÂˆÅ {q(i,u) | 1 Ã¢Â‰Â¤ i Ã¢Â‰Â¤ nex , 1 Ã¢Â‰Â¤ k Ã¢Â‰Â¤ kmax and  u Ã¢ÂˆÂˆ N Ã¢ÂˆÅ Calls}, where nex is the greatest number of  Ã¢Â€Ë˜  Table I  E XPRESSIVENESS RELATIONS AMONG TRSM S AND EPTA S .  EPTA 0  Ã¢Â‰Ä„w  TRSM 0  Ã¢ÂŠÂ†  Ã¢ÂŠÂ†  EPTA 1  Ã¢Â‰Ä„w  TRSM 1  Ã¢ÂŠÂ‚  Ã¢ÂŠÂ‚  EPTA 2  Ã¢Â‰Ä„w  TRSM  Ã¢ÂŠÂ†  EPTA  Ã¢Â€Ë˜  Ã¢Â€Ë˜  exit nodes of all component machines and kmax is the  greatest number of return transitions exiting from every  ex Ã¢ÂˆÂˆ Ex;  S  ÃÂ“={(j,u) | 1 Ã¢Â‰Â¤ j Ã¢Â‰Â¤ n, u Ã¢ÂˆÂˆ Nj  Bj }. A pair (j,u)  gives the index of a component and the current box or  node in the component;  T is defined as follows:  Ã¢Â€Â“ for every pair (j,exi )Ã¢ÂˆÂˆ ÃÂ“ with exi Ã¢ÂˆÂˆ Exj , hq0 , ÄÂ„ ,  (j,exi ), (j,exi ), T rue, {x0 }, Reset, q0 i Ã¢ÂˆÂˆ T ;  Ã¢Â€Â“ for every reset transition of the form hu, ÄÂƒ, ÄÂ•, r1 , Ã¢ÂˆÂ…,  u0 i Ã¢ÂˆÂˆ ÃÂ´j , where u Ã¢ÂˆÂˆ  / Retns and u0 Ã¢ÂˆÂˆ  / Calls, there  is a transition hq0 , ÄÂƒ, (j,u), (j,u0 ), ÄÂ•, r1 , Reset,  q0 i Ã¢ÂˆÂˆ T ;  Ã¢Â€Â“ for every call transition hu, ÄÂƒ, ÄÂ•, r1 , Ã¢ÂˆÂ…, (b, en)i  Ã¢ÂˆÂˆ ÃÂ´j where u Ã¢ÂˆÂˆ  / Retns, b Ã¢ÂˆÂˆ Bj , Yj (b)=j 0 and  en Ã¢ÂˆÂˆ Enj 0 , there is a transition hq0 , ÄÂƒ, (j,u),  (j 0 ,en)Ã‚Ë‡(j,b), ÄÂ•, r1 , Store, q0 i Ã¢ÂˆÂˆ T ;  Ã¢Â€Â“ if h(b,exi ), ÄÂƒk , ÄÂ•k , r1k , r2k , ui Ã¢ÂˆÂˆ ÃÂ´j is the kth return transition from the exit node exi , with  u Ã¢ÂˆÂˆ Nj , Yj (b)=j 0 , then there are the following  transitions:  1) hq0 , ÄÂƒk , (j 0 ,exi ),, ÄÂ•k Ã¢ÂˆÂ§(x0 = 0), r2k , Restore,  (k)  q(i,u) i Ã¢ÂˆÂˆ T ;  (k)  2) hq(i,u) , ÄÂ„ , (j,b), (j,u), x0 = 0, r1k , Reset, q0 i Ã¢ÂˆÂˆ  T;  Ã¢Â€Â“ if h(b,exi ), ÄÂƒk , ÄÂ•k , r1k , r2k , (b0 ,en)i Ã¢ÂˆÂˆ ÃÂ´j is the  k-th return-and-call transition from the exit node  exi , with Yj (b)=j 0 and Yj (b0 )=j 00 , then there are  the following transitions:  1) hq0 , ÄÂƒk , (j 0 ,exi ),, ÄÂ•k Ã¢ÂˆÂ§(x0 = 0), r2k , Restore,  (k)  q(i,(b0 ,en)) i Ã¢ÂˆÂˆ T ;  (k)  2) hq(i,(b0 ,en)) , ÄÂ„ , (j,b),(j 00 ,en)Ã‚Ë‡(j,b0 ), x0 = 0, r1k ,  Store, q0 i Ã¢ÂˆÂˆ T .  The weak bisimulation relation Ã¢Â‰ÅŸ between LT and LP is  defined as follows. For gs Ã¢ÂˆÂˆ GS and gc Ã¢ÂˆÂˆ GC, gs Ã¢Â‰ÅŸ gc if  and only if one of the following holds:  1) gs = hb1 , . . ., bs , u, v1 , . . ., vs , vs+1 i and gc =  hq0 , vs+1 , (j, u)(js , bs ). . . (j1 ,b1 ), vs . . . v1 i, where  vk (x) = vk (x) for all x Ã¢ÂˆÂˆ X and 1 Ã¢Â‰Â¤ k Ã¢Â‰Â¤ s + 1;  2) gs = hb1 , . . ., bs , u, v1 , . . ., vs , vs+1 i and gc =  (n)  hq(i,u) , vs+1 , (js+1 , bs+1 ). . . (j1 ,b1 ), vs . . . v1 i, with  vk (x) = vk (x), for all x Ã¢ÂˆÂˆ X and 1 Ã¢Â‰Â¤ k Ã¢Â‰Â¤ s, and  vs+1 (x) = vs+1 (x) for all x Ã¢ÂˆÂˆ X \ r1n , where r1n  is the set of clocks reset by the n-th return transition  from (bs+1 , exi ) to u and vs+1 (x0 ) = 0;  3) gs = hb1 , . . ., bs , u, v1 , . . ., vs , vs+1 i, with u Ã¢ÂˆÂˆ  En and vs+1 = vs Ã¢Â†Â“r1 n , where r1n is the set of  clocks reset by the n-th return-and-call transition from  (n)  (bs0 , exi ) to (bs , u) and gc = hq(i,(bs ,u)) , vs , (js0 ,  bs0 ). . . (j1 ,b1 ), vsÃ¢ÂˆÂ’1 . . . v1 i, with vk (x) = vk (x), for  all x Ã¢ÂˆÂˆ X and 1 Ã¢Â‰Â¤ k Ã¢Â‰Â¤ s.  We show now that Ã¢Â‰ÅŸ is a bisimulation.  Let us consider the initialization requirement. An initial  state of T has the form gs0 =hen, , v0 i, with en Ã¢ÂˆÂˆ En1 .  The initial state of P has the form gc0 =hq0 , v0 , (1,en), i.  By definition of Ã¢Â‰ÅŸ, it is immediate to show that gs0 Ã¢Â‰ÅŸ gc0  and gc0 Ã¢Â‰ÅŸÃ¢ÂˆÂ’1 gs0 .  Let us consider now the propagation requirement. Let us  assume that gs Ã¢Â‰ÅŸ gc. There are the following cases:  Ã¢Â€Ë˜ Let gs = hb1 , . . ., bs , u, v1 , . . ., vs , vs+1 i be a  global state and gc = hq0 , vs+1 , (j, u)(js , bs ). . . (j1 ,b1 ),  vs . . . v1 i, where vk (x) = vk (x) for all x Ã¢ÂˆÂˆ X and  1 Ã¢Â‰Â¤ k Ã¢Â‰Â¤ s + 1, be a configuration. By definition, gs Ã¢Â‰ÅŸ  gs. Now we show all the possible transitions in Labs (T )  having gs as source:  t  Ã¢Â€Â“ (progress transition): gs Ã¢Â‡Â’ gs0 , for some t Ã¢ÂˆÂˆ  Ã¢Â‰Ä½0  0  D , where gs = hb1 , . . ., bs , u, v1 , . . ., vs ,  vs+1 +ti. Then there exists in Labs (P) the progress  t  transition gc Ã¢Â‡Â’ gc0 , where gc0 = hq0 , vs+1 + t,  (j,u)(js ,bs ). . . (j1 ,b1 ), vs . . . v1 i. By definition, gs0  Ã¢Â‰ÅŸ gc0 ;  ÄÂƒ  Ã¢Â€Â“ (reset transition): gs Ã¢Â‡Â’ gs0 , where gs0 = hb1 , . . .,  bs , u0 , v1 , . . ., vs , vs+1 Ã¢Â†Â“r i, hu, ÄÂƒ, ÄÂ•, r, Ã¢ÂˆÂ…, u0 i  Ã¢ÂˆÂˆ ÃÂ´j and vs+1 Ã¢ÂˆÂˆ ÄÂ•. Then there exists in Labs (P)  ÄÂƒ  the transition gc Ã¢Â‡Â’ gc0 , where gc0 = hq0 , vs+1 Ã¢Â†Â“r ,  (j,u0 )(js ,bs ). . . (j1 ,b1 ), vs . . . v1 i and hq0 , ÄÂƒ, (j,u),  (j,u0 ), ÄÂ•, r, Reset, q 0 i Ã¢ÂˆÂˆ T . By definition, gs0 Ã¢Â‰ÅŸ  gc0 ;  ÄÂƒ  Ã¢Â€Â“ (call transition): gs Ã¢Â‡Â’ gs0 , where gs0 = hb1 , . . .,  bs , bs+1 , en, v1 , . . ., vs+1 , vs+1 Ã¢Â†Â“r1 i, hu, ÄÂƒ, ÄÂ•, r1 ,  Ã¢ÂˆÂ…,(bs+1 , en)i Ã¢ÂˆÂˆ ÃÂ´j and vs+1 Ã¢ÂˆÂˆ ÄÂ•. Then there exists  ÄÂƒ  in Labs (P) the transition gc Ã¢Â‡Â’ gc0 , where gc0 =  hq0 , vs+1 Ã¢Â†Â“r1 , (j 0 , en)(js+1 ,bs+1 ) . . . (j1 ,b1 ),  vs+1 . . . v1 i and hq0 , ÄÂƒ, (j,u), (j 0 ,en)Ã‚Ë‡(js+1 ,bs+1 ),  ÄÂ•, r1 , Store, q0 i Ã¢ÂˆÂˆ T . By definition, gs0 Ã¢Â‰ÅŸ gc0 ;  ÄÂƒn  Ã¢Â€Â“ (return transition): gs Ã¢Â‡Â’  gs0 , where gs0 = hb1 ,  0  . . ., bsÃ¢ÂˆÂ’1 , u , v1 , . . ., vsÃ¢ÂˆÂ’1 , (vs+1 Ã¢Â†Â‘(r2n ,vs ) ) Ã¢Â†Â“r1n i,  h(bs , u), ÄÂƒn , ÄÂ•n , r1n , r2n , u0 i Ã¢ÂˆÂˆ ÃÂ´j is the k Ã¢ÂˆÂ’ th  return transition from u (u=exi ) to u0 and vs+1  Ã¢ÂˆÂˆ ÄÂ•. Then there exists in Labs (P) the transition  ÄÂƒn  (n)  gc Ã¢Â‡Â’  gc0 , where gc0 = hq(i,u0 ) , vs+1 Ã¢Â†Â‘(r2n ,vs ) ,  (js ,bs ). . . (j1 ,b1 ), vsÃ¢ÂˆÂ’1 . . . v1 i and hq0 , ÄÂƒn , (j,exi ),  (n)  , ÄÂ•n Ã¢ÂˆÂ§ (x0 = 0), r2n , Restore, q(i,u0 ) i in T . By  0  0  definition, gs Ã¢Â‰ÅŸ gc ;  ÄÂƒ  Ã¢Â€Â“ (return-and-call transition): gs Ã¢Â‡Â’ gs0 , where  0  gs = hb1 , . . ., bsÃ¢ÂˆÂ’1 , bs+1 , en, v1 , . . ., vs ,  vs+1 Ã¢Â†Â‘(r2n ,vs ) ,vs+1 Ã¢Â†Â‘(r2n ,vs ) Ã¢Â†Â“r1n i, h(bs , u), ÄÂƒn ,  ÄÂ•n , r1n , r2n , (bs+1 ,en)i Ã¢ÂˆÂˆ ÃÂ´j is the n Ã¢ÂˆÂ’ th  return-and-call transition from (bs , u) (u = exi )  to (bs+1 , en) and vs+1 Ã¢ÂˆÂˆ ÄÂ•. Then there exists in  ÄÂƒn  Labs (P) the transition gc Ã¢Â‡Â’  gc0 , where gc0 =  (n)  hq(i,(bs+1 ,en) , vs+1 Ã¢Â†Â‘(r2n ,vs ) , (js ,bs ). . . (j1 ,b1 ),  vsÃ¢ÂˆÂ’1 . . . v1 i and hq0 , ÄÂƒn , (j,exi ),, ÄÂ•n Ã¢ÂˆÂ§ (x0 = 0),  (n)  r2n , Res!tore, q(i,(bs+1 ,en) i in T . By definition,  gs0 Ã¢Â‰ÅŸ gc0 .  ÄÂƒ  Now we show all the possible transitions in Labs (P)  having gc as source:  t  Ã¢Â€Â“ (progress transition): gc Ã¢Â‡Â’ gc0 , for some t Ã¢ÂˆÂˆ DÃ¢Â‰Ä½0 ,  where gc0 = hq0 , vs+1 + t, (j,u)(js ,bs ). . . (j1 ,b1 ),  vs . . . v1 i. Then there exists in Labs (T ) the  t  progress transition gs Ã¢Â‡Â’ gs0 , where gs0 = hb1 ,  . . ., bs , u, v1 , . . ., vs , vs+1 + ti. By definition, gc0  Ã¢Â‰ÅŸÃ¢ÂˆÂ’1 gs0 ;  ÄÂƒ  Ã¢Â€Â“ (reset transition): gc Ã¢Â‡Â’ gc0 , where gc0 = hq0 ,  vs+1 Ã¢Â†Â“r , (j,u0 )(js ,bs ). . . (j1 ,b1 ), vs . . . v1 i, hq0 , ÄÂƒ,  (j,u),(j,u0 ),ÄÂ•,r,Reset,q 0 i Ã¢ÂˆÂˆ T and vs+1 Ã¢ÂˆÂˆ ÄÂ•. Then  ÄÂƒ  there exists Labs (T ) the transition gs Ã¢Â‡Â’ gs0 , where  gs0 = hb1 , . . ., bs , u0 , v1 , . . ., vs , vs+1 Ã¢Â†Â“r i and  hu, ÄÂƒ, ÄÂ•, r, Ã¢ÂˆÂ…, u0 i Ã¢ÂˆÂˆ ÃÂ´j . By definition, gc0 Ã¢Â‰ÅŸÃ¢ÂˆÂ’1  gs0 ;  ÄÂƒ  Ã¢Â€Â“ (store transition): gc Ã¢Â‡Â’ gc0 , where gc0 =  hq0 , vs+1 Ã¢Â†Â“r1 , (j 0 , en) (js+1 ,bs+1 ) . . . (j1 ,b1 ),  vs+1 . . . v1 i, hq0 , ÄÂƒ, (j,u), (j 0 ,en)Ã‚Ë‡(js+1 ,bs+1 ), ÄÂ•,  r1 , Store, q0 i Ã¢ÂˆÂˆ T and vs+1 Ã¢ÂˆÂˆ ÄÂ•. Then there  ÄÂƒ  exists in Labs (T ) the transition gs Ã¢Â‡Â’ gs0 , where  gs0 = hb1 , . . ., bs , bs+1 , en, v1 , . . ., vs+1 ,  vs+1 Ã¢Â†Â“r1 i and hu, ÄÂƒ, ÄÂ•, r1 , Ã¢ÂˆÂ…,(bs+1 , en)i Ã¢ÂˆÂˆ ÃÂ´j .  By definition, gc0 Ã¢Â‰ÅŸÃ¢ÂˆÂ’1 gs0 ;  ÄÂƒn  (n)  Ã¢Â€Â“ (restore transition): gc Ã¢Â‡Â’  gc0 , where gc0 = hq(i,u0 ) ,  vs+1 Ã¢Â†Â‘(r2n ,vs ) , (js ,bs ) . . . (j1 ,b1 ), vsÃ¢ÂˆÂ’1 . . . v1 i,  hq0 , ÄÂƒn , (j,exi ),, ÄÂ•n Ã¢ÂˆÂ§ (x0 = 0), r2n , Restore,  (n)  q(i,u0 ) i in T and vs+1 Ã¢ÂˆÂˆ ÄÂ•. Then there exists in  ÄÂƒn  Labs (T ) the transition gs Ã¢Â‡Â’  gs0 , where gs0 = hb1 ,  0  . . ., bsÃ¢ÂˆÂ’1 , u , v1 , . . ., vsÃ¢ÂˆÂ’1 , (vs+1 Ã¢Â†Â‘(r2n ,vs ) ) Ã¢Â†Â“r1n i  and h(bs , u), ÄÂƒn , ÄÂ•n , r1n , r2n , u0 i Ã¢ÂˆÂˆ ÃÂ´j is the  k Ã¢ÂˆÂ’ th return transition from u (u=exi ) to u0 . By  definition, gc0 Ã¢Â‰ÅŸÃ¢ÂˆÂ’1 gs0 ;  ÄÂ„ [t]  Ã¢Â€Â“ (progress with ÄÂ„ ): gc Ã¢Â‡Â’ gc0 (possible only when  u=exi Ã¢ÂˆÂˆ Exj ), abstracting the ÄÂ„ transition hq0 ,  ÄÂ„ , (j,exi ), (j,exi ), T rue, {x0 }, Reset, q0 i Ã¢ÂˆÂˆ T  and the clock progress of t Ã¢ÂˆÂˆ DÃ¢Â‰Ä½0 units of time.  The resulting configuration is gc0 = hq0 ,vs+1 Ã¢Â†Â“{x0 }  +t,(j,exi ). . . (j1 ,b1 ),vsÃ¢ÂˆÂ’1 . . . v1 i. Then there exists  t  in Labs (T ) the transition gs Ã¢Â‡Â’ gs0 , where gs0 =  hb1 , . . ., bs , u, v1 , . . ., vs , vs+1 +ti. By definition,  gc0 Ã¢Â‰ÅŸÃ¢ÂˆÂ’1 gs0 ;  ÄÂƒn  Ã¢Â€Â“ (restore with ÄÂ„ ): gc Ã¢Â‡Â’  gc0 (possible only when  u=exi Ã¢ÂˆÂˆ Exj ), abstracting the following transitions:  Ã¢ÂˆÂ— hq0 , ÄÂ„ , (j,exi ), (j,exi ), T rue, {x0 }, Reset,  q0 i Ã¢ÂˆÂˆ T ;  Ã¢ÂˆÂ— hq0 , ÄÂƒn , (j,exi ),, ÄÂ•n Ã¢ÂˆÂ§ x0 = 0, r2n , Restore,  (n)  q(i,u0 i in T .  n  The resulting configuration is gc0 = hq(i,u  0),  vs+1  Ã¢Â†Â“{x0 } Ã¢Â†Â‘(r2n ,vs ) , (js ,bs ) . . . (j1 ,b1 ),  vsÃ¢ÂˆÂ’1 . . . v1 i, with vs Ã¢ÂˆÂˆ ÄÂ•n Ã¢ÂˆÂ§ x0 = 0 and  u0 Ã¢ÂˆÂˆ N Ã¢ÂˆÅ Calls. Then there exists in Labs (T )  Ã¢Â€Ë˜  n  gs0 , where gs0 = hb1 , . . .,  the transition gs Ã¢Â‡Â’  bsÃ¢ÂˆÂ’1 , u0 , v1 , . . ., vsÃ¢ÂˆÂ’1 , vs+1 Ã¢Â†Â‘(r2n ,vs ) Ã¢Â†Â“r1n i and  h(bs , exi ), ÄÂƒn , ÄÂ•n , r1n , r2n , u0 i Ã¢ÂˆÂˆ ÃÂ´j is the  k Ã¢ÂˆÂ’ th return (or return-and-call) transition from  u (u=exi ) to u0 . By definition, gc0 Ã¢Â‰ÅŸÃ¢ÂˆÂ’1 gs0 .  Let gs = hb1 , . . ., bs , u, v1 , . . ., vs , vs+1 i be a global  (n)  state and gc = hq(i,u) , vs+1 , (js+1 , bs+1 ). . . (j1 ,b1 ),  vs . . . v1 i, with vk (x) = vk (x), for all x Ã¢ÂˆÂˆ X and  1 Ã¢Â‰Â¤ k Ã¢Â‰Â¤ s, and vs+1 (x) = vs+1 (x) for all x Ã¢ÂˆÂˆ X \  r1n , where r1n is the set of clocks reset by the n-th  return transition from (bs+1 , exi ) to u and vs+1 (x0 ) =  0. By definition, gs Ã¢Â‰ÅŸ gs. Now we show all the possible  transitions in Labs (T ) having gs as source:  t  Ã¢Â€Â“ (progress transition): gs Ã¢Â‡Â’ gs0 , for some t Ã¢ÂˆÂˆ DÃ¢Â‰Ä½0 ,  where gs0 = hb1 , . . ., bs , u, v1 , . . ., vs , vs+1 + ti.  ÄÂ„ [t]  Then there exists in Labs (P) the transition gc Ã¢Â‡Â’  gc0 , abstracting the following transitions:  (n)  1) hq(i,u) , ÄÂ„ , (js+1 ,bs+1 ), (j,u), x0 = 0, r1n ,  Reset, q0 i and  2) the progress transition in q0 of an amount of t  units of time.  The resulting configuration is gc0 = hq0 ,  (vs+1 Ã¢Â†Â“r1n ) + t, (j,u)Ã‚Ë‡ (js ,bs ) . . . (j1 ,b1 ), vs . . .  v1 i. By definition, gs0 Ã¢Â‰ÅŸ gc0 ;  ÄÂƒ  Ã¢Â€Â“ (reset transition): gs Ã¢Â‡Â’ gs0 , where gs0 = hb1 , . . .,  bs , u0 , v1 , . . ., vs , vs+1 Ã¢Â†Â“r i, hu, ÄÂƒ, ÄÂ•, r, Ã¢ÂˆÂ…, u0 i  in ÃÂ´j and vs Ã¢ÂˆÂˆ ÄÂ•. Then there exists in Labs (P)  ÄÂƒ  the transition gc Ã¢Â‡Â’ gc0 , abstracting the following  transitions:  (n)  1) hq(i,u) , ÄÂ„ , (js+1 ,bs+1 ), (j,u),x0 = 0, r1n ,  Reset, q0 i;  2) hq0 , ÄÂƒ, (j,u),(j,u0 ),ÄÂ•,r,Reset,q 0 i  The resulting configuration is gc0 = hq0 ,  (vs+1 Ã¢Â†Â“r1n ) Ã¢Â†Â“r , (j,u0 )Ã‚Ë‡(js ,bs ) . . . (j1 ,b1 ), vs . . .  v1 i. By definition, gs0 Ã¢Â‰ÅŸ gc0 ;  ÄÂƒ  Ã¢Â€Â“ (call transition): gs Ã¢Â‡Â’ gs0 , where gs0 = hb1 , . . .,  bs+1 , en, v1 , . . ., vs+1 , vs+1 Ã¢Â†Â“r1n i and hu, ÄÂƒ,  ÄÂ•, r, Ã¢ÂˆÂ…, (bs+1 , en)i Ã¢ÂˆÂˆ ÃÂ´j and vs Ã¢ÂˆÂˆ ÄÂ•. Then there  ÄÂƒ  exists in P the transition gc Ã¢Â‡Â’ gc0 , abstracting the  following transitions:  (n)  Ã¢ÂˆÂ— hq(i,u) , ÄÂ„ , (js ,bs ), (j,u), x0 = 0, r1n , Reset,  q0 i Ã¢ÂˆÂˆ T ;  Ã¢ÂˆÂ— hq0 , ÄÂƒ, (j,u),(j 0 , en) Ã‚Ë‡ (js+1 , bs+1 ), ÄÂ•, r, Store,  q0 i in T .  The resulting configuration is gc0 = hq0 ,  vs+1 Ã¢Â†Â“{x0 }Ã¢ÂˆÅr , (j 0 , en) Ã‚Ë‡ (js+1 , bs+1 ) . . . (j1 , b1 ),  vs . . . v1 i. By definition, gs0 Ã¢Â‰ÅŸ gc0 .  ÄÂƒ  Ã¢Â€Â“ (return transition): gs Ã¢Â‡Â’k gs0 , where gs0 = hb1 ,  . . ., bsÃ¢ÂˆÂ’1 , u0 , v1 , . . ., vsÃ¢ÂˆÂ’1 , vs+1 Ã¢Â†Â‘(r2k ,vs ) Ã¢Â†Â“r1k i,  h(bs , u), ÄÂƒk , ÄÂ•k , r1k , r2k , u0 i in ÃÂ´j and vs+1 Ã¢ÂˆÂˆ  ÄÂ•k . Then there exists in Labs (P) the transition gc  ÄÂƒ  Ã¢Â‡Â’ gc0 , abstracting the following transitions:  (n)  Ã¢ÂˆÂ— hq0 , ÄÂƒ, (j,u),(j 0 , en) Ã‚Ë‡ (js+1 , bs+1 ), ÄÂ•, r, Store,  q0 i in T .  The resulting configuration is gc0 = hq0 ,  vs+1 Ã¢Â†Â“{x0 }Ã¢ÂˆÅr ,(j 0 , en) Ã‚Ë‡ (js+1 , bs+1 ) . . . (j1 , b1 ), vs  . . . v1 i, with vs+1 Ã¢Â†Â“{x0 } Ã¢ÂˆÂˆ ÄÂ•. Then there exists in  ÄÂƒ  P the transition gs Ã¢Â‡Â’ gs0 , where gs0 = hb1 , . . .,  bs+1 , en, v1 , . . ., vs+1 , vs+1 Ã¢Â†Â“r1n i and hu, ÄÂƒ, ÄÂ•,  r, Ã¢ÂˆÂ…, (bs+1 , en)i Ã¢ÂˆÂˆ ÃÂ´j . By definition, gc0 Ã¢Â‰ÅŸÃ¢ÂˆÂ’1 gs0 ;  ÄÂƒ  Ã¢Â€Â“ (restore transition with ÄÂ„ ): gc Ã¢Â‡Â’ gc0 , abstracting  the following transitions:  (n)  1) hq(i,u) , ÄÂ„ , (js+1 ,bs+1 ), (j,u), x0 = 0, r1n ,  Reset, q0 i;  2) hq0 , ÄÂ„ , (j,u), (j,u), T rue, {x0 }, Reset, q0 i;  3) hq0 , ÄÂƒk , (j,u), , ÄÂ•k Ã¢ÂˆÂ§ (x0 = 0), r2k , Restore,  (k)  q(i,u0 ) i  1) hq(i,u) , ÄÂ„ , (js+1 ,bs+1 ), (j,u), x0 = 0, r1n ,  Reset, q0 i;  2) hq0 , ÄÂ„ , (j,u), (j,u), T rue, {x0 }, Reset, q0 i;  3) hq0 , ÄÂƒk , (j,u), , ÄÂ•k Ã¢ÂˆÂ§ (x0 = 0), r2k , Restore,  (k)  q(i,u0 ) i  (k)  The resulting configuration is gc0 = hq(i,u0 ) ,  vs+1 Ã¢Â†Â“r1n Ã¢ÂˆÅ{x0 }Ã¢ÂˆÅr1n , (js ,bs ) . . . (j1 ,b1 ), vs . . . v1 i.  By definition, gs0 Ã¢Â‰ÅŸ gc0 .  ÄÂƒ  Ã¢Â€Â“ (return-and-call transition): gs Ã¢Â‡Â’k gs0 , where gs0 =  hb1 , . . ., bsÃ¢ÂˆÂ’1 , bs0 , en, v1 , . . ., vsÃ¢ÂˆÂ’1 , vs+1 ,  vs+1 Ã¢Â†Â‘(r2k ,vs ) Ã¢Â†Â“r1k i, h(bs , u), ÄÂƒk , ÄÂ•k , r1k , r2k ,  (bs0 , en)i in ÃÂ´j and vs+1 Ã¢ÂˆÂˆ ÄÂ•k . Then there exists  ÄÂƒ  in Labs (P) the transition gc Ã¢Â‡Â’ gc0 , abstracting the  following transitions:  (n)  1) hq(i,u) , ÄÂ„ , (js , bs ), (j,u), x0 = 0, r1n , Reset,  q0 i;  2) hq0 , ÄÂƒ, (j, u), (j 0 , u0 ) Ã‚Ë‡ (js0 , bs0 ), ÄÂ•, r, Store,  q0 i  The resulting configuration is gc0 = hq0 ,  vs+1 Ã¢Â†Â“r1n Ã¢ÂˆÅr1k , (js0 , bs0 ) Ã‚Ë‡ (js , bs ) . . . (j1 , b1 ), vs+1  . . . v1 i. By definition, gs0 Ã¢Â‰ÅŸ gc0 .  Now we show all the possible transitions in Labs (P)  having gc as source:  ÄÂ„ [t]  Ã¢Â€Â“ (progress transition with ÄÂ„ ): gc Ã¢Â‡Â’ gc0 , abstracting  the following transitions:  (n)  1) hq(i,u) , ÄÂ„ , (js+1 ,bs+1 ), (j,u), x0 = 0, r1n ,  Reset, q0 i and  2) the progress transition in q0 of an amount of t  units of time.  The resulting configuration is gc0 = hq0 ,  (vs+1 Ã¢Â†Â“r1n ) + t, (j, u) Ã‚Ë‡ (js , bs ) . . . (j1 , b1 ), vs . . .  v1 i. By definition, gs0 Ã¢Â‰ÅŸ gc0 . Then there exists  t  in Labs (T ) the transition gs Ã¢Â‡Â’ gs0 , for some t  Ã¢Â‰Ä½0  0  Ã¢ÂˆÂˆ D , where gs = hb1 , . . ., bs , u, v1 , . . ., vs ,  vs+1 + ti. By definition, gc0 Ã¢Â‰ÅŸÃ¢ÂˆÂ’1 gs0 ;  ÄÂƒ  Ã¢Â€Â“ (reset transition with ÄÂ„ ): gc Ã¢Â‡Â’ gc0 , abstracting the  following transitions:  (n)  1) hq(i,u) , ÄÂ„ , (js+1 ,bs+1 ), (j,u),x0 = 0, r1n ,  Reset, q0 i;  2) hq0 , ÄÂƒ, (j,u),(j,u0 ),ÄÂ•,r,Reset,q 0 i  The resulting configuration is gc0 = hq0 ,  (vs+1 Ã¢Â†Â“r1n ) Ã¢Â†Â“r , (j, u0 ) Ã‚Ë‡ (js , bs ) . . . (j1 , b1 ), vs  . . . v1 i, with vs+1 Ã¢Â†Â“r1n Ã¢ÂˆÂˆ ÄÂ•. By definition, gs0 Ã¢Â‰ÅŸ  gc0 . Then there exists in Labs (T ) the transition gs  ÄÂƒ  Ã¢Â‡Â’ gs0 , where gs0 = hb1 , . . ., bs , u0 , v1 , . . ., vs ,  vs+1 Ã¢Â†Â“r i, hu, ÄÂƒ, ÄÂ•, r, Ã¢ÂˆÂ…, u0 i in ÃÂ´j . By definition,  gc0 Ã¢Â‰ÅŸÃ¢ÂˆÂ’1 gs0 ;  ÄÂƒ  Ã¢Â€Â“ (store transition with ÄÂ„ ): gc Ã¢Â‡Â’ gc0 , abstracting the  following transitions:  (n)  Ã¢ÂˆÂ— hq(i,u) , ÄÂ„ , (js ,bs ), (j,u), x0 = 0, r1n , Reset,  q0 i Ã¢ÂˆÂˆ T ;  (k)  Ã¢Â€Ë˜  The resulting configuration is gc0 = hq(i,u0 ) ,  vs+1 Ã¢Â†Â“r1n Ã¢ÂˆÅ{x0 } Ã¢Â†Â‘(r2k ,vs ) , (js , bs ) . . . (j1 , b1 ),  vs . . . v1 i, with vs+1 Ã¢Â†Â“r1n Ã¢ÂˆÅ{x0 } Ã¢ÂˆÂˆ ÄÂ•k . Then  ÄÂƒ  there exists in Labs (P) the transition gs Ã¢Â‡Â’k gs0 ,  0  0  where gs = hb1 , . . ., bsÃ¢ÂˆÂ’1 , u , v1 , . . ., vsÃ¢ÂˆÂ’1 ,  vs+1 Ã¢Â†Â‘(r2k ,vs ) Ã¢Â†Â“r1k i, h(bs , u), ÄÂƒk , ÄÂ•k , r1k , r2k , u0 i  in ÃÂ´j and vs+1 Ã¢ÂˆÂˆ ÄÂ•k . By definition, gc0 Ã¢Â‰ÅŸÃ¢ÂˆÂ’1 gs0 ;  Let gs = hb1 , . . ., bs , u, v1 , . . ., vs , vs+1 i, with u Ã¢ÂˆÂˆ En  and vs+1 = vs Ã¢Â†Â“r1 n , where r1n is the set of clocks reset  by the n-th return-and-call transition from (bs0 , exi ) to  (n)  (bs , u), a global state and gc = hq(i,(bs ,u)) , vs , (js0 ,  bs0 ). . . (j1 ,b1 ), vsÃ¢ÂˆÂ’1 . . . v1 i, with vk (x) = vk (x), for  all x Ã¢ÂˆÂˆ X and 1 Ã¢Â‰Â¤ k Ã¢Â‰Â¤ s. By definition, gs Ã¢Â‰ÅŸ gc. Now  we show all the possible transitions in Labs (T ) having  gs as source:  t  Ã¢Â€Â“ (progress transition): gs Ã¢Â‡Â’ gs0 , for some t Ã¢ÂˆÂˆ DÃ¢Â‰Ä½0 ,  where gs0 = hb1 , . . ., bs , u, v1 , . . ., vs , vs+1 + ti.  ÄÂ„ [t]  Then there exists in Labs (P) the transition gc Ã¢Â‡Â’  gc0 , abstracting the following transitions:  (n)  1) hq(i,(bs ,u) , ÄÂ„ , (js0 , bs0 ), (j, u) Ã‚Ë‡ (js , bs ), x0 = 0,  r1n , Store, q0 i and  2) the progress transition in q0 of an amount of t  units of time.  The resulting configuration is gc0 = hq0 , vs Ã¢Â†Â“r1n  +t, (j,u)(js ,bs ). . . (j1 ,b1 ), vs . . . v1 i. By definition,  gs0 Ã¢Â‰ÅŸ gc0 ;  ÄÂƒ  Ã¢Â€Â“ (reset transition): gs Ã¢Â‡Â’ gs0 , where gs0 = hb1 , . . .,  bs , u0 , v1 , . . ., vs , vs+1 Ã¢Â†Â“r i, hu, ÄÂƒ, ÄÂ•, r, Ã¢ÂˆÂ…, u0 i  in ÃÂ´j and vs+1 Ã¢ÂˆÂˆ ÄÂ•. Then there exists in Labs (P)  ÄÂƒ  the transition gc Ã¢Â‡Â’ gc0 , abstracting the following  transitions:  (n)  1) hq(i,(bs ,u)) , ÄÂ„ , (js0 , bs0 ), (j, u) Ã‚Ë‡ (js , bs ), x0 = 0,  r1n , Store, q0 i;  2) hq0 , ÄÂƒ, (j,u),(j,u0 ),ÄÂ•,r,Reset,q 0 i  The resulting configuration is gc0 = hq0 ,  vs+1 Ã¢Â†Â“r1n Ã¢Â†Â“r , (j,u0 )(js ,bs ). . . (j1 ,b1 ), vs . . . v1 i. By  definition, gs0 Ã¢Â‰ÅŸ gc0 ;  ÄÂƒ  Ã¢Â€Â“ (call transition): gs Ã¢Â‡Â’ gs0 , where gs0 = hb1 , . . .,  bs+1 , en, v1 , . . ., vs , vs+1 , vs+1 Ã¢Â†Â“r i, hu, ÄÂƒ, ÄÂ•,  r, Ã¢ÂˆÂ…, (bs+1 , en)i Ã¢ÂˆÂˆ ÃÂ´j and vs+1 Ã¢ÂˆÂˆ ÄÂ•. Then there  ÄÂƒ  exists in P the transition gc Ã¢Â‡Â’ gc0 , abstracting the  following transitions:  (n)  Ã¢ÂˆÂ— hq(i,(bs ,u)) , ÄÂ„ , (js0 , bs0 ), (j, u) Ã‚Ë‡ (js , bs ), x0 = 0,  r1n , Store, q0 i Ã¢ÂˆÂˆ T ;  Ã¢ÂˆÂ— hq0 , ÄÂƒ, (j,u),(j 0 , en) Ã‚Ë‡ (js+1 , bs+1 ), ÄÂ•, r, Store,  q0 i in T .  The resulting configuration is gc0 = hq0 ,  vs Ã¢Â†Â“r1n Ã¢Â†Â“r , (j 0 , en) Ã‚Ë‡ (js+1 , bs+1 ) . . . (j1 , b1 ),  vs . . . v1 i. By definition, gs0 Ã¢Â‰ÅŸ gc0 .  Now we show all the possible transitions in Labs (P)  having gc as source:  ÄÂ„ [t]  Ã¢Â€Â“ (progress transition): gc Ã¢Â‡Â’ gc0 , abstracting the  following transitions:  (n)  1) hq(i,(bs ,u) , ÄÂ„ , (js0 , bs0 ), (j, u) Ã‚Ë‡ (js , bs ), x0 = 0,  r1n , Store, q0 i and  2) the progress transition in q0 of an amount of t  units of time.  The resulting configuration is gc0 = hq0 , vs Ã¢Â†Â“r1n  +t, (j,u)(js ,bs ). . . (j1 ,b1 ), vs . . . v1 i. By definition,  gs0 Ã¢Â‰ÅŸ gc0 . Then there exists in Labs (T ) the trant  sition gc Ã¢Â‡Â’ gc0 , where gs0 = hb1 , . . ., bs , u, v1 ,  . . ., vs , vs+1 + ti. By definition, gc0 Ã¢Â‰ÅŸÃ¢ÂˆÂ’1 gs0 ;  ÄÂƒ  Ã¢Â€Â“ (reset transition): gc Ã¢Â‡Â’ gc0 , abstracting the following transitions:  (n)  1) hq(i,(bs ,u)) , ÄÂ„ , (js0 , bs0 ), (j, u) Ã‚Ë‡ (js , bs ), x0 = 0,  r1n , Store, q0 i;  2) hq0 , ÄÂƒ, (j,u),(j,u0 ),ÄÂ•,r,Reset,q 0 i  The resulting configuration is gc0 = hq0 ,  vs+1 Ã¢Â†Â“r1n Ã¢Â†Â“r , (j,u0 )(js ,bs ). . . (j1 ,b1 ), vs . . . v1 i,  with vs+1 Ã¢ÂˆÂˆ ÄÂ•. Then there exists in Labs (T ) the  ÄÂƒ  transition gs Ã¢Â‡Â’ gs0 , where gs0 = hb1 , . . ., bs , u0 ,  v1 , . . ., vs , vs+1 Ã¢Â†Â“r i, hu, ÄÂƒ, ÄÂ•, r, Ã¢ÂˆÂ…, u0 i in ÃÂ´j and  vs+1 Ã¢ÂˆÂˆ ÄÂ•. By definition, gc0 Ã¢Â‰ÅŸÃ¢ÂˆÂ’1 gs0 ;  ÄÂƒ  Ã¢Â€Â“ (call transition): gc Ã¢Â‡Â’ gc0 , abstracting the following transitions:  (n)  Ã¢ÂˆÂ— hq(i,(bs ,u)) , ÄÂ„ , (js0 , bs0 ), (j, u) Ã‚Ë‡ (js , bs ), x0 = 0,  r1n , Store, q0 i Ã¢ÂˆÂˆ T ;  Ã¢ÂˆÂ— hq0 , ÄÂƒ, (j,u),(j 0 , en) Ã‚Ë‡ (js+1 , bs+1 ), ÄÂ•, r, Store,  q0 i in T .  The resulting configuration is gc0 = hq0 ,  vs Ã¢Â†Â“r1n Ã¢Â†Â“r , (j 0 , en) Ã‚Ë‡ (js+1 , bs+1 ) . . . (j1 , b1 ),  vs . . . v1 i, with vs Ã¢Â†Â“r1n Ã¢ÂˆÂˆ ÄÂ•. Then there exists in  ÄÂƒ  Labs (T ) the transition gs Ã¢Â‡Â’ gs0 , where gs0 = hb1 ,  . . ., bs+1 , en, v1 , . . ., vs , vs+1 , vs+1 Ã¢Â†Â“r i, hu, ÄÂƒ, ÄÂ•,  r, Ã¢ÂˆÂ…, (bs+1 , en)i Ã¢ÂˆÂˆ ÃÂ´j and vs+1 Ã¢ÂˆÂˆ ÄÂ•. By definition,  gc0 Ã¢Â‰ÅŸÃ¢ÂˆÂ’1 gs0 .  Given the EPTA 2 P = hQ, q0 , X, ÃÂ“, T i over the  alphabet ÃÅ, we define the TRSM T = hA1 , Xi over the  alphabet ÃÅ Ã¢ÂˆÅ {ÄÂ„ } (with ÄÂ„ Ã¢ÂˆÂˆ  / ÃÅ. For every pair (q,a) with  q Ã¢ÂˆÂˆ Q and a Ã¢ÂˆÂˆ ÃÂ“, the component A1 has an entries node  en(q,a) and an exit node ex(q,a) . There is a box ba for each  stack symbol a Ã¢ÂˆÂˆ ÃÂ“, and all boxes are mapped to A1 (i.e.  Y1 (ba )= 1, for all ai Ã¢ÂˆÂˆ ÃÂ“). The transitions in ÃÂ´1 are the  following:  Ã¢Â€Ë˜ for every reset transition of the form hq1 , ÄÂƒ, a1 , a2 , ÄÂ•,  r, Reset, q2 i Ã¢ÂˆÂˆ T , there are the transitions hen(q1 ,a1 ) ,  ÄÂƒ, ÄÂ•, r, Ã¢ÂˆÂ…, en(q2 ,a2 ) i Ã¢ÂˆÂˆ ÃÂ´1 , and hex(q1 ,a1 ) , ÄÂƒ, ÄÂ•, r, Ã¢ÂˆÂ…,  ex(q2 ,a2 ) i Ã¢ÂˆÂˆ ÃÂ´1 ;  Ã¢Â€Ë˜ for every store transition of the form hq1 , ÄÂƒ, a, a1 a2 , ÄÂ•,  r, Store, q2 i Ã¢ÂˆÂˆ T , there are the transitions hen(q1 ,a) ,  ÄÂƒ, ÄÂ•, r, Ã¢ÂˆÂ…, (ba2 ,en(q2 ,a1 ) )i Ã¢ÂˆÂˆ ÃÂ´1 and hex(q1 ,a) , ÄÂƒ, ÄÂ•, r,  Ã¢ÂˆÂ…, (ba2 ,en(q2 ,a1 ) )i Ã¢ÂˆÂˆ ÃÂ´1 ;  Ã¢Â€Ë˜ if hq1 , ÄÂƒ, a, , ÄÂ•, r, Restore, q2 i Ã¢ÂˆÂˆ T , then there are  the following transitions:  1) hen(q1 ,a) , ÄÂ„ , T rue, Ã¢ÂˆÂ…, Ã¢ÂˆÂ…, ex(q1 ,a) i Ã¢ÂˆÂˆ ÃÂ´1 ;  2) h(ba0 , ex(q1 ,a) ), ÄÂƒ, ÄÂ•, Ã¢ÂˆÂ…, r, en(q2 ,a0 ) i Ã¢ÂˆÂˆ ÃÂ´1 , for  every box ba0 and each box exit (ba0 ,exq1 );  The weak bisimulation relation Ã¢Â‰ÅŸ between LP and LT is  defined as follows. For gc Ã¢ÂˆÂˆ GC and gs Ã¢ÂˆÂˆ GS, gc Ã¢Â‰ÅŸ gs if  and only if:  1) gc = hq, vs , as Ã‚Ë‡ asÃ¢ÂˆÂ’1 . . . a1 , vsÃ¢ÂˆÂ’1 . . . v1 i and gs =  hba1 , . . ., basÃ¢ÂˆÂ’1 , u, v1 , . . ., vsÃ¢ÂˆÂ’1 , vs i, with u Ã¢ÂˆÂˆ  {en(q,as ) , ex(q,as ) }.  We show now that Ã¢Â‰ÅŸ is a bisimulation.  Let us consider the initialization requirement. The initial  state of P has the form gc0 =hq0 , v0 , a, i. An initial state  of T has the form gs0 =hen(q,a) , , v0 i, with en(q,a) Ã¢ÂˆÂˆ En1 .  By definition of Ã¢Â‰ÅŸ, it is immediate to show that gc0 Ã¢Â‰ÅŸ gs0  and gs0 Ã¢Â‰ÅŸÃ¢ÂˆÂ’1 gc0 .  Let us consider now the propagation requirement. Let us  assume that gc Ã¢Â‰ÅŸ gs, there are the following cases:  Ã¢Â€Ë˜ Let gc = hq, vs , as Ã‚Ë‡ asÃ¢ÂˆÂ’1 . . . a1 , vsÃ¢ÂˆÂ’1 . . . v1 i a  configuration and gs = hba1 , . . ., basÃ¢ÂˆÂ’1 , u, v1 , . . .,  vsÃ¢ÂˆÂ’1 , vs i, with u Ã¢ÂˆÂˆ {en(q,as ) , ex(q,as ) } a global state.  By definition, gc Ã¢Â‰ÅŸ gs. Now we show all the possible  transitions in Labs (P) having gc as source:  t  Ã¢Â€Â“ (progress transition): gc Ã¢Â‡Â’ gc0 , where gc0 = hq,  vs + t, as Ã‚Ë‡ asÃ¢ÂˆÂ’1 . . . a1 , vsÃ¢ÂˆÂ’1 . . . v1 i and t Ã¢ÂˆÂˆ  DÃ¢Â‰Ä½0 . Then there exists in Labs (T ) the transition  t  gs Ã¢Â‡Â’ gs0 , where gs0 = hba1 , . . ., basÃ¢ÂˆÂ’1 , u, v1 , . . .,  vsÃ¢ÂˆÂ’1 , vs + ti. By definition, gc0 Ã¢Â‰ÅŸ gs0 ;  ÄÂƒ  Ã¢Â€Â“ (reset transition): gc Ã¢Â‡Â’ gc0 , where gc0 = hq 0 ,  0  vs Ã¢Â†Â“r , a Ã‚Ë‡ asÃ¢ÂˆÂ’1 . . . a1 ,vsÃ¢ÂˆÂ’1 . . . v1 i, hq, ÄÂƒ, as , a0 ,  ÄÂ•, r, Reset, q 0 i in T and vs Ã¢ÂˆÂˆ ÄÂ•. Then there  ÄÂƒ  exists in Labs (T ) the transition gs Ã¢Â‡Â’ gs0 , where  0  0  gs = hba1 , . . ., basÃ¢ÂˆÂ’1 , u ,v1 , . . ., vsÃ¢ÂˆÂ’1 , vs Ã¢Â†Â“r i, hu,  ÄÂƒ, ÄÂ•, r, Ã¢ÂˆÂ…, u0 i in T and u0 Ã¢ÂˆÂˆ {en(q0 ,a0 ) , ex(q0 ,a0 ) }.  By definition, gc0 Ã¢Â‰ÅŸ gs0 ;  ÄÂƒ  Ã¢Â€Â“ (store transition): gc Ã¢Â‡Â’ gc0 , where gc0 = hq 0 ,  0 00  vs Ã¢Â†Â“r , a a asÃ¢ÂˆÂ’1 . . . a1 ,vs . . . v1 i, hq, ÄÂƒ, as , a0 a00 ,  ÄÂ•, r, Store, q 0 i in T and vs Ã¢ÂˆÂˆ ÄÂ•. Then there  ÄÂƒ  exists in Labs (T ) the transition gs Ã¢Â‡Â’ gs0 , where  gs0 = hba1 , . . ., basÃ¢ÂˆÂ’1 , ba00 , u0 , v1 , . . ., vsÃ¢ÂˆÂ’1 ,  vs Ã¢Â†Â“r i, hu, ÄÂƒ, ÄÂ•, r, Ã¢ÂˆÂ…, (ba0 ,u0 )i in T and u0 Ã¢ÂˆÂˆ  {en(q0 ,a0 ) , ex(q0 ,a0 ) }. By definition, gc0 Ã¢Â‰ÅŸ gs0 ;  ÄÂƒ  Ã¢Â€Â“ (restore transition): gc Ã¢Â‡Â’ gc0 , where gc0 = hq 0 ,  vs Ã¢Â†Â‘(r,vsÃ¢ÂˆÂ’1 , asÃ¢ÂˆÂ’1 . . . a1 , vsÃ¢ÂˆÂ’2 . . . v1 i, hq, ÄÂƒ,  as , , ÄÂ•, r, Restore, q 0 i in T and vs Ã¢ÂˆÂˆ ÄÂ•.  If u=en(q,as ) then there exists in Labs (T ) the  ÄÂƒ  transition gs Ã¢Â‡Â’ gs0 in Labs (T ) that abstracting  the following transitions:  Ã¢ÂˆÂ— the reset transition hu, ÄÂ„ , T rue, Ã¢ÂˆÂ…, Ã¢ÂˆÂ…, ex(q,as ) i  in ÃÂ´1 ;  Ã¢ÂˆÂ— the return transition h(basÃ¢ÂˆÂ’1 , ex(q,as ) ), ÄÂƒ, ÄÂ•, Ã¢ÂˆÂ…,  r, en(q0 ,asÃ¢ÂˆÂ’1 ) i Ã¢ÂˆÂˆ ÃÂ´1 .  If u=ex(q,as ) then there exists in Labs (T ) the  ÄÂƒ  transition gs Ã¢Â‡Â’ gs0 in Labs (T ), corresponding to  the return transition h(basÃ¢ÂˆÂ’1 , ex(q,as ) ), ÄÂƒ, ÄÂ•, Ã¢ÂˆÂ…, r,  en(q0 ,asÃ¢ÂˆÂ’1 ) i Ã¢ÂˆÂˆ ÃÂ´1 .  The resulting global state is gs0 = hba1 , . . ., basÃ¢ÂˆÂ’2 ,  u,v1 , . . ., vsÃ¢ÂˆÂ’2 , vs Ã¢Â†Â‘(r,vsÃ¢ÂˆÂ’1 i. By definition, gc0 Ã¢Â‰ÅŸ  gs0 ;  Now we show all the possible transitions in Labs (T )  having gs as source.  t  Ã¢Â€Â“ (progress transition): gs Ã¢Â‡Â’ gs0 , where gs0 = hba1 ,  . . ., basÃ¢ÂˆÂ’1 , u, v1 , . . ., vsÃ¢ÂˆÂ’1 , vs + ti and t Ã¢ÂˆÂˆ  DÃ¢Â‰Ä½0 . Then there exists in Labs (P) the transit  tion gc Ã¢Â‡Â’ gc0 , where gc0 = hq, vs + t, as Ã‚Ë‡  asÃ¢ÂˆÂ’1 . . . a1 ,vsÃ¢ÂˆÂ’1 . . . v1 i. By definition, gs0 Ã¢Â‰ÅŸÃ¢ÂˆÂ’1  gc0 ;  ÄÂ„ [t]  Ã¢Â€Â“ (progress transition with ÄÂ„ ): (u Ã¢ÂˆÂˆ En). gs Ã¢Â‡Â’ gs0 ,  where gs0 = hba1 , . . ., basÃ¢ÂˆÂ’1 , u0 , v1 , . . ., vsÃ¢ÂˆÂ’1 ,  vs + ti, u0 Ã¢ÂˆÂˆ Ex and t Ã¢ÂˆÂˆ DÃ¢Â‰Ä½0 . Then there exists  t  in Labs (P) the transition gc Ã¢Â‡Â’ gc0 , where gc0 = hq,  vs + t, as Ã‚Ë‡ asÃ¢ÂˆÂ’1 . . . a1 ,vsÃ¢ÂˆÂ’1 . . . v1 i. By definition,  gs0 Ã¢Â‰ÅŸÃ¢ÂˆÂ’1 gc0 ;  ÄÂƒ  Ã¢Â€Â“ (reset transition): gs Ã¢Â‡Â’ gs0 , where gs0 = hba1 , . . .,  0  basÃ¢ÂˆÂ’1 , u ,v1 , . . ., vsÃ¢ÂˆÂ’1 , vs Ã¢Â†Â“r i, hu, ÄÂƒ, ÄÂ•, r, Ã¢ÂˆÂ…,  u0 i in T , vs Ã¢ÂˆÂˆ ÄÂ• and u0 Ã¢ÂˆÂˆ En Ã¢ÂˆÅ Ex. Then there  ÄÂƒ  exists in Labs (P) the transition gc Ã¢Â‡Â’ gc0 , where  0  0  0  gc = hq , vs Ã¢Â†Â“r , a Ã‚Ë‡ asÃ¢ÂˆÂ’1 . . . a1 ,vsÃ¢ÂˆÂ’1 . . . v1 i, hq,  ÄÂƒ, as , a0 , ÄÂ•, r, Reset, q 0 i in T and vs Ã¢ÂˆÂˆ ÄÂ•. By  definition, gs0 Ã¢Â‰ÅŸÃ¢ÂˆÂ’1 gs0 ;  ÄÂ„ [t]  Ã¢Â€Â“ (reset transition with ÄÂ„ ): (u Ã¢ÂˆÂˆ En). gs Ã¢Â‡Â’ gs0 ,  where gs0 = hba1 , . . ., basÃ¢ÂˆÂ’1 , u0 ,v1 , . . ., vsÃ¢ÂˆÂ’1 ,  vs Ã¢Â†Â“r i, hu, ÄÂƒ, ÄÂ•, r, Ã¢ÂˆÂ…, u0 i in T , vs Ã¢Â†Â“r Ã¢ÂˆÂˆ ÄÂ•  and u0 Ã¢ÂˆÂˆ Ex. Then there exists in Labs (P) the  ÄÂƒ  transition gc Ã¢Â‡Â’ gc0 , where gc0 = hq 0 , vs Ã¢Â†Â“r ,  0  a Ã‚Ë‡ asÃ¢ÂˆÂ’1 . . . a1 ,vsÃ¢ÂˆÂ’1 . . . v1 i, hq, ÄÂƒ, as , a0 , ÄÂ•, r,  Reset, q 0 i in T and vs Ã¢ÂˆÂˆ ÄÂ•. By definition, gs0  Ã¢Â‰ÅŸÃ¢ÂˆÂ’1 gc0 ;  ÄÂƒ  Ã¢Â€Â“ (call transition): gs Ã¢Â‡Â’ gs0 , where gs0 = hba1 , . . .,  basÃ¢ÂˆÂ’1 , ba00 , u0 , v1 , . . ., vsÃ¢ÂˆÂ’1 , vs Ã¢Â†Â“r i, hu, ÄÂƒ, ÄÂ•, r,  Ã¢ÂˆÂ…, (ba0 ,u0 )i in T , vs Ã¢ÂˆÂˆ ÄÂ• and u0 Ã¢ÂˆÂˆ En Ã¢ÂˆÅ Ex. Then  ÄÂƒ  there exists in Labs (P) the transition gc Ã¢Â‡Â’ gc0 ,  where gc0 = hq 0 , vs Ã¢Â†Â“r , a0 a00 asÃ¢ÂˆÂ’1 . . . a1 ,vs . . . v1 i,  hq, ÄÂƒ, as , a0 a00 , ÄÂ•, r, Store, q 0 i in T and vs Ã¢ÂˆÂˆ ÄÂ•.  By definition, gs0 Ã¢Â‰ÅŸÃ¢ÂˆÂ’1 gc0 ;  ÄÂƒ  Ã¢Â€Â“ (call transition with ÄÂ„ ): (u Ã¢ÂˆÂˆ En). gs Ã¢Â‡Â’ gs0 , where  gs0 = hba1 , . . ., basÃ¢ÂˆÂ’1 , ba00 , u0 , v1 , . . ., vsÃ¢ÂˆÂ’1 , vs Ã¢Â†Â“r  i, hu, ÄÂƒ, ÄÂ•, r, Ã¢ÂˆÂ…, (ba0 ,u0 )i in T and vs Ã¢ÂˆÂˆ ÄÂ•. Then  ÄÂƒ  there exists in Labs (P) the transition gc Ã¢Â‡Â’ gc0 ,  where gc0 = hq 0 , vs Ã¢Â†Â“r , a0 a00 asÃ¢ÂˆÂ’1 . . . a1 ,vs . . . v1 i,  hq, ÄÂƒ, as , a0 a00 , ÄÂ•, r, Store, q 0 i in T and vs Ã¢ÂˆÂˆ ÄÂ•.  By definition, gs0 Ã¢Â‰ÅŸÃ¢ÂˆÂ’1 gc0 ;  ÄÂƒ  Ã¢Â€Â“ (return transition): (u Ã¢ÂˆÂˆ Ex). gs Ã¢Â‡Â’ gs0 , where  gs0 = hba1 , . . ., basÃ¢ÂˆÂ’2 , u,v1 , . . ., vsÃ¢ÂˆÂ’2 , vs Ã¢Â†Â‘(r,vsÃ¢ÂˆÂ’1  i and vs Ã¢ÂˆÂˆ ÄÂ•. Then there exists in Labs (P)  ÄÂƒ  the transition gc Ã¢Â‡Â’ gc0 , where gc0 = hq 0 ,  vs Ã¢Â†Â‘(r,vsÃ¢ÂˆÂ’1 , asÃ¢ÂˆÂ’1 . . . a1 ,vsÃ¢ÂˆÂ’2 . . . v1 i, hq, ÄÂƒ, as , ,  ÄÂ•, r, Restore, q 0 i in T and vs Ã¢ÂˆÂˆ ÄÂ•. By definition,  gs0 Ã¢Â‰ÅŸÃ¢ÂˆÂ’1 gc0 ;  ÄÂƒ  Ã¢Â€Â“ (return transition with ÄÂ„ ): (u Ã¢ÂˆÂˆ En). gs Ã¢Â‡Â’ gs0 ,  0  where gs = hba1 , . . ., basÃ¢ÂˆÂ’2 , u,v1 , . . ., vsÃ¢ÂˆÂ’2 ,  vs Ã¢Â†Â‘(r,vsÃ¢ÂˆÂ’1 i and vs Ã¢ÂˆÂˆ ÄÂ•. Then there exists in  ÄÂƒ  Labs (P) the transition gc Ã¢Â‡Â’ gc0 , where gc0 = hq 0 ,  vs Ã¢Â†Â‘(r,vsÃ¢ÂˆÂ’1 , asÃ¢ÂˆÂ’1 . . . a1 ,vsÃ¢ÂˆÂ’2 . . . v1 i, hq, ÄÂƒ, as , ,  ÄÂ•, r, Restore, q 0 i in T and vs Ã¢ÂˆÂˆ ÄÂ•. By definition,  gs0 Ã¢Â‰ÅŸÃ¢ÂˆÂ’1 gc0 .  We now show the bisimulation relation between TRSM 1  and EPTA 1.  Let us consider a TRSM T in the class of TRSM 1, it  is easy to see that the EPTA P simulating T as defined  in the construction of Theorem 1, is actually an EPTA 1.  Conversely, let us consider an EPTA P in the class of  EPTA 1, it is easy to see that the TRSM T simulating P  as defined in the construction of Theorem 1, is actually a  TRSM 1.  Analogues arguments can be used to prove the correspondence between EPTA 0 and TRSM 0.  V. T HE REACHABILITY PROBLEM : DECIDABILITY AND  COMPLEXITY RESULTS  In this section we study the problem of reachability for  TRSMs and EPTAs. In particular, we prove that the problem  is undecidable for the general class of TRSMs and EPTAs,  but that is decidable for TRSM 1 and EPTA 1. We state also  the complexity of the problem for the class of TRSM 0 (and  EPTA 0).  Given a global state gs = hb1 , . . . , bs , u, v1 , . . . , vs , vi  of a TRSM T , we call the tuple hb1 , . . . , bs , ui an untimed  global state of T . The reachability problem for an untimed  global state hb1 , . . . , bs , ui is to determine whether, for some  clock valuations v1 , . . ., vs , v, the global state hb1 , . . ., bs ,  u, v1 , . . ., vs , vi is reachable from an initial configuration  state. A similar notion of reachability can be given for  EPTAs.  The undecidability for TRSMs is stated by showing the  undecidability of the reachability problem for the class  EPTA 2. In fact, it is possible to show (see the complete  work) that EPTA 2s allow to simulate increment and decrement of clocks. For instance, Fig. 3 shows an EPTA 2 which  decrements the clock z, leaving the clock y unchanged (z  and y can be viewed as the two counters). The path leading  from (p, q0Ã¢ÂˆÂ’ ) to (p, q3Ã¢ÂˆÂ’ ), is used to store the value of x  into x00 , while y maintains the original value. In the next  step, these values are stored in the valuation stack, and after  an amount of time equal to x00 Ã¢ÂˆÂ’ 1 is elapsed, the original  value of y is restored. In this way, it is possible to define  an EPTA 2 which simulates a two counter machine (clocks  with increment and decrement can be used as counters). This  allows to reduce the halting problem of two counter Minsky  machine, which is known to be undecidable [5], to the  reachability problem for an EPTA 2.  Theorem 2: The reachability problem for EPTA 2 is  undecidable.  Proof:  We recall that a two counter machine is a finite set of  labeled instructions over two counters c1 and c2 . There are  two type of instructions:  Ã¢Â€Ë˜ increment of x Ã¢ÂˆÂˆ {c1 , c2 }, of the form  p : x := x + 1; goto q;  Ã¢Â€Ë˜ decrement of x Ã¢ÂˆÂˆ {c1 , c2 }, of the form  p : if x > 0 then x:=x - 1; goto q1 else goto q2  The machine starts at an instruction labeled p0 with  c1 =c2 =0 and stops at a special instruction labeled HALT .  The halting problem for a two counter machine consists  in deciding whether the machine reaches the instruction  HALT .  The idea is that the two counters can be simulated by  two clocks, and the instructions of increment and decrement  can be simulated by sequences of transitions of an EPTA 2  which exploit the ability of storing and restoring clock valuations on the valuation stack. The states of the automaton  are the labels of the instruction augmented with additional  ÄÂ„ , , , x0 = 0, Ã¢ÂˆÂ…, Store  (p,q0Ã¢ÂˆÂ’ )  ÄÂ„ , , , T rue, X \ {x00 }, Restore  (p,q1Ã¢ÂˆÂ’ )  (p,q2Ã¢ÂˆÂ’ )  ÄÂ„ , , , (x00 Ã¢ÂˆÂ’ z = 0) Ã¢ÂˆÂ§ (x0 = 0), {z}, Reset  0  (p,q5Ã¢ÂˆÂ’ ) ÄÂ„ , , , T rue, X \ {z}, Restore (p,q4Ã¢ÂˆÂ’ ) ÄÂ„ , , , x = 0, Ã¢ÂˆÂ…, Store (p,q3Ã¢ÂˆÂ’ )  control states, used to simulated increments and decrements.  We denote by C(+) (resp. : C(Ã¢ÂˆÂ’) ) the set of the labels  associated to increment (resp. : decrement) instructions.  Given a machine with two counters x and y, the simulating EPTA 2 is hQ, (p0 , s), X, ÃÂ“, T i, where  S  Ã¢Â€Ë˜ Q=C(+) Ä‚Â—{q0+ , q1+ , q2+ }  C(Ã¢ÂˆÂ’) Ä‚Â—{qiÃ¢ÂˆÂ’ : 0 Ã¢Â‰Â¤ i Ã¢Â‰Â¤ 6}  S  {Halt};  Ã¢Â€Ë˜ s=q0+ if p0 Ã¢ÂˆÂˆ C(+) and s=q0Ã¢ÂˆÂ’ if p0 Ã¢ÂˆÂˆ C(Ã¢ÂˆÂ’) ;  0  00  Ã¢Â€Ë˜ X={x, y, x , x } and ÃÂ“={ÃÅ‚};  Ã¢Â€Ë˜ for every p Ã¢ÂˆÂˆ C(+) associated with the increment of  the counter z Ã¢ÂˆÂˆ {x, y}, T has the transitions:  1) h(p, q0+ ), ÄÂ„ , , ÃÅ‚, x0 = 0, Ã¢ÂˆÂ…, Store, (p, q1+ )i;  2) h(p, q1+ ), ÄÂ„ , , ÃÅ‚, x0 = 1, X \ {z}, Restore,  (p, q2+ )i;  3) let q be the target label of the goto instruction,  then  a) if q Ã¢ÂˆÂˆ C(+) , then h(p, q2+ ), ÄÂ„ , , , x0 = 0,  {x00 }, Reset, (q, q0+ )i;  b) if q Ã¢ÂˆÂˆ C(Ã¢ÂˆÂ’) , then h(p, q2+ ), ÄÂ„ , , , x0 = 0,  {x00 }, Reset, (q, q0Ã¢ÂˆÂ’ )i;  c) if q=Halt, then h(p, q2+ ), ÄÂ„ , , , x0 = 0,  {x00 }, Reset, Halti;  Ã¢Â€Ë˜ for every p Ã¢ÂˆÂˆ C(Ã¢ÂˆÂ’) associated with the decrement of  the counter z Ã¢ÂˆÂˆ {x, y} (see also Figure 3), T has the  transitions:  1) h(p, q0Ã¢ÂˆÂ’ ), ÄÂ„ , , ÃÅ‚, x0 = 0 Ã¢ÂˆÂ§ z Ã¢Â‰Ä½ 1, Ã¢ÂˆÂ…, Store,  (p, q1Ã¢ÂˆÂ’ )i;  2) h(p, q1Ã¢ÂˆÂ’ ), ÄÂ„ , ÃÅ‚, , T rue, X \ {x00 }, Restore,  (p, q2Ã¢ÂˆÂ’ )i;  3) h(p, q2Ã¢ÂˆÂ’ ), ÄÂ„ , , , x00 Ã¢ÂˆÂ’ z = 0 Ã¢ÂˆÂ§ x0 = 0, {z},  Reset, (p, q3Ã¢ÂˆÂ’ )i;  4) h(p, q3Ã¢ÂˆÂ’ ), ÄÂ„ , , ÃÅ‚, x0 = 0, Ã¢ÂˆÂ…, Store, (p, q4Ã¢ÂˆÂ’ )i;  5) h(p, q4Ã¢ÂˆÂ’ ), ÄÂ„ , ÃÅ‚, , T rue, X \ {z}, Restore,  (p, q5Ã¢ÂˆÂ’ )i;  6) h(p, q5Ã¢ÂˆÂ’ ), ÄÂ„ , , , x00 Ã¢ÂˆÂ’ z=1Ã¢ÂˆÂ§ x0 = 0, {x0 ,x00 },  Reset, (p, q6Ã¢ÂˆÂ’ )i;  7) let q be the target label pointed by the goto  instruction (it depends on the chosen branch), then  a) if q Ã¢ÂˆÂˆ C(+) , then h(p, q6Ã¢ÂˆÂ’ ), ÄÂ„ , , , x0 = 0,  {x00 }, Reset, (q, q0+ )i and h(p, q0Ã¢ÂˆÂ’ ), ÄÂ„ , , ,  x0 = 0 Ã¢ÂˆÂ§ z < 1, {x00 }, Reset, (q, q0+ )i;  b) if q Ã¢ÂˆÂˆ C(Ã¢ÂˆÂ’) , then h(p, q6Ã¢ÂˆÂ’ ), ÄÂ„ , , , x0 = 0,  {x00 }, Reset, (q, q0Ã¢ÂˆÂ’ )i and h(p, q0Ã¢ÂˆÂ’ ), ÄÂ„ , , ,  x0 = 0 Ã¢ÂˆÂ§ z < 1, {x00 }, Reset, (q, q0Ã¢ÂˆÂ’ )i;  c) if q=Halt, then h(p, q6Ã¢ÂˆÂ’ ), ÄÂ„ , , , x0 = 0,  {x0 , x00 }, Reset, Halti and h(p, q0Ã¢ÂˆÂ’ ), ÄÂ„ , , ,  x0 = 0 Ã¢ÂˆÂ§ z < 1, {x0 , x00 }, Reset, Halti.  ÄÂ„ , , , (z Ã¢ÂˆÂ’ x00 = 1) Ã¢ÂˆÂ§ (x0 = 0), {x0 , x00 }, Reset  (p,q6Ã¢ÂˆÂ’ )  Figure 3.  EPTA for the decrement of the clock z  As consequence of Theorem 1 we have the following  corollary.  Corollary 1: The reachability problem for TRSMs is  undecidable.  We shall now prove that the reachability problem for  TRSM 1 is decidable. The proof combines two techniques:  the former is the standard regionalization technique, used to  prove reachability in Timed Automata [2], while the latter is  derived from the algorithm, based on a fix point construction,  proposed in [1] to solve the reachability problem for RSMs.  Let us first recall the notion of clock region and region  automaton of a Timed Automaton. Following the standard  construction [6], we assume that constants occurring in the  clock constraints of the automaton are integers. For any t Ã¢ÂˆÂˆ  DÃ¢Â‰Ä½0 , hti denotes the fractional part of t, and btc denotes the  integral part of t (i.e. t=btc+hti). For each clock x Ã¢ÂˆÂˆ X, let  cx be the largest integer constant c such that x is compared  with c in some clock constraint appearing in a transition. The  equivalence relation Ã¢ÂˆÅº  =, (region equivalence), is defined over  the set of clock valuations for X. For two clock valuations  v1 and v2 , we write v1 Ã¢ÂˆÅº  = v2 iff the following conditions  hold:  1) for all clocks x Ã¢ÂˆÂˆ X, either bv1 (x)c and bv2 (x)c are  the same, or both v1 (x) and v2 (x) exceed cx ;  2) for all clocks x, y with v1 (x) Ã¢Â‰Â¤ cx and v1 (y) Ã¢Â‰Â¤ cy ,  hv1 (x)i Ã¢Â‰Â¤ hv1 (y)i iff hv2 (x)i Ã¢Â‰Â¤ hv2 (y)i;  3) for all clocks x Ã¢ÂˆÂˆ X with v1 (x) Ã¢Â‰Â¤ cx , hv1 (x)i = 0 iff  hv2 (x)i = 0.  A clock region is an equivalence class of clock valuations  induced by Ã¢ÂˆÅº  =.  QIf k is the number of the clocks, there are at  most k! Ã‚Ë‡ 4k Ã‚Ë‡ xÃ¢ÂˆÂˆX (cx + 1) regions (see [6]). We denote by  Reg the set of all regions with respect to the set of clocks  X and an indexed family {cx }xÃ¢ÂˆÂˆX .  A clock region reg 0 is a time successor of a clock region  reg if and only if, for all clock valuations v Ã¢ÂˆÂˆ reg, there  exists a t Ã¢ÂˆÂˆ DÃ¢Â‰Ä½0 such that v+t Ã¢ÂˆÂˆ reg 0 . Let ÄÂ• Ã¢ÂˆÂˆ C(X) be a  clock constraint, we write reg Ã¢ÂˆÂˆ ÄÂ• if and only if v Ã¢ÂˆÂˆ ÄÂ•, for  all v Ã¢ÂˆÂˆ reg. Note that for a clock constraint ÄÂ• of a TA, if  vÃ¢ÂˆÅº  = v0 , then v Ã¢ÂˆÂˆ ÄÂ• iff v0 Ã¢ÂˆÂˆ ÄÂ•. Let r Ã¢ÂŠÂ† X a set of clocks,  reg Ã¢Â†Â“r = {v Ã¢Â†Â“r |v Ã¢ÂˆÂˆ reg} denotes the region resulting from  reg by resetting the clocks in r.  It is well known that the reachability problem of a Timed  Automaton can be reduced to the reachability problem over  its region automaton, namely the automaton whose states  are obtained by coupling control states and regions, and  transitions are obtained by suitably coupling the transition  relation of the timed automaton and the successor relation  defined on regions.  Given a TRSM T =hA  S1 , . . ., An , Xi belonging to  TRSM 1, with Ai = hNi Bi , Yi , Eni , Exi , ÃÂ´i i, in order  to compute reachability in T we build a region RSM R for  T , over the alphabet ÃÅ, whose components are the region  automata obtained from the components of the original  TRSM. More formally, R = hA01 , . . ., A0n i, where:  S  A0i = h(Ni Ä‚Â— Reg) Bi , Yi ,Eni Ä‚Â— Reg, Exi Ä‚Â— Reg,ÃÂ´i0 i,  with 1 Ã¢Â‰Â¤ i Ã¢Â‰Â¤ n  and Reg is the finite set of regions for the set of clocks X  and the indexed family {cx }xÃ¢ÂˆÂˆX , where cx is the maximal  constant c which is compared with clock x in some clock  constraint ÄÂ• decorating a transition of T . R is computed as  the fix point of an iterative process, which builds a chain of  region RSMs R(0) , . . ., R(k) . The idea is that, for the sake  of reachability, given a run of a TRSM 1, it is possible  to abstract away all the sub-runs bounded by matching  pairs of call and return transitions. This abstraction can be  performed by augmenting the region RSM R with summary  transitions, which can be used, during the reachability  analysis, to skip the invocation of and the return from the  component, provided that the exit node of the component is  actually reachable from the corresponding entry node. The  process described below iteratively computes these summary  transitions.  (0)  (0)  The initial RSM is R0 = hA0 1 , . . ., A0 n i, where  S  (0)  (0)  A0 i =h(Ni Ä‚Â— Reg) Bi ,Reg,Yi ,En0i , Ex0i , ÃÂ´i i, with 1 Ã¢Â‰Â¤  (0)  i Ã¢Â‰Â¤ n. The transitions in ÃÂ´i are:  1) h(u1 ,reg1 ),ÄÂƒ,(u1 ,reg2 )i, if reg2 is a time successor of  reg1 ;  2) h(u1 ,reg1 ),ÄÂƒ,(u2 ,reg2 )i, if hu1 , ÄÂƒ, ÄÂ†, r1 , Ã¢ÂˆÂ…, u2 i Ã¢ÂˆÂˆ ÃÂ´i ,  reg1 Ã¢ÂˆÂˆ ÄÂ† and reg2 = reg1 Ã¢Â†Â“r1 ;  3) h(u1 ,reg1 ),ÄÂƒ,(b, (u2 ,reg2 )i, if hu1 , ÄÂƒ, ÄÂ†, r1 , Ã¢ÂˆÂ…, (b, u2 )i  Ã¢ÂˆÂˆ ÃÂ´i , reg1 Ã¢ÂˆÂˆ ÄÂ† and reg2 = reg1 Ã¢Â†Â“r1 ;  (0)  Notice that ÃÂ´i does not contain return transitions. At  (k+1)  the (k + 1)-th iteration (k Ã¢Â‰Ä½ 0), we compute ÃÂ´i  , by  adding appropiate summary transitions. Suppose that there  is a call transition in the i-th component from a node u1  to a box b invoking the j-th component into the entry node  en, and there is a return transition from the exit node ex  of the j-th component to a node u2 of the i-th component.  In order to add a summary transition from (u1 , reg1 ) to  (u2 , reg2 ), we need to know whether (ex, reg 00 ) is locally  reachable (i.e. without exploiting call or return transitions)  from (en, reg 0 ) in the j-th component of R(k) , where reg 0  is the region resulting from reg1 after resetting the clocks  according the call transition, reg2 is the region resulting  from reg1 after resetting the clocks according the return  transition in the TRSM and reg 00 satisfy the constraint in  the return transition.  (k+1)  (k)  Formally, the relation transition ÃÂ´i  is ÃÂ´i augumented with the following transitions. For each entry  node (b,(en,reg 0 )), where j=Yi (b), and for each exit node  (k)  (k)  (ex,reg 00 ) Ã¢ÂˆÂˆ A0 j , reachable from (en, reg 0 ) in A0 j , if  (k)  there is a transition h(u1 , reg1 ), ÄÂƒ1 , (b, (en, reg 0 ))i in ÃÂ´i  (k+1)  we add to ÃÂ´i  the transitions:  Ã¢Â€Ë˜  h(u1 , reg1 ), ÄÂƒ1 , (u2 , reg1 Ã¢Â†Â“r )i, whenever h(b, ex), ÄÂƒ2 ,  ÄÂ•, r, X, u2 i Ã¢ÂˆÂˆ ÃÂ´i and reg 00 Ã¢ÂˆÂˆ ÄÂ•.  The iterative construction terminates when it is not possible to add new transitions. Termination of the procedure is  ensured since the number of the states of R and the number  of the transitions in each ÃÂ´i is finite.  The region RSM R, resulting from the construction, can  be proved equivalent, from the reachability viewpoint, to the  original TRMS (see the complete work). Since the reachability problem for RMSs is decidable [1], this establishes  decidability of reachability for the class TRSM 1.  Theorem 3: The reachability problem for the class  TRSM 1 is decidable.  Proof:  Given a TRSM 1 T =hA1 , . . ., An , Xi, the region RSM  R for T , over the alphabet ÃÅ, is R=hA01 , . . S  ., A0n i, where  0  for all (1 Ã¢Â‰Â¤ i Ã¢Â‰Â¤ n), Ai is a tuple h(Ni Ä‚Â— Reg) Bi , Yi ,En0i ,  Ex0i , ÃÂ´i0 i and:  Ã¢Â€Ë˜ Reg is the finite set of all regions with respect to the set  of the clocks X of T and the indexed family {cx }xÃ¢ÂˆÂˆX ,  where cx is the maximal values c such that the clock  x Ã¢ÂˆÂˆ X is compared with c in some clock constraint  appearing in a guard ÄÂ• of all ÃÂ´i ;  0  Ã¢Â€Ë˜ Eni = Eni Ä‚Â— Reg, is the set of initial states;  0  Ã¢Â€Ë˜ Exi = Eni Ä‚Â— Reg, is the set of final states;  The desired RSM R is built as the limit of a (finite)  (0)  sequence of RSM R(i) (i Ã¢Â‰Ä½ 0), where R(0) =hA0 1 , . . .,  0 (0)  0 (0)  A n i and, for all (1 Ã¢Â‰Â¤ i Ã¢Â‰Â¤ n), A i is the tuple  S  (0)  h(Ni Ä‚Â— Reg) Bi ,Reg,Yi ,En0i , Ex0i , ÃÂ´i i. The transitions  (0)  in ÃÂ´i are of the form:  1) h(u1 ,reg1 ),ÄÂƒ,(u1 ,reg2 )i, where reg2 is a time successor of reg1 ;  2) h(u1 ,reg1 ),ÄÂƒ,(u2 ,reg2 )i, where hu1 , ÄÂƒ, ÄÂ†, r1 , Ã¢ÂˆÂ…, u2 i Ã¢ÂˆÂˆ  ÃÂ´i and reg2 is such that for all clock valuation v Ã¢ÂˆÂˆ  reg1 with v Ã¢ÂˆÂˆ ÄÂ† and v Ã¢Â†Â“r1 Ã¢ÂˆÂˆ reg2 ;  3) h(u1 ,reg1 ),ÄÂƒ,(b, (u2 ,reg2 )i, where hu1 , ÄÂƒ, ÄÂ†, r1 , Ã¢ÂˆÂ…, (b,  u2 )i Ã¢ÂˆÂˆ ÃÂ´i and reg2 is such that for all clock valuation  v Ã¢ÂˆÂˆ reg1 with v Ã¢ÂˆÂˆ ÄÂ† and v Ã¢Â†Â“r1 Ã¢ÂˆÂˆ reg2 ;  (k+1)  (k+1)  Given R(k) , with k Ã¢Â‰Ä½ 0, R(k+1) =hA0 1  ,. . ., A0 n  i,  0 (k+1)  where for all 1 Ã¢Â‰Â¤ i Ã¢Â‰Â¤ n, A i  is the tuple h(Ni Ä‚Â—  S  (k+1)  Reg) Bi ,Yi ,Eni , Exi , ÃÂ´i  i. The relation transition  (k+1)  (k)  ÃÂ´i  is ÃÂ´i augumented with the following transitions.  For each enter node (b,(en,reg)), where j=Yi (b), and for  (k)  each exit node (ex,reg 0 ) Ã¢ÂˆÂˆ A0 j , reachable from (en, reg)  (k)  in A0 j , if there is a transition h(u0 , reg 00 ), ÄÂƒ, (b, (en, reg))i  (k)  (k+1)  in ÃÂ´i we add to ÃÂ´i  the transitions:  0  00  Ã¢Â€Ë˜ h(u , reg ), ÄÂƒ, (u, reg2 )i for all the transitions h(b, ex),  ÄÂƒ1 , ÄÂ•, r1 , X, ui Ã¢ÂˆÂˆ ÃÂ´i , where reg2 is such that for all  clock valuation v Ã¢ÂˆÂˆ reg 00 , with v Ã¢ÂˆÂˆ ÄÂ†, v Ã¢Â†Â“r1 Ã¢ÂˆÂˆ reg2 ;  The iterative construction terminates when it is not possible to add new transitions, and we obtain the relations ÃÂ´i0  (termination is ensured since the number of the states and  the number of the transitions in ÃÂ´i is finite, for all i).  For proving the Theorem 3 we preliminary state the  following property:  Let hb1 , . . ., bs , ui be an untimed global state of T , the  global state hb1 , . . ., bs , u, v1 , . . ., vs , vi is reachable from  an initial global state, for some clock evaluations v1 , . . .,  vs , v, iff the global state hb1 , . . ., bs , (u, reg)i of R is  reachable from an initial global state of R, for some reg  and v Ã¢ÂˆÂˆ reg.  Lemma 1: For all b1 , . . ., bs , b01 , . . ., b0k Ã¢ÂˆÂˆ B, for all clock  evaluations v1 , . . ., vs , v10 , . . ., vk0 , with 0 Ã¢Â‰Â¤ s Ã¢Â‰Â¤ k, for all  reg, reg 0 Ã¢ÂˆÂˆ Reg and for all u, u0 Ã¢ÂˆÂˆ Ni , such that hb1 , . . .,  bs , u,v1 , . . ., vs , vi, hb1 , . . ., bs , (u, reg)i, hb01 , . . ., b0k , u,  v10 , . . ., vk0 , vi and hb01 , . . ., b0k , (u0 , reg 0 )i are well-defined  global states: if hb1 , . . ., bs , u,v1 , . . ., vs , vi Ã¢Â†Â’Ã¢ÂˆÂ—T hb1 , . . .,  bs , u0 , v1 , . . ., vs , v0 i, then hb01 , . . ., b0k , u, v10 , . . ., vk0 , vi  Ã¢Â†Â’Ã¢ÂˆÂ—T !hb01 , . . ., b0k , u0 , v10 , . . ., vk0 , v0 i; if hb1 , . . ., bs , (u, reg)i  Ã¢Â†Â’Ã¢ÂˆÂ—R hb1 , . . ., bs , (u0 , reg 0 )i, then hb01 , . . ., b0k , (u, reg)i Ã¢Â†Â’Ã¢ÂˆÂ—R  hb01 , . . ., b0k , (u0 , reg 0 )i.  Proof:  We starting proving the Lemma for the TRSM T .  The prove is by induction on the length k of the run  ÃÅ¥T = hb1 , . . ., bs , u, v1 , . . ., vs , vi Ã¢Â†Â’Ã¢ÂˆÂ—T hb1 , . . ., bs , u0 ,  v1 , . . ., vs , v0 i.  (Base case, k = 0). Immediate.  (Inductive step, k Ã¢Â‰Ä½ 0). Let us suppose that the property  holds for the run of lenght k. Let hb1 , . . ., bs , u, v1 , . . ., vs ,  (k+1)  vi Ã¢Â†Â’T  hb1 , . . ., bs , uk+1 , v1 , . . ., vs , vk+1 i be a run  of lenght k + 1. The (k + 1) Ã¢ÂˆÂ’ th transition can have one of  the following forms:  Ã¢Â€Ë˜  Ã¢Â€Ë˜  Ã¢Â€Ë˜  (progress transition): hb1 , . . ., bs , uk , v1 , . . ., vs , vk i  Ã¢Â†Â’T hb1 , . . ., bs , uk+1 , v1 , . . ., vs , vk+1 i, where  uk+1 = uk , vk+1 = vk + t and t Ã¢ÂˆÂˆ DÃ¢Â‰Ä½0 . By inductive  hypothesis, we have that hb01 , . . ., b0k , u, v10 , . . ., vk0 ,  (k)  vi Ã¢Â†Â’T hb01 , . . ., b0k , uk , v10 , . . ., vk0 , vk i and there is  the progress transition hb01 , . . ., b0k , uk , v10 , . . ., vk0 , vk i  Ã¢Â†Â’T hb01 , . . ., b0k , uk , v10 , . . ., vk0 , vk + ti;  (reset transition): hb1 , . . ., bs , uk , v1 , . . ., vs , vk i  Ã¢Â†Â’T hb1 , . . ., bs , uk+1 , v1 , . . ., vs , vk+1 i, where  huk ,ÄÂƒ,ÄÂ•,r1 ,Ã¢ÂˆÂ…,uk+1 i Ã¢ÂˆÂˆ ÃÂ´i , vk Ã¢ÂˆÂˆ ÄÂ•, vk+1 = vk Ã¢Â†Â“r1 .  By inductive hypothesis, we have that hb01 , . . ., b0k , u,  (k)  v10 , . . ., vk0 , vi Ã¢Â†Â’T hb01 , . . ., b0k , uk , v10 , . . ., vk0 , vk i  and, has an the effect of the reset transition, we have  that hb01 , . . ., b0k , uk , v10 , . . ., vk0 , vk i Ã¢Â†Â’T hb01 , . . ., b0k ,  uk+1 , v10 , . . ., vk0 , vk+1 i;  (return transition): hb1 , . . ., bs+1 , uk , v1 , . . ., vs+1 ,  vk i Ã¢Â†Â’T hb1 , . . ., bs , uk+1 , v1 , . . ., vs , vk+1 i, where  h(bs+1 , uk ), ÄÂƒ, ÄÂ•, r1 , X, uk+1 i Ã¢ÂˆÂˆ ÃÂ´i , vs+1 Ã¢ÂˆÂˆ ÄÂ•,  vk+1 = vs+1 Ã¢Â†Â“r1 . In the run there is the matching  call transition hb1 , . . ., bs , uk0 , v1 , . . ., vs , vs+1 i Ã¢Â†Â’T  hb1 , . . ., bs+1 , en0 , v1 , . . ., vs+1 , vs+1 Ã¢Â†Â“r10 i, where  huk0 , ÄÂƒ 0 , ÄÂ•0 , r10 , Ã¢ÂˆÂ…, (bs+1 , en0 )i Ã¢ÂˆÂˆ ÃÂ´i and vs+1 Ã¢ÂˆÂˆ ÄÂ•0 .  By inductive hypothesis, there is the run hb01 , . . .! , b0k ,  (k0 )  u, v10 , . . ., vk0 , vi Ã¢Â†Â’T hb01 , . . ., b0k , uk0 , v10 , . . ., vk0 ,  vs+1 i (k 0 < k). Has an effect of the call transition, we  have that hb01 , . . ., b0k , uk0 , v10 , . . ., vk0 , vs+1 i Ã¢Â†Â’T hb01 ,  . . ., b0k , bs+1 , en0 , v10 , . . ., vk0 , vs+1 , vs+1 Ã¢Â†Â“r10 i. By  induction hypothesis there is the run hb01 , . . ., b0k , bs+1 ,  en0 , v10 , . . ., vk0 , vs+1 , vs+1 Ã¢Â†Â“r10 i Ã¢Â†Â’Ã¢ÂˆÂ—T hb01 , . . ., b0k ,  bs+1 , uk , v10 , . . ., vk0 , vs+1 , vk i, and as a consequence  of the return transition, we have hb01 , . . ., b0k , bs+1 , uk ,  v10 , . . ., vk0 , vs+1 , vk i Ã¢Â†Â’T hb01 , . . ., b0k , uk+1 , v10 , . . .,  vk0 , vk+1 i.  Now we prove the Lemma for the RSM R.  The prove is by induction on the length k of the run  ÃÅ¥R = hb1 , . . ., bs , (u, reg)i Ã¢Â†Â’Ã¢ÂˆÂ—R hb1 , . . ., bs , (u0 , reg 0 )i.  (Base case, k = 0). Immediate.  (Inductive step, k Ã¢Â‰Ä½ 0). Suppose that the property holds  for the run of lenght k. Let us suppose hb1 , . . ., bs ,  (uk , regk )i Ã¢Â†Â’Ã¢ÂˆÂ—R hb1 , . . ., bs , (uk+1 , regk+1 )i be a run of  lenght k + 1. The (k + 1) Ã¢ÂˆÂ’ th transition can have one of  the following forms:  Ã¢Â€Ë˜ hb1 ,  . . ., bs , (uk , regk )i Ã¢Â†Â’R hb1 , . . ., bs ,  (uk+1 , regk+1 )i, where uk+1 = uk . By inductive  (k)  hypothesis, we have that hb01 , . . ., b0k , (u, reg)i Ã¢Â†Â’R  0  0  hb1 , . . ., bk , (uk , regk )i and there is the transition hb01 ,  . . ., b0k , (uk , regk )i Ã¢Â†Â’R hb01 , . . ., b0k , (uk , regk+1 )i;  Ã¢Â€Ë˜ hb1 ,  . . ., bs , (uk , regk )i Ã¢Â†Â’R hb1 , . . ., bs ,  (uk+1 , regk+1 i, where huk ,ÄÂƒ,ÄÂ•,r1 ,Ã¢ÂˆÂ…,uk+1 i Ã¢ÂˆÂˆ ÃÂ´i .  By inductive hypothesis, we have that hb01 , . . ., b0k ,  (k)  (u, reg)i Ã¢Â†Â’R hb01 , . . ., b0k , (uk , regk )i and has an  effect of the reset transition we have that hb01 , . . ., b0k ,  (uk , regk )i Ã¢Â†Â’R hb01 , . . ., b0k , (uk+1 , regk+1 )i.  ÄÂƒ  ÄÂƒ  ÄÂƒ  Definition 3: Let ÃÅ¥T =gs0 Ã¢Â†Â’0 T gs1 Ã¢Â†Â’1 T . . . Ã¢Â†Â’0 T gsi be  a run of the TRSM T . The nesting depth of ÃÅ¥T is defined  as the maximum s such that gsj = hbj1 , . . ., bjs , u, vj1 , . . .,  vjs , vj i for some 0 Ã¢Â‰Â¤ j Ã¢Â‰Â¤ i.  Lemma 2: Let u, u0 Ã¢ÂˆÂˆ Nj , then h(u, reg)i Ã¢Â†Â’Ã¢ÂˆÂ—A0  j  h(u0 , reg 0 )i iff for all v Ã¢ÂˆÂˆ reg there is v0 Ã¢ÂˆÂˆ reg 0 and hu, vi  Ã¢Â†Â’Ã¢ÂˆÂ—T hu0 , v0 i.  Proof:  (Ã¢Â‡Â’).  Let ÃÅ¥T = hu1 , v1 i Ã¢Â†Â’Ã¢ÂˆÂ—T hun , vn i be a run of T , with  u1 , un Ã¢ÂˆÂˆ Nj , v1 Ã¢ÂˆÂˆ reg1 and vn Ã¢ÂˆÂˆ regn . The proof is by  induction on nesting depth k of ÃÅ¥T .  (Base case, k = 0). In this case, every transition hui , vi i  Ã¢Â†Â’T hui+1 , vi+1 i in ÃÅ¥T , with 1 Ã¢Â‰Â¤ i Ã¢Â‰Â¤ n and ui , ui+1 Ã¢ÂˆÂˆ  Nj , can be only either a progress or a reset transition:  Ã¢Â€Ë˜ (progress transition): ui+1 = ui , vi+1 = vi + t, with  t Ã¢ÂˆÂˆ DÃ¢Â‰Ä½0 . By construction of R, there is the transition  h(ui , regi )i Ã¢Â†Â’A0j h(ui , regi+1 )i, where h(ui , regi ), ÄÂƒ,  (0)  ÃÂ´j  Ã¢Â€Ë˜  (ui , regi+1 )i Ã¢ÂˆÂˆ  Ã¢ÂŠÂ† ÃÂ´j0 , vi Ã¢ÂˆÂˆ regi and vi+1 Ã¢ÂˆÂˆ  regi+1 ;  (reset transition): vi+1 = vi Ã¢Â†Â“r1 , where hui , ÄÂƒi , ÄÂ•i , ri ,  Ã¢ÂˆÂ…, ui+1 i Ã¢ÂˆÂˆ ÃÂ´j and vi Ã¢ÂˆÂˆ ÄÂ•i . By construction of R, there  is the transition h(ui , regi )i Ã¢Â†Â’A0j h(ui+1 , regi+1 )i,  (0)  where h(ui , regi ), ÄÂƒi , (ui+1 , regi+1 )i Ã¢ÂˆÂˆ ÃÂ´j Ã¢ÂŠÂ† ÃÂ´j0 , vi  Ã¢ÂˆÂˆ regi , vi+1 Ã¢ÂˆÂˆ regi+1 and regi Ã¢ÂˆÂˆ ÄÂ•i .  (Inductive step, k > 0). Let us suppose that the nesting  depth of the run hu1 , v1 i Ã¢Â†Â’Ã¢ÂˆÂ—T hun , vn i is k + 1. The run  can have two kind of sub-runs. The first one of the form hui ,  vi i Ã¢Â†Â’Ã¢ÂˆÂ—T hui0 , vi0 i, with nesting depth s Ã¢Â‰Â¤ k and i < i0 Ã¢Â‰Â¤ n.  All sub-runs of this form have, by inductive hypothesis, the  corresponding sub-runs h(ui , regi )i Ã¢Â†Â’Ã¢ÂˆÂ—A0 h(ui0 , regi0 )i, with  j  vi Ã¢ÂˆÂˆ regi and vi0 Ã¢ÂˆÂˆ regi0 . The second one of the form hui ,  vi i Ã¢Â†Â’Ã¢ÂˆÂ—T hui0 , vi0 i with nesting depth k + 1 and i < i0 Ã¢Â‰Â¤ n.  Any such run, can be split in the following way:  hui , vi i Ã¢Â†Â’T hb, en, vi , v0 i Ã¢Â†Â’Ã¢ÂˆÂ—T hb, ex, vi , v00 i Ã¢Â†Â’T hui0 ,  vi0 i. Therefore:  0  Ã¢Â€Ë˜ since hui , vi i Ã¢Â†Â’T hb, en, vi , v i is in L(T ), then  the call transition hui , ÄÂƒ1 , ÄÂ•1 , r1 , Ã¢ÂˆÂ…, (b, en)i is in ÃÂ´j ,  with Yj (b) = i, en Ã¢ÂˆÂˆ Eni , vi Ã¢ÂˆÂˆ ÄÂ•1 , v0 = vi Ã¢Â†Â“r1 .  By construction of ÃÂ´j0 , we have that h(ui , regi ), ÄÂƒ1 ,  (b, (en, reg 0 ))i Ã¢ÂˆÂˆ ÃÂ´j0 , with vi Ã¢ÂˆÂˆ regi and v0 Ã¢ÂˆÂˆ reg 0 ;  00  Ã¢Â€Ë˜ since hb, ex, vi , v i Ã¢Â†Â’T hui0 , vi0 i is in L(T ), then  the return transition h(b, ex), ÄÂƒ2 , ÄÂ•2 , r2 , X, ui0 i is in  ÃÂ´j , with v00 Ã¢ÂˆÂˆ ÄÂ•2 and vi0 = vi Ã¢Â†Â“r2 and v00 Ã¢ÂˆÂˆ ÄÂ•2 .  0  Ã¢ÂˆÂ—  00  Ã¢Â€Ë˜ from hb, en, vi , v i Ã¢Â†Â’T hb, ex, vi , v i. By Lemma  00  0  Ã¢ÂˆÂ—  1, we can write hen, v i Ã¢Â†Â’T hex, v i. By inductive  hypothesis, we have h(en, reg 0 )i Ã¢Â†Â’Ã¢ÂˆÂ—A0 h(ex, reg 00 )i,  i  with v00 Ã¢ÂˆÂˆ reg 00 .  Since ex is reachable from en (locally in the component  machine A0i ) and there are a call and a return transitions  as above (in T ), by construction of R there is a summary  transition h(ui , regi ), ÄÂƒ1 , (ui0 , regi0 )i Ã¢ÂˆÂˆ ÃÂ´j0 and the we can  write h(ui , regi )i Ã¢Â†Â’A0j h(ui0 , regi0 )i.  (Ã¢Â‡Â).  The proof is by induction on the index k of the transition  (k)  relations ÃÂ´j .  (0)  (Base case, k = 0). Immediate, by construction, since ÃÂ´j  0  Ã¢ÂˆÂˆ ÃÂ´j .  (Inductive step, k > 0). Let us suppose, by inductive hypothesis, that the property holds for the run that have all the  (k)  transitions in ÃÂ´j . Let ÃÅ¥A0j =h(u1 , reg1 )i Ã¢Â†Â’Ã¢ÂˆÂ—A0 h(un , regn )i  j  (k+1)  be a run where at least one transition belongs to ÃÂ´j  \  (k)  ÃÂ´j . For all the transitions of the form h(ui , regi )i Ã¢Â†Â’A0j  h(ui+1 , regi+1 )i Ã¢ÂˆÂˆ ÃÅ¥A0j , with h(ui , regi ), ÄÂƒ, (ui+1 , regi+1 i  (k)  Ã¢ÂˆÂˆ ÃÂ´j , by inductive hypothesis we can write hui , vi i Ã¢Â†Â’Ã¢ÂˆÂ—T  hui+1 , vi+1 i, with vi Ã¢ÂˆÂˆ regi and vi+1 Ã¢ÂˆÂˆ regi+1 .  For all the transitions of the form h(ui , regi )i Ã¢Â†Â’A0j  h(ui+1 , regi+1 )i Ã¢ÂˆÂˆ ÃÅ¥A0j , with h(ui , regi ), ÄÂƒ, (ui+1 , regi+1 i  (k+1)  Ã¢ÂˆÂˆ ÃÂ´j  Ã¢Â€Ë˜  Ã¢Â€Ë˜  (k)  (k+1)  \ ÃÂ´j , by construction of ÃÂ´j  we have that:  there is in T a call transition hui , ÄÂƒ1 , ÄÂ•1 , r1 , Ã¢ÂˆÂ…, (b, en)i  Ã¢ÂˆÂˆ ÃÂ´j , with Yj (b) = i, en Ã¢ÂˆÂˆ Eni and regi Ã¢ÂˆÂˆ ÄÂ•i . Taking  a clock valuation vi Ã¢ÂˆÂˆ regi , we have hui , vi i Ã¢Â†Â’T hb,  en, vi , vi Ã¢Â†Â“r1 i;  there is a sub-run h(en, regi Ã¢Â†Â“r1 )i Ã¢Â†Â’Ã¢ÂˆÂ— (k) h(ex, reg 0 )i  Ai  and then there is the sub-run h(en, regi Ã¢Â†Â“r1 )i Ã¢Â†Â’Ã¢ÂˆÂ—A0  i  h(ex, reg 0 )i. By inductive hypothesis, we can write hen,  vi Ã¢Â†Â“r1 Ã¢Â†Â’Ã¢ÂˆÂ—T hex, v0 i, with v0 Ã¢ÂˆÂˆ reg 0 . By Lemma 1, we  have that hb, en, vi , vi Ã¢Â†Â“r1 i Ã¢Â†Â’Ã¢ÂˆÂ—T hb, ex, vi , v0 i;  Ã¢Â€Ë˜  there is in T the matching-return transition h(b, ex), ÄÂƒ2 ,  ÄÂ•2 , r2 , X, ui+1 i Ã¢ÂˆÂˆ ÃÂ´j , with ex Ã¢ÂˆÂˆ Exj and reg 0 Ã¢ÂˆÂˆ ÄÂ•2  (then v0 Ã¢ÂˆÂˆ ÄÂ•2 ). Then, we can write hb, ex, vi , v0 i Ã¢Â†Â’T  hui+1 , vi Ã¢Â†Â“r2 i.  Combining the facts above, we have that hu1 , v1 i Ã¢Â†Â’Ã¢ÂˆÂ—T  hun , vn i.  Now, we show that, for an untimed global state hb1 , . . .,  bs , ui of T , the global state hb1 , . . ., bs , u, v1 , . . ., vs ,  vi is reachable from an initial global state, for some clock  evaluations v1 , . . ., vs , v, iff the global state hb1 , . . ., bs ,  (u, reg)i of R is reachable from an initial global state of  R, for some region reg with v Ã¢ÂˆÂˆ reg.  Proof:  (Ã¢Â‡Â’).  By induction on the lenght k of the run.  (Base case, k = 0). Immediate.  (Inductive step, k > 0). Let ÃÅ¥T = hen, v0 i Ã¢Â†Â’Ã¢ÂˆÂ—T hb1 ,  . . ., bs , u, v1 , . . ., vs , vs+1 i, with u Ã¢ÂˆÂˆ Nj , be a run of  lenght k + 1. The (k + 1) Ã¢ÂˆÂ’ th transition can have one of  the following forms:  Ã¢Â€Ë˜  Ã¢Â€Ë˜  Ã¢Â€Ë˜  (progress transition): hb1 , . . ., bs , u, v1 , . . ., vs , v0 i  Ã¢Â†Â’T hb1 , . . ., bs , u, v1 , . . ., vs , vs+1 i, with vs+1 =  v0 + t for some t Ã¢ÂˆÂˆ DÃ¢Â‰Ä½0 . By construction of R, there  is h(u, reg), ÄÂƒ, (u, regs+1 )i Ã¢ÂˆÂˆ ÃÂ´j0 , with v0 Ã¢ÂˆÂˆ reg and  vs+1 Ã¢ÂˆÂˆ regs+1 (regs+1 is a time successor of reg). By  inductive hypothesis, we can write h(en, reg0 )i Ã¢Â†Â’Ã¢ÂˆÂ—R  hb1 , . . ., bs , (u, reg)i. By the effect of the transition  above, we have hb1 , . . ., bs , (u, reg)i Ã¢Â†Â’R hb1 , . . ., bs ,  (u, regs+1 )i. Therefore, we can conclude h(en, reg0 )i  Ã¢Â†Â’Ã¢ÂˆÂ—R hb1 , . . ., bs , (u, regs+1 )i;  (reset transition): hb1 , . . ., bs , u0 , v1 , . . ., vs , v0 i  Ã¢Â†Â’T hb1 , . . ., bs , u, v1 , . . ., vs , vs+1 i, with hu0 , ÄÂƒ,  ÄÂ•, r, Ã¢ÂˆÂ…, ui Ã¢ÂˆÂˆ ÃÂ´i , v0 Ã¢ÂˆÂˆ ÄÂ•, vs+1 = v0 Ã¢Â†Â“r and u0  Ã¢ÂˆÂˆ Nj . By construction of R, there is the transition  h(u0 , reg), ÄÂƒ, (u, regs+1 )i Ã¢ÂˆÂˆ ÃÂ´j0 , with v0 Ã¢ÂˆÂˆ reg and  vs+1 Ã¢ÂˆÂˆ regs+1 (regs+1 = reg Ã¢Â†Â“r ). By inductive  hypothesis, we can write h(en, reg0 )i Ã¢Â†Â’Ã¢ÂˆÂ—R hb1 , . . ., bs ,  (u0 , reg)i. By the effect of the transition above, we have  hb1 , . . ., bs , (u0 , reg)i Ã¢Â†Â’R hb1 , . . ., bs , (u, regs+1 )i.  Therefore, we can conclude h(en, reg0 )i Ã¢Â†Â’Ã¢ÂˆÂ—R hb1 , . . .,  bs , (u, regs+1 )i;  (call transition): hb1 , . . ., bsÃ¢ÂˆÂ’1 , u0 , v1 , . . ., vsÃ¢ÂˆÂ’1 , vs i  Ã¢Â†Â’T hb1 , . . ., bs , u, v1 , . . ., vs , vs+1 i, with hu0 , ÄÂƒ,  ÄÂ•, r, Ã¢ÂˆÂ…, (bs , u)i Ã¢ÂˆÂˆ ÃÂ´i , Yi (bs ) = j, vs Ã¢ÂˆÂˆ ÄÂ•, vs+1 =  vs Ã¢Â†Â“r and u0 Ã¢ÂˆÂˆ Ni . By construction, there is in R  a call transition h(u0 , reg), ÄÂƒ, (bs , (u, regs+1 ))i, with  vs Ã¢ÂˆÂˆ reg and vs+1 Ã¢ÂˆÂˆ regs+1 (regs+1 = reg Ã¢Â†Â“r ). By  inductive hypothesis, we can write h(en, reg0 )i Ã¢Â†Â’Ã¢ÂˆÂ—R  hb1 , . . ., bsÃ¢ÂˆÂ’1 , (u0 , reg)i. By the effect of the transition  above, we have hb1 , . . ., bs , (u0 , reg)i Ã¢Â†Â’R hb1 , . . ., bs ,  (u, regs+1 )i. Therefore, we can conclude h(en, reg0 )i  Ã¢Â†Â’Ã¢ÂˆÂ—R hb1 , . . ., bs , (u, regs+1 )i;  (return transition): if the (k + 1) Ã¢ÂˆÂ’ th transition is a  return transition, then we can split the run ÃÅ¥T in the  following way  1) a sub-run of lenght k 0 Ã¢Â‰Â¤ k in the form hen, v0 i  Ã¢Â†Â’Ã¢ÂˆÂ—T hb1 , . . ., bs , u0 , v1 , . . ., vs , v0 i, with u0 Ã¢ÂˆÂˆ  Nj . By inductive hypothesis, we have h(en, reg0 )  Ã¢Â†Â’Ã¢ÂˆÂ—R hb1 , . . ., bs , (u0 reg 0 )i, with v0 Ã¢ÂˆÂˆ reg0 and  v0 Ã¢ÂˆÂˆ reg 0 ;  2) hb1 , . . ., bs , u0 , v1 , . . ., vs , v0 i Ã¢Â†Â’T hb1 , . . ., bs+1 ,  en0 , v1 , . . ., vs , v0 , v00 i, where hu0 , ÄÂƒ1 , ÄÂ•1 , r1 , Ã¢ÂˆÂ…,  (bs+1 , en0 )i Ã¢ÂˆÂˆ ÃÂ´j is a call transition, Yj (bs+1 ) = i,  en0 Ã¢ÂˆÂˆ Eni , v0 Ã¢ÂˆÂˆ ÄÂ•1 and v00 = v0 Ã¢Â†Â“r1 . By construction of R, there is the transition h(u0 , reg 0 ),  ÄÂƒ1 , (bs+1 , (en0 , reg 00 )i, with v0 Ã¢ÂˆÂˆ reg 0 , v00 Ã¢ÂˆÂˆ  reg 00 (reg 00 = reg 0 Ã¢Â†Â“r1 ) and (since for a clock  constraint ÄÂ• belongs to a transition in T , if v Ã¢ÂˆÅº  =  v0 , then v Ã¢ÂˆÂˆ ÄÂ• iff v0 Ã¢ÂˆÂˆ ÄÂ•) reg 0 Ã¢ÂˆÂˆ ÄÂ•1 ;  3) hb1 , . . ., bs+1 , en0 , v1 , . . ., vs , v0 , v00 i Ã¢Â†Â’Ã¢ÂˆÂ—T hb1 ,  . . ., bs+1 , ex0 , v1 , . . ., vs , v0 , v000 i, with ex0  Ã¢ÂˆÂˆ Exi . By Lemma 1, we have that hen0 , v00 i  Ã¢Â†Â’Ã¢ÂˆÂ—T hex0 , v000 i. By Lemma 2, h(en0 , reg 00 )i Ã¢Â†Â’Ã¢ÂˆÂ—A0  i  h(ex0 , reg 000 )i, with v000 Ã¢ÂˆÂˆ reg 000 , namely the exit  node (ex0 , reg 000 ) is reachable from the enter node  (en0 , reg 00 ) in the component A0i ;  4) hb1 , . . ., bs+1 , ex0 , v1 , . . ., vs , v0 , v000 i Ã¢Â†Â’T hb1 ,  . . ., bs , u, v1 , . . ., vs , vs+1 i, where h(bs+1 , ex0 ),  ÄÂƒ2 , ÄÂ•2 , r2 , X, ui Ã¢ÂˆÂˆ ÃÂ´j is a return transition, v000  Ã¢ÂˆÂˆ ÄÂ•2 (then reg 000 Ã¢ÂˆÂˆ ÄÂ•2 ), vs+1 = v0 Ã¢Â†Â“r2 and vs+1  Ã¢ÂˆÂˆ regs+1 .  By construction of R, as a consequence of the  three points above, there exists a summary transition  h(u0 , reg 0 ), ÄÂƒ1 , (u, regs+1 )i Ã¢ÂˆÂˆ ÃÂ´j0 . Combining this transition with the inductive hypothesis as above, we can  conclude h(en, reg0 )i Ã¢Â†Â’Ã¢ÂˆÂ—R hb1 , . . ., bs , (u, regs+1 )i  (Ã¢Â‡Â).  The prove is by induction on the lenght k of the run.  (Base case, k = 0). Immediate.  (Inductive step, k Ã¢Â‰Ä½ 0). Let ÃÅ¥R = h(en, reg0 )i Ã¢Â†Â’Ã¢ÂˆÂ—R hb1 ,  . . ., bs , (u, regs+1 )i be a run of lenght k + 1, with u Ã¢ÂˆÂˆ Ni .  The (k + 1) Ã¢ÂˆÂ’ th transition can have one of the following  forms:  Ã¢Â€Ë˜ hb1 , . . ., bs , (u, reg)i Ã¢Â†Â’R hb1 , . . ., bs , (u, regs+1 )i,  where h(u, reg), ÄÂƒ, (u, reg)i Ã¢ÂˆÂˆ ÃÂ´i0 and regs+1 is a time  successor of reg. By construction of R, there exists in  L(T ) (LTS of T ) a progress transition hb1 , . . ., bs , u,  v1 , . . ., vs , v0 i Ã¢Â†Â’T hb1 , . . ., bs , u, v1 , . . ., vs , vs+1 i,  with vs+1 = v0 + t, t Ã¢ÂˆÂˆ DÃ¢Â‰Â¤0 , v0 Ã¢ÂˆÂˆ reg and vs+1 Ã¢ÂˆÂˆ  regs+1 . Combining the facts above with the inductive  hypothesis, we can conclude hen, v0 i Ã¢Â†Â’Ã¢ÂˆÂ—T hb1 , . . ., bs ,  u, v1 , . . ., vs , vs+1 )i;  0  Ã¢Â€Ë˜ hb1 , . . ., bs , (u , reg)i Ã¢Â†Â’R hb1 , . . ., bs , (u, regs+1 )i,  0  where h(u , reg), ÄÂƒ, (u, regs+1 )i Ã¢ÂˆÂˆ ÃÂ´i0 . By construction  of R, there exists in L(T ) a reset transition hb1 , . . .,  Ã¢Â€Ë˜  Ã¢Â€Ë˜  Ã¢Â€Ë˜  bs , u0 , v1 , . . ., vs , v0 i Ã¢Â†Â’T hb1 , . . ., bs , u, v1 , . . ., vs ,  vs+1 i, with hu0 , ÄÂƒ, ÄÂ•, r, Ã¢ÂˆÂ…, ui Ã¢ÂˆÂˆ ÃÂ´i , v0 Ã¢ÂˆÂˆ ÄÂ•, vs+1 =  v0 Ã¢Â†Â“r , v0 Ã¢ÂˆÂˆ reg and vs+1 Ã¢ÂˆÂˆ regs+1 and regs+1 =  reg Ã¢Â†Â“r . Combining the previous facts with the inductive  hypothesis, we can conclude hen, v0 i Ã¢Â†Â’Ã¢ÂˆÂ—T hb1 , . . ., bs ,  u, v1 , . . ., vs , vs+1 )i;  hb1 , . . ., bsÃ¢ÂˆÂ’1 , (u0 , reg)i Ã¢Â†Â’R hb1 , . . ., bs , (u, regs+1 )i,  where h(u0 , reg), ÄÂƒ, (bs , (u, regs+1 ))i is a call transition in ÃÂ´i0 . By construction of R, there exists in L(T ) a  call transition hb1 , . . ., bsÃ¢ÂˆÂ’1 , u0 , v1 , . . ., vsÃ¢ÂˆÂ’1 , vs i Ã¢Â†Â’T  hb1 , . . ., bs , u, v1 , . . ., vs , vs+1 i, with hu0 , ÄÂƒ, ÄÂ•, r, Ã¢ÂˆÂ…,  (bs , u)i Ã¢ÂˆÂˆ ÃÂ´i , vs Ã¢ÂˆÂˆ ÄÂ•, vs+1 = vs Ã¢Â†Â“r , vs Ã¢ÂˆÂˆ reg, vs+1 Ã¢ÂˆÂˆ  regs+1 , and regs+1 = reg Ã¢Â†Â“r . Combining the previous  fact with the inductive hypothesis, we can conclude  hen, v0 i Ã¢Â†Â’Ã¢ÂˆÂ—T hb1 , . . ., bs , u, v1 , . . ., vs , vs+1 )i;  (summary transition): if the (k+1)Ã¢ÂˆÂ’th transition is the  summary transition hb1 , . . ., bs , (u0 , reg)i Ã¢Â†Â’R hb1 , . . .,  bs , (u, regs+1 )i then the summary transition h(u0 , reg),  ÄÂƒ1 , (u, regs+1 )i is in ÃÂ´i0 . By inductive hypothesis, we  have hen, v0 i Ã¢Â†Â’Ã¢ÂˆÂ—T hb1 , . . ., bs , u0 , v1 , . . ., vs , vi,  with v Ã¢ÂˆÂˆ reg. By constraction of R, there exists a  call transition hu0 , ÄÂƒ1 , ÄÂ•1 , r1 , Ã¢ÂˆÂ…, (bs+1 , en0 )i Ã¢ÂˆÂˆ ÃÂ´i ,  with Yi (bs+1 ) = j and, therefore, the call transition  h(u0 , reg), ÄÂƒ1 , (bs+1 , (en0 , reg 0 ))i Ã¢ÂˆÂˆ ÃÂ´i0 , with reg 0 =  reg Ã¢Â†Â“r1 and reg Ã¢ÂˆÂˆ ÄÂ•1 . In addition, since v Ã¢ÂˆÂˆ reg, v  Ã¢ÂˆÂˆ ÄÂ•1 and, therefore, the call transition hb1 , . . ., bs , u0 ,  v1 , . . ., vs , vi Ã¢Â†Â’Ã¢ÂˆÂ—T hb1 , . . ., bs+1 , en0 , v1 , . . ., vs , v,  v0 i, with v0 = v Ã¢Â†Â“r1 , is in L(T ).  Again, by constraction of R, there exists the return  transition h(bs+1 , ex0 ), ÄÂƒ2 , ÄÂ•2 , r2 , X, ui Ã¢ÂˆÂˆ ÃÂ´i , and  h(en0 , reg 0 )i Ã¢Â†Â’Ã¢ÂˆÂ—A0 h(ex0 , reg 000 )i, with reg 000 Ã¢ÂˆÂˆ ÄÂ•2 . By  j  Lemma 2, we have hen0 , v0 i Ã¢Â†Â’Ã¢ÂˆÂ—T hex0 , v000 i, with v0  Ã¢ÂˆÂˆ reg 0 and v000 Ã¢ÂˆÂˆ reg 000 . Since v000 Ã¢ÂˆÂˆ reg 000 and reg 000  Ã¢ÂˆÂˆ ÄÂ•2 , then v000 Ã¢ÂˆÂˆ ÄÂ•2 . By Lemma 1, we have hb1 , . . .,  bs+1 , en0 , v1 , . . ., vs , v, v0 i Ã¢Â†Â’Ã¢ÂˆÂ—T hb1 , . . ., bs+1 , ex0 ,  v1 , . . ., vs , v, v000 i. Since v000 Ã¢ÂˆÂˆ ÄÂ•2 , then the following  transition hb1 , . . ., bs+1 , ex0 , v1 , . . ., vs , v, v000 i Ã¢Â†Â’Ã¢ÂˆÂ—T  hb1 , . . ., bs , u, v1 , . . ., vs , vs+1 i, where vs+1 = v Ã¢Â†Â“r2  is in L(T ).  We can finally conclude hen, v0 i Ã¢Â†Â’Ã¢ÂˆÂ—T hb1 , . . ., bs , u,  v1 , . . ., vs , vs+1 )i.  This end the proof.  As a consequence of Theorem 1, that estabilish an effective equivalence of TRSM and EPTA 2, and of Theorems 2  and 3, we can state the following expressiveness results.  Corollary 2: TRSM 1 (resp. EPTA 1) is a proper subclass of TRSM (resp. EPTA 2).  We conclude the section by considering the complexity  of the reachability problem, by showing that the problem  is PSPACE-complete for the subclass TRSM 0. Notice that,  the construction above shows that the reachability problem  for TRSM 1 can be solved using exponential space, since  the size of the region RSM R is exponential in the size of  the TRSM T . At the moment we have no results concerning  a strict lower bound for TRSM 1.  The idea underlying the construction for reachability in a  TRSM 0 T , is similar to the construction given above for  TRSM 1. In this case, however, we do not need to build  the region graph for T , as we can add summary transitions  directly to T . Indeed, any call transition in a TRSM 0  resets all the clocks when entering the invoked component.  Hence, the only relevant local reachability problem from an  enter to an exit node in the invoked component is the one  which assumes the clock valuation set to zero at the entry  node. This is the main difference with respect to TRSM 1,  where different clock valuations for the entry node have to  be considered, thus forcing to explicitly take into account  regions in the definition of a summary transition.  Since the number of summary transitions for TRSM 0  is clearly polynomial in the number of transitions of T ,  and local reachability in a component boils down to reachability in a Timed Automaton, which is known to be a  PSPACE-complete problem [2], we can construct, using only  polynomial space, a TRSM 0 T 0 equivalent to T from the  reachability viewpoint (see the complete work). This is done,  again, using a fix point construction, which builds a chain of  TRSM 0 T (0) , . . ., T (m) , with T (0) = T , and the transition  (k+1)  (k)  relation ÃÂ´i  (k Ã¢Â‰Ä½ 0) is ÃÂ´i augmented with summary  transitions as follows.  For every box b Ã¢ÂˆÂˆ Bi , with Yi (b) = j, for every entry node  en Ã¢ÂˆÂˆ Enj and for every return transition tex = h(b, ex), ÄÂƒ2 ,  ÄÂ•2 , r2 , X, u2 i Ã¢ÂˆÂˆ ÃÂ´i , we first build the component machine  (k)  Aj Ã¢Â†Â“tex =hNj Ã¢ÂˆÅ Bj Ã¢ÂˆÅ {u0 }, Yj , Enj , {u0 }, ÃÂ´j0 i, where:  Ã¢Â€Ë˜  (k)  ÃÂ´j0 = ÃÂ´j  Ã¢ÂˆÅ {hex, ÄÂƒ2 , ÄÂ•2 , Ã¢ÂˆÂ…, Ã¢ÂˆÂ…, u0 i}, and u0 Ã¢ÂˆÂˆ  / Nj .  Notice that, for any clock valuation v, hen, v0 i Ã¢Â†Â’Ã¢ÂˆÂ— (k)  Aj Ã¢Â†Â“tex  hu0 , vi if and only if hen, v0 i Ã¢Â†Â’Ã¢ÂˆÂ—Aj hex, vi and v Ã¢ÂˆÂˆ ÄÂ•2 .  (k)  Therefore, local reachability of u0 in Aj Ã¢Â†Â“tex ensures both  (k)  that ex is locally reachable in Aj and that tex is enabled  at the exit node, since the constraint ÄÂ•2 , occurring in tex , is  satisfied by the reached clock valuation.  (k)  Then, if u0 is locally reachable from en in Aj Ã¢Â†Â“tex , then  for all call transition hu1 , ÄÂƒ1 , ÄÂ•1 , X, Ã¢ÂˆÂ…, (b, en)i Ã¢ÂˆÂˆ ÃÂ´i , the  (k+1)  summary transition hu1 , ÄÂƒ1 , ÄÂ•1 , r2 , Ã¢ÂˆÂ…, u2 i is added to ÃÂ´i  .  Once computed T 0 , the reachability problem for an untimed global state hb1 , . . ., bs , ui in T can be solved by  checking reachability of hb1 , . . ., bs , ui in T 0 , according to  the following procedure.  Let Ai0 , Ai1 , . . ., Ais be the sequence of the invoked  components, with i0 = 1 and YijÃ¢ÂˆÂ’1 (bj ) = ij . We start by  guessing a sequence of entry nodes en0 , . . ., ens , with enj Ã¢ÂˆÂˆ  Enij . For each j Ã¢Â‰Ä½ 0, we then check whether (bj+1 , enj+1 )  is locally reachable from enj in the component Aij , where,  for the sake of local reachability, call transitions are treated  as reset transitions. Finally, we check whether u is locally  reachable from ens in the component Ais . If all the checks  are fulfilled, then reachability is ensured. Notice that each  local reachability check is a reachability analysis in a Timed  Automaton, which can be done using polynomial space.  Hence, we can conclude the following theorem:  Theorem 4: The reachability problem for TRSM 0 is  PSPACE-complete.  Proof:  Let us consider a TRSM 0 T  S = hA1 , . . ., An , Xi where,  for all 1 Ã¢Â‰Â¤ i Ã¢Â‰Â¤ n, Ai = hNi Bi , Yi , Eni , Exi , ÃÂ´i i. We  define an algorithm which enriched the transition relation  by adding summary transition. We that prove that, if T 0 is  the output of the below reported algorithm, then T 0 and T  are equivalent for reachability viewpoint. The algorithm for  augmentid T with summary transitions is the following:  REPEAT  summarized = FALSE  FOR ALL Ai  FOR ALL b Ã¢ÂˆÂˆ Bi  j = Yi (b)  FOR ALL en Ã¢ÂˆÂˆ Enj  FOR ALL tex = h(b, ex), ÄÂƒ2 , ÄÂ•2 , r2 , X, u2 i Ã¢ÂˆÂˆ ÃÂ´i  ÃÂ´j0 = ÃÂ´j Ã¢ÂˆÅ {hex, ÄÂƒ2 , ÄÂ•2 , Ã¢ÂˆÂ…, Ã¢ÂˆÂ…, u2 i}  Aj Ã¢Â†Â“tex = hNj Ã¢ÂˆÅ Bj Ã¢ÂˆÅ {u0 }, Yj , Enj , {u0 }, ÃÂ´j0 i,  0  (u Ã¢ÂˆÂˆ  / Nj )  IF treach(Aj Ã¢Â†Â“tex , en, u0 )  summarized = TRUE  FOR ALL ten = hu1 , ÄÂƒ1 , ÄÂ•1 , X, Ã¢ÂˆÂ…, (b, en)i Ã¢ÂˆÂˆ  ÃÂ´i  ÃÂ´i = ÃÂ´i Ã¢ÂˆÅ {hu1 , ÄÂƒ1 , ÄÂ•1 , r2 , Ã¢ÂˆÂ…, u2 i}  UNTIL Ã‚Å¹ summarized  In the algorithm, the function treach is the standard  procedure for the reachability problem for a Timed Automata: for instance, if exists a clock valuation v such  that the configuration hu0 , vi is reachable from the initial  configuration hen, v0 i in the Timed Automaton Aj Ã¢Â†Â“tex ,  then the output of treach(Aj Ã¢Â†Â“tex , en, u0 ) is T RU E; else  the output is F ALSE.  Let T a TRSM 0 and T 0 the TRSM 0 output of the  algorithm. In order to prove that T 0 is equivalent to T for  reachability, we need to show the following lemma.  Lemma 3: hu, vi Ã¢Â†Â’Ã¢ÂˆÂ—T hu0 , v0 i, with u, u0 Ã¢ÂˆÂˆ Nj , iff hu,  vi Ã¢Â†Â’Ã¢ÂˆÂ—A0 hu0 ,v0 i.  j  Proof:  (Ã¢Â‡Â’).  The proof is by induction on nesting depth k of the run  ÃÅ¥T = hu1 , v1 i Ã¢Â†Â’Ã¢ÂˆÂ—T hun , vn i.  (Base case, k = 0). In this case, every transition hui , vi i  Ã¢Â†Â’T hui+1 , vi+1 i in ÃÅ¥T , with 1 Ã¢Â‰Â¤ i Ã¢Â‰Â¤ n, can be only either  a progress or a reset transition:  Ã¢Â€Ë˜  (progress transition): we have that ui+1 = ui Ã¢ÂˆÂˆ Nj ,  vi+1 = vi + t, with t Ã¢ÂˆÂˆ DÃ¢Â‰Ä½0 . By construction of A0j ,  there is a progress transition hui , vi )i Ã¢Â†Â’A0j hui ,vi+1 )i;  (reset transition): we have that vi+1 = vi Ã¢Â†Â“r1 , with hui ,  ÄÂƒ1 , ÄÂ•1 , r1 , Ã¢ÂˆÂ…, ui+1 i Ã¢ÂˆÂˆ ÃÂ´j and vi Ã¢ÂˆÂˆ ÄÂ•1 . By construction  of A0j , there is a reset transition hui ,vi i Ã¢Â†Â’A0j hui+1 ,  vi+1 i.  (Inductive step, k > 0). Let us suppose that the nesting  depth of the run hu1 , v1 i Ã¢Â†Â’Ã¢ÂˆÂ—T hun , vn i is k + 1. The run  can have two kinds of sub-runs. The first one has the form  hui , vi i Ã¢Â†Â’Ã¢ÂˆÂ—T hui0 , vi0 i, with nesting depth s Ã¢Â‰Â¤ k and 1 Ã¢Â‰Â¤  i < i0 Ã¢Â‰Â¤ n. All sub-runs of this form have, by inductive  hypothesis, the corresponding sub-runs hui , vi i Ã¢Â†Â’Ã¢ÂˆÂ—A0 hui0 ,  j  vi0 i. The last one has the form hui , vi i Ã¢Â†Â’Ã¢ÂˆÂ—T hui0 , vi0 i with  nesting depth k + 1 and 1 Ã¢Â‰Â¤ i < i0 Ã¢Â‰Â¤ n. It is possible to  split all sub-runs of this form in such a way that:  Ã¢Â€Ë˜ a call transition hui , vi i Ã¢Â†Â’T hb, en, vi , vi Ã¢Â†Â“r1 i, with  hui , ÄÂƒ1 , ÄÂ•1 , r1 , Ã¢ÂˆÂ…, (b, en)i Ã¢ÂˆÂˆ ÃÂ´j , Yj (b) = i, en Ã¢ÂˆÂˆ Eni  and vi Ã¢ÂˆÂˆ ÄÂ•1 . By construction of ÃÂ´j0 , hui , ÄÂƒ1 , ÄÂ•1 , r1 , Ã¢ÂˆÂ…,  (b, en)i Ã¢ÂˆÂˆ ÃÂ´j0 ;  Ã¢ÂˆÂ—  Ã¢Â€Ë˜ a sub-run having the form hb, en, vi , vi Ã¢Â†Â“r1 i Ã¢Â†Â’T hb,  00  ex, vi , v i, with ex Ã¢ÂˆÂˆ Exi . By Lemma 1, we can write  hen, vi Ã¢Â†Â“r1 i Ã¢Â†Â’Ã¢ÂˆÂ—T hex, v00 i, with nesting depth s = k.  By inductive hypothesis there is a corresponding subrun hen, vi Ã¢Â†Â“r1 i Ã¢Â†Â’Ã¢ÂˆÂ—A0 hex, v00 i, with all transitions in  Ã¢Â€Ë˜  (k)  i  ÃÂ´i ;  00  Ã¢Â€Ë˜ a return transition tex = hb, ex, vi , v i Ã¢Â†Â’T hui0 , vi0 i,  with h(b, ex), ÄÂƒ2 , ÄÂ•2 , r2 , X, ui+1 i Ã¢ÂˆÂˆ ÃÂ´j , vi0 = vi Ã¢Â†Â“r2  and v00 Ã¢ÂˆÂˆ ÄÂ•2 .  As a consequence of the facts above, by construction  (k)  of Ai  Ã¢Â†Â“tex = hNj Ã¢ÂˆÅ Bj Ã¢ÂˆÅ {u0 }, Yj , Enj , {u0 }, ÃÂ´i0 i,  since ex is reachable from en and v00 Ã¢ÂˆÂˆ ÄÂ•2 , we have  that u0 is reachable from en (since the valuation v00 in ex  satisfies the constraint ÄÂ• of the return transition tex ) and  then treach(Ai Ã¢Â†Â“tex , en, u0 ) = T RU E. By construction of  T 0 there is a summary transition hui , ÄÂƒ1 , ÄÂ•1 , ui0 i Ã¢ÂˆÂˆ ÃÂ´j0 and  then we can write hui , vi i Ã¢Â†Â’A0j hui0 , vi0 i.  Combining the facts above, we have that hu1 , v1 i Ã¢Â†Â’T 0  hun , vn i.  (Ã¢Â‡Â).  (k)  The proof is by induction on the index k of ÃÂ´j .  (Base case, k = 0). If k = 0, there is no summary  (0)  transition in ÃÂ´j , and the property holds immediately.  (Inductive step, k > 0). Let hu1 , v1 i Ã¢Â†Â’Ã¢ÂˆÂ—A0 hus , vs i be a  j  0  (k+1)  run with at least one transition belonging to ÃÂ´j  The run ÃÅ¥A0j can be split as follows:  Ã¢Â€Ë˜  (k)  .  for each sub-run hui , vi i Ã¢Â†Â’Ã¢ÂˆÂ—A0 hui0 , vi0 i, with 1 Ã¢Â‰Â¤  j  Ã¢Â€Ë˜  0  \ ÃÂ´j  0  (k)  i < i0 Ã¢Â‰Â¤ s and all transitions in ÃÂ´j , by inductive  hypothesis we have that hui , vi i Ã¢Â†Â’Ã¢ÂˆÂ—T hui0 , vi0 i;  for each summary transition hui , ÄÂƒ1 , ÄÂ•1 , r, Ã¢ÂˆÂ…, ui+1 i  0  (k+1)  Ã¢ÂˆÂˆ ÃÂ´j  , such that hui , vi i Ã¢Â†Â’A0j hui+1 , vi Ã¢Â†Â“r i, with  1 Ã¢Â‰Â¤ i < s, we have that:  Ã¢Â€Â“ there is a call transition hui , ÄÂƒ1 , ÄÂ•1 , X, Ã¢ÂˆÂ…, (b, en)i  Ã¢ÂˆÂˆ ÃÂ´j , with Yj (b) = j 0 , such that vi Ã¢ÂˆÂˆ ÄÂ•1 ;  Ã¢Â€Â“ there is a return transition tex = h(b, ex), ÄÂƒ2 , ÄÂ•2 ,  r, X, ui+1 i Ã¢ÂˆÂˆ ÃÂ´j ;  Ã¢Â€Â“ treach(Aj 0 Ã¢Â†Â“tex , en, u0 ) is T RU E, namely hen,  v0 i Ã¢Â†Â’Ã¢ÂˆÂ—Aj0 Ã¢Â†Â“tex hex, vi Ã¢Â†Â’Aj0 Ã¢Â†Â“tex hu0 , vi, for some  clock valuation v such that v Ã¢ÂˆÂˆ ÄÂ•2 . By construction of Aj 0 Ã¢Â†Â“tex and by induction, we have that  hen, v0 i Ã¢Â†Â’Ã¢ÂˆÂ—T hui+1 , vi Ã¢Â†Â“r i.  As a consequence of the facts above, we have that hu, vi  Ã¢Â†Â’Ã¢ÂˆÂ—T hu0 , v0 i.  Now we can show that, for an untimed global state hb1 ,  . . ., bs , ui of T , the global state hb1 , . . ., bs , u, v1 , . . ., vs ,  vi is reachable, in T , from an initial global state, for some  clock evaluations v1 , . . ., vs , v, iff the global state hb1 , . . .,  bs , ui of T 0 is reachable from the initial global state of T 0 .  Proof:  (Ã¢Â‡Â’).  The proof is by induction on the lenght of the run ÃÅ¥T =  hen, v0 i Ã¢Â†Â’Ã¢ÂˆÂ—T hb1 , . . ., bs , u, v1 , . . ., vs , vs+1 i, with u Ã¢ÂˆÂˆ  Ni .  (Base case, k = 0). Immediate.  (Inductive step, k Ã¢Â‰Ä½ 0). Let ÃÅ¥T be a run of lenght k + 1.  The (k + 1) Ã¢ÂˆÂ’ th transition can have one of the following  forms:  Ã¢Â€Ë˜  Ã¢Â€Ë˜  Ã¢Â€Ë˜  Ã¢Â€Ë˜  (progress transition): hb1 , . . ., bs , u, v1 , . . ., vs , v0 i Ã¢Â†Â’T  hb1 , . . ., bs , u, v1 , . . ., vs , vs+1 i, with vs+1 = v0 + t,  t Ã¢ÂˆÂˆ DÃ¢Â‰Ä½0 . By construction we have that hb1 , . . ., bs ,  u, v1 , . . ., vs , v0 i Ã¢Â†Â’T 0 hb1 , . . ., bs , u, v1 , . . ., vs ,  vs+1 i. Combining the previous fact with the inductive  hypothesis, we have hen, v0 i Ã¢Â†Â’Ã¢ÂˆÂ—T 0 hb1 , . . ., bs , u, v1 ,  . . ., vs , vs+1 i;  (reset transition): hb1 , . . ., bs , u0 , v1 , . . ., vs , v0 i Ã¢Â†Â’T  hb1 , . . ., bs , u, v1 , . . ., vs , vs+1 i, with hu0 , ÄÂƒ, ÄÂ•, r,  Ã¢ÂˆÂ…, ui Ã¢ÂˆÂˆ ÃÂ´i , u0 Ã¢ÂˆÂˆ Ni , v0 Ã¢ÂˆÂˆ ÄÂ• and vs+1 = v0 Ã¢Â†Â“r . By  construction of T 0 , hu0 , ÄÂƒ, ÄÂ•, r, Ã¢ÂˆÂ…, ui Ã¢ÂˆÂˆ ÃÂ´i0 . Combining  this transition with the inductive hypothesis, we have  hen, v0 i Ã¢Â†Â’Ã¢ÂˆÂ—T 0 hb1 , . . ., bs , u, v1 , . . ., vs , vs+1 i;  (call transition): hb1 , . . ., bsÃ¢ÂˆÂ’1 , u0 , v1 , . . ., vsÃ¢ÂˆÂ’1 , vs i  Ã¢Â†Â’T hb1 , . . ., bs , u, v1 , . . ., vs , vs+1 i, with hu0 , ÄÂƒ, ÄÂ•,  X, Ã¢ÂˆÂ…, (bs , u)i Ã¢ÂˆÂˆ ÃÂ´j , Yj (bs ) = i, u0 Ã¢ÂˆÂˆ Nj , vs Ã¢ÂˆÂˆ ÄÂ• and  vs+1 = vs Ã¢Â†Â“X = v0 . By construction of T 0 , hu0 , ÄÂƒ, ÄÂ•,  X, Ã¢ÂˆÂ…, (bs , u)i Ã¢ÂˆÂˆ ÃÂ´j0 . Combining this transition with the  inductive hypothesis, we have hen, v0 i Ã¢Â†Â’Ã¢ÂˆÂ—T 0 hb1 , . . .,  bs , u, v1 , . . ., vs , vs+1 i;  (return transition): if the (k + 1) Ã¢ÂˆÂ’ th transition is a  return transition (tex0 ), then we can split the run ÃÅ¥T in  the following way:  1) a sub-run of lenght k 0 Ã¢Â‰Â¤ k in the form hen, v0 i  Ã¢Â†Â’Ã¢ÂˆÂ—T hb1 , . . ., bs , u0 , v1 , . . ., vs , v0 i, with u0 Ã¢ÂˆÂˆ  Ni . By inductive hypothesis we can write hen,  v0 i Ã¢Â†Â’Ã¢ÂˆÂ—T 0 hb1 , . . ., bs , u0 , v1 , . . ., vs , v0 i;  2) a matching call transition hb1 , . . ., bs , u0 , v1 , . . .,  vs , v0 i Ã¢Â†Â’T hb1 , . . ., bs , bs+1 , en0 , v1 , . . ., vs ,  v0 , v00 i, where hu0 , ÄÂƒ1 , ÄÂ•1 , X, Ã¢ÂˆÂ…, (bs+1 , en0 )i Ã¢ÂˆÂˆ  ÃÂ´i , Yi (bs+1 ) = j, en0 Ã¢ÂˆÂˆEnj , v0 Ã¢ÂˆÂˆ ÄÂ•1 and v00 =  v0 Ã¢Â†Â“X = v0 ;  3) a sub-run hb1 , . . ., bs+1 , en0 , v1 , . . ., vs , v0 , v0 i  Ã¢Â†Â’Ã¢ÂˆÂ—T hb1 , . . ., bs+1 , ex0 , v1 , . . ., vs , v0 , v000 i, with  ex0 Ã¢ÂˆÂˆ Exj . By Lemma 1 we have that hen0 , v0 i  Ã¢Â†Â’Ã¢ÂˆÂ—T hex0 , v000 i and by Lemma 3 we have that  hen0 , v0 i Ã¢Â†Â’Ã¢ÂˆÂ—Aj Ã¢Â†Â“t 0 hex0 , v000 i;  ex  4) a return transition hb1 , . . ., bs+1 , ex0 , v1 , . . ., vs ,  v0 , v000 i Ã¢Â†Â’Ã¢ÂˆÂ—T hb1 , . . ., bs , u, v1 , . . ., vs , vs+1 i,  where tex0 = h(bs+1 , ex0 ), ÄÂƒ2 , ÄÂ•2 , r2 , X, ui Ã¢ÂˆÂˆ ÃÂ´i  is a return transition, v000 Ã¢ÂˆÂˆ ÄÂ•2 and vs+1 = v0 Ã¢Â†Â“r2 .  By construction of Aj Ã¢Â†Â“tex0 , hex, ÄÂƒ2 , ÄÂ•2 , Ã¢ÂˆÂ…, Ã¢ÂˆÂ…, u00 i  Ã¢ÂˆÂˆ ÃÂ´j0 , with u00 Ã¢ÂˆÂˆ  / N . Since hen0 , v0 i Ã¢Â†Â’Ã¢ÂˆÂ—Aj Ã¢Â†Â“t 0  ex  0  000  hex , v i (see the point above) and v000 Ã¢ÂˆÂˆ ÄÂ•2 , we  can write hen0 , v0 i Ã¢Â†Â’Aj Ã¢Â†Â“t 0 hu00 , v000 i. But this  ex  implies that treach(Aj Ã¢Â†Â“tex0 , en, u00 ) is T RU E.  As consequence of the facts above, we have that there  exists in T 0 a summary transition hu0 , ÄÂƒ1 , ÄÂ•1 , r2 , Ã¢ÂˆÂ…, ui, and  then, we can write hen, v0 i Ã¢Â†Â’Ã¢ÂˆÂ—T 0 hb1 , . . ., bs , u, v1 , . . ., vs ,  vs+1 i.  (Ã¢Â‡Â).  The proof is by induction on the lenght of the run ÃÅ¥T 0 =  hen, v0 i Ã¢Â†Â’Ã¢ÂˆÂ—T 0 hb1 , . . ., bs , u, v1 , . . ., vs , vs+1 i, with u Ã¢ÂˆÂˆ  Ni .  (Base case, k = 0). Immediate.  (Inductive step, k Ã¢Â‰Ä½ 0). Let ÃÅ¥T 0 = hen, v0 i Ã¢Â†Â’Ã¢ÂˆÂ—T 0 hb1 ,  . . ., bs , u, v1 , . . ., vs , vs+1 i be a run of lenght k + 1. The  (k + 1) Ã¢ÂˆÂ’ th transition can have one of the following forms:  Ã¢Â€Ë˜  Ã¢Â€Ë˜  Ã¢Â€Ë˜  Ã¢Â€Ë˜  (progress transition): hb1 , . . ., bs , u, v1 , . . ., vs , v0 i  Ã¢Â†Â’T 0 hb1 , . . ., bs , u, v1 , . . ., vs , vs+1 i, with vs+1 =  v0 + t, t Ã¢ÂˆÂˆ DÃ¢Â‰Ä½0 . By construction we have that hb1 , . . .,  bs , u, v1 , . . ., vs , v0 i Ã¢Â†Â’T hb1 , . . ., bs , u, v1 , . . ., vs ,  vs+1 i. Combining the previous fact with the inductive  hypothesis, we have hen, v0 i Ã¢Â†Â’Ã¢ÂˆÂ—T hb1 , . . ., bs , u, v1 ,  . . ., vs , vs+1 i;  (reset transition): hb1 , . . ., bs , u0 , v1 , . . ., vs , v0 i Ã¢Â†Â’T 0  hb1 , . . ., bs , u, v1 , . . ., vs , vs+1 i, with hu0 , ÄÂƒ, ÄÂ•, r,  Ã¢ÂˆÂ…, ui Ã¢ÂˆÂˆ ÃÂ´i0 , u0 Ã¢ÂˆÂˆ Ni , v0 Ã¢ÂˆÂˆ ÄÂ• and vs+1 = v0 Ã¢Â†Â“r . By  construction of T 0 , hu0 , ÄÂƒ, ÄÂ•, r, Ã¢ÂˆÂ…, ui Ã¢ÂˆÂˆ ÃÂ´i . Combining  this transition with the inductive hypothesis, we have  hen, v0 i Ã¢Â†Â’Ã¢ÂˆÂ—T hb1 , . . ., bs , u, v1 , . . ., vs , vs+1 i;  (call transition): hb1 , . . ., bsÃ¢ÂˆÂ’1 , u0 , v1 , . . ., vsÃ¢ÂˆÂ’1 , vs i  Ã¢Â†Â’T 0 hb1 , . . ., bs , u, v1 , . . ., vs , vs+1 i, with hu0 , ÄÂƒ, ÄÂ•,  X, Ã¢ÂˆÂ…, (bs , u)i Ã¢ÂˆÂˆ ÃÂ´j0 , Yj (bs ) = i, u0 Ã¢ÂˆÂˆ Nj , vs Ã¢ÂˆÂˆ ÄÂ• and  vs+1 = vs Ã¢Â†Â“X = v0 . By construction of T 0 , hu0 , ÄÂƒ, ÄÂ•,  X, Ã¢ÂˆÂ…, (bs , u)i Ã¢ÂˆÂˆ ÃÂ´j . Combining this transition with the  inductive hypothesis, we have hen, v0 i Ã¢Â†Â’Ã¢ÂˆÂ—T hb1 , . . .,  bs , u, v1 , . . ., vs , vs+1 i;  (summary transition): if the (k + 1) Ã¢ÂˆÂ’ th transition is  a summary transition hb1 , . . ., bs , u0 , v1 , . . ., vs , v0 i  Ã¢Â†Â’T 0 hb1 , . . ., bs , u, v1 , . . ., vs , vs+1 i, where hu0 , ÄÂƒ1 ,  ÄÂ•1 , r2 , Ã¢ÂˆÂ…, ui Ã¢ÂˆÂˆ ÃÂ´i0 , u0 Ã¢ÂˆÂˆ Ni , v0 Ã¢ÂˆÂˆ ÄÂ•1 and vs+1 = v0 Ã¢Â†Â“r2 ,  then by construction of T 0 , we have that:  1) there is a call transition hu0 , ÄÂƒ1 , ÄÂ•1 , X, Ã¢ÂˆÂ…,  (bs+1 , en0 )i Ã¢ÂˆÂˆ ÃÂ´i0 , with Yi (bs+1 ) = j and en0 Ã¢ÂˆÂˆ  Enj . Since v0 Ã¢ÂˆÂˆ ÄÂ•1 (see above), we have that hb1 ,  . . ., bs , u0 , v1 , . . ., vs , v0 i Ã¢Â†Â’T hb1 , . . ., bs+1 , en0 ,  v1 , . . ., vs , v0 , v0 i;  2) treach(Aj Ã¢Â†Â“tex0 ) = T RU E, where Aj Ã¢Â†Â“tex0 =  hNj Ã¢ÂˆÅ Bj Ã¢ÂˆÅ {u00 }, Yj , Enj , {u00 }, ÃÂ´j0 i and  tex0 = h(bs+1 , ex0 ), ÄÂƒ2 , ÄÂ•2 , r2 , Ã¢ÂˆÂ…, ui Ã¢ÂˆÂˆ ÃÂ´i . But  treach(Aj Ã¢Â†Â“tex0 ) = T RU E implies that ex0 is  reachable from the configuration hen0 , v0 i with  some clock valuation v, with v Ã¢ÂˆÂˆ ÄÂ•2 . Then,  we can write hen0 , v0 i Ã¢Â†Â’Ã¢ÂˆÂ—Aj Ã¢Â†Â“t 0 hex0 , vi. By  ex  Lemma 3, we can write hen0 , v0 i Ã¢Â†Â’Ã¢ÂˆÂ—T hex0 , vi.  By Lemma 1, we have that hb1 , . . ., bs+1 , en0 , v1 ,  . . ., vs v0 , v0 i Ã¢Â†Â’Ã¢ÂˆÂ—T hb1 , . . ., bs+1 , en0 , v1 , . . .,  vs v0 , vi;  3) since v Ã¢ÂˆÂˆ ÄÂ•2 , we can write hb1 , . . ., bs+1 , ex0 ,  v1 , . . ., vs v0 , vi Ã¢Â†Â’T hb1 , . . ., bs , u, v1 , . . ., vs  vs+1 i, by the effect of the return transition tex0 ,  with vs+1 = v0 Ã¢Â†Â“r2 .  As a consequence, by applying the inductive hypothesis, we can write hen, v0 i Ã¢Â†Â’Ã¢ÂˆÂ—T hb1 , . . ., bs , v1 , . . ., vs ,  vs+1 i.  Once computed T 0 , the reachability problem for an untimed global state hb1 , . . ., bs , ui in T can be solved by  checking reachability of hb1 , . . ., bs , ui in T 0 , according to  the following procedure.  Let Ai0 , Ai1 , . . ., Ais be the sequence of the invoked  components, with i0 = 1 and YijÃ¢ÂˆÂ’1 (bj ) = ij . We start by  guessing a sequence of enter nodes en0 , . . ., ens , with enj Ã¢ÂˆÂˆ  Enij . For each j Ã¢Â‰Ä½ 0, we then check whether (bj+1 , enj+1 )  is locally reachable from enj in the component Aij , where,  for the sake of local reachability, call transitions are treated  as reset transitions. Finally, we check whether u is locally  reachable from ens in the component Ais . If all the checks  are fulfilled, then reachability is ensured. Notice that each  local reachability check is a reachability analysis in a Timed  Automaton, which can be done using polynomial space.  VI. C ONCLUSION  In this paper we have introduced TRSMs, a real time  extension of RSMs, able to model real time recursive  systems. We have shown that TRSMs allow to specify  interesting context-free properties, both on the untimed and  the timed dimensions. Though reachability of the general  framework is undecidable, we have shown that the problem  is still decidable for the meaningful classes TRSM 1 and  TRSM 0, and that it is PSPACE-complete for the class  TRSM 0, the same complexity of reachability in standard  Timed Automata.  A number of interesting issues are still to be investigated.  In particular, tight complexity results for the reachability  problem in TRSM 1 are yet to be established.  The paper focuses on the relationship with the most  related formalisms, namely PTAs and RSMs. On the other  hand, a comparison with other related formalisms need  to be settled. In particular, the undecidability proof for  EPTAs shows that they are able to simulate clock updates  (increment and decrement) similar to those provided by  Updatable Timed Automata [3]. Also the formalisms of  Stopwatch Automata [8] requires a comparison. It seems  that Stopwatch Automata can be simulated by the class  EPTA 2, while the opposite seems not to hold. Another  relevant issue concerns the study of the class of context-free  timed languages accepted by EPTAs and by their subclasses.  R EFERENCES  [1] Alur R., Benedikt, M., Etessami, K., Godefroid, P. Reps, T.  and Yannakakis, M.: Analysis of Recursive State Machines. In:  13th International Conference on Computer-aided Verification  (CAVÃ¢Â€Â™01), pp. 207Ã¢Â€Â“220.  [2] Alur R., and Dill D. L.: A Theory of Timed Automata. In:  Theoretical Computer Science, Volume 126, pages 183Ã¢Â€Â“235,  1994.  [3] Bouyer P., Dufourd C., Fleury E. and Petit A.: Updatable timed  automata, Theoretical Computer Science, vol. 321, number 2Ã¢Â€Â“  3, pages 291Ã¢Â€Â“345, 2004.  [4] Dang Z.: Pushdown timed automata: a binary reachability characterization and safety verification. In: Theoretical Computer  Science, Volume 302 , Issue 1-3, pages 93Ã¢Â€Â“121, 2003.  [5] Minsky M. L.: Computation: finite and infinite machines,  Prentice-Hall Inc., Upper Saddle River, NJ, USA., 1967.  [6] Alur R., Parthasathy M.: Decision Problems for Timed Automata: A Survey. In: Proceedings of the 4th International  School on Formal Methods for the Design of Computer,  Communication and Software System: Real Time (SFM-RT  2004), pp. 1Ã¢Â€Â“24.  [7] Bouajjani A., Echahed R., Robbana R.: On the Automatic Verification of Systems with Continuous Variables and Unbounded  Discrete Data Structures. In: Proc. Hybrid System II, LNCS  999, 1995.  [8] Cassez F. and Larsen K.: The Impressive Power of Stopwatches. In Proc. of CONCUR 2000: Concurrency Theory, pp.  138Ã¢Â€Â“152, LNCS 1877, 2000. 