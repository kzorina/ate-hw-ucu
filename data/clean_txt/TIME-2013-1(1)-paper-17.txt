2013 20th International Symposium on Temporal Representation and Reasoning  Event Algebra for Transition Systems Composition  Application to Timed Automata  Elie FARES  Jean-Paul BODEVEIX  Mamoun FILALI  IRIT, UniversiteĚ de Toulouse  IRIT, UniversiteĚ de Toulouse  IRIT, UniversiteĚ de Toulouse  AbstractâFormal speciďŹcation languages have a lot of notions  in common. They all introduce entities usually called processes,  offer similar operators, and most importantly deďŹne their operational semantics based on labeled transition systems (LTS).  However, each language deďŹnes speciďŹc synchronizing and/or  memory structures. For instance, in CSP, the synchronization  is deďŹned between identical events, while in CCS and in  synchronization vectors-based views it is deďŹned respectively  between complementary events or between possibly different  events. In this paper, we aim at capturing some similarities  of speciďŹcation languages by deďŹning a label-based composition  formal framework. Firstly, we deďŹne a high-level synchronization  mechanism in the form of an abstract label structure. We then  couple this label structure with several compositional operations  and properties. Secondly, we introduce an LTS-based behavioral  framework and deďŹne a unique LTS composition operator which  is reused to deďŹne syntactic composition of extended transition  systems and a compositional semantics.  high-level synchronization mechanism in the form of a label  structure. The label structure is abstract enough [4] so that  both homogeneous and heterogeneous system synchronization  could be described. It is equipped with a composition operator  which encapsulates the speciďŹc composition laws of each  language and would further serve as a parameter of the  behavioral framework. Thanks to the separation between the  composition laws and the behavioral framework, the latter,  which is based on LTS, offers a unique LTS composition  which is reused to deďŹne syntactic composition of timed  automata and a compositional semantics. The idea of a label  structure or similar constructs is not new since it appears  in earlier studies [14], [15], [18], [13]. In [14], [15], the  label composition operator appears under a functional form  (the same as ours, see Label Structure : Section II) but the  authors do not go beyond this deďŹnition, while in [18], [13],  it appears under a relational form. In these latter studies, the  authors are interested in reaching generic semantic rules for  process calculi behavioral operators (preďŹx, choice...). This is  orthogonal to our goal that consists in reaching a label-based  composition framework for speciďŹcation languages.  I. I NTRODUCTION  For the past three decades, speciďŹcation languages such  as CSP [17], CCS [16], LOTOS [10], Altarica [5], and  BIP [6] have proven valuable in the speciďŹcation and design of  concurrent and distributed systems. The behavioral aspects of  these languages share a common base since they all deďŹne  their operational semantics in terms of labeled transition  systems (LTS). Yet, the difference lies in the synchronizing  structure of the labels of these systems. For example in CSP  the synchronization is deďŹned between two identical events,  while in CCS and in synchronization vectors-based views,  it is deďŹned respectively between complementary events or  between possibly different events. Through the years, the basic  versions of some of these languages have been extended by  time, memory, and priority notions. Accordingly, other formalisms have emerged in order to model the semantics of these  extensions. For example, we can cite Alur and Dillâs timed automata [3] and Henzinger et alâs timed transition systems [11]  that both capture the time addition or the semantic model  of [19] used to model the priorities. However, even though  the rules of the composition operations of these formalisms  are the same in nature (synchronous and asynchronous rules),  they are well distinguished in reality, maybe because of the  speciďŹc attributes that come with each formalism. A distinct  composition operation is then introduced for each deďŹned  formalism.  In this paper, we aim at capturing some similarities of  speciďŹcation languages by providing a semantic framework  for system composition. For this purpose, we introduce a  1530-1311/13 $26.00 ÂŠ 2013 IEEE  1550-1311/13  DOI 10.1109/TIME.2013.23  Our contribution can be viewed from two perspectives. One  way is to see this work as an abstraction of the composition of  different behavioral formalisms via a separation of the labels  composition laws of each language and a reuse of the LTS  composition. In fact, depending on the language, the label  structure is deďŹned and instantiated differently. Using the  common framework, one would then proceed by giving the  semantics of other behavioral operators of the speciďŹcation  language in question. Another way to see our label structure  and their associated operations is as a generalization of the  composition functions given and used in [14], [15]. Indeed,  we show how such abstract composition functions (or label  structures in our terms) may be implemented and instantiated  to simulate existing synchronization mechanisms. Most importantly, we push forward this work by giving new deďŹnitions,  properties, and operations to manipulate such label structures.  The rest of the paper is organized as follows. In the second  section, we start by deďŹning the label structure along with its  associated properties and operations. In the third section, we  deďŹne our behavioral framework and show how it reuses the  label structure notions. We conclude the paper in the fourth  section.  111  125  II. L ABEL S TRUCTURE  We start by describing the labels of transition systems by  means of a label structure which is later used as an attribute  of transition systems.  DeďŹnition 1 (Label Structure): A label structure is a tuple  L, 1 where L is a set of labels and (1: L Ă L  L) is a  partial binary composition operator over L.  The function is partial because some composition may be  blocked since 1 describes exclusively synchronous compositions. The asynchronous aspects are covered later (see LTS  composition). Our composition then models the following  cases :  1) A successful synchronization between l and l that  results in l 1 l â L.  /  2) A blocking synchronization between l and l : (l, l ) â  dom(1).  Let the reader not confuse our label structure with other event  structuring propositions, namely with the event structures [8].  Event structures model the occurrence of events during the  system execution via the introduction of a causal dependency  relation and a conďŹict relation between the events. In our case,  we introduce a label structure which models the way the labels  (i.e., events) are statically composed.  DeďŹnition 2 (Commutativity of a Label Structure): Given  a label structure LS = L, 1, LS is said to be commutative  if its composition operator 1 is commutative. Formally, for  l1 , l2 and l3 â L, LS is commutative if :  b) Basic CSP Synchronizing Structure: Here, we model  the case of the completely synchronous composition of CSP.  For C a set of communication ports, a synchronizing structure  on C is the label structure :  SyncCSP = C, (c1 , c2 ) â c1 if c1 = c2   The synchronization of two ports of the set C is only deďŹned  when these two ports are the same. Otherwise an interleaving  occurs.  c) CCS Synchronizing Structure: For C a set of events,  C? = {c? | c â C} and C! = {c! | c â C}, this is represented  in our label structure as follows :  SyncCCS =  C?âŞC!âŞ{Ď }âŞ{(c!, c?) â Ď | c â C}, {(c!, c?) â Ď | c â C}  B. Label Structure Properties  We give the frequent label structures properties used in this  paper.  Property  Idempotency  Unique  Composition  Diagonality  DeďŹnition  âl â L,  (l, l) â dom(1) â§ l 1 l = l  âl1 l2 â L, (l1 , l2 ) â dom(1) â  / dom(1)  âl â L, ((l1 1 l2 ), l) â  â§(l, (l1 1 l2 )) â  / dom(1)  âl1 l2 â L,  (l1 , l2 ) â dom(1) â l1 = l2  Example  SyncCSP , T S  SyncCCS  SyncCSP , T S  We denote by ACI the conjunction of the associativity,  commutativity and idempotence properties. A label structure  fulďŹlling the ACI property is seen as a join semi-lattice where  1 is interpreted as the join operator and the partial order  relation l â¤ l is deďŹned by l â¤ l  l 1 l = l .  (l1 , l2 ) â dom(1) â (l2 , l1 ) â dom(1) â§ l1 1 l2 = l2 1 l1  DeďŹnition 3 (Associativity of a Label Structure): Given a  label structure LS = L, 1, LS is said to be associative if its  composition operator 1 is associative. Formally, for l1 , l2 and  l3 â L, LS is associative if it satisďŹes the following conditions  1) (l1 , l2 ) â dom(1) â§ ((l1 1 l2 ), l3 ) â dom(1) â  (l2 , l3 ) â dom(1) â§ (l1 , (l2 1 l3 )) â dom(1). This  means that independently of the composition order, they  are both deďŹned.  2) (l1 , l2 ) â dom(1) â§ ((l1 1 l2 ), l3 ) â dom(1) â  ((l1 1 l2 ) 1 l3 ) = (l1 1 (l2 1 l3 )). This means that  independently of the composition order, they both lead  to the same result.  DeďŹnition 4 (Stability of a Set of Labels): Given a label  structure LS = L, 1 and a label set G â L, we say that  G is stable over LS if â(l1 , l2 ) â dom(1), l1 1 l2 â G â  l1 â G â§ l2 â G, and â(l1 , l2 ) â dom(1), l1 â G â¨ l2 â G â  l1 1 l2 â G.  C. Composition of Label Structures  We deďŹne the product and the sum of two label structures.  The product operation builds new labels as pairs of the  composed labels. For example, this is used when composing  synchronization and memory access labels. Unlike the product  operation, the labels of the sum operation are deďŹned over the  union of the composed labels. This is used when composing  synchronization and time labels to specify that only one of the  events may occur at one time and not simultaneously.  1) Product of Label Structures: Given two label structures  L, 1 and L , 1 , their product ranges over the set P =  (L âŞ {}) Ă (L âŞ { })\{(,  )} where  (resp.  ) is a new  element of L (resp. L ) supposed to be neutral 1 for the 1  operator of its respective label structure. For l1 , l2 â L and  l1 , l2 â L , the composition of (l1 , l1 ), (l2 , l2 ) is deďŹned only  if the composition of l1 and l2 and the composition l1 and l2  are both deďŹned.  A. Label Structure Examples  a) Time Label Structure: For Î a time domain, e.g., non  negative real numbers, naturals . . . , equipped with a binary  associative operator + and a neutral element 0, we introduce  the time structure T S on the domain Î. Its composition  operator is only deďŹned between identical time labels Î´ and  returns the label itself.    P,  T S = Î, (Î´1 , Î´2 ) â Î´1 if Î´1 = Î´2   1 If  126  112  L, 1 â L , 1  =  (l1 , l1 ), (l2 , l2 ) â (l1 1 l2 , l1 1 l2 )  if (l1 , l2 ) â dom(1) â§ (l1 , l2 ) â dom(1 )      L had already a neutral element , we suppose that n 1  =  1 n = n.  2) Sum of Label Structures: Given L, 1 and L , 1 ,  their sum ranges over the union of Lâ˘ âŞ â˘ L where Lâ˘ =  {lâ˘ | l â L} and â˘ L = {â˘ l | l â L }.  L, 1 â L , 1  =  Lâ˘ âŞ â˘ L ,    â˘  l1 â˘ , l2 â˘ â (l1 1 l2 ) if (l1 , l2 ) â dom(1)  â˘  l1 , â˘ l2 â â˘ (l1 1 l2 ) if (l1 , l2 ) â dom(1 )      Proposition 1 (Preservation of ACI ): Given LS and LS  ,  if LS and LS  satisfy one of the ACI properties then LS â  LS  and LS â LS  satisfy this same property.  A label structure transformation is used to map labels from a  label structure to another. We start by giving the deďŹnition of a  transformation followed by instances of such transformations.  DeďŹnition 5 (Transformation): A transformation f between  two label structures LS1 = L1 , 11  and LS2 = L2 , 12  is  deďŹned as a partial morphism f from LS1 labels to LS2 labels  such that :  â˘  â˘  Inl  Inr  ââ  â  â  Outl  Outr  Extl  Extr  P rjl  P rjr  â  â  â  â  â  â  ââ  â  â  ââ  Signature  Embedding  LS1  LS1 â LS2  LS2  LS1 â LS2  Retraction  LS1 â LS2  LS1  LS1 â LS2  LS2  Extension  LS1  LS1 â LS2  LS2  LS1 â LS2  Projection  LS1 â LS2  LS1  LS2 â LS1  LS2  (tr : LS1  LS2 )  â  LS1 â LS  LS2 â LS  T r Inr  (âLSâ  LSâ )  (tr : LS1  LS2 )  â  LS â LS1  LS â LS2  T r Extl  (ââLS  âLS )  (tr : LS1  LS2 )  â  LS1 â LS  LS2 â LS  T r Extr  (âLSâ  LSâ )  (tr : LS1  LS2 )  â  LS â LS1  LS â LS2  â˘  l1 â â˘ tr(l1 )  lâ˘ â lâ˘  â§  â¨(l1 , l2 ) â (tr(l1 ), l2 )  (, l2 ) â (, l2 )  âŠ(l , ) â (tr(l ), )  1  1  â§  â¨(l1 , l2 ) â (l1 , tr(l2 ))  (, l2 ) â (, tr(l2 ))  âŠ(l , ) â (l , )  1  1  A. Labeled Transition System (LTS)  DeďŹnition 6 (Labeled Transition System LTS): Given  LS = L, 1, a labeled transition system L over LS âdenoted  as LLS â is deďŹned as Q, Q0 â Q, T â Q Ă L Ă Q where  Q, Q0 , T denote respectively the sets of states, initial states,  and transitions. We denote by LT SLS the set of LTSs over  LS.  l  We write q â q  for an element (q, l, q  ) of T . Furthermore,  we deďŹne the alphabet of an LLS âdenoted as ÎąLLS â as the  set of labels that are actually used by the transitions of LLS :  l  ÎąLLS = {l â L | âq q  , q â q  â T }.  DeďŹnition 7 (Bisimulation): Given ALS = Qa , Q0a , Ta   and CLS = Qc , Q0c , Tc , a relation R â Qc Ă Qa deďŹnes  a simulation between CLS and ALS denoted as CLS R ALS  iff : (1) âqc0 â Q0c , âqa0 â Q0a such that (qc0 , qa0 ) â R and (2)  l  âqc , qc , qa , l if qc â qc and (qc , qa ) â R, âqa â Qa such that  l  qa â qa and (qc , qa ) â R.  Two LTSs LLS and L LS are said to be bisimilar through the  relation R â Q Ă Q denoted as LLS R L LS if LLS R  L LS and L LS Râ1 LLS . Furthermore, we say that LLS and  L LS are state-bisimilar if transition labels are not required to  match.  DeďŹnition 8 (LTS Diagonality, Idempotency and Determinism):  An LTS is said to be diagonal (resp. idempotent) if  the restriction of its label structure to the LTS alphabet is  diagonal (resp. idempotent). An LTS is said to be deterministic  l  l  if whenever q â q  and q â q  then q  = q  . In the rest of  the paper, this set of LTS properties will be named DID.  1) LTS Composition: Given two LTSs deďŹned over L, 1,  a set S â L denoting the allowed synchronization results, and  two sets of labels Al and Ar denoting respectively the left and  right interleaving labels, the label composition function 1 is  A  A  extended to an LTS composition function l 1 r as follows:  We write f : LS1  LS2 to denote such transformations.  1) Basic Transformations: Given two label structures LS1  and LS2 , we deďŹne label structure transformations which  are used to embed a label into a sum of labels, destruct  a label sum, extend a label to a couple of labels, or also  project a couple of labels to an element of the couple. These  transformations are given in the following table :  Notation  T r Inl  (ââLS  âLS )  tr   Transformation  l1 â˘ â tr(l1 )â˘  â˘l â â˘l  III. B EHAVIORAL F RAMEWORK  ran(11 ) â dom(f ).  âl, l â dom(f ), (l, l ) â dom(11 ) â (f (l), f (l )) â  dom(12 ).  âl, l â dom(f ), (l, l ) â dom(11 ) â f (l 11 l ) =  f (l) 12 f (l ).  Name  Signature  We note here that the transformation properties are satisďŹed  by the resulting functions. The previous four transformations  also preserve the injectivity of tr.  D. Label Structure Transformations  â˘  Name  DeďŹnition  l â lâ˘  l â â˘l  lâ˘ â l  â˘  lâl  l â (l, )  l â (, l)  (l, ) â l  (, l) â l  It is not difďŹcult to see that the transformation properties  (DeďŹnition 5) are satisďŹed by the transformations we have  deďŹned. We note that all these transformations are injective.  2) High-Level Transformations: Given the label structures  2  LS, LS1 , LS2 , and âLS  LS1 a transformation from LS1 to LS2 ,  we deďŹne the following four high level transformations :  S  Q1 , Q01 , T1  1  Al  S  Ar  Q2 , Q02 , T2  = Q1 Ă Q2 , Q01 Ă Q02 , T   where the set T is deďŹned by the following rules :  127  113  l  q1 â1T1  q1  l  q2 â2T2  q2  (l1 , l2 ) â dom(1) â§ (l1 1 l2 ) â S  l 1l  (q1 , q2 ) 1âT2 (q1 , q2 )  Corollary 2: Given an associative label structure LS =  L, 1, the label set S â L, the LTSs L1LS , L2LS , and L3LS  we have :  1) L1 1(L2 1L3 )  (L1 1L2 )1L3 if S, S  are  S YNC  S  l  q1 â1T1 q1 l1 â Al  l  (q1 , q2 ) â1T (q1 , q2 )  l  q2 â2T2 q2 l2 â Ar  l  (q1 , q2 ) â2T (q1 , q2 )  I NTERLEAVINGR  S is omitted when it is equal to L. In this case, if Al = Ar = â  then 1 is a fully synchronous composition operator.  Theorem 1 (Bisimulation Compatibility ): Given the LTSs  L1 , L 1 , L2 , and L 2 deďŹned over the label structure LS, we  have :  L1  L2 â§ L 1  L 2 â L1 l 1  A  Ar  S  L 1  L2 l 1  A  S  Ar  S  A  L1  1   Ar1  [f ]Q, Q0 , â1  =  Q, Q0 , â2 = {(q, f (l), q  ) | l â dom(f ) â§ (q, l, q  ) ââ1 }  A  S1  (L2  Al2  1   Ar2  S2  Proposition 5 (Transformation Bisimulation Compatibility):  Given LS1 = L1 , 11 , LS2 = L2 , 12 , two LTSs L1 and  L2 both over LS1 , and a transformation f : LS1  LS2 ,  L1  L2 â [f ](L1 )  [f ](L2 ).  Theorem 3 (Transformation Compositionality): Given  LS1 = L1 , 11 , LS2 = L2 , 12 , two LTSs L1 and L2 both  over LS1 , and an injective transformation f : LS1  LS2  such that dom(f ) is stable over LS1 , we have :  A  [f ](L1 l 1  S  L3 )  Al1  1   S1  Ar1  L2 )  Al2  1   S2  Ar2  Ar  L2 )  [f ](L1 )  f (Al )   1   f (S)  f (Ar )  [f ](L2 )  Proof: We only sketch the proof of the synchronous case.  Given LS1 , LS2 , LLS1 , and L LS1 , we prove that the two  sides are bisimilar through the identity relation. The proof is  based on showing that each transition of the ďŹrst system can be  found in the second system and vice versa. It is depicted in the  following implications which can be read from bottom to top  and vice versa from either sides of the parentheses. The main  points of this proof are ďŹrst the use of the stability hypothesis  so that we conclude that when l â dom(f ) then l1 , l2 â  dom(f ) and conversely, second the use of the injectivity of  f in order to connect the two branches of the proof.    (L1  S  The label structure of an LTS may be changed in a composition such as making local a global event (CSP hide) or  changing its name (CSP Rename). Here, we consider some  LTS labels transformations by extending the label structure  transformations to LTS transformations.  DeďŹnition 9 (LTS Transformation): Given two label structures LS1 and LS2 , and a transformation f : LS1  LS2 , we  deďŹne [f ] : LLS1 â LLS2 as :  Theorem 2 (Associativity of l 1 r ): Given LS = L, 1  S  , the label sets Al1 , Ar1 , Al2 , Ar2 , S1 , S2 â L, and the LTSs  L1LS , L2LS , and L3LS . If LS is associative, S1 , S2 , Ar1 , Al2  are stable over LS, and either one of the following conditions  is satisďŹed :  1) Ar2 âŠ ÎąL3 = â and Al1 âŠ ÎąL1 = â.  2) Al1 â Al2 , Ar2 â Ar1 , S2 âŠ Al1 = â, and S1 âŠ Ar2 = â.  3) Al1 â Al2 , Ar2 â Ar1 , S â Al1 , S â Ar2 , and S1 =  S2 .  We have :  Al1  S  B. LTS Transformations  L 2  This theorem allows us to reason by making use of substitution  by bisimulation.  Proposition 2 (Synchronous Composition ): Given  two  LTSs L1 and L2 deďŹned over the label structure LS, we have  L1 1L2  L1 1L2 if S is stable over LS, ÎąL1 â S, and  S  ÎąL2 â S.  A  A  two  Proposition 3 (Commutativity of l 1 r ): Given  S  LTSs L1 and L2 deďŹned over the label structure LS, we have  A  A  A  A  L1 l 1 r L2  L2 r 1 l L1 if LS is commutative.  S  S  stable over LS 2 . This ďŹrst proposition is the same as  the weak associativity theorem of the CSP generalized  parallel operator [17]. The hypothesis added in our  context are satisďŹed by the label structure associated to  CSP.  2) L1 1(L2 1L3 )  (L1 1L2 )1L3 if S, S  are  S  S  stable over LS and ÎąL1 â S.  Proposition 4 (Idempotency of 1): Given LS = L, 1  and LLS , if LLS is DID then 1 is idempotent meaning  that LLS 1LLS  LLS .  I NTERLEAVINGL  L3  The conditions of this theorem are only sufďŹcient conditions  and have been selected in order to ďŹt with our needs. Other  conditions can be found in other contexts, for example the  CSP context [17].  We note how the third set of sufďŹcient conditions satisfy  the CCS parallel composition. In this case, this result can be  instantiated by taking S = Al1 = Al2 = Ar1 = Ar2 = L  which leads to the following CCS associativity corollary.  Corollary 1 (CCS Associativity): The CCS parallel composition operator is associative.  Other associativity corollaries may also be deduced such as  the followings :  Proposition 6 (Preservation of DID properties): Given  two label structures LS1 , LS2 , an injective transformation  f : LS1  LS2 , and an LTS L over LS1 , each of the  2S  128  114  is the complement of S.  â  l  l  l1   l2   1  2      q1 , q2 â  q2 , l = l1 1 l2 q1 â q1 , l1 â dom(f ) q2 â q2 , l2 â dom(f )  q1 â  â  â  )  f  (l  f (l2 )  l  1  â (q1 , q2 ) â  (q1 , q2 ) , l â dom(f )  q1 â q1  q2 â q2  l = l1 1 l2  â  f (l)  (q1 , q2 ) â (q1 , q2 )  (q1 , q2 )  DID properties is preserved by the transformation f .  Formally, for P a DID property we have : P (L) â P ([f ]L).  f (l)=f (l1 )1f (l2 )  ââ  â  â  â  â  â  (q1 , q2 )  3) Timed Automata Label Structure: Given a set of clocks  C, we deďŹne a timed automaton as an LTS such that its  transitions are labeled by communication channels (deďŹned  by some label structure LS), guards (the label structure G)  and reset actions (the label structure A). For this moment, LS  is left undeďŹned and can either model the CCS-based synchronization or the CSP-based one. Given a label structure LS, a  timed automaton (TA) over LS is an LTS over LS â G â A.  IV. T IMED S YSTEMS  A. Timed Transition Systems (TTS)  DeďŹnition 10 (TTS): Given a label structure LS = L, 1,  a Timed Transition System (TTS) over LS is an LTS over  LS â T S.  DeďŹnition 11 (TTS composition): Thanks to the introduction of our label structure, the TTS composition is the composition of the underlying LTSs.  T ALS = LT SLSâGâA  DeďŹnition 12 (TA Composition): Thanks to our label structure, the TA composition is deďŹned as the composition of the  underlying LTS systems.  4) TA Semantics: The semantics of a timed automaton is a  TTS over LS â G â A. In the following we denote GA for  (G â A).  Lemma 1: If LS is associative (commutative) 3 then LS â  GA â T S is associative (commutative).  Proof: G, A, and T S are associative (commutative). By  Proposition 1, â and â preserves the associativity (commutativity).  The TA semantics is given via a composition with a clock  manager Clk deďŹned over GA â T S (Fig 2).  B. Timed Automata (TA)  We consider ďŹrst a deďŹnition of timed automata [3] in  which no invariants are associated to its locations (this is  close to a timed graph [2] since neither invariants nor committed states are modeled). The transitions are in the form of  guard/event/reset where the guards contain a conjunction of  constraints represented as clock intervals and the reset actions  consist in a set of clocks to be reset. This is represented  as a product of three label structures. The ďŹrst manages the  synchronization events, the second manages clock guards, and  the third manages the clock reset. In the rest of this paper, we  consider a set C of clocks and a time domain Î (e.g. R+ ).  1) Guard Label Structure: Based on the Alur Dill timed  automata [3], a guard is a conjunction of interval constraints  associated to clocks. Here, this is modeled as a function C â  2Î . The guard label structure is deďŹned as :                             G  C â 2Î , (g1 , g2 ) â (c â g1 (c) âŠ g2 (c))  The guard label structure is ACI.  2) Action Label Structure: Based on the Alur Dill timed  automata [3], an action associated to a discrete transition can  reset some clocks while keeping the other clocks managed  by the current timed automaton unchanged. In order to allow  the composition of reset actions, the clocks not managed by  a given timed automaton are left undetermined. Consequently  an action is modeled by two disjoint sets r denoting the clocks  to be reset and u denoting the clocks to be left unchanged.  Their composition is deďŹned by respectively the union of the  reset sets and the union of the unchanged sets provided that  the reset and the unchanged sets are disjoint.  Fig. 1.               Semantics of TA via a Composition of Two LTSs  a) Clock Manager: The Clk automaton contains variables (denoted as cĚ) corresponding to the clocks c of C.  It has two types of transitions. The ďŹrst type correspond to  transitions of time evolution labeled by â˘ Î´ in which after  each possible delay all of the clocks are incremented by the  amount of this delay. The second type correspond to discrete  â˘  transitions labeled by g, (r, u) in which certain clocks are  checked against their guard constraints (cĚ â g(c)), and clocks  belonging to r are reset. In order to impose the determinism  of Clk, we suppose that râŞu = C in Clk, but we synchronize  labels l of ta with labels l of Clk when l â¤ l . We recall that  A   {(r, u) â 2C Ă 2C | r âŠ u = â},  ((r1 , u1 ), (r2 , u2 )) â (r1 âŞ r2 , u1 âŞ u2 )  if r1 âŠ u2 = r2 âŠ u1 = â  The action label structure is ACI.  3 This  129  115  is veriďŹed for both of CCS and CSP.  this partial order relation â¤ has been deďŹned from the join  operator in Section II-B.  Since Clk is diagonal, idempotent, and deterministic, it  follows that Clk1Clk  Clk (Proposition 4).  b) Reconstructing the TA Semantics: The TA semantics  is deďŹned by means of a composition between the syntactic  ta and Clk where ta transmits the clock commands to Clk.  Since the LTS composition is deďŹned over the same label  structure, then the label structures on which ta and Clk are  deďŹned have to be adapted so that they both become deďŹned  over LSâGAâT S. More precisely, we use the left embedding  transformation for ta and the transformed right extension for  Clk. This is formally deďŹned as :  S  [[ta]] = (ta âLSâGAâT    LSâGA  1  (LSâGA)â˘  Theorem 5: Given a timed automaton where each transition  is labeled by an action (not by  labels introduced by the  label structure product), its standard and proposed (revised)  semantics are state-bisimilar through the identity relation.  C. Timed Automata with Invariants  We now add state invariants to timed automata as deďŹned  in [12].  1) Invariant Label Structure: Here we consider an invariant  to be an upper bound constraint that may be associated to each  clock. It is deďŹned as a partial function from clocks to the  time domain Î. The composition of two invariants associates  to each clock, when it exists, the minimum of the two bounds.  The invariant label structure is deďŹned as :  S LSâGA   Clk(ââT  ))  âT S âGA  Theorem 4 (TA Semantics Compositionality): Given two  timed automata ta1 and ta2 , [[ta1 1ta2 ]]  [[ta1 ]]1[[ta2 ]].  Proof: This proof is based on proving the bisimulation  between the semantics of the composition of ta1 and ta2 and  the composition of their semantics. We start by unfolding the  semantics of the TA composition [[ta1 1ta2 ]] and by applying  a sequence of bisimulations we reach [[ta1 ]]1[[ta2 ]]. In the  S  following proof we denote   1 â˘  by  and âLSâGAâT  LSâGA  I  C  Î,  (i1 , i2 ) â (c â  The invariant label structure is ACI.  2) Timed Automata with Invariants Label Structure: Given  a set of clocks C, we deďŹne a timed safety automaton (TSA) as  an LTS such that its transitions are labeled by communication  channels (deďŹned by some label structure LS), guards (the  label structure G) and reset actions (the label structure A).  Furthermore, invariants which are usually attached to locations, are here stored on special looping transitions in order  to synchronize with the Invariant Clock controller (IClk in  paragraph IV-C3a).  Given a label structure LS, a timed safety automaton over  LS is an LTS over LS â G â A â I.  (LSâGA)  S  by âââT  .  â  S  S  S  S  (ta1 âââT  Clk âLSâGAâT  )1(ta2 âââT  Clk âLSâGAâT  )  â  â  GAâT S  GAâT S   {Associativity : Corollary 1.2}  S  S  S  S  (ta1 âââT  (Clk âLSâGAâT  1(ta2 âââT  Clk âLSâGAâT  )))  â  â  GAâT S  GAâT S   {Commutativity : Proposition 3}  ââT S  ââT S  LSâGAâT S  LSâGAâT S  (ta1 ââ  ((ta2 ââ  Clk âGAâT S  )1Clk âGAâT S  ))   {Associativity : Corollary 1.2}  S  S  S  S  (ta1 âââT  (ta2 âââT  (Clk âLSâGAâT  1Clk âLSâGAâT  )))  â  â  GAâT S  GAâT S   {Idempotency : Proposition 4}  S  S  S  (ta1 âââT  (ta2 âââT  Clk âLSâGAâT  ))  â  â  GAâT S   {Associativity : Corollary 1.1}  ââT S  ââT S  LSâGAâT S  ((ta1 ââ  ta2 ââ  )  Clk âGAâT S  )   {Synchronous Composition : Proposition 2}  ââT S  ââT S  LSâGAâT S  ((ta1 ââ  1ta2 ââ  )  Clk âGAâT S  )  T SALS = LT SLSâGâAâI  DeďŹnition 13 (TSA Composition): Thanks to our label  structure, the TSA composition is deďŹned as the composition  of the underlying LTS systems.  3) TSA Semantics: The semantics of a timed safety automaton is a LTS over LS â GA â I â T S.  Lemma 2: If LS is associative (commutative) then LS â  GA â I â T S is associative (commutative).  Proof: G, A, I and T S are associative (commutative).  By Proposition 1, â and â preserves the associativity (commutativity).  The TSA semantics is given via a composition with an  invariant clock manager IClk deďŹned over GA â I â T S  (Fig 2).  a) Invariant Clock Manager : The IClk automaton  extends the Clk automaton by constraining the time elapsing.  It synchronizes on the invariant speciďŹed by the user-provided  timed automaton, and on any GA label operator that is equal  to the GA label provided by the timed automaton.  Since IClk is diagonal, idempotent, and deterministic, it  follows that IClk1IClk  IClk (Proposition 4).   {Transformation Compositionality : Theorem 3}  S  S  ((ta1 1ta2 ) âââT   Clk âLSâGAâT  )  â  GAâT S  Of course, the hypothesis of the applied results have been  â˘  veriďŹed. Namely, (LS â GA) is stable over LS â GA â T S,  â˘  LSâGAâT S  â (LS â GA) , DID is preserved by the  Îąta1 âLSâGA  transformations, Clk veriďŹes the DID properties, the product  and the transformation are compatible w.r.t bisimulation and  Lemma 1.  5) Comparison with Standard TA Semantics: We now state  the equivalence between our TA semantics and the standard  one. We start by deďŹning the standard TA semantics by the  function [[ ]]std : LT SLSâGA â LT SLSâGAâT S such that  [[Q, Q0 , â]]std = Q Ă (C â R+ ), Q0 Ă {c : C â 0}, âs   where :  (l,(g,(r,u)))  q ââââââââq  ,    câC  v(c)âg(c) ,    câr  v  (c)=0 ,    câu  â§  â¨min(i1 (c), i2 (c)) if c â dom(i1 ) âŠ dom(i2 )  i1 (c) if c â dom(i1 ) \ dom(i2 )  )  âŠi (c) if c â dom(i ) \ dom(i )  2  2  1  v  (c)=v(c)  (l,(g,(r,u)))  (q,v)ââââââââs (q  ,v  )  Î´  (q,v)âs (q,v+Î´)  130  116  or by composing the original LTS with the one provided with  the extension.  We show that these two methods are equivalent and that,  provided some hypothesis, the semantics of the extension is  compositional.                                        Fig. 2.       A. Semantic Extension  Given a label structure LS1 , we introduce an extension label  structure LS2 supposed to be ACI, and its semantics deďŹned  by an LTS C(the controller) over LS2 â LS3 .  We deďŹne the extended semantics by the function [[ ]]std  :  C  LT SLS1 âLS2 â LT SLS1 âLS2 âLS3 such that [[L =  0  0  Q, Q0 , â]]std  C = Q Ă QC , Q Ă QC , âs  where :        Semantics of TSA via a Composition of Two LTSs  b) Reconstructing the TSA Semantics: As before, the  TSA semantics is deďŹned by means of a composition between  the syntactic tsa and IClk. The semantics of a timed safety  automaton is reconstructed as follows :  l2 â˘  (l1 ,l2 )  qâ  ââââq , qC âââqC , l2 â¤l2  (l1 ,l2 )â˘   )  (q,qC )âââââs (q  ,qC  â˘l  (l,)  q âââq     qC âqC   )  (q,qC )ââââs (q  ,qC   )  (q,qC )âs (q,qC  â˘l  (l,)â˘  [[tsa]] =  IâT S  )1  (tsa(âLSâGAâ  LSâGAâ âI  S LSâGA  Clk(ââIâT  ))  âIâT S âGA  The semantic LTS is deďŹned over the product of the state  space of the syntactic LTS L and the controller C. Its transitions are built by joining transitions on LS1 â LS2 and  adding transitions over LS3 . In order to allow the composition  with user-given LTSs, we add non-determinism through the  introduction of the label l2 such that l2 â¤ l2 . Coming back to  Timed Automata, this corresponds to making at least the resets  and the unchanged actions asked by the user. Unreferenced  clocks can be freely modiďŹed which allows parallel LTSs to  impose their own modiďŹcations.  This semantics is shown to be equivalent to the following  one which reuses the label structure operators  Theorem 6 (TSA Semantics Compositionality): Given two  timed safety automata tsa1 and tsa2 , [[tsa1 1tsa2 ]]   [[tsa1 ]]1[[tsa2 ]].  Proof: This proof is similar to the TA Semantics Compositionality proof.  4) Comparison with Standard TSA Semantics: We now  state the equivalence between our TSA semantics and the  derived standard one in which a speciďŹc encoding of the state  invariant is taken into account. We start by deďŹning the standard TSA semantics by the function [[ ]]std : LT SLSâGAâI â  LT SLSâGAâIâT S such that [[Q, Q0 , â]]std = Q Ă (C â  R+ ), Q0 Ă {c : C â 0}, âs  where :  (l,(g,(r,u)))  q ââââââââq ,      câC  v(c)âg(c) ,    câr    v (c)=0 ,    câu  1 âLS2 âLS3    [[L]]C = (L âLS  LS1 âLS2    v (c)=v(c)  i  3 LS1 âLS2   C(ââLS  ))  âLS3 âLS2  Theorem 8 (Extension Semantic): Given two LTSs L over  LS1 â LS2 and C over LS2 â LS3 with LS2 ACI, [[L]]std  C  and [[L]]C are state-bisimilar through the identity relation if  the following conditions hold :  â˘ transitions of L are not of the form (l, ),  â˘ the LS2 labels of the transitions of C are maximal for â¤.  (l,(g,(r,u)))  (q,v)ââââââââs (q  ,v  )  q âq  1  (LS1 âLS2 )â˘  âcâC,v(c)+Î´â¤i(c)  Î´  (q,v)âs (q,v+Î´)  Remark that a disjunctive invariant can be modeled using  several looping transitions (second rule).  Theorem 7: Given a timed safety automaton where each  transition is labeled by an action (not by  labels introduced by  the label structure product), its standard and proposed (revised)  semantics are state-bisimilar through the identity relation.  B. Compositionality  The compositionality result concerning the parallel operator  of timed automata can be generalized as follows :  Theorem 9 (Generalized Compositionality): Given  two  LTSs L1 and L2 over LS1 â LS2 and a controller C over  LS2 â LS3 , we have  V. T OWARDS G IVING L IFE TO L ABEL S TRUCTURES  In this section, we show how the previous semantic deďŹnitions could be generalized by attaching behaviors to label  structures. For this purpose, we abstract the timed automata  semantic construction by associating a behavior to label  structures in the form of an LTS. Starting from an LTS  built on a given label structure, a syntactic extension can  be reached by composing labels with those of a new label  structure (for instance, as we have seen, extending LTS to  Timed Automata by adding action and guard labels). The  corresponding semantics can be deďŹned either by overlaying  [[L1 1L2 ]]C  [[L1 ]]C 1[[L2 ]]C  if the following conditions hold :  â˘ LS1 and LS3 are associative and commutative.  â˘ LS2 is ACI.  â˘ C is DID.  This theorem has a similar proof as the timed automata one.  Furthermore, all the hypothesis are satisďŹed in the timed  automata context.  131  117  [2] R. Alur, C. Courcoubetis, and D. Dill. Model-checking in dense realtime. Inf. Comput., 104(1):2â34, May 1993.  [3] R. Alur and D. L. Dill. A theory of timed automata. Theor. Comput.  Sci., 126(2):183â235, Apr. 1994.  [4] F. Arbab. Abstract behavior types: a foundation model for components  and their composition. Sci. Comput. Program., 55(1-3):3â52, Mar. 2005.  [5] A. Arnold, G. Point, A. Griffault, and A. Rauzy. The AltaRica formalism  for describing concurrent systems. Fundam. Inf., 40(2-3):109â124, 1999.  [6] A. Basu, M. Bozga, and J. Sifakis. Modeling heterogeneous real-time  components in bip. In SEFM, pages 3â12. IEEE Computer Society,  2006.  [7] G. Behrmann, A. David, and K. G. Larsen. A tutorial on uppaal. In  M. Bernardo and F. Corradini, editors, International School on Formal  Methods for the Design of Computer, Communication, and Software  Systems, SFM-RT 2004. Revised Lectures, volume 3185 of Lecture Notes  in Computer Science, pages 200â237. Springer Verlag, 2004.  [8] W. Brauer, W. Reisig, and G. Rozenberg, editors. Petri Nets: Central  Models and Their Properties, Advances in Petri Nets 1986, Part II,  Proceedings of an Advanced Course, Bad Honnef, 8.-19. September  1986, volume 255 of Lecture Notes in Computer Science. Springer, 1987.  [9] P. Farail, P. GauďŹllet, F. Peres, J.-P. Bodeveix, M. Filali, B. Berthomieu,  S. Rodrigo, F. Vernadat, H. Garavel, and F. Lang. FIACRE: an intermediate language for model veriďŹcation in the TOPCASED environment. In  European Congress on Embedded Real-Time Software, ERTSâ08, 2008.  [10] I. O. for Standardization. Information processing systems - open systems  interconnection - LOTOS - a formal description technique based on the  temporal ordering of observational behaviour. International standard.  ISO, 1989.  [11] T. Henzinger, Z. Manna, and A. Pnueli. Timed transition systems. In  J. de Bakker, C. Huizing, W. de Roever, and G. Rozenberg, editors, RealTime: Theory in Practice, volume 600 of Lecture Notes in Computer  Science, pages 226â251. Springer, 1992. 10.1007/BFb0031995.  [12] T. A. Henzinger, X. Nicollin, J. Sifakis, and S. Yovine. Symbolic model  checking for real-time systems. Inf. Comput., 111(2):193â244, 1994.  [13] T. Hoare and P. OâHearn. Separation logic semantics for communicating  processes. Electron. Notes Theor. Comput. Sci., 212:3â25, Apr. 2008.  [14] H. HuĚttel and K. Larsen. The use of static constructs in a model process  logic. In A. Meyer and M. Taitslin, editors, Logic at Botik â89, volume  363 of Lecture Notes in Computer Science, pages 163â180. Springer  Berlin Heidelberg, 1989.  [15] K. Larsen, P. Pettersson, and W. Yi. Model-checking for real-time  systems. In H. Reichel, editor, Fundamentals of Computation Theory,  volume 965 of Lecture Notes in Computer Science, pages 62â88.  Springer, 1995. 10.1007/3-540-60249-6 41.  [16] R. Milner. Communication and concurrency. Prentice Hall International,  1995.  [17] A. W. Roscoe. The Theory and Practice of Concurrency. Prentice Hall,  1997.  [18] A. W. Roscoe. On the expressiveness of CSP. Technical report,  www.cs.ox.ac.uk/files/1383/complete(3).pdf, 2011.  [19] E. Sekerinski and K. Sere. A theory of prioritizing composition.  Technical report, 1996.  VI. C ONCLUSION  We have presented a formal semantic framework for studying, deďŹning, and manipulating the composition of extended  transition systems based on the composition of their labels.  The framework is based on the idea of deďŹning a label  structure containing a composition operator. Depending on  the language in question, a different label structure is deďŹned  and thus different composition laws are integrated. The label  structure is then used as a parameter of labeled transition  systems which describe the common semantic domain of  the considered languages. We believe that the suggested  parametrization of the behavioral framework is a promising  work and may represent, especially with the perspectives we  have, the ďŹrst step towards giving a uniďŹed formal semantic  framework for different process algebras and speciďŹcation  languages.  In our study, we emphasize on composition operators of  process algebras without concentrating on other behavioral  operators. In this context, we have pushed forward existing  work of similar structures [14], [18], [13] by offering a richer  set of operations and properties such as the composition of  label structures and transformations between label structures.  Following our technique, the composition of different LTS  extensions, whether it is a syntactic model or a semantic  model, is captured by a unique composition operation deďŹned  on LTS. This is a direct result of the separation between the  label structure and the behavioral framework. This result is  different than what can be found in the literature since with  each system, a different composition operation is provided.  This can be seen classically in the composition operations of  LTS and TTS. Even though a TTS is exactly an LTS having  additionally time transitions, usually its composition operation  does not reuse the LTS one.  Furthermore, generic results concerning label structures and  LTS transformations are applied to establish well known properties of high-level structures such as the deďŹnition of timed  automata semantics. We have shown that these semantics  match with the standard timed automata semantics and that the  timed automata are compositional w.r.t the parallel operator.  We are now working on a dual view of this work which  consists in coupling our label structures to states. This will  help us to naturally take into consideration state-based mechanisms such as the the committed states of UPPAAL [7]. We  are also working on deďŹning the formal semantics of real  time languages (BIP [6] and FIACRE [9]). Namely, we are  interested in extending our label structure with priorities which  are present in all the three cited languages. Another extension  is to revisit this work by incorporating some categorical ďŹavor.  Finally, all the theorems related to the presented framework  have been validated in the proof assistant Coq. The Coq theory  may be found at [1].  Acknowledgement: The authors would like to thank the  reviewers for thoroughly reading the paper.  R EFERENCES  [1] http://www.irit.fr/~Jean-Paul.Bodeveix/COQ/LblStr.  132  118 