2013 20th International Symposium on Temporal Representation and Reasoning  Event Algebra for Transition Systems Composition  Application to Timed Automata  Elie FARES  Jean-Paul BODEVEIX  Mamoun FILALI  IRIT, UniversiteÄšÂ de Toulouse  IRIT, UniversiteÄšÂ de Toulouse  IRIT, UniversiteÄšÂ de Toulouse  AbstractÃ¢Â€Â”Formal speciÄÅ¹Âcation languages have a lot of notions  in common. They all introduce entities usually called processes,  offer similar operators, and most importantly deÄÅ¹Âne their operational semantics based on labeled transition systems (LTS).  However, each language deÄÅ¹Ânes speciÄÅ¹Âc synchronizing and/or  memory structures. For instance, in CSP, the synchronization  is deÄÅ¹Âned between identical events, while in CCS and in  synchronization vectors-based views it is deÄÅ¹Âned respectively  between complementary events or between possibly different  events. In this paper, we aim at capturing some similarities  of speciÄÅ¹Âcation languages by deÄÅ¹Âning a label-based composition  formal framework. Firstly, we deÄÅ¹Âne a high-level synchronization  mechanism in the form of an abstract label structure. We then  couple this label structure with several compositional operations  and properties. Secondly, we introduce an LTS-based behavioral  framework and deÄÅ¹Âne a unique LTS composition operator which  is reused to deÄÅ¹Âne syntactic composition of extended transition  systems and a compositional semantics.  high-level synchronization mechanism in the form of a label  structure. The label structure is abstract enough [4] so that  both homogeneous and heterogeneous system synchronization  could be described. It is equipped with a composition operator  which encapsulates the speciÄÅ¹Âc composition laws of each  language and would further serve as a parameter of the  behavioral framework. Thanks to the separation between the  composition laws and the behavioral framework, the latter,  which is based on LTS, offers a unique LTS composition  which is reused to deÄÅ¹Âne syntactic composition of timed  automata and a compositional semantics. The idea of a label  structure or similar constructs is not new since it appears  in earlier studies [14], [15], [18], [13]. In [14], [15], the  label composition operator appears under a functional form  (the same as ours, see Label Structure : Section II) but the  authors do not go beyond this deÄÅ¹Ânition, while in [18], [13],  it appears under a relational form. In these latter studies, the  authors are interested in reaching generic semantic rules for  process calculi behavioral operators (preÄÅ¹Âx, choice...). This is  orthogonal to our goal that consists in reaching a label-based  composition framework for speciÄÅ¹Âcation languages.  I. I NTRODUCTION  For the past three decades, speciÄÅ¹Âcation languages such  as CSP [17], CCS [16], LOTOS [10], Altarica [5], and  BIP [6] have proven valuable in the speciÄÅ¹Âcation and design of  concurrent and distributed systems. The behavioral aspects of  these languages share a common base since they all deÄÅ¹Âne  their operational semantics in terms of labeled transition  systems (LTS). Yet, the difference lies in the synchronizing  structure of the labels of these systems. For example in CSP  the synchronization is deÄÅ¹Âned between two identical events,  while in CCS and in synchronization vectors-based views,  it is deÄÅ¹Âned respectively between complementary events or  between possibly different events. Through the years, the basic  versions of some of these languages have been extended by  time, memory, and priority notions. Accordingly, other formalisms have emerged in order to model the semantics of these  extensions. For example, we can cite Alur and DillÃ¢Â€Â™s timed automata [3] and Henzinger et alÃ¢Â€Â™s timed transition systems [11]  that both capture the time addition or the semantic model  of [19] used to model the priorities. However, even though  the rules of the composition operations of these formalisms  are the same in nature (synchronous and asynchronous rules),  they are well distinguished in reality, maybe because of the  speciÄÅ¹Âc attributes that come with each formalism. A distinct  composition operation is then introduced for each deÄÅ¹Âned  formalism.  In this paper, we aim at capturing some similarities of  speciÄÅ¹Âcation languages by providing a semantic framework  for system composition. For this purpose, we introduce a  1530-1311/13 $26.00 Ã‚Å  2013 IEEE  1550-1311/13  DOI 10.1109/TIME.2013.23  Our contribution can be viewed from two perspectives. One  way is to see this work as an abstraction of the composition of  different behavioral formalisms via a separation of the labels  composition laws of each language and a reuse of the LTS  composition. In fact, depending on the language, the label  structure is deÄÅ¹Âned and instantiated differently. Using the  common framework, one would then proceed by giving the  semantics of other behavioral operators of the speciÄÅ¹Âcation  language in question. Another way to see our label structure  and their associated operations is as a generalization of the  composition functions given and used in [14], [15]. Indeed,  we show how such abstract composition functions (or label  structures in our terms) may be implemented and instantiated  to simulate existing synchronization mechanisms. Most importantly, we push forward this work by giving new deÄÅ¹Ânitions,  properties, and operations to manipulate such label structures.  The rest of the paper is organized as follows. In the second  section, we start by deÄÅ¹Âning the label structure along with its  associated properties and operations. In the third section, we  deÄÅ¹Âne our behavioral framework and show how it reuses the  label structure notions. We conclude the paper in the fourth  section.  111  125  II. L ABEL S TRUCTURE  We start by describing the labels of transition systems by  means of a label structure which is later used as an attribute  of transition systems.  DeÄÅ¹Ânition 1 (Label Structure): A label structure is a tuple  L, 1 where L is a set of labels and (1: L Ä‚Â— L  L) is a  partial binary composition operator over L.  The function is partial because some composition may be  blocked since 1 describes exclusively synchronous compositions. The asynchronous aspects are covered later (see LTS  composition). Our composition then models the following  cases :  1) A successful synchronization between l and l that  results in l 1 l Ã¢ÂˆÂˆ L.  /  2) A blocking synchronization between l and l : (l, l ) Ã¢ÂˆÂˆ  dom(1).  Let the reader not confuse our label structure with other event  structuring propositions, namely with the event structures [8].  Event structures model the occurrence of events during the  system execution via the introduction of a causal dependency  relation and a conÄÅ¹Â‚ict relation between the events. In our case,  we introduce a label structure which models the way the labels  (i.e., events) are statically composed.  DeÄÅ¹Ânition 2 (Commutativity of a Label Structure): Given  a label structure LS = L, 1, LS is said to be commutative  if its composition operator 1 is commutative. Formally, for  l1 , l2 and l3 Ã¢ÂˆÂˆ L, LS is commutative if :  b) Basic CSP Synchronizing Structure: Here, we model  the case of the completely synchronous composition of CSP.  For C a set of communication ports, a synchronizing structure  on C is the label structure :  SyncCSP = C, (c1 , c2 ) Ã¢Â†Â’ c1 if c1 = c2   The synchronization of two ports of the set C is only deÄÅ¹Âned  when these two ports are the same. Otherwise an interleaving  occurs.  c) CCS Synchronizing Structure: For C a set of events,  C? = {c? | c Ã¢ÂˆÂˆ C} and C! = {c! | c Ã¢ÂˆÂˆ C}, this is represented  in our label structure as follows :  SyncCCS =  C?Ã¢ÂˆÅC!Ã¢ÂˆÅ{ÄÂ„ }Ã¢ÂˆÅ{(c!, c?) Ã¢Â†Â’ ÄÂ„ | c Ã¢ÂˆÂˆ C}, {(c!, c?) Ã¢Â†Â’ ÄÂ„ | c Ã¢ÂˆÂˆ C}  B. Label Structure Properties  We give the frequent label structures properties used in this  paper.  Property  Idempotency  Unique  Composition  Diagonality  DeÄÅ¹Ânition  Ã¢ÂˆÂ€l Ã¢ÂˆÂˆ L,  (l, l) Ã¢ÂˆÂˆ dom(1) Ã¢ÂˆÂ§ l 1 l = l  Ã¢ÂˆÂ€l1 l2 Ã¢ÂˆÂˆ L, (l1 , l2 ) Ã¢ÂˆÂˆ dom(1) Ã¢Â‡Â’  / dom(1)  Ã¢ÂˆÂ€l Ã¢ÂˆÂˆ L, ((l1 1 l2 ), l) Ã¢ÂˆÂˆ  Ã¢ÂˆÂ§(l, (l1 1 l2 )) Ã¢ÂˆÂˆ  / dom(1)  Ã¢ÂˆÂ€l1 l2 Ã¢ÂˆÂˆ L,  (l1 , l2 ) Ã¢ÂˆÂˆ dom(1) Ã¢Â‡Â” l1 = l2  Example  SyncCSP , T S  SyncCCS  SyncCSP , T S  We denote by ACI the conjunction of the associativity,  commutativity and idempotence properties. A label structure  fulÄÅ¹Âlling the ACI property is seen as a join semi-lattice where  1 is interpreted as the join operator and the partial order  relation l Ã¢Â‰Â¤ l is deÄÅ¹Âned by l Ã¢Â‰Â¤ l  l 1 l = l .  (l1 , l2 ) Ã¢ÂˆÂˆ dom(1) Ã¢Â‡Â’ (l2 , l1 ) Ã¢ÂˆÂˆ dom(1) Ã¢ÂˆÂ§ l1 1 l2 = l2 1 l1  DeÄÅ¹Ânition 3 (Associativity of a Label Structure): Given a  label structure LS = L, 1, LS is said to be associative if its  composition operator 1 is associative. Formally, for l1 , l2 and  l3 Ã¢ÂˆÂˆ L, LS is associative if it satisÄÅ¹Âes the following conditions  1) (l1 , l2 ) Ã¢ÂˆÂˆ dom(1) Ã¢ÂˆÂ§ ((l1 1 l2 ), l3 ) Ã¢ÂˆÂˆ dom(1) Ã¢Â‡Â”  (l2 , l3 ) Ã¢ÂˆÂˆ dom(1) Ã¢ÂˆÂ§ (l1 , (l2 1 l3 )) Ã¢ÂˆÂˆ dom(1). This  means that independently of the composition order, they  are both deÄÅ¹Âned.  2) (l1 , l2 ) Ã¢ÂˆÂˆ dom(1) Ã¢ÂˆÂ§ ((l1 1 l2 ), l3 ) Ã¢ÂˆÂˆ dom(1) Ã¢Â‡Â’  ((l1 1 l2 ) 1 l3 ) = (l1 1 (l2 1 l3 )). This means that  independently of the composition order, they both lead  to the same result.  DeÄÅ¹Ânition 4 (Stability of a Set of Labels): Given a label  structure LS = L, 1 and a label set G Ã¢ÂŠÂ† L, we say that  G is stable over LS if Ã¢ÂˆÂ€(l1 , l2 ) Ã¢ÂˆÂˆ dom(1), l1 1 l2 Ã¢ÂˆÂˆ G Ã¢Â‡Â’  l1 Ã¢ÂˆÂˆ G Ã¢ÂˆÂ§ l2 Ã¢ÂˆÂˆ G, and Ã¢ÂˆÂ€(l1 , l2 ) Ã¢ÂˆÂˆ dom(1), l1 Ã¢ÂˆÂˆ G Ã¢ÂˆÂ¨ l2 Ã¢ÂˆÂˆ G Ã¢Â‡Â’  l1 1 l2 Ã¢ÂˆÂˆ G.  C. Composition of Label Structures  We deÄÅ¹Âne the product and the sum of two label structures.  The product operation builds new labels as pairs of the  composed labels. For example, this is used when composing  synchronization and memory access labels. Unlike the product  operation, the labels of the sum operation are deÄÅ¹Âned over the  union of the composed labels. This is used when composing  synchronization and time labels to specify that only one of the  events may occur at one time and not simultaneously.  1) Product of Label Structures: Given two label structures  L, 1 and L , 1 , their product ranges over the set P =  (L Ã¢ÂˆÅ {}) Ä‚Â— (L Ã¢ÂˆÅ { })\{(,  )} where  (resp.  ) is a new  element of L (resp. L ) supposed to be neutral 1 for the 1  operator of its respective label structure. For l1 , l2 Ã¢ÂˆÂˆ L and  l1 , l2 Ã¢ÂˆÂˆ L , the composition of (l1 , l1 ), (l2 , l2 ) is deÄÅ¹Âned only  if the composition of l1 and l2 and the composition l1 and l2  are both deÄÅ¹Âned.  A. Label Structure Examples  a) Time Label Structure: For ÃÂ” a time domain, e.g., non  negative real numbers, naturals . . . , equipped with a binary  associative operator + and a neutral element 0, we introduce  the time structure T S on the domain ÃÂ”. Its composition  operator is only deÄÅ¹Âned between identical time labels ÃÂ´ and  returns the label itself.    P,  T S = ÃÂ”, (ÃÂ´1 , ÃÂ´2 ) Ã¢Â†Â’ ÃÂ´1 if ÃÂ´1 = ÃÂ´2   1 If  126  112  L, 1 Ã¢ÂŠÂ— L , 1  =  (l1 , l1 ), (l2 , l2 ) Ã¢Â†Â’ (l1 1 l2 , l1 1 l2 )  if (l1 , l2 ) Ã¢ÂˆÂˆ dom(1) Ã¢ÂˆÂ§ (l1 , l2 ) Ã¢ÂˆÂˆ dom(1 )      L had already a neutral element , we suppose that n 1  =  1 n = n.  2) Sum of Label Structures: Given L, 1 and L , 1 ,  their sum ranges over the union of LÃ¢Â€Ë˜ Ã¢ÂˆÅ Ã¢Â€Ë˜ L where LÃ¢Â€Ë˜ =  {lÃ¢Â€Ë˜ | l Ã¢ÂˆÂˆ L} and Ã¢Â€Ë˜ L = {Ã¢Â€Ë˜ l | l Ã¢ÂˆÂˆ L }.  L, 1 Ã¢ÂŠÂ• L , 1  =  LÃ¢Â€Ë˜ Ã¢ÂˆÅ Ã¢Â€Ë˜ L ,    Ã¢Â€Ë˜  l1 Ã¢Â€Ë˜ , l2 Ã¢Â€Ë˜ Ã¢Â†Â’ (l1 1 l2 ) if (l1 , l2 ) Ã¢ÂˆÂˆ dom(1)  Ã¢Â€Ë˜  l1 , Ã¢Â€Ë˜ l2 Ã¢Â†Â’ Ã¢Â€Ë˜ (l1 1 l2 ) if (l1 , l2 ) Ã¢ÂˆÂˆ dom(1 )      Proposition 1 (Preservation of ACI ): Given LS and LS  ,  if LS and LS  satisfy one of the ACI properties then LS Ã¢ÂŠÂ•  LS  and LS Ã¢ÂŠÂ— LS  satisfy this same property.  A label structure transformation is used to map labels from a  label structure to another. We start by giving the deÄÅ¹Ânition of a  transformation followed by instances of such transformations.  DeÄÅ¹Ânition 5 (Transformation): A transformation f between  two label structures LS1 = L1 , 11  and LS2 = L2 , 12  is  deÄÅ¹Âned as a partial morphism f from LS1 labels to LS2 labels  such that :  Ã¢Â€Ë˜  Ã¢Â€Ë˜  Inl  Inr  Ã¢Â†Â‘Ã¢ÂŠÂ•  Ã¢ÂŠÂ•  Ã¢Â†Â‘  Outl  Outr  Extl  Extr  P rjl  P rjr  Ã¢ÂŠÂ•  Ã¢Â†Â“  Ã¢ÂŠÂ•  Ã¢Â†Â“  Ã¢ÂŠÂ—  Ã¢Â†Â‘  Ã¢Â†Â‘Ã¢ÂŠÂ—  Ã¢ÂŠÂ—  Ã¢Â†Â“  Ã¢Â†Â“Ã¢ÂŠÂ—  Signature  Embedding  LS1  LS1 Ã¢ÂŠÂ• LS2  LS2  LS1 Ã¢ÂŠÂ• LS2  Retraction  LS1 Ã¢ÂŠÂ• LS2  LS1  LS1 Ã¢ÂŠÂ• LS2  LS2  Extension  LS1  LS1 Ã¢ÂŠÂ— LS2  LS2  LS1 Ã¢ÂŠÂ— LS2  Projection  LS1 Ã¢ÂŠÂ— LS2  LS1  LS2 Ã¢ÂŠÂ— LS1  LS2  (tr : LS1  LS2 )  Ã¢Â†Â’  LS1 Ã¢ÂŠÂ• LS  LS2 Ã¢ÂŠÂ• LS  T r Inr  (Ã¢Â‡Â‘LSÃ¢ÂŠÂ•  LSÃ¢ÂŠÂ• )  (tr : LS1  LS2 )  Ã¢Â†Â’  LS Ã¢ÂŠÂ• LS1  LS Ã¢ÂŠÂ• LS2  T r Extl  (Ã¢Â‡Â‘Ã¢ÂŠÂ—LS  Ã¢ÂŠÂ—LS )  (tr : LS1  LS2 )  Ã¢Â†Â’  LS1 Ã¢ÂŠÂ— LS  LS2 Ã¢ÂŠÂ— LS  T r Extr  (Ã¢Â‡Â‘LSÃ¢ÂŠÂ—  LSÃ¢ÂŠÂ— )  (tr : LS1  LS2 )  Ã¢Â†Â’  LS Ã¢ÂŠÂ— LS1  LS Ã¢ÂŠÂ— LS2  Ã¢Â€Ë˜  l1 Ã¢Â†Â’ Ã¢Â€Ë˜ tr(l1 )  lÃ¢Â€Ë˜ Ã¢Â†Â’ lÃ¢Â€Ë˜  Ã¢ÂÂ§  Ã¢ÂÂ¨(l1 , l2 ) Ã¢Â†Â’ (tr(l1 ), l2 )  (, l2 ) Ã¢Â†Â’ (, l2 )  Ã¢ÂÅ (l , ) Ã¢Â†Â’ (tr(l ), )  1  1  Ã¢ÂÂ§  Ã¢ÂÂ¨(l1 , l2 ) Ã¢Â†Â’ (l1 , tr(l2 ))  (, l2 ) Ã¢Â†Â’ (, tr(l2 ))  Ã¢ÂÅ (l , ) Ã¢Â†Â’ (l , )  1  1  A. Labeled Transition System (LTS)  DeÄÅ¹Ânition 6 (Labeled Transition System LTS): Given  LS = L, 1, a labeled transition system L over LS Ã¢Â€Â“denoted  as LLS Ã¢Â€Â“ is deÄÅ¹Âned as Q, Q0 Ã¢ÂŠÂ† Q, T Ã¢ÂŠÂ† Q Ä‚Â— L Ä‚Â— Q where  Q, Q0 , T denote respectively the sets of states, initial states,  and transitions. We denote by LT SLS the set of LTSs over  LS.  l  We write q Ã¢Â†Â’ q  for an element (q, l, q  ) of T . Furthermore,  we deÄÅ¹Âne the alphabet of an LLS Ã¢Â€Â“denoted as ÃÄ…LLS Ã¢Â€Â“ as the  set of labels that are actually used by the transitions of LLS :  l  ÃÄ…LLS = {l Ã¢ÂˆÂˆ L | Ã¢ÂˆÂƒq q  , q Ã¢Â†Â’ q  Ã¢ÂˆÂˆ T }.  DeÄÅ¹Ânition 7 (Bisimulation): Given ALS = Qa , Q0a , Ta   and CLS = Qc , Q0c , Tc , a relation R Ã¢ÂŠÂ† Qc Ä‚Â— Qa deÄÅ¹Ânes  a simulation between CLS and ALS denoted as CLS R ALS  iff : (1) Ã¢ÂˆÂ€qc0 Ã¢ÂˆÂˆ Q0c , Ã¢ÂˆÂƒqa0 Ã¢ÂˆÂˆ Q0a such that (qc0 , qa0 ) Ã¢ÂˆÂˆ R and (2)  l  Ã¢ÂˆÂ€qc , qc , qa , l if qc Ã¢Â†Â’ qc and (qc , qa ) Ã¢ÂˆÂˆ R, Ã¢ÂˆÂƒqa Ã¢ÂˆÂˆ Qa such that  l  qa Ã¢Â†Â’ qa and (qc , qa ) Ã¢ÂˆÂˆ R.  Two LTSs LLS and L LS are said to be bisimilar through the  relation R Ã¢ÂŠÂ† Q Ä‚Â— Q denoted as LLS R L LS if LLS R  L LS and L LS RÃ¢ÂˆÂ’1 LLS . Furthermore, we say that LLS and  L LS are state-bisimilar if transition labels are not required to  match.  DeÄÅ¹Ânition 8 (LTS Diagonality, Idempotency and Determinism):  An LTS is said to be diagonal (resp. idempotent) if  the restriction of its label structure to the LTS alphabet is  diagonal (resp. idempotent). An LTS is said to be deterministic  l  l  if whenever q Ã¢Â†Â’ q  and q Ã¢Â†Â’ q  then q  = q  . In the rest of  the paper, this set of LTS properties will be named DID.  1) LTS Composition: Given two LTSs deÄÅ¹Âned over L, 1,  a set S Ã¢ÂŠÂ† L denoting the allowed synchronization results, and  two sets of labels Al and Ar denoting respectively the left and  right interleaving labels, the label composition function 1 is  A  A  extended to an LTS composition function l 1 r as follows:  We write f : LS1  LS2 to denote such transformations.  1) Basic Transformations: Given two label structures LS1  and LS2 , we deÄÅ¹Âne label structure transformations which  are used to embed a label into a sum of labels, destruct  a label sum, extend a label to a couple of labels, or also  project a couple of labels to an element of the couple. These  transformations are given in the following table :  Notation  T r Inl  (Ã¢Â‡Â‘Ã¢ÂŠÂ•LS  Ã¢ÂŠÂ•LS )  tr   Transformation  l1 Ã¢Â€Ë˜ Ã¢Â†Â’ tr(l1 )Ã¢Â€Ë˜  Ã¢Â€Ë˜l Ã¢Â†Â’ Ã¢Â€Ë˜l  III. B EHAVIORAL F RAMEWORK  ran(11 ) Ã¢ÂŠÂ† dom(f ).  Ã¢ÂˆÂ€l, l Ã¢ÂˆÂˆ dom(f ), (l, l ) Ã¢ÂˆÂˆ dom(11 ) Ã¢Â‡Â” (f (l), f (l )) Ã¢ÂˆÂˆ  dom(12 ).  Ã¢ÂˆÂ€l, l Ã¢ÂˆÂˆ dom(f ), (l, l ) Ã¢ÂˆÂˆ dom(11 ) Ã¢Â‡Â’ f (l 11 l ) =  f (l) 12 f (l ).  Name  Signature  We note here that the transformation properties are satisÄÅ¹Âed  by the resulting functions. The previous four transformations  also preserve the injectivity of tr.  D. Label Structure Transformations  Ã¢Â€Ë˜  Name  DeÄÅ¹Ânition  l Ã¢Â†Â’ lÃ¢Â€Ë˜  l Ã¢Â†Â’ Ã¢Â€Ë˜l  lÃ¢Â€Ë˜ Ã¢Â†Â’ l  Ã¢Â€Ë˜  lÃ¢Â†Â’l  l Ã¢Â†Â’ (l, )  l Ã¢Â†Â’ (, l)  (l, ) Ã¢Â†Â’ l  (, l) Ã¢Â†Â’ l  It is not difÄÅ¹Âcult to see that the transformation properties  (DeÄÅ¹Ânition 5) are satisÄÅ¹Âed by the transformations we have  deÄÅ¹Âned. We note that all these transformations are injective.  2) High-Level Transformations: Given the label structures  2  LS, LS1 , LS2 , and Ã¢Â†Â‘LS  LS1 a transformation from LS1 to LS2 ,  we deÄÅ¹Âne the following four high level transformations :  S  Q1 , Q01 , T1  1  Al  S  Ar  Q2 , Q02 , T2  = Q1 Ä‚Â— Q2 , Q01 Ä‚Â— Q02 , T   where the set T is deÄÅ¹Âned by the following rules :  127  113  l  q1 Ã¢Â†Â’1T1  q1  l  q2 Ã¢Â†Â’2T2  q2  (l1 , l2 ) Ã¢ÂˆÂˆ dom(1) Ã¢ÂˆÂ§ (l1 1 l2 ) Ã¢ÂˆÂˆ S  l 1l  (q1 , q2 ) 1Ã¢Â†Â’T2 (q1 , q2 )  Corollary 2: Given an associative label structure LS =  L, 1, the label set S Ã¢ÂŠÂ† L, the LTSs L1LS , L2LS , and L3LS  we have :  1) L1 1(L2 1L3 )  (L1 1L2 )1L3 if S, S  are  S YNC  S  l  q1 Ã¢Â†Â’1T1 q1 l1 Ã¢ÂˆÂˆ Al  l  (q1 , q2 ) Ã¢Â†Â’1T (q1 , q2 )  l  q2 Ã¢Â†Â’2T2 q2 l2 Ã¢ÂˆÂˆ Ar  l  (q1 , q2 ) Ã¢Â†Â’2T (q1 , q2 )  I NTERLEAVINGR  S is omitted when it is equal to L. In this case, if Al = Ar = Ã¢Âˆ  then 1 is a fully synchronous composition operator.  Theorem 1 (Bisimulation Compatibility ): Given the LTSs  L1 , L 1 , L2 , and L 2 deÄÅ¹Âned over the label structure LS, we  have :  L1  L2 Ã¢ÂˆÂ§ L 1  L 2 Ã¢Â‡Â’ L1 l 1  A  Ar  S  L 1  L2 l 1  A  S  Ar  S  A  L1  1   Ar1  [f ]Q, Q0 , Ã¢Â†Â’1  =  Q, Q0 , Ã¢Â†Â’2 = {(q, f (l), q  ) | l Ã¢ÂˆÂˆ dom(f ) Ã¢ÂˆÂ§ (q, l, q  ) Ã¢ÂˆÂˆÃ¢Â†Â’1 }  A  S1  (L2  Al2  1   Ar2  S2  Proposition 5 (Transformation Bisimulation Compatibility):  Given LS1 = L1 , 11 , LS2 = L2 , 12 , two LTSs L1 and  L2 both over LS1 , and a transformation f : LS1  LS2 ,  L1  L2 Ã¢Â‡Â’ [f ](L1 )  [f ](L2 ).  Theorem 3 (Transformation Compositionality): Given  LS1 = L1 , 11 , LS2 = L2 , 12 , two LTSs L1 and L2 both  over LS1 , and an injective transformation f : LS1  LS2  such that dom(f ) is stable over LS1 , we have :  A  [f ](L1 l 1  S  L3 )  Al1  1   S1  Ar1  L2 )  Al2  1   S2  Ar2  Ar  L2 )  [f ](L1 )  f (Al )   1   f (S)  f (Ar )  [f ](L2 )  Proof: We only sketch the proof of the synchronous case.  Given LS1 , LS2 , LLS1 , and L LS1 , we prove that the two  sides are bisimilar through the identity relation. The proof is  based on showing that each transition of the ÄÅ¹Ârst system can be  found in the second system and vice versa. It is depicted in the  following implications which can be read from bottom to top  and vice versa from either sides of the parentheses. The main  points of this proof are ÄÅ¹Ârst the use of the stability hypothesis  so that we conclude that when l Ã¢ÂˆÂˆ dom(f ) then l1 , l2 Ã¢ÂˆÂˆ  dom(f ) and conversely, second the use of the injectivity of  f in order to connect the two branches of the proof.    (L1  S  The label structure of an LTS may be changed in a composition such as making local a global event (CSP hide) or  changing its name (CSP Rename). Here, we consider some  LTS labels transformations by extending the label structure  transformations to LTS transformations.  DeÄÅ¹Ânition 9 (LTS Transformation): Given two label structures LS1 and LS2 , and a transformation f : LS1  LS2 , we  deÄÅ¹Âne [f ] : LLS1 Ã¢Â†Â’ LLS2 as :  Theorem 2 (Associativity of l 1 r ): Given LS = L, 1  S  , the label sets Al1 , Ar1 , Al2 , Ar2 , S1 , S2 Ã¢ÂŠÂ† L, and the LTSs  L1LS , L2LS , and L3LS . If LS is associative, S1 , S2 , Ar1 , Al2  are stable over LS, and either one of the following conditions  is satisÄÅ¹Âed :  1) Ar2 Ã¢ÂˆÅ  ÃÄ…L3 = Ã¢ÂˆÂ… and Al1 Ã¢ÂˆÅ  ÃÄ…L1 = Ã¢ÂˆÂ….  2) Al1 Ã¢ÂŠÂ† Al2 , Ar2 Ã¢ÂŠÂ† Ar1 , S2 Ã¢ÂˆÅ  Al1 = Ã¢ÂˆÂ…, and S1 Ã¢ÂˆÅ  Ar2 = Ã¢ÂˆÂ….  3) Al1 Ã¢ÂŠÂ† Al2 , Ar2 Ã¢ÂŠÂ† Ar1 , S Ã¢ÂŠÂ† Al1 , S Ã¢ÂŠÂ† Ar2 , and S1 =  S2 .  We have :  Al1  S  B. LTS Transformations  L 2  This theorem allows us to reason by making use of substitution  by bisimulation.  Proposition 2 (Synchronous Composition ): Given  two  LTSs L1 and L2 deÄÅ¹Âned over the label structure LS, we have  L1 1L2  L1 1L2 if S is stable over LS, ÃÄ…L1 Ã¢ÂŠÂ† S, and  S  ÃÄ…L2 Ã¢ÂŠÂ† S.  A  A  two  Proposition 3 (Commutativity of l 1 r ): Given  S  LTSs L1 and L2 deÄÅ¹Âned over the label structure LS, we have  A  A  A  A  L1 l 1 r L2  L2 r 1 l L1 if LS is commutative.  S  S  stable over LS 2 . This ÄÅ¹Ârst proposition is the same as  the weak associativity theorem of the CSP generalized  parallel operator [17]. The hypothesis added in our  context are satisÄÅ¹Âed by the label structure associated to  CSP.  2) L1 1(L2 1L3 )  (L1 1L2 )1L3 if S, S  are  S  S  stable over LS and ÃÄ…L1 Ã¢ÂŠÂ† S.  Proposition 4 (Idempotency of 1): Given LS = L, 1  and LLS , if LLS is DID then 1 is idempotent meaning  that LLS 1LLS  LLS .  I NTERLEAVINGL  L3  The conditions of this theorem are only sufÄÅ¹Âcient conditions  and have been selected in order to ÄÅ¹Ât with our needs. Other  conditions can be found in other contexts, for example the  CSP context [17].  We note how the third set of sufÄÅ¹Âcient conditions satisfy  the CCS parallel composition. In this case, this result can be  instantiated by taking S = Al1 = Al2 = Ar1 = Ar2 = L  which leads to the following CCS associativity corollary.  Corollary 1 (CCS Associativity): The CCS parallel composition operator is associative.  Other associativity corollaries may also be deduced such as  the followings :  Proposition 6 (Preservation of DID properties): Given  two label structures LS1 , LS2 , an injective transformation  f : LS1  LS2 , and an LTS L over LS1 , each of the  2S  128  114  is the complement of S.  Ã¢ÂÂ›  l  l  l1   l2   1  2      q1 , q2 Ã¢Â†Â’  q2 , l = l1 1 l2 q1 Ã¢Â†Â’ q1 , l1 Ã¢ÂˆÂˆ dom(f ) q2 Ã¢Â†Â’ q2 , l2 Ã¢ÂˆÂˆ dom(f )  q1 Ã¢Â†Â’  Ã¢ÂÂœ  Ã¢ÂÂœ  )  f  (l  f (l2 )  l  1  Ã¢ÂÂœ (q1 , q2 ) Ã¢Â†Â’  (q1 , q2 ) , l Ã¢ÂˆÂˆ dom(f )  q1 Ã¢Â†Â’ q1  q2 Ã¢Â†Â’ q2  l = l1 1 l2  Ã¢ÂÂ  f (l)  (q1 , q2 ) Ã¢Â†Â’ (q1 , q2 )  (q1 , q2 )  DID properties is preserved by the transformation f .  Formally, for P a DID property we have : P (L) Ã¢Â‡Â’ P ([f ]L).  f (l)=f (l1 )1f (l2 )  Ã¢ÂˆÂ’Ã¢Â†Â’  Ã¢ÂÂ  Ã¢ÂÂŸ  Ã¢ÂÂŸ  Ã¢ÂÂŸ  Ã¢Â  (q1 , q2 )  3) Timed Automata Label Structure: Given a set of clocks  C, we deÄÅ¹Âne a timed automaton as an LTS such that its  transitions are labeled by communication channels (deÄÅ¹Âned  by some label structure LS), guards (the label structure G)  and reset actions (the label structure A). For this moment, LS  is left undeÄÅ¹Âned and can either model the CCS-based synchronization or the CSP-based one. Given a label structure LS, a  timed automaton (TA) over LS is an LTS over LS Ã¢ÂŠÂ— G Ã¢ÂŠÂ— A.  IV. T IMED S YSTEMS  A. Timed Transition Systems (TTS)  DeÄÅ¹Ânition 10 (TTS): Given a label structure LS = L, 1,  a Timed Transition System (TTS) over LS is an LTS over  LS Ã¢ÂŠÂ• T S.  DeÄÅ¹Ânition 11 (TTS composition): Thanks to the introduction of our label structure, the TTS composition is the composition of the underlying LTSs.  T ALS = LT SLSÃ¢ÂŠÂ—GÃ¢ÂŠÂ—A  DeÄÅ¹Ânition 12 (TA Composition): Thanks to our label structure, the TA composition is deÄÅ¹Âned as the composition of the  underlying LTS systems.  4) TA Semantics: The semantics of a timed automaton is a  TTS over LS Ã¢ÂŠÂ— G Ã¢ÂŠÂ— A. In the following we denote GA for  (G Ã¢ÂŠÂ— A).  Lemma 1: If LS is associative (commutative) 3 then LS Ã¢ÂŠÂ—  GA Ã¢ÂŠÂ• T S is associative (commutative).  Proof: G, A, and T S are associative (commutative). By  Proposition 1, Ã¢ÂŠÂ• and Ã¢ÂŠÂ— preserves the associativity (commutativity).  The TA semantics is given via a composition with a clock  manager Clk deÄÅ¹Âned over GA Ã¢ÂŠÂ• T S (Fig 2).  B. Timed Automata (TA)  We consider ÄÅ¹Ârst a deÄÅ¹Ânition of timed automata [3] in  which no invariants are associated to its locations (this is  close to a timed graph [2] since neither invariants nor committed states are modeled). The transitions are in the form of  guard/event/reset where the guards contain a conjunction of  constraints represented as clock intervals and the reset actions  consist in a set of clocks to be reset. This is represented  as a product of three label structures. The ÄÅ¹Ârst manages the  synchronization events, the second manages clock guards, and  the third manages the clock reset. In the rest of this paper, we  consider a set C of clocks and a time domain ÃÂ” (e.g. R+ ).  1) Guard Label Structure: Based on the Alur Dill timed  automata [3], a guard is a conjunction of interval constraints  associated to clocks. Here, this is modeled as a function C Ã¢Â†Â’  2ÃÂ” . The guard label structure is deÄÅ¹Âned as :                             G  C Ã¢Â†Â’ 2ÃÂ” , (g1 , g2 ) Ã¢Â†Â’ (c Ã¢Â†Â’ g1 (c) Ã¢ÂˆÅ  g2 (c))  The guard label structure is ACI.  2) Action Label Structure: Based on the Alur Dill timed  automata [3], an action associated to a discrete transition can  reset some clocks while keeping the other clocks managed  by the current timed automaton unchanged. In order to allow  the composition of reset actions, the clocks not managed by  a given timed automaton are left undetermined. Consequently  an action is modeled by two disjoint sets r denoting the clocks  to be reset and u denoting the clocks to be left unchanged.  Their composition is deÄÅ¹Âned by respectively the union of the  reset sets and the union of the unchanged sets provided that  the reset and the unchanged sets are disjoint.  Fig. 1.               Semantics of TA via a Composition of Two LTSs  a) Clock Manager: The Clk automaton contains variables (denoted as cÄšÂ„) corresponding to the clocks c of C.  It has two types of transitions. The ÄÅ¹Ârst type correspond to  transitions of time evolution labeled by Ã¢Â€Ë˜ ÃÂ´ in which after  each possible delay all of the clocks are incremented by the  amount of this delay. The second type correspond to discrete  Ã¢Â€Ë˜  transitions labeled by g, (r, u) in which certain clocks are  checked against their guard constraints (cÄšÂ„ Ã¢ÂˆÂˆ g(c)), and clocks  belonging to r are reset. In order to impose the determinism  of Clk, we suppose that rÃ¢ÂˆÅu = C in Clk, but we synchronize  labels l of ta with labels l of Clk when l Ã¢Â‰Â¤ l . We recall that  A   {(r, u) Ã¢ÂˆÂˆ 2C Ä‚Â— 2C | r Ã¢ÂˆÅ  u = Ã¢ÂˆÂ…},  ((r1 , u1 ), (r2 , u2 )) Ã¢Â†Â’ (r1 Ã¢ÂˆÅ r2 , u1 Ã¢ÂˆÅ u2 )  if r1 Ã¢ÂˆÅ  u2 = r2 Ã¢ÂˆÅ  u1 = Ã¢ÂˆÂ…  The action label structure is ACI.  3 This  129  115  is veriÄÅ¹Âed for both of CCS and CSP.  this partial order relation Ã¢Â‰Â¤ has been deÄÅ¹Âned from the join  operator in Section II-B.  Since Clk is diagonal, idempotent, and deterministic, it  follows that Clk1Clk  Clk (Proposition 4).  b) Reconstructing the TA Semantics: The TA semantics  is deÄÅ¹Âned by means of a composition between the syntactic  ta and Clk where ta transmits the clock commands to Clk.  Since the LTS composition is deÄÅ¹Âned over the same label  structure, then the label structures on which ta and Clk are  deÄÅ¹Âned have to be adapted so that they both become deÄÅ¹Âned  over LSÃ¢ÂŠÂ—GAÃ¢ÂŠÂ•T S. More precisely, we use the left embedding  transformation for ta and the transformed right extension for  Clk. This is formally deÄÅ¹Âned as :  S  [[ta]] = (ta Ã¢Â†Â‘LSÃ¢ÂŠÂ—GAÃ¢ÂŠÂ•T    LSÃ¢ÂŠÂ—GA  1  (LSÃ¢ÂŠÂ—GA)Ã¢Â€Ë˜  Theorem 5: Given a timed automaton where each transition  is labeled by an action (not by  labels introduced by the  label structure product), its standard and proposed (revised)  semantics are state-bisimilar through the identity relation.  C. Timed Automata with Invariants  We now add state invariants to timed automata as deÄÅ¹Âned  in [12].  1) Invariant Label Structure: Here we consider an invariant  to be an upper bound constraint that may be associated to each  clock. It is deÄÅ¹Âned as a partial function from clocks to the  time domain ÃÂ”. The composition of two invariants associates  to each clock, when it exists, the minimum of the two bounds.  The invariant label structure is deÄÅ¹Âned as :  S LSÃ¢ÂŠÂ—GA   Clk(Ã¢Â‡Â‘Ã¢ÂŠÂ•T  ))  Ã¢ÂŠÂ•T S Ã¢Â†Â‘GA  Theorem 4 (TA Semantics Compositionality): Given two  timed automata ta1 and ta2 , [[ta1 1ta2 ]]  [[ta1 ]]1[[ta2 ]].  Proof: This proof is based on proving the bisimulation  between the semantics of the composition of ta1 and ta2 and  the composition of their semantics. We start by unfolding the  semantics of the TA composition [[ta1 1ta2 ]] and by applying  a sequence of bisimulations we reach [[ta1 ]]1[[ta2 ]]. In the  S  following proof we denote   1 Ã¢Â€Ë˜  by  and Ã¢Â†Â‘LSÃ¢ÂŠÂ—GAÃ¢ÂŠÂ•T  LSÃ¢ÂŠÂ—GA  I  C  ÃÂ”,  (i1 , i2 ) Ã¢Â†Â’ (c Ã¢Â†Â’  The invariant label structure is ACI.  2) Timed Automata with Invariants Label Structure: Given  a set of clocks C, we deÄÅ¹Âne a timed safety automaton (TSA) as  an LTS such that its transitions are labeled by communication  channels (deÄÅ¹Âned by some label structure LS), guards (the  label structure G) and reset actions (the label structure A).  Furthermore, invariants which are usually attached to locations, are here stored on special looping transitions in order  to synchronize with the Invariant Clock controller (IClk in  paragraph IV-C3a).  Given a label structure LS, a timed safety automaton over  LS is an LTS over LS Ã¢ÂŠÂ— G Ã¢ÂŠÂ— A Ã¢ÂŠÂ• I.  (LSÃ¢ÂŠÂ—GA)  S  by Ã¢Â†Â‘Ã¢ÂˆÂ’Ã¢ÂŠÂ•T  .  Ã¢ÂˆÂ’  S  S  S  S  (ta1 Ã¢Â†Â‘Ã¢ÂˆÂ’Ã¢ÂŠÂ•T  Clk Ã¢Â†Â‘LSÃ¢ÂŠÂ—GAÃ¢ÂŠÂ•T  )1(ta2 Ã¢Â†Â‘Ã¢ÂˆÂ’Ã¢ÂŠÂ•T  Clk Ã¢Â†Â‘LSÃ¢ÂŠÂ—GAÃ¢ÂŠÂ•T  )  Ã¢ÂˆÂ’  Ã¢ÂˆÂ’  GAÃ¢ÂŠÂ•T S  GAÃ¢ÂŠÂ•T S   {Associativity : Corollary 1.2}  S  S  S  S  (ta1 Ã¢Â†Â‘Ã¢ÂˆÂ’Ã¢ÂŠÂ•T  (Clk Ã¢Â†Â‘LSÃ¢ÂŠÂ—GAÃ¢ÂŠÂ•T  1(ta2 Ã¢Â†Â‘Ã¢ÂˆÂ’Ã¢ÂŠÂ•T  Clk Ã¢Â†Â‘LSÃ¢ÂŠÂ—GAÃ¢ÂŠÂ•T  )))  Ã¢ÂˆÂ’  Ã¢ÂˆÂ’  GAÃ¢ÂŠÂ•T S  GAÃ¢ÂŠÂ•T S   {Commutativity : Proposition 3}  Ã¢ÂˆÂ’Ã¢ÂŠÂ•T S  Ã¢ÂˆÂ’Ã¢ÂŠÂ•T S  LSÃ¢ÂŠÂ—GAÃ¢ÂŠÂ•T S  LSÃ¢ÂŠÂ—GAÃ¢ÂŠÂ•T S  (ta1 Ã¢Â†Â‘Ã¢ÂˆÂ’  ((ta2 Ã¢Â†Â‘Ã¢ÂˆÂ’  Clk Ã¢Â†Â‘GAÃ¢ÂŠÂ•T S  )1Clk Ã¢Â†Â‘GAÃ¢ÂŠÂ•T S  ))   {Associativity : Corollary 1.2}  S  S  S  S  (ta1 Ã¢Â†Â‘Ã¢ÂˆÂ’Ã¢ÂŠÂ•T  (ta2 Ã¢Â†Â‘Ã¢ÂˆÂ’Ã¢ÂŠÂ•T  (Clk Ã¢Â†Â‘LSÃ¢ÂŠÂ—GAÃ¢ÂŠÂ•T  1Clk Ã¢Â†Â‘LSÃ¢ÂŠÂ—GAÃ¢ÂŠÂ•T  )))  Ã¢ÂˆÂ’  Ã¢ÂˆÂ’  GAÃ¢ÂŠÂ•T S  GAÃ¢ÂŠÂ•T S   {Idempotency : Proposition 4}  S  S  S  (ta1 Ã¢Â†Â‘Ã¢ÂˆÂ’Ã¢ÂŠÂ•T  (ta2 Ã¢Â†Â‘Ã¢ÂˆÂ’Ã¢ÂŠÂ•T  Clk Ã¢Â†Â‘LSÃ¢ÂŠÂ—GAÃ¢ÂŠÂ•T  ))  Ã¢ÂˆÂ’  Ã¢ÂˆÂ’  GAÃ¢ÂŠÂ•T S   {Associativity : Corollary 1.1}  Ã¢ÂˆÂ’Ã¢ÂŠÂ•T S  Ã¢ÂˆÂ’Ã¢ÂŠÂ•T S  LSÃ¢ÂŠÂ—GAÃ¢ÂŠÂ•T S  ((ta1 Ã¢Â†Â‘Ã¢ÂˆÂ’  ta2 Ã¢Â†Â‘Ã¢ÂˆÂ’  )  Clk Ã¢Â†Â‘GAÃ¢ÂŠÂ•T S  )   {Synchronous Composition : Proposition 2}  Ã¢ÂˆÂ’Ã¢ÂŠÂ•T S  Ã¢ÂˆÂ’Ã¢ÂŠÂ•T S  LSÃ¢ÂŠÂ—GAÃ¢ÂŠÂ•T S  ((ta1 Ã¢Â†Â‘Ã¢ÂˆÂ’  1ta2 Ã¢Â†Â‘Ã¢ÂˆÂ’  )  Clk Ã¢Â†Â‘GAÃ¢ÂŠÂ•T S  )  T SALS = LT SLSÃ¢ÂŠÂ—GÃ¢ÂŠÂ—AÃ¢ÂŠÂ•I  DeÄÅ¹Ânition 13 (TSA Composition): Thanks to our label  structure, the TSA composition is deÄÅ¹Âned as the composition  of the underlying LTS systems.  3) TSA Semantics: The semantics of a timed safety automaton is a LTS over LS Ã¢ÂŠÂ— GA Ã¢ÂŠÂ• I Ã¢ÂŠÂ— T S.  Lemma 2: If LS is associative (commutative) then LS Ã¢ÂŠÂ—  GA Ã¢ÂŠÂ• I Ã¢ÂŠÂ— T S is associative (commutative).  Proof: G, A, I and T S are associative (commutative).  By Proposition 1, Ã¢ÂŠÂ• and Ã¢ÂŠÂ— preserves the associativity (commutativity).  The TSA semantics is given via a composition with an  invariant clock manager IClk deÄÅ¹Âned over GA Ã¢ÂŠÂ• I Ã¢ÂŠÂ— T S  (Fig 2).  a) Invariant Clock Manager : The IClk automaton  extends the Clk automaton by constraining the time elapsing.  It synchronizes on the invariant speciÄÅ¹Âed by the user-provided  timed automaton, and on any GA label operator that is equal  to the GA label provided by the timed automaton.  Since IClk is diagonal, idempotent, and deterministic, it  follows that IClk1IClk  IClk (Proposition 4).   {Transformation Compositionality : Theorem 3}  S  S  ((ta1 1ta2 ) Ã¢Â†Â‘Ã¢ÂˆÂ’Ã¢ÂŠÂ•T   Clk Ã¢Â†Â‘LSÃ¢ÂŠÂ—GAÃ¢ÂŠÂ•T  )  Ã¢ÂˆÂ’  GAÃ¢ÂŠÂ•T S  Of course, the hypothesis of the applied results have been  Ã¢Â€Ë˜  veriÄÅ¹Âed. Namely, (LS Ã¢ÂŠÂ— GA) is stable over LS Ã¢ÂŠÂ— GA Ã¢ÂŠÂ• T S,  Ã¢Â€Ë˜  LSÃ¢ÂŠÂ—GAÃ¢ÂŠÂ•T S  Ã¢ÂŠÂ† (LS Ã¢ÂŠÂ— GA) , DID is preserved by the  ÃÄ…ta1 Ã¢Â†Â‘LSÃ¢ÂŠÂ—GA  transformations, Clk veriÄÅ¹Âes the DID properties, the product  and the transformation are compatible w.r.t bisimulation and  Lemma 1.  5) Comparison with Standard TA Semantics: We now state  the equivalence between our TA semantics and the standard  one. We start by deÄÅ¹Âning the standard TA semantics by the  function [[ ]]std : LT SLSÃ¢ÂŠÂ—GA Ã¢Â†Â’ LT SLSÃ¢ÂŠÂ—GAÃ¢ÂŠÂ•T S such that  [[Q, Q0 , Ã¢Â†Â’]]std = Q Ä‚Â— (C Ã¢Â†Â’ R+ ), Q0 Ä‚Â— {c : C Ã¢Â†Â’ 0}, Ã¢Â†Â’s   where :  (l,(g,(r,u)))  q Ã¢ÂˆÂ’Ã¢ÂˆÂ’Ã¢ÂˆÂ’Ã¢ÂˆÂ’Ã¢ÂˆÂ’Ã¢ÂˆÂ’Ã¢ÂˆÂ’Ã¢Â†Â’q  ,    cÃ¢ÂˆÂˆC  v(c)Ã¢ÂˆÂˆg(c) ,    cÃ¢ÂˆÂˆr  v  (c)=0 ,    cÃ¢ÂˆÂˆu  Ã¢ÂÂ§  Ã¢ÂÂ¨min(i1 (c), i2 (c)) if c Ã¢ÂˆÂˆ dom(i1 ) Ã¢ÂˆÅ  dom(i2 )  i1 (c) if c Ã¢ÂˆÂˆ dom(i1 ) \ dom(i2 )  )  Ã¢ÂÅ i (c) if c Ã¢ÂˆÂˆ dom(i ) \ dom(i )  2  2  1  v  (c)=v(c)  (l,(g,(r,u)))  (q,v)Ã¢ÂˆÂ’Ã¢ÂˆÂ’Ã¢ÂˆÂ’Ã¢ÂˆÂ’Ã¢ÂˆÂ’Ã¢ÂˆÂ’Ã¢ÂˆÂ’Ã¢Â†Â’s (q  ,v  )  ÃÂ´  (q,v)Ã¢Â†Â’s (q,v+ÃÂ´)  130  116  or by composing the original LTS with the one provided with  the extension.  We show that these two methods are equivalent and that,  provided some hypothesis, the semantics of the extension is  compositional.                                        Fig. 2.       A. Semantic Extension  Given a label structure LS1 , we introduce an extension label  structure LS2 supposed to be ACI, and its semantics deÄÅ¹Âned  by an LTS C(the controller) over LS2 Ã¢ÂŠÂ• LS3 .  We deÄÅ¹Âne the extended semantics by the function [[ ]]std  :  C  LT SLS1 Ã¢ÂŠÂ—LS2 Ã¢Â†Â’ LT SLS1 Ã¢ÂŠÂ—LS2 Ã¢ÂŠÂ•LS3 such that [[L =  0  0  Q, Q0 , Ã¢Â†Â’]]std  C = Q Ä‚Â— QC , Q Ä‚Â— QC , Ã¢Â†Â’s  where :        Semantics of TSA via a Composition of Two LTSs  b) Reconstructing the TSA Semantics: As before, the  TSA semantics is deÄÅ¹Âned by means of a composition between  the syntactic tsa and IClk. The semantics of a timed safety  automaton is reconstructed as follows :  l2 Ã¢Â€Ë˜  (l1 ,l2 )  qÃ¢ÂˆÂ’  Ã¢ÂˆÂ’Ã¢ÂˆÂ’Ã¢ÂˆÂ’Ã¢Â†Â’q , qC Ã¢ÂˆÂ’Ã¢ÂˆÂ’Ã¢Â†Â’qC , l2 Ã¢Â‰Â¤l2  (l1 ,l2 )Ã¢Â€Ë˜   )  (q,qC )Ã¢ÂˆÂ’Ã¢ÂˆÂ’Ã¢ÂˆÂ’Ã¢ÂˆÂ’Ã¢Â†Â’s (q  ,qC  Ã¢Â€Ë˜l  (l,)  q Ã¢ÂˆÂ’Ã¢ÂˆÂ’Ã¢Â†Â’q     qC Ã¢Â†Â’qC   )  (q,qC )Ã¢ÂˆÂ’Ã¢ÂˆÂ’Ã¢ÂˆÂ’Ã¢Â†Â’s (q  ,qC   )  (q,qC )Ã¢Â†Â’s (q,qC  Ã¢Â€Ë˜l  (l,)Ã¢Â€Ë˜  [[tsa]] =  IÃ¢ÂŠÂ—T S  )1  (tsa(Ã¢Â‡Â‘LSÃ¢ÂŠÂ—GAÃ¢ÂŠÂ•  LSÃ¢ÂŠÂ—GAÃ¢ÂŠÂ• Ã¢Â†Â‘I  S LSÃ¢ÂŠÂ—GA  Clk(Ã¢Â‡Â‘Ã¢ÂŠÂ•IÃ¢ÂŠÂ—T  ))  Ã¢ÂŠÂ•IÃ¢ÂŠÂ—T S Ã¢Â†Â‘GA  The semantic LTS is deÄÅ¹Âned over the product of the state  space of the syntactic LTS L and the controller C. Its transitions are built by joining transitions on LS1 Ã¢ÂŠÂ— LS2 and  adding transitions over LS3 . In order to allow the composition  with user-given LTSs, we add non-determinism through the  introduction of the label l2 such that l2 Ã¢Â‰Â¤ l2 . Coming back to  Timed Automata, this corresponds to making at least the resets  and the unchanged actions asked by the user. Unreferenced  clocks can be freely modiÄÅ¹Âed which allows parallel LTSs to  impose their own modiÄÅ¹Âcations.  This semantics is shown to be equivalent to the following  one which reuses the label structure operators  Theorem 6 (TSA Semantics Compositionality): Given two  timed safety automata tsa1 and tsa2 , [[tsa1 1tsa2 ]]   [[tsa1 ]]1[[tsa2 ]].  Proof: This proof is similar to the TA Semantics Compositionality proof.  4) Comparison with Standard TSA Semantics: We now  state the equivalence between our TSA semantics and the  derived standard one in which a speciÄÅ¹Âc encoding of the state  invariant is taken into account. We start by deÄÅ¹Âning the standard TSA semantics by the function [[ ]]std : LT SLSÃ¢ÂŠÂ—GAÃ¢ÂŠÂ•I Ã¢Â†Â’  LT SLSÃ¢ÂŠÂ—GAÃ¢ÂŠÂ•IÃ¢ÂŠÂ—T S such that [[Q, Q0 , Ã¢Â†Â’]]std = Q Ä‚Â— (C Ã¢Â†Â’  R+ ), Q0 Ä‚Â— {c : C Ã¢Â†Â’ 0}, Ã¢Â†Â’s  where :  (l,(g,(r,u)))  q Ã¢ÂˆÂ’Ã¢ÂˆÂ’Ã¢ÂˆÂ’Ã¢ÂˆÂ’Ã¢ÂˆÂ’Ã¢ÂˆÂ’Ã¢ÂˆÂ’Ã¢Â†Â’q ,      cÃ¢ÂˆÂˆC  v(c)Ã¢ÂˆÂˆg(c) ,    cÃ¢ÂˆÂˆr    v (c)=0 ,    cÃ¢ÂˆÂˆu  1 Ã¢ÂŠÂ—LS2 Ã¢ÂŠÂ•LS3    [[L]]C = (L Ã¢Â†Â‘LS  LS1 Ã¢ÂŠÂ—LS2    v (c)=v(c)  i  3 LS1 Ã¢ÂŠÂ—LS2   C(Ã¢Â‡Â‘Ã¢ÂŠÂ•LS  ))  Ã¢ÂŠÂ•LS3 Ã¢Â†Â‘LS2  Theorem 8 (Extension Semantic): Given two LTSs L over  LS1 Ã¢ÂŠÂ— LS2 and C over LS2 Ã¢ÂŠÂ• LS3 with LS2 ACI, [[L]]std  C  and [[L]]C are state-bisimilar through the identity relation if  the following conditions hold :  Ã¢Â€Ë˜ transitions of L are not of the form (l, ),  Ã¢Â€Ë˜ the LS2 labels of the transitions of C are maximal for Ã¢Â‰Â¤.  (l,(g,(r,u)))  (q,v)Ã¢ÂˆÂ’Ã¢ÂˆÂ’Ã¢ÂˆÂ’Ã¢ÂˆÂ’Ã¢ÂˆÂ’Ã¢ÂˆÂ’Ã¢ÂˆÂ’Ã¢Â†Â’s (q  ,v  )  q Ã¢Â†Â’q  1  (LS1 Ã¢ÂŠÂ—LS2 )Ã¢Â€Ë˜  Ã¢ÂˆÂ€cÃ¢ÂˆÂˆC,v(c)+ÃÂ´Ã¢Â‰Â¤i(c)  ÃÂ´  (q,v)Ã¢Â†Â’s (q,v+ÃÂ´)  Remark that a disjunctive invariant can be modeled using  several looping transitions (second rule).  Theorem 7: Given a timed safety automaton where each  transition is labeled by an action (not by  labels introduced by  the label structure product), its standard and proposed (revised)  semantics are state-bisimilar through the identity relation.  B. Compositionality  The compositionality result concerning the parallel operator  of timed automata can be generalized as follows :  Theorem 9 (Generalized Compositionality): Given  two  LTSs L1 and L2 over LS1 Ã¢ÂŠÂ— LS2 and a controller C over  LS2 Ã¢ÂŠÂ• LS3 , we have  V. T OWARDS G IVING L IFE TO L ABEL S TRUCTURES  In this section, we show how the previous semantic deÄÅ¹Ânitions could be generalized by attaching behaviors to label  structures. For this purpose, we abstract the timed automata  semantic construction by associating a behavior to label  structures in the form of an LTS. Starting from an LTS  built on a given label structure, a syntactic extension can  be reached by composing labels with those of a new label  structure (for instance, as we have seen, extending LTS to  Timed Automata by adding action and guard labels). The  corresponding semantics can be deÄÅ¹Âned either by overlaying  [[L1 1L2 ]]C  [[L1 ]]C 1[[L2 ]]C  if the following conditions hold :  Ã¢Â€Ë˜ LS1 and LS3 are associative and commutative.  Ã¢Â€Ë˜ LS2 is ACI.  Ã¢Â€Ë˜ C is DID.  This theorem has a similar proof as the timed automata one.  Furthermore, all the hypothesis are satisÄÅ¹Âed in the timed  automata context.  131  117  [2] R. Alur, C. Courcoubetis, and D. Dill. Model-checking in dense realtime. Inf. Comput., 104(1):2Ã¢Â€Â“34, May 1993.  [3] R. Alur and D. L. Dill. A theory of timed automata. Theor. Comput.  Sci., 126(2):183Ã¢Â€Â“235, Apr. 1994.  [4] F. Arbab. Abstract behavior types: a foundation model for components  and their composition. Sci. Comput. Program., 55(1-3):3Ã¢Â€Â“52, Mar. 2005.  [5] A. Arnold, G. Point, A. Griffault, and A. Rauzy. The AltaRica formalism  for describing concurrent systems. Fundam. Inf., 40(2-3):109Ã¢Â€Â“124, 1999.  [6] A. Basu, M. Bozga, and J. Sifakis. Modeling heterogeneous real-time  components in bip. In SEFM, pages 3Ã¢Â€Â“12. IEEE Computer Society,  2006.  [7] G. Behrmann, A. David, and K. G. Larsen. A tutorial on uppaal. In  M. Bernardo and F. Corradini, editors, International School on Formal  Methods for the Design of Computer, Communication, and Software  Systems, SFM-RT 2004. Revised Lectures, volume 3185 of Lecture Notes  in Computer Science, pages 200Ã¢Â€Â“237. Springer Verlag, 2004.  [8] W. Brauer, W. Reisig, and G. Rozenberg, editors. Petri Nets: Central  Models and Their Properties, Advances in Petri Nets 1986, Part II,  Proceedings of an Advanced Course, Bad Honnef, 8.-19. September  1986, volume 255 of Lecture Notes in Computer Science. Springer, 1987.  [9] P. Farail, P. GauÄÅ¹Âllet, F. Peres, J.-P. Bodeveix, M. Filali, B. Berthomieu,  S. Rodrigo, F. Vernadat, H. Garavel, and F. Lang. FIACRE: an intermediate language for model veriÄÅ¹Âcation in the TOPCASED environment. In  European Congress on Embedded Real-Time Software, ERTSÃ¢Â€Â™08, 2008.  [10] I. O. for Standardization. Information processing systems - open systems  interconnection - LOTOS - a formal description technique based on the  temporal ordering of observational behaviour. International standard.  ISO, 1989.  [11] T. Henzinger, Z. Manna, and A. Pnueli. Timed transition systems. In  J. de Bakker, C. Huizing, W. de Roever, and G. Rozenberg, editors, RealTime: Theory in Practice, volume 600 of Lecture Notes in Computer  Science, pages 226Ã¢Â€Â“251. Springer, 1992. 10.1007/BFb0031995.  [12] T. A. Henzinger, X. Nicollin, J. Sifakis, and S. Yovine. Symbolic model  checking for real-time systems. Inf. Comput., 111(2):193Ã¢Â€Â“244, 1994.  [13] T. Hoare and P. OÃ¢Â€Â™Hearn. Separation logic semantics for communicating  processes. Electron. Notes Theor. Comput. Sci., 212:3Ã¢Â€Â“25, Apr. 2008.  [14] H. HuÄšÂˆttel and K. Larsen. The use of static constructs in a model process  logic. In A. Meyer and M. Taitslin, editors, Logic at Botik Ã¢Â€Â™89, volume  363 of Lecture Notes in Computer Science, pages 163Ã¢Â€Â“180. Springer  Berlin Heidelberg, 1989.  [15] K. Larsen, P. Pettersson, and W. Yi. Model-checking for real-time  systems. In H. Reichel, editor, Fundamentals of Computation Theory,  volume 965 of Lecture Notes in Computer Science, pages 62Ã¢Â€Â“88.  Springer, 1995. 10.1007/3-540-60249-6 41.  [16] R. Milner. Communication and concurrency. Prentice Hall International,  1995.  [17] A. W. Roscoe. The Theory and Practice of Concurrency. Prentice Hall,  1997.  [18] A. W. Roscoe. On the expressiveness of CSP. Technical report,  www.cs.ox.ac.uk/files/1383/complete(3).pdf, 2011.  [19] E. Sekerinski and K. Sere. A theory of prioritizing composition.  Technical report, 1996.  VI. C ONCLUSION  We have presented a formal semantic framework for studying, deÄÅ¹Âning, and manipulating the composition of extended  transition systems based on the composition of their labels.  The framework is based on the idea of deÄÅ¹Âning a label  structure containing a composition operator. Depending on  the language in question, a different label structure is deÄÅ¹Âned  and thus different composition laws are integrated. The label  structure is then used as a parameter of labeled transition  systems which describe the common semantic domain of  the considered languages. We believe that the suggested  parametrization of the behavioral framework is a promising  work and may represent, especially with the perspectives we  have, the ÄÅ¹Ârst step towards giving a uniÄÅ¹Âed formal semantic  framework for different process algebras and speciÄÅ¹Âcation  languages.  In our study, we emphasize on composition operators of  process algebras without concentrating on other behavioral  operators. In this context, we have pushed forward existing  work of similar structures [14], [18], [13] by offering a richer  set of operations and properties such as the composition of  label structures and transformations between label structures.  Following our technique, the composition of different LTS  extensions, whether it is a syntactic model or a semantic  model, is captured by a unique composition operation deÄÅ¹Âned  on LTS. This is a direct result of the separation between the  label structure and the behavioral framework. This result is  different than what can be found in the literature since with  each system, a different composition operation is provided.  This can be seen classically in the composition operations of  LTS and TTS. Even though a TTS is exactly an LTS having  additionally time transitions, usually its composition operation  does not reuse the LTS one.  Furthermore, generic results concerning label structures and  LTS transformations are applied to establish well known properties of high-level structures such as the deÄÅ¹Ânition of timed  automata semantics. We have shown that these semantics  match with the standard timed automata semantics and that the  timed automata are compositional w.r.t the parallel operator.  We are now working on a dual view of this work which  consists in coupling our label structures to states. This will  help us to naturally take into consideration state-based mechanisms such as the the committed states of UPPAAL [7]. We  are also working on deÄÅ¹Âning the formal semantics of real  time languages (BIP [6] and FIACRE [9]). Namely, we are  interested in extending our label structure with priorities which  are present in all the three cited languages. Another extension  is to revisit this work by incorporating some categorical ÄÅ¹Â‚avor.  Finally, all the theorems related to the presented framework  have been validated in the proof assistant Coq. The Coq theory  may be found at [1].  Acknowledgement: The authors would like to thank the  reviewers for thoroughly reading the paper.  R EFERENCES  [1] http://www.irit.fr/~Jean-Paul.Bodeveix/COQ/LblStr.  132  118 