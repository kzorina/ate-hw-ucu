Monitoring Usage-control Policies in Distributed Systems  David Basin, Matúš Harvan, Felix Klaedtke, and Eugen Zălinescu  ETH Zurich, Computer Science Department, Switzerland  Abstract—We have previously presented a monitoring algorithm for compliance checking of policies formalized in  an expressive metric first-order temporal logic. We explain  here the steps required to go from the original algorithm to  a working infrastructure capable of monitoring an existing  distributed application producing millions of log entries per  day. The main challenge is to correctly and efficiently monitor  the trace interleavings obtained by totally ordering actions  that happen at the same time. We provide solutions based  on formula transformations and monitoring representative  traces. We also report, for the first time, on statistics on the  performance of our monitor on real-world data, providing  evidence of its suitability for nontrivial applications.  I. Introduction  Determining whether the usage of sensitive data complies  with regulations and policies is a growing concern for companies, administrations, and end users alike. In the context  of IT systems, this question amounts to whether one can implement processes that monitor other processes. In previous  work [1], [2], we have demonstrated that metric first-order  temporal logic (MFOTL) is a good candidate for monitoring  data usage to determine policy compliance. In particular,  the metric temporal operators allow one to formalize both  qualitative and quantitative temporal relationships between  actions and, as the logic is first-order, we can also formulate  dependencies between the finite but unbounded number of  agents and data elements in IT systems. We have given  a monitoring algorithm for MFOTL [1] and many usagecontrol policies can be naturally formulated in the fragment  that the monitor handles efficiently [2].  In this paper, we extend our previous work by deploying  and evaluating our monitoring approach in a real-world  concurrent and distributed setting. This is in contrast to  our previous analysis [2], which we carried out in a nondistributed setting where we used log files filled with synthetically generated actions. In the following, we describe  our monitoring setup and the challenges we faced. We begin  with an abstract description of the systems that we handle.  System Model. The types of entities in our systems  are data, (data) stores, agents, and actions. Data is stored in  distributed data stores such as databases and repositories and  created, read, modified, propagated, combined, and deleted  by actions initiated by agents. Agents are either humans or  applications, including database triggers.  Agents always access the data directly from a store and  never indirectly from another agent. Whenever an agent  Figure 1.  System Extension  wants to use some data, it accesses the appropriate store,  uses the data, and discards it afterwards. For subsequent  usage, it must access the store again. Before discarding the  data, the agent may write it, possibly after processing it in  some way, into the same or a different store. In this way,  data can propagate between stores. A consequence of this  restriction on the interaction between system entities is that  the use of data is always observable at the data stores.  Systems are governed by (usage-control) policies, which  state requirements on the usage of the data. For example,  only agents with particular credentials may modify data, or  data must be deleted after two years from a given store.  Agents may or may not comply with policies.  Logging and Monitoring. Given a system that is an  instance of the above system model, we must extend it  to support logging and monitoring. To determine whether  a policy is violated we usually need to relate actions that  are carried out in different parts of the system. Moreover,  the ordering of actions and the time elapsed between them  is important. To relate actions and the times when they  happen, we log them locally, annotating each action with a  timestamp, and merge these logs after some pre-processing.  We then monitor this merged stream of logged actions. These  system extensions are depicted in Figure 1.  Challenges and Contributions. Individual logs are  totally ordered and timestamped using local clocks. However, even assuming clock synchronization [3], we have only  a partial order on system actions [4] as multiple actions  with the same timestamp may occur in different logs. Our  main theoretical challenge is to monitor such a partially  ordered set of actions, which is, in general, an intractable  problem. In Section III, we identify a subclass of formulas  that describe properties that are insensitive to the ordering  of actions labeled by the same timestamp and for which  it suffices to monitor a particular merging of the logs,  namely, the merging that assumes that actions with equal  timestamps happen simultaneously. Furthermore, in case  the given formula is outside this class we provide means  to meaningfully monitor this merge by approximating the  described property.  A practical challenge is to deploy adequate logging mechanisms. The mechanisms should be complete in that they  log all occurrences of policy-relevant system actions. They  should also be accurate in that if an action is logged then it  has happened in the system and the corresponding log entry  accurately describes the action, e.g, it describes the involved  data and the associated timestamp is the actual time when  the action happened. Incomplete or inaccurate logging may  lead to false positives and false negatives when monitoring  the system.  In Section IV, we explain how we handle these practical  challenges in our case study. Where possible, we use existing  logging mechanisms and extract policy-relevant information  from the produced log entries. For system components where  no logging was available, we either added logging directly  to the components or we extended the components with  proxy mechanisms that logged actions. However, proxies  have limitations: agents do not necessarily access a store  over a proxy and proxies see requested actions but not  necessarily all the effects on the involved data. In our case,  the interactions could be accurately observed but not for all  agents, which led to accurate but incomplete logs.  Summarizing, we see our contributions as follows. We  provide solutions for efficiently monitoring partially ordered  logs, which is a central problem in monitoring real-time  concurrent distributed systems. Moreover, we evaluate the  performance of our monitoring approach and demonstrate  its effectiveness on a real-world application.  Organization. The remainder of this paper is structured  as follows. In Section II, we give background on MFOTL  and our monitor. In Section III, we show how we handle  the interleavings of multiple streams of logged actions from  different log producers. In Section IV, we report on our  case study. In Section V, we discuss related work and in  Section VI, we draw conclusions. The Appendices A–D  contain additional proof details. Additional details on the  case study are given in Appendix E.  II. Preliminaries  We briefly review metric first-order temporal logic  (MFOTL) and describe how we use it to monitor systems.  Syntax and Semantics. Let I be the set of nonempty  intervals over N. We will write an interval I ∈ I as [b, b0 ) :=  {a ∈ N | b ≤ a < b0 }, where b ∈ N, b0 ∈ N ∪ {∞}, and b < b0 .  A signature S is a tuple (C, R, ι), where C is a finite set  of constant symbols, R is a finite set of predicates disjoint  from C, and the function ι : R → N associates each predicate  r ∈ R with an arity ι(r) ∈ N. In the following, let S = (C, R, ι)  be a signature and V a countably infinite set of variables,  assuming V ∩ (C ∪ R) = ∅.  (D̄, τ̄, v, i) |= t≈ t0  (D̄, τ̄, v, i) |= t≺ t0  (D̄, τ̄, v, i) |= r(t1 , . . . , tι(r) )  (D̄, τ̄, v, i) |= (¬φ)  (D̄, τ̄, v, i) |= (φ ∨ ψ)  (D̄, τ̄, v, i) |= (∃x. φ)  (D̄, τ̄, v, i) |= ( I φ)  (D̄, τ̄, v, i) |= (#I φ)  (D̄, τ̄, v, i) |= (φ SI ψ)  (D̄, τ̄, v, i) |= (φ UI ψ)  v(t) = v(t0 )  v(t) < v(t0 )    v(t1 ), . . . , v(tι(r) ) ∈ rDi  (D̄, τ̄, v, i) 6|= φ  (D̄, τ̄, v, i) |= φ or (D̄, τ̄, v, i) |= ψ  (D̄, τ̄, v[x/d], i) |= φ, for some d ∈ |D̄|  i > 0, τi − τi−1 ∈ I, and (D̄, τ̄, v, i − 1) |= φ  τi+1 − τi ∈ I and (D̄, τ̄, v, i + 1) |= φ  for some j ≤ i, τi − τ j ∈ I, (D̄, τ̄, v, j) |= ψ,  and (D̄, τ̄, v, k) |= φ, for all k ∈ [ j + 1, i + 1)  iff for some j ≥ i, τ j − τi ∈ I, (D̄, τ̄, v, j) |= ψ,  and (D̄, τ̄, v, k) |= φ, for all k ∈ [i, j)  iff  iff  iff  iff  iff  iff  iff  iff  iff  Figure 2.  Semantics of MFOTL  Formulas over the signature S are given by the grammar  φ ::= t1≈ t2 t1≺ t2 r(t1 , . . . , tι(r) ) (¬φ) (φ ∨ φ) (∃x. φ)  (  I  φ) (#I φ) (φ SI φ) (φ UI φ) ,  where t1 , t2 , . . . range over the elements in V ∪ C, and r, x,  and I range over the elements in R, V, and I, respectively.  To define MFOTL’s semantics, we need the following  notions. A structure D over S consists of a domain |D| , ∅  and interpretations cD ∈ |D| and rD ⊆ |D|ι(r) , for each c ∈ C  and r ∈ R. A temporal structure over S is a pair (D̄, τ̄),  where D̄ = (D0 , D1 , . . . ) is a sequence of structures over S  and τ̄ = (τ0 , τ1 , . . . ) is a sequence of natural numbers (i.e.,  timestamps), where:  (1) The sequence τ̄ is monotonically increasing (i.e., τi ≤  τi+1 , for all i ≥ 0) and makes progress (i.e., for every  i ≥ 0, there is some j > i such that τ j > τi ).  (2) D̄ has constant domains, i.e., |Di | = |Di+1 |, for all i ≥ 0.  We denote the domain by |D̄| and require that |D̄| is  strict linearly ordered by a relation <.  (3) Each constant symbol c ∈ C has a rigid interpretation,  i.e., cDi = cDi+1 , for all i ≥ 0. We denote c’s interpretation by cD̄ .  A valuation is a mapping v : V → |D̄|. We abuse notation  by applying a valuation v also to constant symbols c ∈ C,  with v(c) = cD̄ . For a valuation v, a variable x, and d ∈ |D̄|,  v[x/d] is the valuation mapping x to d and not altering the  other variables’ valuation.  The semantics of MFOTL, (D̄, τ̄, v, i) |= φ, is given in  Figure 2, where (D̄, τ̄) is a temporal structure over the  signature S , with D̄ = (D0 , D1 , . . . ), τ̄ = (τ0 , τ1 , . . . ), v a  valuation, i ∈ N, and φ a formula over S . Note that the  temporal operators are labeled with intervals I and a formula  of the form ( I φ), (#I φ), (φSI ψ), or (φUI ψ) is only satisfied  in (D̄, τ̄) at the time point i, if it is satisfied within the bounds  given by the interval I of the respective temporal operator,  which are relative to the current timestamp τi .  Terminology and Notation. We use standard syntactic  sugar such as I φ := ¬(trueSI ¬φ) and I φ := ¬(trueUI ¬φ),  where true := ∃x. x ≈ x. We also use non-metric operators  like  φ := [0,∞) φ. We omit parentheses where possible,  III. Monitoring Concurrently Logged Actions  In this section, we first prove the intractability of monitoring where logs are produced in a concurrent setting. We then  show how to partially overcome this obstacle by monitoring  a single log where all actions with equal timestamps are  assumed to have happened at the same point in time. Proof  details are given in the Appendices A–D.  Definition 1. Let (D̄1 , τ̄1 ), (D̄2 , τ̄2 ), and (D̄, τ̄) be temporal  structures. (D̄, τ̄) is an interleaving of (D̄1 , τ̄1 ) and (D̄2 , τ̄2 )  if there are strictly monotonic functions f1 , f2 : N → N with  (1) img( f1 ) ∪ img( f2 ) = N,  (2) img( f1 ) ∩ img( f2 ) = ∅, and  k  (3) τki = τ fk (i) and rDi = rD fk (i) , for all k ∈ {1, 2}, i ∈ N, r ∈ R.  We denote by (D̄1 , τ̄1 ) (D̄2 , τ̄2 ) the set of all interleavings  of the temporal structures (D̄1 , τ̄1 ) and (D̄2 , τ̄2 ).  Since there are usually multiple interleavings of two  temporal structures, we formulate policy violations in terms  of a set of temporal structures.  Definition 2. Let T be a set of temporal structures.  (1) T weakly violates the formula φ at time point i ∈ N if  for some (D̄, τ̄) ∈ T and some valuation v, it holds that  (D̄, τ̄, v, i) 6|= φ.  (2) T strongly violates the formula φ at time point i ∈ N if  for all (D̄, τ̄) ∈ T, there is some valuation v such that  (D̄, τ̄, v, i) 6|= φ.  Unfortunately, even in a propositional setting, determining  whether the set of interleavings weakly or strongly violates  a formula is intractable.  Theorem 3. Let (D̄1 , τ̄1 ) and (D̄2 , τ̄2 ) be temporal structures, i ∈ N, and φ a quantifier-free sentence with only  Boolean and non-metric past operators that neither contains  the equality symbol ≈ nor the ordering symbol ≺.  1. Determining whether the set of interleavings (D̄1 , τ̄1 )  (D̄2 , τ̄2 ) weakly violates φ at i is NP-complete.  2. Determining whether the set of interleavings (D̄1 , τ̄1 )  (D̄2 , τ̄2 ) strongly violates φ at i is coNP-complete.  ./  We assume that the actions for publishing and approving  reports are logged in relations. Specifically, for each time  point i ∈ N, we have the unary relations PUBLISH i and  APPROVEi such that (1) x ∈ PUBLISH i iff report f is  published at time point i and (2) x ∈ APPROVEi iff report  x is approved at time point i. Observe that there can be  multiple approvals at the same time point for different  reports. Furthermore, every time point i has a timestamp  τi ∈ N.  The corresponding temporal structure (D̄, τ̄) with D̄ =  (D0 , D1 , . . . ) and τ̄ = (τ0 , τ1 , . . . ) of a sequence of logged  publishing and approval actions is as follows. The only  relational symbols in D̄’s signature are publish and approve,  both of arity 1. The domain of D̄ consists of all reports. The  ith structure in D̄ is timestamped with τi and contains the  relations PUBLISH i and APPROVEi .  To detect policy violations, our monitor [1] iteratively  processes the temporal structure (D̄, τ̄) representing the  stream of logged actions. This can be done offline or online.  At each time point i, it outputs the valuations satisfying  the negation of the formula publish(x) → [0,11) approve(x).  Note that we drop the outermost quantifier since we are not  only interested in whether the policy is violated but also  which data is responsible for the reported violations.  In general, we assume that policies formalized in MFOTL  are of the form  ψ, where ψ is bounded. Since ψ is  bounded, the monitor need only take into account a finite  prefix of (D̄, τ̄) when determining the satisfying valuations  of ¬ψ at a time point i. To effectively determine all these  valuations, we also assume here that predicates have finite  interpretations in (D̄, τ̄), i.e., the relation rD j is finite, for  every predicate r and every j ∈ N. Furthermore, we require  that ¬ψ can be rewritten to a temporal-subformula-domainindependent formula, a generalization of the standard notion  of domain-independent database queries [5].  ./   ∀x. publish(x) → [0,11) approve(x) .  Log Interleavings. Intuitively, an interleaving of logs  preserves the ordering of the logged actions with respect  to their timestamps, but allows for all possible orderings of  actions with equal timestamps that are recorded by different  log producers. To define this, let img( f ) denote the set {y ∈  Y | f (x) = y, for some x ∈ X}, for a function f : X → Y.  Furthermore, we assume in this section that all temporal  structures have the same signature (C, R, ι), equal domains,  and that constant symbols are equally interpreted. Note that  any two temporal structures in which the common constant  symbols are equally interpreted can easily be extended so  that their extensions fulfill this requirement.  ./  e.g., unary operators (temporal and Boolean) bind stronger  than binary ones. A formula φ is bounded if the interval I of  every temporal operator UI occurring in φ is finite. We use  standard terminology like atomic formula and subformula.  System Monitoring. We illustrate our use of MFOTL  and our monitoring algorithm [1] for compliance checking  by the simple policy stating that reports must be approved  within at most 10 time units before they are published:  Note that both decision problems are well defined as φ  does not contain future operators. We therefore only need  to examine the finite prefixes with length i + 1 of the  interleavings to determine whether φ is weakly or strongly  violated at the given time point i.  Collapsing Interleaved Logs. We first give conditions  with respect to an arbitrary set of temporal structures for  when it suffices to monitor a single temporal structure. We  then identify a natural temporal structure for the set of  interleavings of two temporal structures, which we use for  In the following, the set T in the above definition will be  the set of interleavings of two temporal structures. For the  temporal structure (C̄, κ̄), we will use the so-called collapse:  Definition 5. Let (D̄, τ̄) and (C̄, κ̄) be temporal structures.  (C̄, κ̄) is a collapse of (D̄, τ̄) if there is a monotonic surjective  function f : N → N such that  (1) if τi = τ j then f (i) = f ( j), for all i, j ∈ N,  (2) κ f (i) = τi , for all i ∈ N, and  S  (3) rC j = i∈ f −1 ( j) rDi , for all j ∈ N and r ∈ R.  Intuitively, the structures of the temporal structure (D̄, τ̄)  with equal timestamps are collapsed into a single structure. The collapse is uniquely defined and we denote it  by col(D̄, τ̄). Furthermore, the collapses of temporal structures in the set of interleavings of two given temporal  structures are all isomorphic.  Before we identify formulas for which the collapse of an  interleaving of given temporal structures can be correctly  used for monitoring, we give practical reasons that justify  its use for monitoring. First, observe that the collapse can  be incrementally obtained from an arbitrary interleaving  of two given temporal structures. Hence, monitoring the  collapse can be done efficiently. Second, note that the  actual ordering of actions logged with equal timestamps  in a concurrent system cannot be known. Hence, it does  not make sense to consider just one arbitrary interleaving.  Assuming that equally timestamped actions have happened  at the same point in time naturally “hides” the differences  between interleavings. Moreover, reasonable policies for a  concurrent system should not care about the ordering of  equally timestamped actions in case of accurate and precise  clocks. In other words, if the collapsed temporal structure  is not sufficient for the policy on the set of interleavings,  then the policy might not be the intended one for the  system. Finally, monitoring the collapsed temporal structure  is practically more efficient than monitoring an interleaving.  This is because the monitor is invoked less often since time  points with equal timestamps are merged to a single one.  Hence, the monitor processes the logged actions with equal  timestamp in a single invocation.  Monitoring the Collapse. Intuitively, collapse-sufficient formulas are formulas that do not yield false positives  and false negatives when monitoring the collapse of an  interleaving:  Definition 6. Let φ be a formula. For k ∈ {1, 2}, we say that  φ has the property (Ck) if (C̄, κ̄) fulfills the condition (Ck) in  ./  Monitoring the collapse of a collapse-sufficient formula is  correct with respect to strong violations. Since the formula  has property (C2), violations found in (C̄, κ̄) imply that  the set of interleavings strongly violates the formula. The  converse is ensured by the property (C1): if no violation is  found in (C̄, κ̄) then all interleavings are policy compliant.  Furthermore, by monitoring (C̄, κ̄) we also detect when the  set of interleavings weakly violates the given formula. The  reason is that if a formula is strongly violated by the set of  interleavings then it also weakly violated, since the set of  interleavings is always nonempty.  Example 7. The formula ∀x.publish(x) → [0,11) approve(x)  is not collapse-sufficient. Suppose that a report x is pub1  lished in (D̄1 , τ̄1 ) at time point i, i.e., x ∈ publishDi and  only approved in (D̄2 , τ̄2 ) at the equally timestamped time  2  point j, i.e., x ∈ approveD j with τ2j = τ1i . Then there is an  interleaving (D̄, τ̄) ∈ (D̄1 , τ̄1 ) (D̄2 , τ̄2 ) where the approval  action comes (pointwise) strictly after the publish action.  As a result, we cannot handle this formula correctly by  monitoring the collapsed temporal structure (C̄, κ̄) of an  interleaving of the given temporal structures (D̄1 , τ̄1 ) and  (D̄2 , τ̄2 ).  A slightly stronger policy can be efficiently monitored.  Namely, the policy that requires that an approval action must happen timewise strictly before the publish action, i.e.,  ∀x. publish(x) → [1,11) approve(x). This formula is collapse-sufficient. Similarly,  ∀x. publish(x) →  ♦[0,1) [0,11) approve(x) is also collapse-sufficient. It formalizes the slightly weaker policy where publish actions must  be timewise but not pointwise previously approved.  Note that stutter-invariance [6] is a necessary condition for  collapse-sufficiency. However, it is not a sufficient condition.  For example, the formula  ∀x. p(x) ∧ q(x) is stutteringinvariant but not collapse-sufficient.  A Collapse-sufficient Fragment. In the following,  we present a fragment of collapse-sufficient formulas. Our  fragment is defined in terms of an algorithm that identifies  formulas that have property (C1) or property (C2).  The algorithm labels the atomic subformulas of the given  formula and propagates these labels bottom-up to the formula’s root using a fixed set of inference rules. The labels  represent invariants, which capture the relation between  violations found in a collapsed temporal structure (C̄, κ̄)  at some time point and violations found in its pre-images  (D̄, τ̄) ∈ col−1 (C̄, κ̄) at a time point with an equal timestamp,  where col−1 (C̄, κ̄) denotes the set of temporal structures  (D̄0 , τ̄0 ) with col(D̄0 , τ̄0 ) = (C̄, κ̄). Note that (D̄, τ̄) (D̄0 , τ̄0 ) (  col−1 (C̄, κ̄), where (C̄, κ̄) is the collapse of an interleaving of  ./  Definition 4. The temporal structure (C̄, κ̄) is sufficient for  the formula φ on the set T of temporal structures if for all  valuations v, the following conditions are fulfilled:  (C1) If (C̄, κ̄, v, 0) |= φ then (D̄, τ̄, v, 0) |= φ, for all (D̄, τ̄) ∈ T.  (C2) If (C̄, κ̄, v, 0) 6|= φ then (D̄, τ̄, v, 0) 6|= φ, for all (D̄, τ̄) ∈ T.  Definition 4 with respect to φ and (D̄, τ̄) (D̄0 , τ̄0 ), for every  (D̄, τ̄), (D̄0 , τ̄0 ), and (C̄, κ̄), where (C̄, κ̄) is the collapse of an  interleaving of (D̄, τ̄) and (D̄0 , τ̄0 ). Moreover, φ is collapsesufficient if it has the properties (C1) and (C2).  ./  monitoring.  t ≈ t0 : (|= ∀)  r(t1 , . . . , tι(r) ) : (|= ∃)  ψ : (|= ∀)  ψ : (|= ∃)  ψ : (|= ∀)  I ψ : (|= ∀)  ψ : (|= ∃)  I ψ : (|= ∃)  t ≈ t0 : (6|= ∀)  r(t1 , . . . , tι(r) ) : (6|= ∀)  ψ : (6|= ∀)  ψ : (6|= ∃)  ψ : (|= ∃)  0<I  I ψ : (|= ∀)  ψ : (6|= ∀)  I ψ : (6|= ∀)  ψ : (|= ∃)  0∈I∩J  I ♦ J ψ : (|= ∀)  Figure 3.  Selection of Inference Rules  the temporal structures (D̄, τ̄) and (D̄0 , τ̄0 ).  The labels and their corresponding invariants are as follows for a formula φ:  (|= ∀): For all valuations v and all i ∈ N, if (C̄, κ̄, v, i) |= φ  then for every (D̄, τ̄) ∈ col−1 (C̄, κ̄) and every j ∈ N with  κi = τ j , it holds that (D̄, τ̄, v, j) |= φ.  (|= ∃): For all valuations v and all i ∈ N, if (C̄, κ̄, v, i) |= φ  then for every (D̄, τ̄) ∈ col−1 (C̄, κ̄), there is some j ∈ N  with κi = τ j such that (D̄, τ̄, v, j) |= φ.  (6|= ∀): For all valuations v and all i ∈ N, if (C̄, κ̄, v, i) 6|= φ  then for every (D̄, τ̄) ∈ col−1 (C̄, κ̄) and every j ∈ N with  κi = τ j , it holds that (D̄, τ̄, v, j) 6|= φ.  (6|= ∃): For all valuations v and all i ∈ N, if (C̄, κ̄, v, i) 6|= φ  then for every (D̄, τ̄) ∈ col−1 (C̄, κ̄), there is some j ∈ N  with κi = τ j such that (D̄, τ̄, v, j) 6|= φ.  The first symbol (|= or 6|=) in a label states whether the  formula is satisfied in the collapsed temporal structure (C̄, κ̄).  The second symbol (∀ or ∃) states whether the formula is  satisfied at some equally timestamped time point or at all  equally timestamped time points in all temporal structures  (D̄, τ̄) ∈ col−1 (C̄, κ̄).  Due to space limitations, Figure 3 shows only some of  our inference rules. All rules can be found in Appendix C,  where we also prove their soundness.  First, consider the rules in Figure 3 for atomic formulas.  An atomic formula t ≈ t0 depends only on the valuation and  therefore can be labeled (|= ∀) and (6|= ∀). An atomic formula  of the form r(t1 , . . . , tι(r) ) can be labeled (|= ∃) and (6|= ∀).  We only explain the labeling (|= ∃). The explanation for the  label (6|= ∀) is analogous. The interpretation of a predicate in  a collapsed temporal structure (C̄, κ̄) at a time point i is the  union of the predicate’s interpretations at all time points j in  a temporal structure (D̄, τ̄) ∈ col−1 (C̄, κ̄) for which τ j equals  κi . Therefore, if ā ∈ rCi then ā ∈ rD j , for some j ∈ N with  τ j = κi . Note that ā ∈ rD j does not necessarily hold for all  these js; hence, we cannot label r(t1 , . . . , tι(r) ) with (6|= ∀).  The next two rules in Figure 3 express that the invariants corresponding to the labels (|= ∀) and (6|= ∀) imply the  invariants corresponding to (|= ∃) and (6|= ∃), respectively.  Next, we consider the inference rules for the temporal  operator I . We first justify the inference rule that allows  us to propagate the label (|= ∀) from ψ to I ψ. If I ψ is  satisfied in the collapsed temporal structure (C̄, κ̄) at time  point i then ψ is satisfied at some previous time point j ≤ i  in (C̄, κ̄) with κi − κ j ∈ I. Because ψ is labeled with (|= ∀),  all time points with timestamp κ j in the temporal structure  (D̄, τ̄) ∈ col−1 (C̄, κ̄) also satisfy ψ, and hence, all time points  with timestamp κi satisfy I ψ in (D̄, τ̄). When ψ is labeled  with (|= ∃), possibly only a single time point k in (D̄, τ̄)  with τk = κ j satisfies ψ. If 0 ∈ I then I ψ might not be  satisfied at time points before k, even if these time points  have the timestamp κi . So, we can label I with (|= ∃) but  not with (|= ∀). However, if 0 < I then ψ is satisfied in (C̄, κ̄)  at a time point j with the timestamp κ j < κi . Hence I ψ  is satisfied in (D̄, τ̄) at all time points with the timestamp  κi . This allows us to label I ψ with (|= ∀). Finally, consider  the rule where ψ is labeled (6|= ∀). If I ψ is violated in the  collapsed temporal structure (C̄, κ̄) at timestamp κi then ψ  is violated at all previous points in the temporal structure  (D̄, τ̄) ∈ col−1 (C̄, κ̄) that satisfy the metric constraints given  by I. But then I ψ is also violated in (D̄, τ̄) at all time points  with the timestamp κi . Hence we can label I ψ with (6|= ∀).  We can try to label a formula solely based on inference  rules that involve only a single Boolean or temporal operator.  However, with more specialized inference rules like the  one for I ♦ J ψ given in Figure 3, we are more likely to  succeed in propagating labels to the root of the formula.  Intuitively, with the nesting of the operators I and ♦ J , and  when 0 ∈ I ∩ J, the ordering of equally timestamped time  points becomes irrelevant since from a given time point, we  can freely choose any of these time points that satisfy the  metric constraints given by the intervals I and J. Hence, a  labeling (|= ∃) for ψ allows us to label I ♦ J ψ with (|= ∀).  Finally, we remark that there are no inference rules for  the temporal operators I and #I because these operators  inherently rely on the relative ordering of the structures in  a temporal structure.  Based on the labels at the root of the formula, we can  determine if the formula has the property (C1) or the  property (C2). The conclusions we can draw are stated in  the following lemma, which follows from the soundness of  the inference rules.  Lemma 8.  1. If φ can  2. If φ can  3. If φ can  4. If φ can  Let φ be a formula.  be labeled by (|= ∀) then φ has property (C1).  be labeled by (6|= ∀) then φ has property (C2).  be labeled by (|= ∃) then ♦ φ has property (C1).  be labeled by (6|= ∃) then  φ has property (C2).  Based on this lemma, we obtain the following theorem.  Theorem 9. If the formula φ can be labeled by (|= ∀)  and (6|= ∀) then it is collapse-sufficient. Moreover, we can  determine in linear time in the formula’s length whether φ  can be labeled by (|= ∀), (|= ∃), (6|= ∀), and (6|= ∃).  Note that formulas of the form  ψ are already collapse-  sufficient if ψ can be labeled by (6|= ∃) and  ψ can be labeled  by (|= ∀). Even if only one of these labellings can be derived,  monitoring  ψ on the collapsed temporal structure of an  interleaving is still useful. For example, if ψ is labeled  by (6|= ∃) then violations that are found on the collapsed  temporal structure relate to strong violations on the set of  interleavings. However, we might miss some violations.  Example 10. We illustrate our algorithm and its inference  rules by applying it to the formula  ∀x. publish(x) →  [0,11) approve(x). We first remove some syntactic sugar and  obtain the formula  ∀x. ¬publish(x) ∨ [0,11) approve(x). We  start by labeling the atomic subformulas. Both publish(x)  and approve(x) are labeled with (|= ∃) and (6|= ∀). According  to the inference rules for the temporal operator I we  label [0,11) approve(x) with (|= ∃) and (6|= ∀). We cannot  label it with (|= ∀) since the interval contains 0. Moreover, the subformula ¬publish(x) is labeled with (6|= ∃) and  (|= ∀). The subformulas ¬publish(x) ∨ [0,11) approve(x) and  ∀x. ¬publish(x) ∨ [0,11) approve(x) are labeled (|= ∃) and  (6|= ∃). We conclude that the formula  ∀x. ¬publish(x) ∨  [0,11) approve(x) has the property (C2). It does not have  the property (C1), as shown in Example 7.  The formula  ∀x. publish(x) → [1,11) approve(x) has  both properties (C1) and (C2). The labeling starts similarly  but [1,11) approve(x) is additionally labeled with (|= ∀) since  the interval of the temporal operator does not contain 0. This  label propagates to the root of the formula. We conclude that   ∀x. ¬publish(x)∨[1,11) approve(x) also has property (C1).  Policy Approximation. In Example 7, we have seen  that we can obtain collapse-sufficient policies by strengthening or weakening the original policy. In the following,  we present a systematic approach along these lines by overapproximating and under-approximating policies.  Let φ be a formula in positive normal form. We obtain the weakened formula φw by replacing each atomic  subformula r(t1 , . . . , tι(r) ) that occurs positively in φ by  I ♦I 0 r(t1 , . . . , tι(r) ), for some intervals I and I 0 with 0 ∈  I ∩ I 0 . Analogously, in the strengthened formula φ s , we  replace each negative occurrence of an atomic subformula  r(t1 , . . . , tι(r) ) by I ♦I 0 r(t1 , . . . , tι(r) ).  Theorem 11. Let φw and φ s be weakened and strengthened  formulas of the formula φ in positive normal form. The  formulas φ → φw and φ s → φ are valid. Moreover,  1. if φ s is collapse-sufficient then φ has property (C1), and  2. if φw is collapse-sufficient then φ has property (C2).  Weakened and strengthened formulas are more likely  to be collapse-sufficient, since their subformulas of the  form I ♦I 0 r(t1 , . . . , tι(r) ) can be labeled with (|= ∀), while  r(t1 , . . . , tι(r) ) can only be labeled with the weaker label (|= ∃).  Simultaneously weakening and strengthening always results  in a collapse-sufficient formula. However, the resulting formula does not necessarily relate to the original formula.  Figure 4.  Nokia’s Data-collection Campaign  Finally, note that by inserting the temporal operators [0,1)  and ♦[0,1) around positively occurring atomic subformulas,  the ordering of equally timestamped actions becomes irrelevant. This is desirable in systems where the clocks  used to timestamp the actions are synchronized but too  coarse-grained. Taking this idea further, by putting temporal  operators [0,b) and ♦[0,b) around these subformulas with  b ≥ 1, we take into account that the timestamps in a temporal  structure are inaccurate and might differ from their actual  value by the threshold b—a situation that occurs in practice.  IV. Practical Experience  In this section, we describe the implementation of our  monitoring approach within Nokia’s Data-collection Campaign [7], which is a real-world application with realistic  usage-control policies. Furthermore, we report on the monitor’s performance and our findings.  Scenario. The campaign,1 which was launched in 2009,  collects contextual information from cell phones of about  180 participants. This sensitive data includes phone locations, call and SMS information, and the like. The data  collected by a participant’s phone is propagated into the  databases db1, db2, and db3. The phones use WLAN to  periodically upload their data to database db1. Every night,  the synchronization script script1 copies the data from db1  to db2. Furthermore, triggers running on db2 anonymize  and copy the data to db3, where researchers can access and  analyze the anonymized data. The participants can access  and delete their own data using a web interface to db1.  Deletions are propagated to all databases: from db1 to db2  by the synchronization script script2, which also runs every  night, and from db2 to db3 by database triggers. Figure 4  summarizes the various usages of data in the campaign.  Within the campaign, data is organized by records and  can easily be identified. When uploading data from a phone  into db1, a unique identifier is generated for each record.  This identifier together with an identifier of the participant  who contributed the data is attached to the record.  Policies. The collected data is subject to various policies in order to protect the participants’ privacy. For example, there are access control rules and policies governing  1 See  http://research.nokia.com/page/11367 for details.  Table I.  policy  delete  ins-1-2  ins-2-3  del-1-2  Policy Formalizations in MFOTL  MFOTL formalization   ∀user. ∀data. delete(user, db2, data) → user ≈ script2   ∀user. ∀data. insert(user, db1, data) ∧ data 0 unknown →  [0,1s) ♦[0,30h] ∃user0 . insert(user0 , db2, data) ∨ delete(user0 , db1, data)   ∀user. ∀data. insert(user, db2, data) ∧ data 0 unknown →  [0,1s) ♦[0,60s) ∃user0 . insert(user0 , db3, data)   ∀user. ∀data. delete(user, db1, data) ∧ data 0 unknown  →    [0,1s) ♦[0,30h) ∃user0 . delete(user0 , db2, data) ∨  (♦[0,1s) [0,30h) ∃user0 . insert(user0 , db1, data))∧    ([0,30h) [0,30h) ¬∃user0 . insert(user0 , db2, data))  the process of propagating the data between databases. In  particular, any insertion or deletion of data in db1 must be  propagated to db2 within 30 hours, and from db2 to db3  within 1 minute. Furthermore, only the latest version of the  synchronization scripts may be used and the scripts may not  run longer than 6 hours. Finally, access to the databases is  restricted to selected user accounts and the account script1  may be used only while the script script1 is running.  We present here just a few representative policies in  Table I. Details about all the 14 policies are given in  Appendix E. The predicates insert and delete correspond  to the equally-named database commands. The arguments  of these predicates are the agent that initiated the action, the  name of the database where the action was carried out, and  an identifier of the involved data.  Note that all policy formalizations in Table I are  collapse-sufficient. However, some policies have slightly  weaker or stronger variants that are not collapsesufficient. For example, we obtained ins-2-3 from the  policy “all data inserted into db2 must also be inserted  into db3 within 60 seconds” by weakening the formula   ∀users. ∀data. insert(user, db2, data)∧data 0 unknown →  ♦[0,60s) ∃user0 . insert(user0 , db3, data). Intuitively, ins-2-3 is  the policy formalization that we actually intended: we  do not want to distinguish the relative ordering of the  insertions into db2 and db3 when they are logged with the  same timestamp. This is because the 1 second timestamp  granularity that is used may not be fine-granular enough:  the database triggers may be activated within milliseconds.  Logging Mechanisms. We extended the data-collection  setup with mechanisms to log policy-relevant actions. We  installed logging mechanisms for the three databases, the  script script1, and the SVN repository, assuming synchronized clocks for timestamping. We now discuss details of  these logging mechanisms.  As logs for the database db1 were not available, we  implemented a proxy to inspect interactions of participants  and phones with db1. The proxy logs what data is inserted  and deleted. To observe the insertion of new data, we  monitor the network traffic when the phone uploads data. For  deletions, we use a custom front-end that logs the requests  for deleting data. For practical reasons, we could deploy  these mechanisms only for 2 out of the 180 participants.  Hence, we have only partial logging for db1, which only  Table II.  log  1  2  3  4  5  6  7  8  9  # time  points  29,672  10,870  6,601  20,330  8,114  9,218  7,327  86,892  86,764  total  # actions  1,462,700  969,520  1,019,428  962,766  687,402  630,287  554,733  936,249  986,249  Log Statistics  # insert actions  db2  db3  82,486  678,840  678,840  23,828  472,369  472,369  33,229  492,411  492,411  12,918  468,844  468,844  7,067  339,674  339,647  4,207  311,882  311,835  3,251  275,208  275,199  47,786  400,490  400,475  30,118  434,268  434,259  db1  # other  actions  22,534  954  1377  11,298  12,160  1,366  1,014  87,498  87,604  affects 2 out of the 14 policies.  The databases db2 and db3 reside physically on a single  PostgreSQL server, which logs the SQL queries. We extract  relevant actions from these PostgreSQL logs. The main  challenge is to determine what data is processed in a query  since only the query itself is logged. Fortunately, most  relevant queries are made by automated scripts or database  triggers and contain enough information to determine what  data is used. For example, an insert or delete query initiated  by a synchronization script includes the identifier of the  used data record. Hence, a simple syntactic analysis of these  queries suffices to log the relevant actions in sufficient detail.  When the analysis failed to extract the data, we identified  the data with the constant unknown.  Evaluation. To evaluate the performance of our monitor on different data sets, we split the logs into smaller  files, where each file corresponds to roughly 24 hours of  log entries. Table II provides details about the collapsed  temporal structures corresponding to these logs. Observe that  the number of insert actions is significantly larger than the  number of other actions. None of the log files used contains  more than 100 delete actions. Table III shows the monitor’s  running times and memory usage for each policy and log  file. For the experiments, we used a desktop computer with  a 1150 MHz AMD Phenom 9600B Quad-Core CPU.  Monitoring invariants like the policy delete is fast: the  monitor needed no more than 10 seconds for a 24-hours  log file. More complex policies involving temporal operators  with large time windows, take more time to monitor. For  example, for the policy ins-1-2, the monitor took more than  4 hours in some cases. The policy del-1-2 with an even  larger time window, however, could be quickly monitored.  The reason here is that the log files used contain only few  delete actions. Although we monitored the logs offline, the  running times indicate that an online monitoring approach  is possible, since the running times are less than the time  period covered by the logs. The memory requirements are  also modest. For the policies delete and ins-2-3, the monitor  does not require more than 10 MB of RAM. For ins-1-2 and  del-1-2, the monitor used under 200 MB of RAM, which is  also acceptable due to the large time windows.  Findings. The monitor reported the following policy  violations. First, some static access control policies like  delete were violated. These violations were due to testing,  Table III.  policy  delete  ins-1-2  ins-2-3  del-1-2  log 1  10 s / 4 MB  231 m / 161 MB  9 m / 8 MB  24 s / 176 MB  log 2  7 s / 4 MB  44 m / 103 MB  3 m / 7 MB  16 s / 139 MB  Monitor Performance — Running Times / Memory Usage  log 3  7 s / 4 MB  67 m / 107 MB  5 m / 8 MB  13 s / 87 MB  log 4  6 s / 4 MB  24 m / 102 MB  4 m / 8 MB  11 s / 79 MB  debugging, and other improvement activities going on while  the system was running. Second, an earlier version of one of  the synchronization scripts contained a bug, which was not  detected in previous tests. Only a subset of the insertions  were propagated between the databases. Third, while the  campaign was running, the infrastructure was migrated to  another server. After the migration, the deployment of the  scripts was delayed, which caused policy violations.  Overall, the main reason for these violations is that we  monitored an experimental system still under development.  In this case study the monitor proved to be a powerful  debugging tool. For commercial systems, it can detect policy  violations thereby protecting the users’ privacy and increasing users’ trust in using the systems. Our findings also show  that policy monitoring makes sense even in systems where  users are honest and interested in honoring the policies.  V. Related Work  The usage-control architecture described by Pretschner  et al [8] and the UCONABC architecture of Park and  Sandhu [9] both utilize monitoring techniques. However, the  two architectures are only conceptual and have neither been  deployed nor evaluated in a real-word setting.  Goodloe and Pike [10] recently surveyed the state of  the art for monitoring distributed systems. We restrict ourselves here to the most related work. Bauer et al [11]  examine a setting where actions are totally ordered and  system requirements are given in a propositional linear-time  temporal logic. Both assumptions are too restrictive in our  setting. However, their monitoring architecture additionally  includes a component that analyzes the cause of a failure,  which is fed back into the system. Genon et al [12]  present a monitoring algorithm for propositional LTL, where  events are partially ordered. They use symbolic exploration  methods to cope with the interleavings of events. It is  unclear how their algorithm extends to a first-order setting.  Moreover, in our approach, we consider formulas in a richer  logic for which monitoring a single trace is sufficient. In  contrast to these works and ours, Sen et al [13] present  a distributed monitoring approach, where multiple monitors  are implemented locally and communicate with each other.  These monitors are generated from a propositional past-time  linear-time distributed temporal logic. A potential bottleneck  is the monitors’ communication overhead.  Finally, research on checking temporal integrity constrains [14], [15] of stored data and temporal triggers [16] in  databases is related to our monitoring algorithm [1]. In fact,  log 5  5 s / 4 MB  9 m / 71 MB  2 m / 8 MB  8 s / 58 MB  log 6  4 s / 4 MB  5 m / 65 MB  2 m / 7 MB  7 s / 53 MB  4 s  3 m  1 m  12 s  log 7  / 4 MB  / 57 MB  / 7 MB  / 111 MB  log 8  6 s / 4 MB  73 m / 115 MB  2 m / 8 MB  21 s / 184 MB  log 9  6 s / 4 MB  48 m / 111 MB  1 m / 6 MB  11 s / 102 MB  our monitoring algorithm extends Chomicki’s monitor [14]  by handling bounded future operators. These temporal operators are extremely useful for formalizing usage-control  policies, which usually contain obligations. We are not  aware of any implementation and experimental evaluation  of Chomicki’s monitoring algorithm.  VI. Conclusion  We theoretically and practically tackled the problem of  monitoring the usage of data in concurrent distributed systems. We provided means to efficiently monitor concurrently generated logs. We also deployed and evaluated a  monitoring architecture in a real-world application, Nokia’s  Data-collection Campaign. Our case study demonstrates the  feasibility and benefits of monitoring the usage of sensitive  data.  As future work we plan to develop monitoring techniques  for more complex systems with more agents, actions, and  databases. The challenges will be to handle less accurate and  less complete logging, and to provide monitoring algorithms  that scale up from millions to billions of log entries per day.  Our future work also includes developing monitoring techniques that can also be used for policy enforcement, i.e.,  preventing policy violations.  Acknowledgments. This work was supported by the  Nokia Research Center, Switzerland. The authors thank  Imad Aad, Debmalya Biswas, Olivier Bornet, Olivier  Dousse, Juha Laurila, and Valtteri Niemi for valuable input.  References  [1] D. Basin, F. Klaedtke, S. Müller, and B. Pfitzmann, “Runtime monitoring of metric first-order temporal properties,” in  Proceedings of the 28th IARCS Annual Conference on Foundations of Software Technology and Theoretical Computer  Science (FSTTCS), ser. Leibniz International Proceedings in  Informatics (LIPIcs), vol. 2. Schloss Dagstuhl - Leibniz  Center for Informatics, 2008, pp. 49–60.  [2] D. Basin, F. Klaedtke, and S. Müller, “Monitoring security  policies with metric first-order temporal logic,” in Proceeding  of the 15th ACM Symposium on Access Control Models and  Technologies (SACMAT). ACM Press, 2010, pp. 23–34.  [3] A. S. Tanenbaum and M. van Steen, Distributed Systems:  Principles and Paradigms. Prentice Hall, 2002.  [4] L. Lamport, “Time, clocks, and the ordering of events in a  distributed system,” Commun. ACM, vol. 21, no. 7, pp. 558–  565, 1978.  [5] S. Abiteboul, R. Hull, and V. Vianu, Foundations of  Databases: The Logical Level. Addison Wesley, 1994.  [6] L. Lamport, “What good is temporal logic?” in Proceedings  of the IFIP 9th World Computer Congress, ser. Information  Processing, vol. 83. North-Holland, 1983, pp. 657–668.  Appendix  A. Additional Proof Details: Intractability Results  We remark that related intractability results for LTL on  so-called partially ordered traces are given in [17]. However,  the setting is different from ours. In particular, it is unclear  how to describe the set of interleavings of two timestamped  traces using partially ordered traces as defined in [17].  Moreover, we reduce SAT and TAUT, respectively, to the  respective decision problem for proving its hardness. In [17],  the global-predicate-detection decision problem is used.  The decision problem in Theorem 3(1) is in NP as a  nondeterministic Turing machine can first guess the violating  interleaving up to the given time point and then verify its  guess in polynomial time [18]. Note that the Turing machine  does not need to guess a valuation, as the input formula  is a quantifier-free sentence and this contains no variables.  Hardness is established by polynomially reducing SAT to  the decision problem in Theorem 3(1) as shown below.  Analogously, the coNP-hardness of the decision problem  in Theorem 3(2) is shown by polynomially reducing TAUT  to it, also explained below. This problem is in coNP since  its complement is in NP.  Reduction from SAT. We show NP-hardness of the  decision problem in Theorem 3(1) by reduction from SAT.  To fix notation, we recall that a propositional formula α  over a set of atomic propositions P is satisfiable if there is  an assignment θ of propositions to truth values ⊥ (denoting  false) and > (denoting true), i.e. θ : P → {⊥, >}, such that  θ(α) = >, where θ is extended from atomic propositions  to formulas as expected. The SAT problem asks whether a  given propositional formula is satisfiable. SAT is NP-hard.  Suppose P = {p0 , . . . , pn−1 }, with n ≥ 0, is a set of atomic  propositions. Let S be the signature (C, R, ι) with C = {c},  R = {q0 , r0 , . . . , qn−1 , rn−1 }, and ι(qi ) = ι(ri ) = 1, for any  0 ≤ i < n. The two temporal structures (D̄1 , τ̄1 ) and (D̄2 , τ̄2 )  over S are given by: |D̄| = {c}, cD̄ = c, τ1i = τ2i = i for any  i ∈ N, and for any k ∈ {1, 2} and i, j ∈ N with 0 ≤ i < n,  (  Dkj  {c} if k = 1 and i = j,  qi =  ∅  otherwise,  (  k  D  {c} if k = 2 and i = j,  ri j =  ∅  otherwise.  Given a propositional formula α over P, the MFOTL  formula pαq is obtained by replacing each occurrence of    a proposition pi in α with  ri (c) ∧  qi (c) . Thus, given  a propositional formula α, the reduction constructs the two  prefixes of length n of (D̄1 , τ̄1 ) and (D̄2 , τ̄2 ) and the MFOTL  formula pαq. This reduction is linear in the size of α. Its  correctness is shown by Lemma 13. The following remarks  and lemma will be needed.  Remark. For any interleaving (D̄, τ̄) ∈ (D̄1 , τ̄1 ) (D̄2 , τ̄2 ), the  functions f1 and f2 in Definition 1 satisfy fk (i) ∈ {2i, 2i +  1} where k ∈ {1, 2}. Moreover, these functions are unique,  ./  [7] I. Aad and V. Niemi, “NRC data collection campaign and the  privacy by design principles,” in Proceedings of the International Workshop on Sensing for App Phones (PhoneSense),  2010.  [8] A. Pretschner, M. Hilty, and D. Basin, “Distributed usage  control,” Commun. ACM, vol. 49, no. 9, pp. 39–44, 2006.  [9] J. Park and R. Sandhu, “The UCONABC usage control model,”  ACM Trans. Inform. Syst. Secur., vol. 7, no. 1, pp. 128–174,  2004.  [10] A. Goodloe and L. Pike, “Monitoring distributed real-time  systems: A survey and future directions,” NASA Langley  Research Center, Tech. Rep. NASA/CR-2010-216724, July  2010.  [11] A. Bauer, M. Leucker, and C. Schallhart, “Model-based runtime analysis of distributed reactive systems,” in Proceedings  of the 2006 Australian Software Engineering Conference  (ASWEC). IEEE Computer Society, 2006.  [12] A. Genon, T. Massart, and C. Meuter, “Monitoring distributed  controllers: When an efficient LTL algorithm on sequences  is needed to model-check traces,” in Proceedings of the 14th  International Symposium on Formal Methods (FM), ser. Lect.  Notes Comput. Sci., vol. 4085. Springer, 2006, pp. 557–572.  [13] K. Sen, A. Vardhan, G. Agha, and G. Roşu, “Efficient  decentralized monitoring of safety in distributed systems,” in  Proceedings of the 26th International Conference on Software  Engineering (ICSE). IEEE Computer Society, 2004, pp. 418–  427.  [14] J. Chomicki, “Efficient checking of temporal integrity constraints using bounded history encoding,” ACM Trans.  Database Syst., vol. 20, no. 2, pp. 149–186, 1995.  [15] U. W. Lipeck and G. Saake, “Monitoring dynamic integrity  constraints based on temporal logic,” Inform. Syst., vol. 12,  no. 3, pp. 255–269, 1987.  [16] A. P. Sistla and O. Wolfson, “Temporal triggers in active  databases,” IEEE Trans. Knowl. Data Eng., vol. 7, no. 3, pp.  471–486, 1995.  [17] T. Massart, C. Meuter, and L. Van Begin, “On the complexity  of partial order trace model checking,” Inform. Process. Lett.,  vol. 106, no. 3, pp. 120–126, 2008.  [18] N. Markey and P. Schnoebelen, “Model checking a path,” in  Proceedings of the 14th International Conference on Concurrency Theory (CONCUR), ser. Lect. Notes Comput. Sci., vol.  2761. Springer, 2003, pp. 248–262.  ./  Lemma 13. Let α be a propositional formula. It holds that α  is satisfiable if and only if (D̄1 , τ̄1 ) (D̄2 , τ̄2 ) weakly violates  ¬pαq at time point 2n.  Proof: Suppose first that α is satisfiable. Then there is  a truth value assignment θ such that θ(α) = >. Let (D̄, τ̄) be  the interleaving determined by the functions f1 and f2 given  by  (  2i  if θ(pi ) = >,  f1 (i) =  2i + 1 otherwise,  and  (  f2 (i) =  2i  2i + 1  if θ(pi ) = ⊥,  otherwise.  ./  Let v be an arbitrary valuation. From Lemma 12, we obtain  that (D̄, τ̄, v, 2n) |= pαq, that is, (D̄, τ̄, v, 2n) 6|= ¬pαq.  Suppose now that (D̄1 , τ̄1 ) (D̄2 , τ̄2 ) weakly violates ¬pαq  at time point 2n. Then there is an interleaving (D̄, τ̄) and a  valuation v such (D̄, τ̄, v, 2n) 6|= ¬pαq. Let f1 and f2 the be  functions determined by (D̄, τ̄) as in Definition 1. Let θ be  a truth value assignment such that θ(pi ) = > if and only  if f1 (i) = 2i. Using again Lemma 12, we get that θ is a  satisfying assignment for α.  ./  Proof: Suppose first that α is a tautology. Let (D̄, τ̄)  be an arbitrary interleaving in (D̄1 , τ̄1 ) (D̄2 , τ̄2 ) and f1 , f2  be functions as in Definition 1. Let θ be a truth value  assignment such that θ(pi ) = > if and only if f1 (i) = 2i.  Let v be an arbitrary valuation. Using Lemma 12, we obtain  that (D̄, τ̄, v, 2n) 6|= ¬pαq. Hence (D̄1 , τ̄1 ) (D̄2 , τ̄2 ) strongly  violates ¬pαq at time point 2n.  Suppose now that (D̄1 , τ̄1 ) (D̄2 , τ̄2 ) strongly violates ¬pαq  at time point 2n. Let θ be an arbitrary truth value assignment.  Let (D̄, τ̄) be the interleaving determined by the functions  f1 and f2 given by  (  2i  if θ(pi ) = >,  f1 (i) =  2i + 1 otherwise,  ./  Proof: We use structural induction on the form of α.  The only interesting case is the base case, the other cases  follow directly from the induction hypotheses. Thus let α =  pi ∈ P.  Suppose that (D̄, τ̄, v, 2n) |= (ri (c)∧ qi (c)). That is, there  is a time point j ≤ 2n such that (D̄, τ̄, v, j) |= ri (c) and such  that there is a time point j0 ≤ j for which (D̄, τ̄, v, j0 ) |=  D0  D  qi (c). Then c ∈ ri j and c ∈ qi j . From the definition of an  interleaving and the definitions of the interpretations of the  predicates qi and ri , it follows that j = f2 (i) and j0 = f1 (i).  Then, as f1 (i), f2 (i) ∈ {2i, 2i + 1}, f1 (i) , f2 (i), and j0 ≤ j,  we get that f1 (i) = 2i and f2 (i) = 2i + 1. Thus θ(pi ) = >.  Suppose that θ(α) = >. Then f1 (i) = 2i and f2 (i) = 2i + 1.  We have (D̄, τ̄, v, 2i) |= qi (c) and (D̄, τ̄, v, 2i+1) |= ri (c). Thus  (D̄, τ̄, v, 2i + 1) |= ri (c) ∧  qi (c) and clearly (D̄, τ̄, v, 2n) |=     ri (c) ∧  qi (c) .  Lemma 14. Let α be a propositional formula. It holds that  α is a tautology if and only if (D̄1 , τ̄1 ) (D̄2 , τ̄2 ) strongly  violates ¬pαq at time point 2n.  ./  ./  Lemma 12. Let α be a propositional formula, θ a truth  value assignment, v a valuation, and (D̄, τ̄) an interleaving  of (D̄1 , τ̄1 ) (D̄2 , τ̄2 ) given by the functions f1 and f2 such  that θ(pi ) = > iff f1 (i) = 2i, for any i with 0 ≤ i < n. It holds  that θ(α) = > if and only if (D̄, τ̄, v, 2n) |= pαq.  Reduction from TAUT. We show coNP-hardness of the  decision problem in Theorem 3(2) by reduction from TAUT.  We recall that a propositional formula α over a set of  atomic propositions P is a tautology if θ(α) = > for any  assignment θ of propositions to truth values. The TAUT  problem asks whether a given propositional formula is a  tautology. TAUT is coNP-hard.  We use the same reduction as for the decision problem  in Theorem 3(1). The correctness of the reduction follows  from the following lemma.  ./  that is, if g1 , g2 : N → N are strictly monotonic functions  satisfying conditions (1)–(3) in Definition 1 then either g1 =  f1 and g2 = f2 , or g1 = f2 and g2 = f1 . Furthermore, for any  strictly monotonic functions f1 and f2 satisfying conditions  (1) and (2) in Definition 1 and with f1 (i), f2 (i) ∈ {2i, 2i + 1}  for 0 ≤ i < n, there is a unique temporal structure (D̄, τ̄)  such that f1 and f2 also satisfy condition (3). In other words,  the functions f1 , f2 determine an interleaving of (D̄1 , τ̄1 ) and  (D̄2 , τ̄2 )  and  (  f2 (i) =  2i  2i + 1  if θ(pi ) = ⊥,  otherwise.  There is a valuation v such (D̄, τ̄, v, 2n) 6|= ¬pαq. Using again  Lemma 12, we get that θ is a satisfying assignment for α.  Hence α is a tautology.  B. Additional Proof Details: Derivation Rules  Figure 5 lists all the inference rules for label propagation.  Lemma 15 (see below) shows the soundness of these rules.  When considering formulas in positive normal form, as  required in Theorem 11, the Boolean operator ∨ and the  temporal operators release RI and trigger TI are seen as  primitives, instead of being defined as syntactic sugar. We  recall that ψ RI χ abbreviates ¬(¬ψ SI ¬χ) and ψ TI χ  abbreviates ¬(¬ψ UI ¬χ). Figure 6 lists propagation rules for  formulas that use these operators. Their soundness follows  from the soundness of rules in Figure 5 and the mentioned  equivalences. For instance, the correctness of the rule  ψ : (|= ∃) χ : (|= ∀)  0 < I, 0 ∈ J  (ψ RI χ) ∨ (♦ J ψ) : (|= ∀)  follows from unfolding the abbreviation (ψ RI χ) ∨ (♦ J ψ),    which is ¬ (¬ψ SI ¬χ) ∧ ( J ¬ψ) , and the following deriva-  tion:  •  ψ : (|= ∃)  χ : (|= ∀)  ¬ψ : (6|= ∃) ¬χ : (6|= ∀)  0 < I, 0 ∈ J  (¬ψ SI ¬χ) ∧ ( J ¬ψ) : (6|= ∀)    ¬ (¬ψ SI ¬χ) ∧ ( J ¬ψ) : (|= ∀)  •  Finally, for convenience, Figure 7 lists some inference  rules for formulas for which the main operator is one of the  temporal operators I , ♦I , I , and I . These rules can be  derived from the rules in Figure 5 by simply applying the  definition of syntactic sugar. For instance, the rule  ψ : (|= ∀)  I ψ : (|= ∀)  •  can be derived from  x ≈ x : (|= ∀)  ∃x. x ≈ x : (|= ∀) ψ : (|= ∀)  (∃x. x ≈ x) SI ψ : (|= ∀)  Note that I ψ is syntactic sugar for (∃x. x ≈ x) SI ψ.  We now show the soundness of the inference rules in  Figure 5.  •  Lemma 15. Let φ be a formula. If φ can be labeled  with `, then φ satisfies the invariant `, where ` ∈    (|= ∀), (6|= ∀), (6|= ∃), (|= ∃) .  Proof: Let (C̄, κ̄) be the collapse of an interleaving of  two given temporal structures.  We proceed by induction on size of the derivation tree  assigning label ` to φ. We make a case distinction based on  the rule applied to label the formula, that is, the rule at the  root of the tree. However, for clarity, we generally group  cases by the formula’s form.  For readability, and without loss of generality, we already  fix an arbitrary valuation v, an arbitrary time point i, and an  arbitrary temporal structure (D̄, τ̄) ∈ col−1 (C̄, κ̄).  • We first consider the weakening rules.  – φ is labeled with (|= ∀) and (|= ∃). Suppose that  (C̄, κ̄, v, i) |= φ. By the induction hypothesis, φ satisfies the invariant (|= ∀), thus (D̄, τ̄, v, j) |= φ for any  j with τ j = κi . By the definition of (C̄, κ̄), there is  at least one j with τ j = κi . Hence φ satisfies the  invariant (|= ∃).  – φ is labeled with (6|= ∀) and with (6|= ∃). This case is  analogous to the previous one.  0  0  • φ = t ≈ t , where t and t are variables or constants. In  this case φ is labeled with (|= ∀) and (6|= ∀).  – φ is labeled with (|= ∀). Suppose that (C̄, κ̄, v, i) |= φ.  Then v(t) = v(t0 ). Clearly, (D̄, τ̄, v, j) |= φ for any  time point j, as φ only depends on the valuation.  The invariant (|= ∀) is hence satisfied.  – φ is labeled with (6|= ∀). This case is analogous to the  previous one.  •  •  φ = t ≺ t0 , where t and t0 are variables or constants.  This case is analogous to the previous one.  φ = r(t1 , . . . , tι(r) ), where t1 , . . . , tι(r) are variables or  constants. In this case φ is labeled with (|= ∃) and (6|= ∀).  – φ is labeled with (|= ∃). Suppose that (C̄, κ̄, v, i) |= φ.  S  Then (v(t1 ), . . . , v(tι(r) )) ∈ rCi . As rCi = { j|τ j =κi } rD j ,  there is a j with τ j = κi such that (v(t1 ), . . . , v(tι(r) )) ∈  rD j . Therefore (D̄, τ̄, v, j) |= φ. Thus φ satisfies the  invariant (|= ∃).  – φ is labeled with (6|= ∀). Suppose that (C̄, κ̄, v, i) 6|=  φ. Then for any j with τ j = κi we have that  (v(t1 ), . . . , v(tι(r) )) < rD j , that is, (D̄, τ̄, v, j) |= φ. Thus  φ satisfies the invariant (6|= ∀).  φ = ¬ψ. If ψ is labeled with `, then φ is labeled with  ¬`, where ¬` is (|= ∀), (6|= ∀), (6|= ∃), or (|= ∃) when ` is  (6|= ∀), (|= ∀), (|= ∃), or (6|= ∃) respectively.  – φ is labeled with (|= ∀). Suppose that (C̄, κ̄, v, i) |=  ¬ψ. By the induction hypothesis, ψ satisfies the  invariant (6|= ∀). As (C̄, κ̄, v, i) 6|= ψ, we have that  (D̄, τ̄, v, k) 6|= ψ, that is, (D̄, τ̄, v, k) |= φ, for all k  with τk = κi . Thus φ satisfies the invariant (|= ∀).  – The other cases are similar.  φ = ψ ∧ χ. There are four rules to be analyzed.  – φ, ψ, and χ are labeled with (|= ∀). Suppose that  (C̄, κ̄, v, i) |= ψ ∧ χ. Then (C̄, κ̄, v, i) |= ψ and  (C̄, κ̄, v, i) |= χ. By the induction hypothesis, ψ and  χ satisfy the invariant (|= ∀). Hence, for all j with  τ j = κi , we have (D̄, τ̄, v, j) |= ψ and (D̄, τ̄, v, j) |= χ.  Thus (D̄, τ̄, v, j) |= φ and (D̄, τ̄, v, j) |= χ for all j  with τ j = κi . Hence, φ satisfies the invariant (|= ∀).  – The other cases are similar.  φ = ∃x.ψ. There are four rules, one for each label: if ψ  is labeled with `, then φ is labeled with `.  – ` is (|= ∀). Suppose that (C̄, κ̄, v, i) |= ∃x.ψ. Then there  is a d ∈ |D̄| such that (C̄, κ̄, v[x/d], i) |= ψ. As ψ satisfies the invariant (|= ∀), we have (D̄, τ̄, v[x/d], j) |= ψ  for all j with τ j = κi . That is, (D̄, τ̄, v, j) |= ∃x.ψ  for all j with τ j = κi . Hence φ satisfies the invariant  (|= ∀).  – The other cases are similar.  φ = ψ SI χ. We have three rules to analyze.  – φ, ψ, and χ are each labeled with (|= ∀). By the  induction hypothesis, ψ and χ satisfy the invariant  (|= ∀). Suppose that (C̄, κ̄, v, i) |= φ. Then, for some  j ≤ i with κi − κ j ∈ I, we have (C̄, κ̄, v, j) |= χ and  (C̄, κ̄, v, k) |= ψ for all k ∈ [ j + 1, i + 1). Let i0 be an  arbitrary time point such that τi0 = κi . As χ satisfies  the invariant (|= ∀), for the largest j0 with τ j0 = κ j we  have (D̄, τ̄, v, j0 ) |= χ. Clearly, τi0 − τ j0 ∈ I. From the  definition of (C̄, κ̄), for any k0 ∈ [ j0 + 1, i0 + 1), there  is a k ∈ [ j + 1, i + 1) such that τk0 = κk . Then, as ψ  satisfies the invariant (|= ∀), for any k0 ∈ [ j0 +1, i0 +1),  we have (D̄, τ̄, v, k0 ) |= ψ. As ψ satisfies the invariant  (|= ∀), for all k ∈ [ j + 1, i + 1) and all k0 with τk0 = κk ,  φ : (|= ∀)  φ : (|= ∃)  t ≈ t0 : (|= ∀)  t ≈ t0 : (6|= ∀)  r(t1 , . . . , tι(r) ) : (|= ∃)  ψ : (|= ∃)  ¬ψ : (6|= ∃)  ψ : (|= ∀)  ¬ψ : (6|= ∀)  φ : (6|= ∀)  φ : (6|= ∃)  t ≺ t0 : (|= ∀)  t ≺ t0 : (6|= ∀)  r(t1 , . . . , tι(r) ) : (6|= ∀)  ψ : (6|= ∃)  ¬ψ : (|= ∃)  ψ : (6|= ∀)  ¬ψ : (|= ∀)  ψ : (|= ∀) χ : (|= ∀)  ψ ∧ χ : (|= ∀)  ψ : (|= ∀) χ : (|= ∃)  ψ ∧ χ : (|= ∃)  ψ : (6|= ∀) χ : (6|= ∀)  ψ ∧ χ : (6|= ∀)  ψ : (6|= ∃) χ : (6|= ∃)  ψ ∧ χ : (6|= ∃)  ψ : (|= ∀)  ∃x. ψ : (|= ∀)  ψ : (|= ∃)  ∃x. ψ : (|= ∃)  ψ : (6|= ∀)  ∃x. ψ : (6|= ∀)  ψ : (6|= ∃)  ∃x. ψ : (6|= ∃)  ψ : (|= ∀) χ : (|= ∀)  ψ SI χ : (|= ∀)  ψ : (6|= ∀) χ : (6|= ∀)  ψ SI χ : (6|= ∀)  ψ : (6|= ∃) χ : (6|= ∀)  ψ SI χ : (6|= ∃)  ψ : (6|= ∃) χ : (6|= ∀)  0 < I, 0 ∈ J  (ψ SI χ) ∧ ( J ψ) : (6|= ∀)  ψ : (|= ∀) χ : (|= ∀)  ψ UI χ : (|= ∀)  ψ : (6|= ∀) χ : (6|= ∀)  ψ UI χ : (6|= ∀)  ψ : (6|= ∃) χ : (6|= ∀)  ψ UI χ : (6|= ∃)  ψ : (6|= ∃) χ : (6|= ∀)  0 < I, 0 ∈ J  (ψ UI χ) ∧ ( J ψ) : (6|= ∀)  ψ : (|= ∃)  I ψ : (|= ∃)  ψ : (|= ∃)  0<I  I ψ : (|= ∀)  ψ : (|= ∃)  ♦I ψ : (|= ∃)  ψ : (|= ∃)  0<I  ♦I ψ : (|= ∀)  ψ : (|= ∃)  0∈I∩J  I ♦ J ψ : (|= ∀)  Figure 5.  Inference Rules  ψ : (6|= ∀) χ : (6|= ∀)  ψ ∨ χ : (6|= ∀)  ψ : (6|= ∀) χ : (6|= ∃)  ψ ∨ χ : (6|= ∃)  ψ : (|= ∀) χ : (|= ∀)  ψ ∨ χ : (|= ∀)  ψ : (|= ∃) χ : (|= ∃)  ψ ∨ χ : (|= ∃)  ψ : (6|= ∀) χ : (6|= ∀)  ψ RI χ : (6|= ∀)  ψ : (|= ∀) χ : (|= ∀)  ψ RI χ : (|= ∀)  ψ : (|= ∃) χ : (|= ∀)  ψ RI χ : (|= ∃)  ψ : (|= ∃) χ : (|= ∀)  0 < I, 0 ∈ J  (ψ RI χ) ∨ (♦ J ψ) : (|= ∀)  ψ : (6|= ∀) χ : (6|= ∀)  ψ TI χ : (6|= ∀)  ψ : (|= ∀) χ : (|= ∀)  ψ TI χ : (|= ∀)  ψ : (|= ∃) χ : (|= ∀)  ψ TI χ : (|= ∃)  ψ : (|= ∃) χ : (|= ∀)  0 < I, 0 ∈ J  (ψ TI χ) ∨ ( J ψ) : (|= ∀)  Figure 6.  Inference Rules for Formulas in Positive Normal Form  ψ : (|= ∀)  I ψ : (|= ∀)  ψ : (6|= ∀)  I ψ : (6|= ∀)  ψ : (|= ∀)  ♦I ψ : (|= ∀)  ψ : (6|= ∀)  ♦I ψ : (6|= ∀)  ψ : (|= ∀)  I ψ : (|= ∀)  ψ : (6|= ∀)  I ψ : (6|= ∀)  ψ : (6|= ∃)  I ψ : (6|= ∃)  ψ : (6|= ∃)  0<I  I ψ : (6|= ∀)  ψ : (|= ∀)  I ψ : (|= ∀)  ψ : (6|= ∀)  I ψ : (6|= ∀)  ψ : (6|= ∃)  I ψ : (6|= ∃)  ψ : (6|= ∃)  0<I  I ψ : (6|= ∀)  ψ : (6|= ∃)  0∈I∩J  I  J ψ : (6|= ∀)  Figure 7.  •  •  Derived Inference Rules  we have (D̄, τ̄, v, k0 ) |= ψ. Hence (D̄, τ̄, v, i0 ) |= ψ SI χ,  and thus φ satisfies the invariant (|= ∀).  – φ, ψ, and χ are each labeled with (6|= ∀). By the  induction hypothesis, ψ and χ satisfy the invariant  (6|= ∀). Suppose that (C̄, κ̄, v, i) 6|= φ and that, by  absurdity, φ does not satisfy the invariant (6|= ∀). That  is, there is an i0 with τi0 = κi such that (D̄, τ̄, v, i0 ) |= φ.  Then there is a j0 ≤ i0 with τi0 − τ j0 ∈ I such that  (D̄, τ̄, v, j0 ) |= χ and for all k0 ∈ [ j0 +1, i0 +1) we have  (D̄, τ̄, v, k) |= ψ. By the definition of (C̄, κ̄), there is  a j with κ j = τ j0 . As χ satisfies the invariant (6|= ∀),  we have that (C̄, κ̄, v, j) |= χ. Similarly, we have that  (C̄, κ̄, v, k) |= ψ for all k ∈ [ j + 1, i + 1). That is,  (C̄, κ̄, v, i) |= φ, which is a contradiction.  – φ and ψ are labeled with (6|= ∃), and χ is labeled by  (6|= ∀). By the induction hypothesis, ψ and χ satisfy  the invariants (6|= ∃) and (6|= ∀) respectively. As before,  suppose that (C̄, κ̄, v, i) 6|= φ and that, by absurdity, φ  does not satisfy the invariant (6|= ∃). That is, for all i0  with τi0 = κi we have (D̄, τ̄, v, i0 ) |= φ. Consider the  largest such i0 . Then there is a j0 ≤ i0 with τi0 −τ j0 ∈ I  such that (D̄, τ̄, v, j0 ) |= χ and for all k0 ∈ [ j0 + 1, i0 +  1) we have (D̄, τ̄, v, k0 ) |= ψ. By the definition of  (C̄, κ̄), there is a j with κ j = τ j0 . As χ satisfies the  invariant (6|= ∀), we have that (C̄, κ̄, v, j) |= χ. Take  k ∈ [ j + 1, i + 1) arbitrarily. If (C̄, κ̄, v, k) 6|= ψ, as ψ  satisfies the invariant (6|= ∃), then there is a k0 with  τk0 = κk such that (D̄, τ̄, v, k0 ) 6|= ψ. This contradicts  our assumption that (D̄, τ̄, v, i0 ) |= φ, since such k0  must be in the interval [ j0 + 1, i0 + 1). We thus have  that (C̄, κ̄, v, k) |= ψ for all k ∈ [ j + 1, i + 1). Hence  (C̄, κ̄, v, i) |= φ, which is a contradiction.  φ = ψ UI χ. This case is analogous to the previous one.  φ = (ψ SI χ) ∧ ( J ψ) with 0 < I and 0 ∈ J. φ and χ  are labeled with (6|= ∀), and ψ is labeled by (6|= ∃). By  the induction hypothesis, ψ and χ satisfy the invariants  •  •  (6|= ∃) and (6|= ∀) respectively. Suppose that (C̄, κ̄, v, i) 6|= φ  and that, by absurdity, φ does not satisfy the invariant  (6|= ∀). That is, there is an i0 with τi0 = κi such that  (D̄, τ̄, v, i0 ) |= φ. Then there is a j0 ≤ i0 with τi0 − τ j0 ∈ I  such that (D̄, τ̄, v, j0 ) |= χ and for all k0 ∈ [ j0 + 1, i0 + 1)  we have (D̄, τ̄, v, k0 ) |= ψ; and for all j00 ≥ i0 with τ j00 −  τi0 ∈ J we have (D̄, τ̄, v, j00 ) |= ψ.  By the definition of (C̄, κ̄), there is a j with κ j = τ j0 . As  χ satisfies the invariant (6|= ∀), we have that (C̄, κ̄, v, j) |=  χ. Take k ∈ [ j + 1, i) arbitrarily. If (C̄, κ̄, v, k) 6|= ψ, as  ψ satisfies the invariant (6|= ∃), then there is a k0 with  τk0 = κk such that (D̄, τ̄, v, k0 ) 6|= ψ. This contradicts our  assumption that (D̄, τ̄, v, i0 ) |= φ. Indeed, such a k0 must  be in the interval [ j0 + 1, i00 + 1) where i00 is the largest  such that τi00 = κi . If k0 ≤ i0 then (D̄, τ̄, v, i0 ) 6|= ψ SI χ.  If k0 > i0 then (D̄, τ̄, v, i0 ) 6|=  J ψ, as 0 ∈ J. We thus  have that (C̄, κ̄, v, k) |= ψ for all k ∈ [ j + 1, i + 1). Hence  (C̄, κ̄, v, i) |= ψ SI χ.  As (D̄, τ̄, v, i0 ) |=  J ψ and 0 ∈ J, it follows that for all  k0 ≥ i0 with τk0 = τi0 we have (D̄, τ̄, v, k0 ) |= ψ. We have  seen that (D̄, τ̄, v, k0 ) |= ψ for all k0 ∈ [ j0 + 1, i0 + 1).  Because τ j0 < τi0 (as 0 < I), it also follows that for  all k0 ≤ i0 with τk0 = τi0 we have (D̄, τ̄, v, k0 ) |= ψ.  Hence (D̄, τ̄, v, k0 ) |= ψ for all k0 with τk0 = τi0 . As ψ  satisfies the invariant (6|= ∃), we obtain that (C̄, κ̄, v, i) |=  ψ. Similarly, we obtain that (C̄, κ̄, v, k) |= ψ for all k > i  such that κk − κi ∈ J. Hence (C̄, κ̄, v, i) |=  J ψ.  We showed that (C̄, κ̄, v, i) |= φ, which is a contradiction.  Thus φ satisfies the invariant (6|= ∀).  φ = (ψ UI χ) ∧ ( J ψ) with 0 < I and 0 ∈ J. This case  is analogous to the previous one.  φ = I ψ. There are two rules to analyze. For both rules,  ψ is labeled with (|= ∃). Suppose that (C̄, κ̄, v, i) |= φ.  Then there is a j ≤ i with κi − κ j ∈ I such that  (C̄, κ̄, v, j) |= ψ. As, by the induction hypothesis, ψ  satisfies the invariant (|= ∃), there is a j0 with τ j0 = κ j  •  •  such that (D̄, τ̄, v, j0 ) |= ψ.  – φ is labeled with (|= ∃). Take i0 to be the largest k  such that τk = κi . Clearly, τi0 − τ j0 ∈ I and j0 ≤ i0 .  Hence (D̄, τ̄, v, i0 ) |= I ψ and φ satisfies the invariant  (|= ∃).  – 0 < I and φ is labeled with (|= ∀). Take i0 arbitrarily  such that τi0 = κi . Clearly, τi0 − τ j0 ∈ I and, as 0 < I,  τi0 − τ j0 > 0, thus j0 < i0 . Hence (D̄, τ̄, v, i0 ) |= I ψ.  Thus φ satisfies the invariant (|= ∀).  φ = ♦I ψ. This case is analogous to the previous one.  φ = I ♦ J ψ with 0 ∈ I ∩ J. There is only one rule to  consider: ψ is labeled with (|= ∃) and φ is labeled by  (|= ∀). Suppose that (C̄, κ̄, v, i) |= φ. Then there is a j ≤ i  with κi − κ j ∈ I and there is a k ≥ j with κk − κ j ∈ I such  that (C̄, κ̄, v, k) |= ψ. As, by the induction hypothesis ψ  satisfies the invariant (|= ∃), there is a k0 with τk0 = κk  such that (D̄, τ̄, v, k0 ) |= ψ. Take i0 arbitrarily such that  τi0 = κi . If k0 ≥ i0 then 0 ≤ τk0 −τi0 = κk −κi ≤ κk −κ j ∈ J.  As 0 ∈ J, we have τk0 − τi0 ∈ J. Thus (D̄, τ̄, v, i0 ) |= ♦ J ψ  and, as 0 ∈ I, (D̄, τ̄, v, i0 ) |= I ♦ J ψ. The case when  k0 < i0 is similar. Hence φ satisfies the invariant (|= ∀).  C. Additional Proof Details: Theorem 9  The implication in Theorem 9 follows directly from  Lemma 8, which in turn follows the correctness of the  derivation rules (Lemma 15) and from the following lemma.  Lemma 16. Let φ be a formula.  1. If φ satisfies the invariant (|= ∀), then φ has property (C1).  2. If φ satisfies the invariant (6|= ∀), then φ has property (C2).  3. If φ satisfies the invariant (|= ∃), then ♦ φ has property (C1).  4. If φ satisfies the invariant (6|= ∃), then  φ has property (C2).  1.  2.  3.  4.  Proof: We fix a temporal structure (C̄, κ̄).  Suppose φ satisfies the invariant (|= ∀) and that  (C̄, κ̄, v, 0) |= φ for some valuation v. Then, for any  (D̄, τ̄) ∈ col−1 (C̄, κ̄) and every j ∈ N with κ0 = τ j ,  it holds that (D̄, τ̄, v, j) |= φ. By the definition of  collapsed temporal structure, we have κ0 = τ0 . Hence φ  satisfies (C1).  This case is analogous to the previous one.  Suppose φ satisfies the invariant (|= ∃) and that  (C̄, κ̄, v, 0) |= ♦ φ for some arbitrary valuation v. Then,  for every (D̄, τ̄) ∈ col−1 (C̄, κ̄), there is some j ∈ N  with κ0 = τ j such that (D̄, τ̄, v, j) |= φ. It follows that  (D̄, τ̄, v, 0) |= ♦ φ. Hence ♦ φ satisfies (C1).  This case is analogous to the previous one.  Complexity of the Labeling Procedure. We now prove  the other part of Theorem 9, which states that a formula φ  can be labeled in time linear in its length, that is, in O(|φ|).  We start with some definitions and then present a simple  labeling algorithm and analyze its complexity.  For a formula φ, we define its immediate subformulas  isub(φ) to be: (i) {ψ} if φ = ¬ψ, φ = ∃x. ψ, φ = I ψ, or  φ = #I ψ; (ii) {ψ, χ} if φ = ψ ∧ χ, φ = ψ SI χ, or φ = ψ UI χ;  and (iii) ∅ otherwise. For a rule r, we denote `(r) the label  of the conclusion of the rule.  We assume that the data structure used to represent formulas is a tree corresponding to the formula’s syntax tree and  that each node in the tree also stores 4 bits representing the 4  different labels. Initially these bits are set to 0, meaning that  no label is associated with the corresponding subformula.  1  2  3  4  5  6  add labels(φ)  foreach ψ ∈ isub(φ)  add labels(ψ)  foreach rule r  if matches(φ, r) then  add label(φ, `(r))  The function matches(φ, r) checks if the formula φ pattern  matches a rule r. The order of rules is arbitrary, with the  exception that the weakening rules are checked last. So,  for instance if φ received label (|= ∀), then φ will match  the appropriate weakening rule and it will also be labeled  with (|= ∃). As rules have constant size, and only at most the  first two levels of the tree representing the formula φ need  to be inspected, we conclude that the function executes in  constant time.  The function add label(φ, `) simply adds the label ` to  φ. Clearly, this operation can be performed in constant time.  Note that the execution of the lines 2 and 4–6 takes  constant time: |isub(φ)| ≤ 2 for any φ, there is a fixed,  constant number of rules, and the functions matches and  add label execute in constant time. Furthermore, the function add labels is executed exactly |φ| times, once for each  subformula of φ. Hence the whole labeling procedure of φ  can be done in linear time in the size of φ.  D. Additional Proof Details: Theorem 11  We first show that φw is weaker than φ, or more precisely,  that the formula φ → φw is valid. We proceed by structural  induction on φ.  0  0  0  0  • φ = t ≈ t , φ = t ≺ t , φ = ¬(t ≈ t ), φ = ¬(t ≺ t ), or  0  ¬r(t1 , . . . , tι(r) ), where t, t , and ti with 1 ≤ i ≤ ι(r) are  variables or constants. Then φw = φ, and the statement  clearly holds.  w  • φ = r(t1 , . . . , tι(r) ). Then φ =  J ♦ J 0 r(t1 , . . . , tι(r) ), for  0  some intervals J and J with 0 ∈ J ∩ J 0 . Let (D̄, τ̄) be  a temporal structure, v a valuation, and i a time point.  Suppose that (D̄, τ̄, v, i) |= φ. As 0 ∈ I ∩ J, we clearly  have (D̄, τ̄, v, i) |=  J ♦ J 0 φ, that is, (D̄, τ̄, v, i) |= φ0 .  • φ = ψ ∧ χ, φ = ∃x. ψ, φ =  I ψ, φ = #I ψ, φ = ψ SI χ,  or φ = ψ UI χ. These cases follow directly from the  induction hypotheses. We only present the case φ =  ./  ./  ψ SI χ. We have φw = ψw SI χw . Let (D̄, τ̄) be a temporal  structure, v a valuation, and i a time point. Suppose that  (D̄, τ̄, v, i) |= φ. Then there is a j ≤ i with τi − τ j ∈ I  such that (D̄, τ̄, v, j) |= χ and (D̄, τ̄, v, k) |= ψ for any  k ∈ [i + 1, j + 1). Using the induction hypotheses for ψ  and χ, we obtain that (D̄, τ̄, v, j) |= χw and (D̄, τ̄, v, k) |=  ψw for any k ∈ [i + 1, j + 1). Hence (D̄, τ̄, v, i) |= φw .  The proof of the dual case, that is, that the formula φ s → φ  is valid, is similar. It is based on the remark that the formula    ¬  J ♦ J 0 r(t1 , . . . , tι(r) ) → ¬r(t1 , . . . , tι(r) ) is valid.  Finally, we prove statement (1). Statement (2) is similar.  Let (C̄, κ̄) be the collapse of two temporal structures (D̄1 , τ̄1 )  and (D̄2 , τ̄2 ). Suppose that φ s is collapse-sufficient and that  (C̄, κ̄, v, 0) |= φ s , for some arbitrary valuation v. It follows  that (D̄, τ̄, v, 0) |= φ s for any (D̄, τ̄) ∈ (D̄1 , τ̄1 ) (D̄2 , τ̄2 ).  As φ s → φ is valid, we have that (D̄, τ̄, v, 0) |= φ, for any  (D̄, τ̄) ∈ (D̄1 , τ̄1 ) (D̄2 , τ̄2 ).  E. Additional Details on Practical Experience  In this section, we describe in detail all our policies in  Nokia’s Data-collection Campaign, their MFOTL formalization, and the resources needed for monitoring.  Policies in Nokia’s Data-collection Campaign. We first  describe the domain and relations used for formalizing the  policies. Then we describe the policies in natural language  and give their formalization.  The domain, that is, the values that can occur as a  parameter of a system actions are the databases db1, db2,  db3, all database accounts, all data identifiers, the constant  unknown, all possible names for the synchronization scripts,  all possible subversion URLs, all possible subversion revision numbers, and the subversion status values latest, old,  mod, and nosvn.  We represent actions in the system as elements in relations. We explain now the relations used. The elements  of the relations for the predicates select, insert, delete,  and update correspond to database operations with equallynamed SQL commands. The parameters are the user executing the operation, the name of the database, and an identifier  of the involved data. The elements in the relations for the  predicates start and stop indicate the starting and finishing of  a synchronization script and contain the name of the script  as their only parameter. After the script script1 starts, it logs  details about its SVN status in the relations for the predicate  svn. The parameters are the name of the script, its SVN  status determined by the command svn status -u -v,  the SVN URL, and the SVN revision number. Possible  values for SVN status are latest for the latest version, old  for an older version, mod for a locally modified version,  and nosvn if the script has not been checked out from  the subversion repository. The relations for the predicate  commit represent committing a new script version into the  subversion repository. The parameters are the SVN URL and  revision number.  Table IV.  policy  delete  insert  select  update  script1  runtime  svn  svn2  ins-1-2  ins-2-3  ins-3-2  del-1-2  del-2-3  del-3-2  Policy Formalizations in MFOTL  MFOTL formalization   ∀user. ∀data. delete(user, db2, data) → user ≈ script2   ∀user. ∀data. insert(user, db2, data) → user ≈ script1   ∀user. ∀data. select(user, db2, data) →  user ≈ script1 ∨ user ≈ script2 ∨ user ≈ triggers   ∀user. ∀data. ¬update(user, db2, data)   ∀db. ∀data. select(script1, db, data) ∨ insert(script1, db, data) ∨  delete(script1, db, data) ∨ update(script1, db, data) →  (¬ [0,1s) ♦[0,1s) end(script1)) S ([0,1s) ♦[0,1s) start(script1)) ∨  [0,1s) ♦[0,1s) end(script1)   ∀script. start(script) → (¬ [0,1s) ♦[0,1s) end(script)) ∧ ♦[1s,6h) end(script)   ∀script. start(script) → [0,1s) ♦[0,10s) ∃url. ∃rev. svn(script, latest, url, rev)   ∀script. ∀status. ∀url. ∀rev. svn(script, status,   url, rev) →  [1s,∞) commit(url, rev0 ) → rev0  rev   ∀user. ∀data. insert(user, db1, data) ∧ data 0 unknown →  [0,1s) ♦[0,30h] ∃user0 . insert(user0 , db2, data) ∨ delete(user0 , db1, data)   ∀user. ∀data. insert(user, db2, data) ∧ data 0 unknown →  [0,1s) ♦[0,60s) ∃user0 . insert(user0 , db3, data)   ∀user. ∀data. insert(user, db3, data) ∧ data 0 unknown →  [0,60s) ♦[0,1s) ∃user0 . insert(user0 , db2, data)   ∀user. ∀data. delete(user, db1, data) ∧ data 0 unknown  →    [0,1s) ♦[0,30h) ∃user0 . delete(user0 , db2, data) ∨  (♦[0,1s) [0,30h) ∃user0 . insert(user0 , db1, data))∧    ([0,30h) [0,30h) ¬∃user0 . insert(user0 , db2, data))   ∀user. ∀data. delete(user, db2, data) ∧ data 0 unknown →  [0,1s) ♦[0,60s) ∃user0 . delete(user0 , db3, data)   ∀user. ∀data. delete(user, db3, data) ∧ data 0 unknown →  [0,60s) ♦[0,1s) ∃user0 . delete(user0 , db2, data)  In the following, we informally state the policies in natural  language and for the more involved policies, we provide  additional explanations. The MFOTL formalization of the  policies is shown in Table IV. The policies are:  • delete: Only user script2, representing the synchronization script script2, may delete data in db2 by executing  the SQL delete command.  • insert: Only user script1, representing the synchronization script script1, may insert data in db2 by executing  the SQL insert command.  • select: Only a limited set of users (script1, script2,  triggers) may read data from db2 by executing the SQL  select command.  • update: No SQL update commands are allowed in db2,  only insertion and deletions.  • script1: Database operations may be executed under  the user account script1 only while the script script1  is running. The motivation for this policy is that the  account script1 should only be used by the script, so  if the account is used while the script is not running,  the account may have been compromised. The database  operation can happen while the script is running, including the boundaries. That is, the time points when  an operation happens and when the script starts or ends  may have equal time stamps. The semantics of the  S operator includes the script start, but excludes the  script end. Therefore, the script end is allowed with  the additional disjunct at the end of the formula.  • runtime: The synchronization scripts must run for at  least 1 second and for no longer than 6 hours.  • svn, svn2: The synchronization scripts are maintained  in an SVN repository. We require that when started, the  synchronization scripts are the latest version available  Table V.  policy  delete  insert  select  update  script1  runtime  svn  svn2  ins-1-2  ins-2-3  ins-3-2  del-1-2  del-2-3  del-3-2  •  •  log 1  10 s / 4 MB  13 s / 4 MB  10 s / 4 MB  10 s / 4 MB  14 s / 4 MB  12 s / 9 MB  10 s / 4 MB  12 s / 16 MB  231 m / 161 MB  9 m / 8 MB  7 m / 5 MB  24 s / 176 MB  10 s / 4 MB  10 s / 4 MB  log 2  7 s / 4 MB  8 s / 4 MB  7 s / 4 MB  6 s / 4 MB  9 s / 4 MB  8 s / 9 MB  7 s / 4 MB  9 s / 16 MB  44 m / 103 MB  3 m / 7 MB  3 m / 5 MB  16 s / 139 MB  6 s / 4 MB  6 s / 4 MB  Monitor Performance — Running Times / Memory Usage  log 3  7 s / 4 MB  10 s / 4 MB  7 s / 4 MB  8 s / 4 MB  10 s / 4 MB  8 s / 6 MB  7 s / 4 MB  9 s / 16 MB  67 m / 107 MB  5 m / 8 MB  5 m / 5 MB  13 s / 87 MB  7 s / 4 MB  7 s / 4 MB  log 4  6 s / 4 MB  8 s / 4 MB  6 s / 4 MB  6 s / 4 MB  9 s / 4 MB  8 s / 9 MB  6 s / 4 MB  9 s / 16 MB  24 m / 102 MB  4 m / 8 MB  4 m / 6 MB  11 s / 79 MB  6 s / 4 MB  6 s / 4 MB  in the repository (largest SVN revision number). We  use two different formalizations, svn and svn2. The  policy svn uses the status parameter of the relation  svn. The policy svn2 compares the revision number  parameter of the relation svn with the committed revision numbers obtained from the subversion log via the  commit relation. Computing the latest revision number  is done by the logging mechanism for the policy svn,  but by the monitor for the policy svn2. Monitoring  both policies allows us to compare how efficiently the  monitor copes with these different formalizations and to  observe the impact of offloading the monitor by doing  pre-computations in the logging mechanisms.  ins-*: Data uploaded by the phone into db1 must  be propagated to all databases. In particular, ins-1-2  requires that data uploaded into db1 must be inserted  into db2 within 30 hours after the upload, unless it  has been deleted from db1 in between. Furthermore,  ins-2-3 and ins-3-2 require that data may be inserted  into db2 iff it is inserted into db3 within 1 minute. The  time limit from db1 to db2 is 30 hours because the  synchronization scripts run once every 24 hours and  can run for up to 6 hours. The time limit from db2  to db3 is only 60 seconds as this synchronization is  implemented by database triggers that start immediately  upon a change in db2. Note that these policies require  propagation of new data between db2 and db3 in both  directions. However, between db1 and db2 only one  direction is required. The reason is the incomplete  logging for db1.  del-*: Data deleted from db1 must be consistently  deleted from all databases. The policies del-2-3 and  del-3-2 are analogous to the policies ins-2-3 and  ins-3-2, respectively. The formalization of the policy  del-1-2 is more involved: If data is deleted from db1,  then this data must also be deleted from db2 within  30 hours. However, if the data has just been uploaded  to db1 and not yet propagated to db2, then it simply  should not be propagated to db2 in the future either.  Since the propagation would happen in at most 30  hours, we can simply consider the past and the future  log 5  5 s / 4 MB  6 s / 4 MB  5 s / 4 MB  4 s / 4 MB  6 s / 4 MB  5 s / 7 MB  5 s / 4 MB  7 s / 16 MB  9 m / 71 MB  2 m / 8 MB  2 m / 5 MB  8 s / 58 MB  5 s / 4 MB  4 s / 4 MB  log 6  4 s / 4 MB  5 s / 4 MB  4 s / 4 MB  4 s / 4 MB  6 s / 4 MB  5 s / 7 MB  4 s / 4 MB  6 s / 16 MB  5 m / 65 MB  2 m / 7 MB  2 m / 5 MB  7 s / 53 MB  4 s / 4 MB  4 s / 4 MB  4 s  5 s  4 s  4 s  5 s  4 s  4 s  6 s  3 m  1 m  1 m  12 s  4 s  4 s  log 7  / 4 MB  / 4 MB  / 4 MB  / 4 MB  / 4 MB  / 7 MB  / 4 MB  / 16 MB  / 57 MB  / 7 MB  / 5 MB  / 111 MB  / 4 MB  / 4 MB  log 8  6 s / 4 MB  8 s / 4 MB  7 s / 4 MB  6 s / 4 MB  9 s / 4 MB  7 s / 20 MB  7 s / 4 MB  8 s / 16 MB  73 m / 115 MB  2 m / 8 MB  2 m / 5 MB  21 s / 184 MB  6 s / 4 MB  6 s / 4 MB  log 9  6 s / 4 MB  8 s / 4 MB  6 s / 4 MB  7 s / 4 MB  8 s / 4 MB  7 s / 21 MB  7 s / 4 MB  8 s / 16 MB  48 m / 111 MB  1 m / 6 MB  1 m / 5 MB  11 s / 102 MB  6 s / 4 MB  6 s / 4 MB  30 hours to determine whether data has been and will  be propagated to db2 or not.  Monitor Performance. Table V shows the monitor’s  running times and memory usage for all policies in Table IV  and all log files in Table II.  Our reason for splitting the available stream of logged  actions into smaller chunks (i.e., log files) is to evaluate  our monitor on different data sets with different characteristics. Each of our chunks corresponds to a time span  of approximately 24 hours. We point out that monitoring  such chunks separately may reveal different violations than  monitoring the whole stream of actions. This is because,  policy conformance at a time point may depend on actions  that have been logged in another (timewise subsequent or  prior) chunk, as the time window of a temporal operator  may overpass the time span of a chunk. Except for the policy  del-1-2, all policy violations on the whole stream are also  detected on a chunk. However, due to splitting, additional  violations may be reported. We were not concerned about  these issues, as our main focus was on evaluating the  performance of the monitor. Moreover, we have manually  checked that all violations reported in Section IV are indeed  violations on the whole stream. 