2013 20th International Symposium on Temporal Representation and Reasoning  A Tool for Deciding the Satisﬁability of  Continuous-time Metric Temporal Logic  Marcello M. Bersani , Matteo Rossi , Pierluigi San Pietro:   Dipartimento di Elettronica Informazione e Bioingegneria, Politecnico di Milano, Italy  : CNR IEIIT-MI, Milano, Italy  Email: {marcellomaria.bersani, matteo.rossi, pierluigi.sanpietro}@polimi.it  Abstract—Constraint LTL-over-clocks is a variant of CLTL,  an extension of linear-time temporal logic allowing atomic assertions in a concrete constraint system. Satisﬁability of CLTL-overclocks is here shown to be decidable by means of a reduction to  a decidable SMT (Satisﬁability Modulo Theories) problem. The  result is a complete Bounded Satisﬁability Checking procedure,  which has been implemented by using standard SMT solvers.  The importance of this technique derives from the possibility  of translating various continuous-time metric temporal logics,  such as MITL and QTL, into CLTL-over-clocks itself. Although  standard decision procedures of these logics do exist, they have  never been realized in practice. Suitable translations into CLTLover-clocks have instead allowed us the development of the  ﬁrst prototype tool for deciding MITL and QTL. The paper  also reports preliminary, but encouraging, experiments on some  signiﬁcant examples of MITL and QTL formulae.  I.  typically based on Timed Automata [6], but, to the best of our  knowledge, they have never been realized in practice. This may  suggest that these approaches are not easily implementable  although they were the ﬁrst used to prove the decidability  properties of such logics.  In general, the level of support for veriﬁcation of  continuous-time temporal logics is not as well developed as  for discrete-time models. Uppaal [7] is the de-facto standard  tool for veriﬁcation of Timed Automata, but it does not  support continuous-time temporal logics: not only satisﬁability  checking is not available in Uppaal, but even the formalization  of system properties in temporal logic is not allowed, aside  from rather simple invariants and reachability properties. Satisﬁability Modulo Theories is a promising but well-consolidated  theory, supported by efﬁcient solvers that are able to decide  problems of many disciplines. In particular, decidable SMT  problems have been already considered in the recent past, for  instance to solve reachability [8] and the bounded version of  language inclusion [9] for Timed Automata. The idea is to give  a direct representation of bounded runs of Timed Automata  through an SMT formula, capturing a bounded unrolling of the  transition relation. Similarly, also Bounded Model-Checking  of Linear Temporal Logic on Timed Automata [10] can be  tackled by reducing the problem to an instance of a SMT  problem, by using a technique extending the traditional BMC  procedure for LTL ﬁnite automata [11], but by restricting the  set of valid runs to those that are periodic in the values of  the clocks. Finite or periodic runs of Timed Automata can  then be encoded in SMT formulae with explicit arithmetic.  Nonetheless, also this approach has so far failed to produce a  concrete decision procedure for logics such as MITL and QTL.  This difﬁculty is caused by the gap of translating formulae into  Timed Automata, a step which is avoided by our approach.  I NTRODUCTION  Constraint-LTL [1], called CLTL, is an extension of lineartime temporal logic allowing atomic assertions in a concrete  constraint system. By carefully choosing the constraint system,  CLTL may be decidable, as well as expressive and well-suited  to deﬁne inﬁnite-state systems and their properties.  In this paper, we deﬁne a variant of CLTL, called CLTLover-clocks (CLTL-oc), where arithmetic variables occurring in  atomic assertions are evaluated as clocks. A clock “measures”  the time elapsed since the last time the clock itself was “reset”  (i.e., the variable was equal to 0); clocks can also be tested  against a constant. By deﬁnition, in CLTL-oc each (discrete)  instant i is associated with a “time delay” corresponding to the  “time elapsed” between i and the next instant i 1. This allows  mixing of discrete events with continuous-time, a typical  situation arising in many computer-controlled applications.  Satisﬁability of CLTL-oc is here shown to be decidable  by means of a reduction to a decidable SMT (Satisﬁability  Modulo Theories) problem, resulting in a complete Bounded  Satisﬁability Checking procedure. Although other automatabased decision procedures would be suitable to show decidability of CLTL-oc (e.g., [1]), the novelty of our reduction  is that it can easily be implemented (by using standard SMT  solvers). In fact, the paper also reports on a new tool, publicly  available, to verify CLTL-oc formulae.  Suitable translations into CLTL-oc have instead allowed  us the development of the ﬁrst available tool for deciding  both MITL and QTL, hence showing the generality and  effectiveness of our approach. Further evidence of this is  provided by the fact that we have also been able to provide  a translation of the extension of QTL with so-called Pnueli  and counting modalities [12], thus providing its ﬁrst concrete  decision procedure.  Although CLTL-oc may be used to specify and verify  timed systems, a further advantage of our approach is that it is  possible to translate various continuous-time metric temporal  logics, such as MITL (Metric Interval Temporal Logic) [2] and  QTL [3], into CLTL-oc itself. Standard decision procedures of  MITL and QTL logics do already exist (e.g., [2], [4], [5]),  1530-1311/13 $26.00 © 2013 IEEE  1550-1311/13  DOI 10.1109/TIME.2013.20  We also report preliminary, but encouraging, experiments  on some signiﬁcant examples, such as the timed lamp and its  properties, in CLTL-oc, MITL and QTL.  The paper is organized as follows: Sect. II deﬁnes CLTLoc, and illustrates it by means of a running example (a  87  99  pπ, σ q, i |ù p ô p P π piq for p P AP  timed lamp). Sect. III proves that CLTL-oc is decidable,  while Sect. IV outlines the corresponding SMT-based decision  procedure. Sect. V brieﬂy describes MITL and QTL, showing  also the general idea behind their translation into CLTL-oc.  Sect. VI illustrates the tool, showing veriﬁcation results of  CLTL-oc, MITL and QTL formulae. Sect. VII concludes.  II.  pπ, σ q, i |ù Rpα1 , . . . , αn q ô pσ pi  pπ, σ q, i |ù  |αn |, xαn qq P R  pπ, σ q, i |ù φ ^ ψ ô pπ, σ q, i |ù φ and pπ, σ q, i |ù ψ  pπ, σ q, i |ù X pφq ô pπ, σ q, i  1 |ù φ  pπ, σ q, i |ù Y pφq ô pπ, σ q, i  1 |ù φ ^ i ¡ 0  pπ, σ q, i |ù φUψ ô D j ¥ i : pπ, σ q, j |ù ψ ^  pπ, σ q, n |ù φ @ i ¤ n  C ONSTRAINT LTL ( OVER CLOCKS )  j  pπ, σ q, i |ù φSψ ô D 0 ¤ j ¤ i : pπ, σ q, j |ù ψ ^  Constraint LTL (CLTL [1], [13]) is the decidable logic  that is used in Sect. V to solve the satisﬁability problem of  various metric temporal logics over continuous time. CLTL  formulae are deﬁned with respect to a ﬁnite set V of variables  and a constraint system D, which is a pair pD, Rq with D  being a speciﬁc domain of interpretation for variables and  constants and R being a family of relations on D, such  that the set AP of atomic propositions coincides with set  R0 of 0-ary relations. An atomic constraint is a term of  the form Rpx1 , . . . , xn q, where R is an n-ary relation of R  on domain D and x1 , . . . , xn are variables. A valuation is  a mapping v : V Ñ D, i.e., an assignment of a value in  D to each variable. A constraint is satisﬁed by v, written  v |ùD Rpx1 , . . . , xn q, if pv px1 q, . . . , v pxn qq P R. Given a  variable x P V over domain D, temporal terms are deﬁned  by the syntax: α : c | x | Xα, where c is a constant in D and  x denotes a variable over D. Operator X is very similar to X,  but it only applies to temporal terms, with the meaning that  Xα is the value of temporal term α in the next time instant.  Well-formed CLTL formulae are deﬁned as follows:  pπ, σ q, n |ù φ @ j  TABLE I.  n¤i  S EMANTICS OF CLTL.  unless it is “reset” (i.e., σ pi 1, xq  0). We show in Sect. III  that CLTL-oc is decidable. Before going further, to motivate  our approach, we provide an example of a CLTL-oc formula  representing a simple yet realistic timed system.  Example 1: we consider the LTL speciﬁcation of a timed  lamp and its properties (studied in Sect. VI) from [14]. The  lamp is controlled by two buttons, labeled ON and OFF  respectively, which cannot be pressed simultaneously. The  lamp itself can be either on or off. When ON is pressed the  lamp is immediately turned on, regardless of its current state,  while if OFF is pushed then the lamp is immediately turned  off, also regardless of its current state. After ON is pressed,  the lamp will not stay on forever, but, if no more buttons are  pressed, it will automatically turn off with a delay Δ, a positive  real constant. By pressing the ON button before the timeout  expiration then the timeout is extended by a new delay Δ.  φ : Rpα1 , . . . , αn q | φ ^ φ | φ | X pφq | Y pφq | φUφ | φSφ  where αi ’s are temporal terms, R P R, X, Y, U and S are the  usual “next”, “previous”, “until” and “since” operators of LTL,  with the same meaning. The dual operators “release” R, and  “trigger” T may be deﬁned as usual, i.e., φRψ is p φU ψ q  and φTψ is p φS ψ q.  Our CLTL-oc formula makes use of atomic propositions  on, off and l representing, respectively, events “push button  ON” and “push button OFF” and the state “light is on”. Clocks  may be used to measure the exact time elapsed since the  last on; clearly some clock must be “reset” (i.e., set to 0, in  analogy to Timed Automata) whenever ON is pressed, while  when a clock is equal to Δ then the timeout expires.Since the  introduction of clocks is not straightforward, we ﬁrst deﬁne a  few shorthands called rst-c, testcΔ and test0 c¤Δ . They have  the intuitive meaning (which will be formalized after the main  speciﬁcation) that they are true if, and only if, a clock c is reset  or, respectively, c  Δ, or 0 c ¤ Δ. The speciﬁcation of the  lamp, still lacking  the precise clock speciﬁcation, is deﬁned by  5  the formula G  i0 piq , where G pφq is the usual globally  operator deﬁned by KRφ, of the following formulae:  The semantics of CLTL formulae is deﬁned with respect  to a strict linear order representing time pN, q. Truth values  of propositions in AP , and values of variables belonging to  V are deﬁned by a pair pπ, σ q where σ : N  V Ñ D is a  function which deﬁnes the value of variables at each position  in N and π : N Ñ ℘pAP q is a function associating a subset  of the set of propositions with each element of N. The value  of terms is deﬁned with respect to σ as follows:  σ pi, αq  σ pi  |α1 |, xα1 q, . . . , σ pi  φ ô pπ, σ q, i |ù φ  |α|, xα q  where xα is the variable in V occurring in term α and |α| is the  depth of a temporal term, namely the total amount of temporal  shift needed in evaluating α: |x|  0 when x is a variable, and  |Xα|  |α| 1. The semantics of a CLTL formula φ at instant  i ¥ 0 over a linear structure pπ, σ q is recursively deﬁned as  in Table I, A formula φ P CLTL is satisﬁable if there exists a  pair pπ, σ q such that pπ, σ q, 0 |ù φ.  pon ^ offq  on ô rst-c  Yplq ñ test0 c¤Δ  turnoff ô Yplq ^ poff _ testcΔ q  l ô turnoff S on.  In this paper, we consider a variant of CLTL, where  arithmetic variables are evaluated as clocks and set RzR0 is  t , u. A clock “measures” the time elapsed since the last  time the clock was “reset” (i.e., the variable was equal to 0).  By deﬁnition, in CLTL-oc each i P N is associated with a  “time delay” δ piq, where δ piq ¡ 0 for all i, which corresponds  to the “time elapsed” between i and the next state i 1. More  precisely, for all clocks x P V , σ pi 1, xq  σ pi, xq δ piq,  (1)  (2)  (3)  (4)  (5)  Formula (1) ensures mutual exclusion; (2) states that the  timeout must be (re)started whenever button ON is pressed;  (3) constrains the time elapsed since the previous instant if the  light was on at that moment (i.e., not more than Δ); (4) deﬁnes  (for readability) an event turnoff, capturing the two cases when  the lamp (supposed to be ON in the previous instant) must be  turned off at the current instant (i.e., OFF being pressed or  100  88  a sequence of clock regions R0 R1 , . . . such that, for all time  position i, Ri 1 is a time-successor of region Ri [6], except  for the clocks that in Ri 1 are reset (i.e., whose value is 0).  Let φ be a CLTL-oc formula and Aφ be its Büchi automaton  recognizing symbolic models of φ [15]. Then, we deﬁne an  automaton AR  φ accepting all the symbolic models belonging  to L Aφ , such that the sequence of regions entailed by  clock constraints within symbolic valuations obeys the timeR, δ be the automaton where  successor relation. Let AcR  R is the set of all regions induced by the clocks, c is the  maximum constant that all clocks are compared with and δ is  the transition relation containing all R  R1 such that R1 R  is a time-successor of R R, except for the clocks whose  value is 0 in R1 . Automaton AR  φ is deﬁned as the product of  Aφ and automaton AcR recognizing the language of successive  regions, which are induced by formula φ. It is worthy to be  noticed that the following construction only guarantees that  time elapses and all clocks progress by the same amount of  time. Since we are dealing with a CLTL formulae where atoms  may be relations over clocks, the construction of AR  φ does not  force the value of clocks which is instead constrained by the  formula. This impacts the deﬁnition of the initial region, which  does not follow the standard construction where all clocks are  zero. In our case, we relax the assumption that all clocks start  from 0, by simply considering each region as potentially initial.  the timeout expiring); ﬁnally, (5) gives the speciﬁcation of the  light, as being on if, and only if, there was in the past an on  event not followed by a turnoff. Initialization is implicit in the  speciﬁcation (at instant 0, the light is off).  To complete the speciﬁcation, we must formalize also  the clock behavior. In CLTL-oc, “resetting a clock” c, e.g.,  following an on event is as simple as stating that on  c 0;  testing a clock c against a constant Δ and causing say, a turnoff  is a simple as stating that c Δ  turnoff. Unfortunately, the  same clock cannot be tested and reset at the same time. A  possible solution is to introduce two clocks c0 and c1 , rather  than just one clock, so that they are reset alternatively: only  one of the two clocks is reset and a new reset of the same clock  will eventually occur only after the occurrence of a reset of  the other clock. The behavior of this clock pair is described  by the axiom G 6  7 , where formulae (6) and (7) are:  p q  ñ    ñ  i  i  i 1  i  2  0,1  0  1  2  2  2  c Δ  0 c Δ  0  1  0 c Δ  c Δ  i  iPt0,1u  III.  We brieﬂy recall some key elements of Aφ (see [13]  for further details). Let SV φ denote the set of symbolic  valuations associated with φ. The closure of φ, denoted cl φ ,  is the smallest set containing all subformulae of φ and closed  under negation. An atom Γ cl φ is a maximally consistent  subset of formulae of cl φ , i.e., such that, for each subformula  ξ in φ, either ξ Γ or ξ Γ. Automaton Aφ is the tuple  SV φ , Q, Q0 , η, F where Q is the set of all the atoms and  η is deﬁned as in the standard Vardi-Wolper construction.  pq  i  i  0,1  i 1  2  i 1  P  Ñ  P  pp q ^ p qq   (6)  c  0 ñ X pcp q ¡ 0 U c  0q  Pt u  (7)  c  0 ñ pc  0q  and pq stands for the modulo 2 operator (i.e., p1q  0,  p2q  0). Finally, the above clock shorthands rst-c, test   and test ¤ are deﬁned as follows:  rst-c ô c  0 _ c  0  ª 0 c ¤Δ  test ¤ ô  Pt u  ª    c  Δ ^ pcp q ¡ Δ _ cp q  0q  test  ô  ©  p q  2  P  p pq  D ECIDABILITY OF CLTL OVER CLOCKS  Our argument is divided in two parts. First, in this section,  we show that a CLTL-oc formula φ can be translated into a  suitable Büchi automaton AR  φ , which recognizes the language  of the regions of the clocks appearing in φ. If the automaton  accepts some ultimately periodic words of the form uv ω  over the alphabet of clock regions induced by φ, then φ is  satisﬁable. In fact, through arguments akin to those in [6], we  can show that an inﬁnite sequence of successive regions is  representative of a trace of a CLTL-oc formula. Automaton  AR  φ is built using a slight variation of the construction used  in [1] and [13]; it differs from those built in the earlier works  in that its symbolic runs include the sequences of symbolic  valuations that satisfy φ [1] and also constraints representing  the clock regions induced by φ. Second, in Sect. IV we provide  a way to solve in practice the satisﬁability of CLTL-oc, through  the method used in [13] to solve satisﬁability of CLTL. The  technique relies on encoding CLTL formulae into formulae of  a decidable fragment of ﬁrst-order logic, which can then be  solved by off-the-shelf SMT solvers. The decision procedure  hinges on ﬁnding a ﬁnite sequence of assignments to the  clocks appearing in the CLTL formula φ, which satisﬁes φ  and such that it is a witness of an ultimately periodic sequence  of successive clock regions. Since the clock regions deﬁne a  partition of the space of clock assignments, each assignment  of values to clocks uniquely identiﬁes a region, hence an  exhaustive deﬁnition of all the regions is not needed.  q  pq  pq   pq  P  p pq    Rq.  Y  1  pΓ, Rq ÝÝÝÑ pΓ , R1q if,  and only if, sv P SV pφq satisﬁes Γ, the pair pΓ, Γ1 q is onestep consistent, R Ñ R1 P δ and sv Y R is satisﬁable. Set  I  Q  R of initial states consists of states (atoms) of Q  that are consistent with respect to regions in R; i.e., the set  of arithmetical constraints in Γ P Q union R is a satisﬁable  1  Now, we deﬁne AR  φ as tuple SV φ , Q R, I, η , F  sv R  Relation η 1 is deﬁned as follows:  0  0  0  conjunction of formulae.  A run ρ of AR  φ is a sequence:  Y  Y  Ñ . . . pΓ , R q ÝÝÝÝÝ  Ñ pΓ , R q . . .  pΓ , R q ÝÝÝÝÝ  where pΓ , R q P I. Let pπ, σ q be a sequence where π : N Ñ  ℘pAP q and σ : N  V Ñ R. pπ, σ q witnesses ρ, i.e., pπ, σ q |ù  ρ, when for all i ¥ 0:  π piq  Γ X AP and σ, i |ù sv Y R .  Lemma 1. Let φ be a CLTL-oc formula. pπ, σ q |ù φ if, and  only if, there is an accepting run ρ of A such that pπ, σ q |ù ρ.  Proof: We ﬁrst show that, if pπ, σ q |ù φ, then there is  0  0  0  sv0 R0  i  i  svi Ri  i 1  i 1  0  i  i  i  R  φ  an accepting run of automaton AR  φ . In [1] it is shown that a  CLTL formula φ is satisﬁable if, and only if, there is a run  ρ sv0 sv1 . . . of automaton Aφ recognizing symbolic models  of the formula. We have to show that when the variables of φ  behave like clocks, then the sequence of valuations deﬁnes a    To represent correctly the elapsing time as measured by  clocks, symbolic models of CLTL-oc formulae has to deﬁne  101  89  sequence of successive clock regions, hence ρ is also a run of  AR  φ . In fact, we have that σ, i |ù svi . Since the set of clock  regions is a partition of the clocks space, there is only one  region R P R such that σ, i |ù Ri , with Ri  R. Therefore,  σ, i |ù svi Y Ri and model pπ, σ q induces a sequence of regions  R0 R1 . . . . By construction, each atom Γi is such that π piq   Γi X AP . Finally, we prove that each Ri Ri 1 in the sequence  R0 R1 . . . is a pair of successive regions. In fact, if σ pi, xq  and σ pi 1, xq are two adjacent valuations for a clock x of φ,  then either there is a t ¡ 0 such that xpi 1q  xpiq t or  xpi 1q  0 (reset). Therefore, Ri 1 is a time successor of  Ri (except for the clocks whose value is 0 in Ri 1 ) and the  sequence R0 R1 . . . is a sequence of successive regions which  belongs to the language L pAcR q. At each position i, we have  that π piq  Γi X AP and σ piq |ù svi Y Ri . Hence, pπ, σ q |ù ρ.  show the PSPACE-completeness for CLTL-oc using arguments  similar to those used in [6] to show how the transition relation  of the automaton checked for language emptiness can be  computed in PSPACE. In fact, consider a CLTL-oc formula φ.  If we indicate with |φ| the number of subformulae of φ, with  N the number of clock variables in φ, and with K the biggest  constant against which the clock variables of φ are compared,  since the number of clock regions is OpN !  K N q [6], the  |φ|  N !  K N q.  number of states of automaton AR  φ is O p2  However, to check for the emptiness of L pAR  φ q we do not  need to build the whole state space, but only a constant  number of vertices at a time. Since the space needed to store  a vertex of automaton AR  φ , when using a binary encoding for  K, is polynomial in |φ| logpK q, the algorithm for checking the  emptiness of AR  φ is in PSPACE.  We now show that, if automaton AR  φ has an accepting  run ρ, then CLTL formula φ is satisﬁable. The Vardi-Wolper  construction of the Büchi automaton Aφ guarantees that at  each position of the run ρ a subset of the subformulae of φ  are satisﬁed and φ is witnessed at position 0. By construction,  the sequence of symbolic valuation sv0 sv1 . . . is a symbolic  model of φ and such that it admits arithmetical model; i.e.,  there is an inﬁnite sequence of valuations of the variables  occurring in φ and satisfying the constraints in svi , for all i  [1]. By construction, the sequence R0 R1 . . . is a sequence of  successive clock regions in the language L pAcR q. Therefore,  by standard arguments from Timed Automata, we can build a  sequence of delays δ piq such that, for each clock x P V , it is  xpi 1q  xpiq δ piq, unless x is reset (i.e. xpiq  0).  IV.  We outline how to decide the satisﬁability problem for  CLTL-oc formulae by a SMT-based technique instead of  automata. The technique is based on previous work [16] [15],  in which we used a k-bounded satisﬁability problem to solve  the satisﬁability of CLTL formulae by using a polynomial  reduction to a SMT problem. k-bounded satisﬁability is complete, and deciding the satisﬁability of a CLTL formula can be  done by means of a ﬁnite amount of k-bounded satisﬁability  tests, for increasing values of k. To deal with variables that  behave like clocks, the method developed in [15] is extended  to represent time progress.  Given a CLTL formula φ, we say that φ is k-bounded  satisﬁable if there exists an ultimately periodic sequence of  symbolic valuations sv0 , . . . , svl1 psvl . . . svk1 qω , which is a  symbolic model of φ and such that there is a partial assignment  of values to all the variables occurring in φ only for a ﬁnite  number of positions in time, from 0 to k 1. In other words,  in k-bounded satisﬁability we look for a ﬁnite sequence of  symbolic valuations sv0 , . . . , svl1 psvl . . . svk1 svk q, where  svk  svl , which admits a k-bounded arithmetical model and  that is representative of an inﬁnite symbolic model for φ of  the form sv0 , . . . , svl1 psvl . . . svk1 qω . While in PSPACE, in  practice k-bounded satisﬁability can be quite efﬁcient, at least  when the value of k is small enough to perform the check:  checking k-bounded satisﬁability is then equivalent to solve a  few SMT problems in P. Obviously, the upper bound for k is  in general exponential in the size of the formula.  Observe that time progression in automaton AR  φ is not guaranteed by the construction. However, this requirement is easily  achieved by the CLTL formula: G pXx  0 _ Xx ¡ xq ^  pGF px  0q _ FG px ¡ cpxqqq (where cpxq is the biggest  constant clock x is compared to), for all clocks x P V .  Finally, the following result is a direct consequence of  Lemma 1 and of properties of CLTL and Timed Automata.  Theorem 1. Satisﬁability for CLTL-oc is decidable.  Proof: Let φ be a CLTL-oc formula. By Lemma 1 we  can build automaton AR  φ , recognizing symbolic models of φ,  that has an accepting run (i.e., whose accepted language is  non-empty) iff φ is satisﬁable. Checking the emptiness of  the language L pAφ q is done by standard techniques which  look for cycles in the graph of AR  φ embedding (at least) one  accepting control state. The language of AR  φ is not empty if  there exists a path of AR  φ of the form  p  In [15] we show how to solve k-bounded satisﬁability for  CLTL formulae over a class of arithmetical constraints that  include the family of clock constraints used in Sect. II. The kbounded satisﬁability problem is solved through a polynomialtime reduction to the satisﬁbility problem of a formula in  the theory of Equality and Uninterpreted Functions combined  with Linear Integers/Reals Arithmetic. The combination of  the two theories is decidable and its decision procedure is  implemented by many SMT-solvers. The reduction of [15] has  been implemented in the ae2 zot plugin of the Zot tool [17].  Therefore, an instance of the k-bounded satisﬁability problem  for CLTL formulae has the complexity of the underlying SMT  problem, which depends on the arithmetic theory required.  In our case, since clocks are in R, we solve SMT problems  in QF-EUF Y LRA, whose complexity is P. A peculiarity  of the SMT-based approach is that, if the set of symbolic  Γ0 , R0 q . . . pΓl1 , Rl1 qpΓl , Rl q . . . pΓk , Rk q  where Γk  Γl , Rk  Rl and all atoms belonging to F  occur at least once in pΓl1 , Rl1 qpΓl , Rl q . . . pΓk1 , Rk1 q.  The word which is recognized by the run is an ultimately  periodic one over the language SV pφq Y R of the form:  p  S OLVING CLTL- OVER - CLOCKS SATISFIBILITY  ω  sv0 , R0 q . . . psvl1 , Rl1 q ppsvl , Rl q . . . psvk1 , Rk1 qq .  1) Complexity. : The satisﬁability problem for CLTL-oc  is PSPACE-hard, as any LTL formula (whose satisﬁability  problem is PSPACE-complete) is also a CLTL formula. We can  102  90  valuations partitions of the space D|V | (with D the domain  of the variables in V ), then a sequence of valuations uniquely  induces a sequence of symbolic valuations. By solving the  k-bounded satisﬁability problem for a formula φ we obtain,  from the model of the QF-EUF formula, the sequence of  valuations satisfying the constraints occurring in the formula,  which induces a symbolic model. Hence, unlike automatabased techniques, our approach does not require the explicit  construction of the set SV pφq. We exploit this to avoid building  the set of clock regions induced by CLTL formulae.  δ  x  y  1  k  0.2  0.9  2.4  0.5  0.6  ...  0.1  0.3  1.2  0  0.5  ...  2.1  2.3  3.2  5.5  6  Rl1  Rl  R  svl  Rk  1.1  svk  6.6  Fig. 1. A (portion of) bounded model satisfying inﬁnitely often formula  py ¡ 0qUpx  0q. P er pacpRφ qq enforces regions Rl and Rk (dashed  rectangles) to be equal, where Rl  txl  yl , 1  xl  2, 2  yl u  yk , 1  xk  2, 2  yk u. Solid rectangles represent  and Rk  txk  symbolic valuations svl  svk where constraints x  c are not written  because included in the regions. The set of all constraints a Ñ b (representing  a  b) between all the pairs of elements in tx, y, 0, 2u deﬁnes a symbolic  valuation. Value xk1  0 satisﬁes constraint G pF px  0qq and values yi ,  with i P rl  1, k  1s, witnesses F pG py ¡ cpy qqq. The complete deﬁnition  of |φ|k can be found in [15]. We provide some of its formulae for the sake  of space. Formula 1 ¤ l ¤ k  1 sets position l of the loop in r1, k  1s.  The semantics of the formula φ  py ¡ 0qUpx  0q is achieved by means  of the ﬁxpoint deﬁnition of U over all positions in 0, k that is ki0 φi ô  pxi  0q _ pyi ¡ 0 ^ φi 1 q. The semantic equivalence of position k and l,  i.e., all the subformulae of φ have the same truth value at k and l, is enforced  by φl ô φk , pxl  0q ô pxk  0q, pyl ¡ 0q ô pyk ¡ 0q. The eventuality  of px  0q in the periodic part, when φ holds at position k, is guaranteed by  φk ñ l ¤ iφ ¤ k ^ pxiφ  0q.  To solve the satisﬁability of CLTL-oc we still use kbounded satisﬁability to look for ultimately periodic models,  but we extend the method in order to represent clock regions  and time progression. Representing clock regions is quite  straightforward and exploits the fact that regions partition the  space of all possible clock valuations. In other words, a clock  valuation identiﬁes a clock region, so it is not necessary to  precompute the set of all clock regions from the formula.  The only requirement to be enforced is the periodicity of the  sequence of clock regions corresponding to clock valuations. If  one is looking for a model of length k, the sequence of clock  regions is of the form: R0 . . . Rl1 pRl . . . Rk1 qω , which is  obtained from a ﬁnite sequence R0 . . . Rl1 pRl . . . Rk1 Rk q  with the periodicity constraint Rl  Rk . The QF-EUF encoding of CLTL formulae is deﬁned to enforce periodicity of all  atomic formulae (atomic propositions and clock constraints)  between positions k and l. For instance, given two clocks  x, y, if x  y holds at position k (i.e., xpk q  y pk q) then,  by the periodicity constraints, it must also hold at position l:  xpk q  y pk q ô xplq  y plq. To obtain a periodic sequence  of regions we provide the solver with all the clock constraints  which may occur in the deﬁnition of regions in Rφ (but not  all the regions). Given a CLTL-oc formula φ, we deﬁne the  set acpRφ q as the set of all clock constraints induced by φ.  Let φ1 be a CLTL formula, Cφ be the set of clocks appearing  in φ1 , and x, y P Cφ . If cpxq is the maximum constant with  which clock x is compared in φ1 and P t , , ¡u, the set  acpxq  tx  c | @c P r0, 1, . . . , cpxqsuztx 0u is the set of  all clock constraints between x and constant cpxq, while set  acpx, y q  tx  y u is the set of all clock constraints between  x and y. Then, set acpRφ q is deﬁned as: x,y P Cφ ,xy acpxqY  acpx, y q. We indicate with P erpacpRφ qq the set of QF-EUF  periodicity constraints on arithmetic constraints acpRq, that  is, @θ P acpRq θpk q ô θplq. Time elapsing is obtained by  forcing all clocks in φ1 to progress by the same amount of  time between two positions of the model. Let i P r0, k  1s;  then, constraint xpi 1q  xpiq δ piq _ xpi 1q  0, where  δ piq ¡ 0, is imposed to represent a positive elapsing time,  for all clocks x P Cφ . We indicate with Adv pCφ q the set  of constraints that impose the uniform time advancement of  clocks in Cφ . Since all variables in the theory of Reals are  deﬁned over R and all x P Cφ behave like clocks, we force  xpiq ¥ 0 for all x P Cφ and for all i P r0, k s. We indicate the  conjunction of these constraints as nN eg pCφ q.    V.  E NCODING M ETRIC T EMPORAL L OGICS  We exploit the decision procedure for CLTL-oc outlined  in Sect. IV to deﬁne mechanisms for deciding various metric  temporal logics over continuous time. In fact, we have deﬁned  several satisﬁability-preserving reductions from metric temporal logics to CLTL-oc; hence, satisﬁability of formulae of these  former logics can be determined by solving the corresponding  problem for CLTL-oc. In particular, the logics we have targeted  so far are: MITL [2], QTL [18], and QTL with counting and  Pnueli modalities [12]. In this section, after brieﬂy recalling  the deﬁnition of MITL and QTL, we present some highlights  from the aforementioned reductions.  1  1  Let AP be a ﬁnite set of atomic propositions. The syntax  of (well formed) formulae of MITL is deﬁned as follows:    φ : p | φ ^ φ |  1  1  k  l  φ | φUI φ  with p P AP and I is an interval of the form xa, by or  of the form xa, 8y, where a, b P N are constants, with  a  b. Interval xa, by can be, in general, left open or closed  (respectively, p or r) but only right closed (written as s). We  omit the interval I when it is r0, 8q.  1  M, t  M, t  1  1  1  p  ô  p  φ  ô  M, t |ù φ  M, t  P  M, t  |ù  φ^ψ  ô  M, t  |ù  φUI ψ  ô Dt  1  M ptq  P  We solve the satisﬁability problem of CLTL-oc formula  φ by feeding the SMT solver the set of constraints |φ1 |k Y  P erpacpRφ qq Y Adv pCφ q Y nN eg pCφ q, where |φ1 |k is the  bounded representation of φ1 described in [15].  p  AP  P  |ù  φ and M, t  t  I : M, t  TABLE II.  1  1  |ù  |ù  1  |ù  |ù  ψ  ψ and M, t  2  |ù  φ @t  2  P rt,  t  1  q  S EMANTICS OF MITL.  The semantics of MITL is deﬁned in Table II with respect  to signals. A signal is a function M : R Ñ 2AP (with R  the set of nonnegative reals). A MITL formula φ is satisﬁable  if there exists a signal M such that M, 0 |ù φ (in this case, M  is called a model of φ). The globally GI and eventually FI  1  The complete deﬁnition of |φ|k can be found in [15].  103  91  operators can be deﬁned by the usual abbreviations: FI φ  JUI φ and GI φ  FI p φq.    false to true), this occurred more than b instants ago (i.e., the  clock associated with ψ that is not reset now is ¥ b).  QTL is similar to MITL, but it is based on a single metric  operator, Fp0,1q (and its past counterpart Pp0,1q ), so its syntax  is the following:1  φ:   p|φ^φ|  |  |  |  θ  |  φ φUp0,8q φ Fp0,1q φ φSp0,8q φ Pp0,1q φ.  We now brieﬂy show how to encode MITL and QTL  formulae into CLTL-oc ones . For space reasons we only  provide some highlights of the reduction in a special case.  Let us restrict signals to those where intervals are leftclosed and right-open (l.c.r.o. signals,  ). In  addition, given a MITL formula φ we are interested in signals  that are non-Zeno [20] models of φ, i.e., such that in every  ﬁnite interval of the temporal domain there is a ﬁnite number of  change points of the value of the atomic propositions of φ. For  these (l.c.r.o.) signals, the temporal domain can be partitioned  in a countable set of adjacent l.c.r.o. intervals such that in each  such interval the value of every subformula of φ is constant.  Then, for each subformula θ of φ (θ P subf pφq) we introduce    a CLTL-oc predicate θ that represents the value of θ in the  intervals in which the temporal domain is partitioned. We also  introduce the following abbreviations:      ξ  ξ        !ξ   Yp ξ q^ ξ    iPt0,1u  zψi  ¤b  i  zψ  ¥b  (9)  (10)  (11)  (12)  (13)  Predicates p and q become false before each position 2k 1.5  by requiring that p ^ q occurs until an interval of length 0.5  where both p and q are false. Let tpk P p2k 1, 2k 1.5q be  the instant where p becomes false, and tqk  tpk δk P p2k  1, 2k 1.5q the one where q becomes false; let δk  tpk  tqk be  the length of the interval where p does not occur while q does.  Formula (13) lengthens signal p of δk time units over the next  interval starting from 2k: p holds in rtpk 1, tpk 2 δk q. The  series of values δk is strictly monotonic decreasing because  each value is arbitrarily strictly less than the previous one, i.e.,  δk ¡ δk 1 , for all k. Therefore, the sequence of δ piq is not  periodic, although the sequence of clock regions of induced  by the clocks in the CLTL-oc formula corresponding to the  formulae above is indeed periodic.  (8)  The case for θ becoming true is not shown for brevity.  Consider the case θ  Pr0,bq pψ q. Formula (9) captures  the condition in which θ becomes true. This occurs when ψ  becomes true and either the current instant is the origin (O is  an abbreviation for Y pJq), or ψ has never become true since  the origin, or the last time ψ changed value (necessarily from  1 Note  iPt0,1u  GpGx0,1s pp ^ q q ñ Fx1,2s pp p ^ q qUpGx0,0.5s q qq  Gp p ^ q ñ Gx1,2s pq  Formula (8), then, captures the condition in which formula  θ  Fp0,bs pψ q becomes false: in this case, ψ must become  false, and it cannot become true again for b instants (i.e., ψ  cannot become true again before its associated clock that is  reset when ψ becomes false hits b).  ψR  ª  Both signals p and q hold over intervals longer than one time  unit, because of the l.c.r.o. assumption. In addition, we require  that q is at least as long as p by means of formula G pp ñ q q.  Formulae (10)-(11) admit, in general, models that can be  periodic; therefore, we have to restrict the set only to aperiodic  models. This may be achieved by enforcing that, over intervals  of the form r2k 1, 2k 2s, with k ¥ 0, signal q is strictly  longer than p, while over intervals r2k 1.5, 2k 2q both p  and q are false, as required by the followig two formulae:  For simplicity, we focus our attention on temporal operators  Fp0,bs pψ q and Pr0,bq pψ q. We remark that it can be shown  that, if ψ holds only in l.c.r.o. intervals, so do Fp0,bs pψ q and  Pr0,bq pψ q (the same does not hold, for example, for Fp0,bq pψ q).  For each subformula θ P subf pφq we introduce two clocks, zθ0  and zθ1 , which measure the time from the last change point  (either θ or !θ , so we have θ _ !θ ô zθ0  0 _ zθ1  0),  and whose resets alternate.  ! θ ô !ψ ^  pO^ ψ q _  Gx0,1s p ^ GpGx0,1s p ñ Gx2,3s pq  Gx0,1s q ^ GpGx0,1s q ñ Gx2,3s q q.  where ξ , for example, captures the situation in which ξ  changes value from false to true, with the formula being true  in the current interval.     ψ^ ©  ψS  Example 2: consider the conjunction of the following  MITL formulae deﬁning the behaviour of two signals p, q as  depicted in Figure 2. Signal p holds in r2k, 2k 1 εq, for all  k, and is false elsewhere, as formalized by the MITL formulae  Yp ξ q^ ξ    ψ  To conclude this section, we provide an example of MITL  formula (to be evaluated over l.c.r.o. signals) over two atomic  propositions p, q whose model is intrinsically aperiodic in the  values of the delays between changepoints in the values of  p and q. The existence of formulae admitting only aperiodic  models shows that, in the decision procedure of Sect. IV, the  periodicity must be enforced on the set of constraints deﬁning  regions, but not on the actual values of the clocks, nor on  the time differences δ; i.e., the encoding of CLTL formula φ1  does not include constraints δ pk q  δ plq and xpk q  xplq. In  other words, for the example below there does not exist a periodic sequence of time increments δ p0qδ p1q . . . pδl . . . δk1 qω  representing the time elapsing for aperiodic models even if the  sequence of clock regions is periodic.  For brevity, we omit the semantics of QTL, which is however  similar to the one in Tab. II. Note that, despite its apparent  simplicity, QTL has the same expressive power as MITL [19].  ξ  ô      ^ O _ Y  VI.  I MPLEMENTATION & E XPERIMENTAL R ESULTS  The decision procedure of Sect. IV for CLTL-oc is implemented in a plugin, called ae2 zot, of our Zot toolkit [17],  whereas the reductions outlined in Sect. V are implemented in  the qtlsolver tool, available from [21]. The tool translates  that MITL can be enriched with the “metric since” SI past operator.  104  92        QTL        We used the above two encodings and the CLTL-oc decision procedure to carry out some veriﬁcation experiments on  the example of the Timed Lamp described in Sect. II. More  precisely, we have built several descriptions of the behavior  of the lamp: (i) the CLTL-oc model presented in Sect. II;  (ii) a MITL speciﬁcation assuming l.c.r.o. signals; (iii) a QTL  speciﬁcation in which predicates on and off are constrained to  be true only in isolated instants. On each of these speciﬁcations  we have carried out three experiments, assuming Δ  5: a  check of the satisﬁability of the speciﬁcation, to show that it  is consistent (sat); the (dis)proof of property “the light never  stays on for more than Δ time units” (p1 ); the proof of property  “if at some point the light stays on for more than Δ time  units, then there is an instant when on is pressed, and then it  is pressed again before Δ time units” (p2 ). Depending on the  temporal logic and of the restrictions on the signals (l.c.r.o. or  not) the formalization of the timed lamp and of the properties  can change.      Fig. 2.  Aperiodic model for MITL formula of Example 2  MITL or QTL into CLTL-oc, which can be checked for  satisﬁability by ae2 zot.  The resulting toolkit has a 3-layered structure, where  CLTL-oc is the intermediate layer between SMT-solvers and  various temporal formalisms that can be reduced to CLTLoc. This not only supports (bounded) satisﬁability veriﬁcation  of different languages, but it also allows the expression of  different degrees of abstraction. For instance, QTL and MITL  abstract away the notion of clocks, inherently encompassed  within temporal modalities, which are instead explicit in  CLTL-oc (as witnessed by the example of the timed lamp in  Sect. II) and available to a user, e.g., to express or verify properties where clocks are very convenient. In fact, preliminary  experimental results point out that the time required to solve  CLTL-oc may be signiﬁcantly smaller than the one needed for  more abstract classes of languages, such as MITL. This gap  is caused by the “effort” required to capture the semantics of  temporal modalities, which, on the other hand, allow for more  concise and manageable high-level speciﬁcations. One can  then take advantage of the layered structure, which allows the  resolution of a formula to be compliant also with constraints  imposed at lower layers, for instance by adding at the CLTLoc layer some extra formula limiting the set of valid models  (e.g., by discarding certain edges of some events or by adding  particular timing requirements). Also the third layer (the SMT  solver) may be used to add further constraints, e.g., to force  the occurrence of a proposition or of a certain clock value at  a speciﬁc discrete position of the ﬁnite model.  In the case of the CLTL-oc speciﬁcation of the timed lamp,  in order to formalize properties p1 and p2 we introduce an  auxiliary clock caux , which is reset every time the light is  turned on, i.e., caux ô l ^ Y p lq. Then, in CLTL-oc property  p1 is captured by formula G pY plq ñ caux ¤ Δq. In addition,  property p2 is formalized by the following formula:  F pl ^ caux ¥ Δq ñ F pon ^ Xp rst-cUpon ^ test0  ¤  c Δ qqq  (14)  The behavior of the timed lamp can be captured by the  following MITL formula over l.c.r.o. signals (we write G for  Gr0,8q , and S for Sr0,8q ):  G  l ô p off S onq ^ Pr0,Δq ponq    ^ pon ñ  offq    (15)  In MITL over l.c.r.o. signals, where predicates hold over nonnull intervals, we limit the length of intervals in which on (and  off) holds to be at most 1 by adding the following constraint:  G  Gp0,1s ponq ^    Gp0,1s poffq .  (16)  Over unrestricted signals, instead, we force on to hold only in  isolated instants by adding QTL constraint (similarly for off)  G  The current implementation of qtlsolver supports various reductions. More precisely, it realizes the MITL-to-CLTLover-clock translation tailored to l.c.r.o. signals, as highlighted  in Sect. V. It also implements a translation from a generalized  version of QTL to CLTL-oc. This translation does not assume  any special shape for signals, except that they be ﬁnitely variable; it natively supports operators Fx0,by and Gx0,by (and their  past counterparts), where the bounds can be either included  or excluded. These operators allow us to deﬁne concisely  Fxa,by and Gxa,by as abbreviations. Forinstance, Gp3,6q pφq  is equivalent to Gp0,3q Fp0,3q Gp0,3q pφq ; deﬁning a similar  equivalence using only the Fp0,1q and Gp0,1q modalities (see,  e.g., [3]) involves the recursive expansions of each conjunct  Gpn,n 1q pφq is  of Gp3,4q pφq ^ Gr4,5q pφq ^ Gr5,6q pφq, where    equivalent to Gpn1,nq Fp0,1q Gp0,1q pφq . The following two  encodings are currently available:  MITL  providing the deﬁnition of generalized QTL operators  with unrestricted signals (other than they be ﬁnitely  variable), and MITL operators through abbreviations.  pon  Up0,  8q Jq ^  pon  Sp0,  8q Jq    .  (17)  Properties p1 and p2 over unrestricted signals are captured by  the following QTL formulae (where F stands for Fr0, 8q ):    G Fr0,Δs p lq      F Gr0,Δs plq ñ F on ^ Fp0,Δs ponq  (18)  (19)  Over l.c.r.o. signals property p1 is still captured by Formula  (18); property p2 , instead, is more involved, and corresponds  to the following formula:  F Gr0,Δs plq    ñ  F  p    on ^ Pr0,Δq ponqqU on  (20)  Table VI reports the time and space required for the checks  outlined above (all tests have been done using the Common  Lisp compiler SBCL 1.1.2 on a 2.13GHz Core2 Duo MacBook  Air with MacOS X 10.7 and 4GB of RAM; the solver was z3  4.0). All bounded satisﬁability checks have been performed  using a bound k  20. The ﬁrst line of each row shows  providing a direct deﬁnition of MITL operators, assuming l.c.r.o. intervals;  105  93  limited to logics, but in principle also Timed Automata or  Timed Petri Nets).  TABLE III.  E XPERIMENTAL RESULTS WITH THE TIMED LAMP,  REPORTING T IME ( SEC ) AND HEAP SIZE (MB).  Problem  Satisﬁable?  CLTL-o-c  MITL (l.c.r.o)  QTL (unrest.)  sat  Yes  0.48/0.33  5.63  15.5/13.84  66.45  4.24/3.04  27.12  p1  Yes  0.52/0.35  6.22  36.74/33.16  102.47  17.2/14.86  63.5  p2  No  0.67/0.49  6.55  6.61/5.09  110.27  257.1/240.88  58.66  To the best of our knowledge, our approach is the ﬁrst  allowing an effective implementation of a fully automated  veriﬁcation tool for continuous-time metric temporal logics  such as MITL and QTL. The tool is still a non-optimized  prototype, whose performance might also be substantially  improved in future versions. Still, veriﬁcation of formulae  requiring many clocks may always be infeasible, since satisﬁability of MITL is EXPSPACE-complete (but we also support  veriﬁcation also of an interesting, PSPACE-complete fragment  of MITL). However, in practice a large number of clocks is not  very frequent, and the examples of MITL (and QTL) formulae  that we studied were veriﬁed in a fairly short time.  the total processing time (i.e., parsing and solving) and the  time taken by the SMT-solver (both times in seconds). The  second line reports the heap size (in Mbytes) required by Z3.  In every case the speciﬁcation is satisﬁable, property p1 does  not hold (the tool returns a counterexample), while property  p2 holds (“unsat” is returned). In addition to the results shown  in the table, a variant of Formula (14) where test0 c Δ is used  instead of test0 c¤Δ (i.e., ¤ is replaced by ) is shown to not  hold, and a counterexample is obtained in less than 1 second.  R EFERENCES  [1]  [2]  Finally, we present an interesting behavior over unrestricted  signals. The behavior is captured by the following formulae,  which state that p and q only occur in isolated instants, with p  occurring exactly every 80 time units, and q occurring within  80 time units in the past from each p (origin excluded).  [3]  [4]    Gp0,80q p pq ñ Gp80,160q p pq ^  G  pp ñ Fp0,160q pq ^ pq ñ p qq U Jq ^  p ^ Gp0,80q p pq ^ Gp0,8q pp ñ Pp0,80q q q  [5]  [6]  (21)  [7]  In this case, the bound k  10 is enough to prove that the  formula is satisﬁable and a model is produced in about 40  secs. In around the same time the solver shows that property  Gpp ñ Fp0,80q pq qq holds for model (21) (up to the considered  bound), whereas property Gpq ñ Fp0,80q pq qq does not. Note  that, in Formula (21), the constants involved in the temporal  modalities are signiﬁcantly greater than the bound k required  to obtain a model. In fact, any value is possible in principle for  the clock increments between two consecutive discrete instants,  controlled by the (nondeterministic) variable δ. This highlights  that the length of the intervals described by a CLTL-oc model  is independent of the bound k, as long as this is big enough to  capture all changepoints that are necessary to build a periodic  sequence of regions.  VII.  [8]  [9]  [10]  [11]  [12]  [13]  C ONCLUSIONS  This paper investigates a bounded approach to satisﬁability  checking of an extension of CLTL where variables behave like  clocks (CLTL-oc). The decidability of the logic (by means  of an automata-based technique) is shown ﬁrst, followed by  an encoding into a decidable SMT problem. This encoding,  implemented in our ae2 zot tool, allows, both in principle and  in practice, the use of SMT solvers to check the satisﬁability  of CLTL-oc. We provide a short but non-trivial example of  a CLTL-oc speciﬁcation describing a timed behavior over  continuous time, which should demonstrate the effectiveness of  this approach, as we are able to (dis)prove various properties of  the speciﬁcation. The paper also outlines the encoding of two  continuous time, metric temporal logics, namely MITL and  QTL, that are implemented in our qtlsolver tool. This shows  that CLTL-oc can be considered as a target language to reduce  decision problems of various continuous-time formalisms (not  [14]  [15]  [16]  [17]  [18]  [19]  [20]  [21]  106  94  S. Demri and D. D’Souza, “An automata-theoretic approach to constraint LTL,” Inf. Comput., vol. 205, no. 3, pp. 380–415, 2007.  R. Alur, T. Feder, and T. A. Henzinger, “The beneﬁts of relaxing  punctuality,” Journal of the ACM, vol. 43, no. 1, pp. 116–146, 1996.  Y. Hirshfeld and A. Rabinovich, “Timer formulas and decidable metric  temporal logic,” Inf. and Comp., vol. 198, no. 2, pp. 148 – 178, 2005.  O. Maler, D. Nickovic, and A. Pnueli, “From MITL to timed automata,”  in Proc. of FORMATS, ser. LNCS, 2006, vol. 4202, pp. 274–289.  P.-Y. Schobbens, J.-F. Raskin, and T. A. Henzinger, “Axioms for realtime logics,” Theor. Comput. Sci., vol. 274, no. 1-2, pp. 151–182, 2002.  R. Alur and D. L. Dill, “A theory of timed automata,” Theoretical  Computer Science, vol. 126, no. 2, pp. 183–235, 1994.  J. Bengtsson and W. Yi, “Timed automata: Semantics, algorithms and  tools,” in Lect. on Concurrency and Petri Nets, ser. LNCS. Springer,  2004, vol. 3098, pp. 87–124.  P. Niebert, M. Mahfoudh, E. Asarin, M. Bozga, O. Maler, and N. Jain,  “Veriﬁcation of timed automata via satisﬁability checking,” in FTRTFT,  ser. LNCS, 2002, vol. 2469, pp. 225–243.  B. Badban and M. Lange, “Exact incremental analysis of timed automata with an SMT-solver,” in FORMATS, ser. LNCS, 2011, vol. 6919,  pp. 177–192.  G. Audemard, A. Cimatti, A. Kornilowicz, and R. Sebastiani, “Bounded  model checking for timed systems,” in Proc. of FORTE, 2002, pp. 243–  259.  E. M. Clarke, D. Kroening, J. Ouaknine, and O. Strichman, “Completeness and complexity of bounded model checking,” in VMCAI, ser.  LNCS, vol. 2937. Springer, 2004, pp. 85–96.  A. Rabinovich, “Complexity of metric temporal logics with counting  and the Pnueli modalities,” Th. Comp. Sci., vol. 411, pp. 2331–2342,  2010.  M. M. Bersani, A. Frigeri, M. Rossi, and P. San Pietro, “Completeness  of the bounded satisﬁability problem for constraint LTL,” in Reachability Problems, ser. LNCS, 2011, vol. 6945, pp. 58–71.  M. Pradella, A. Morzenti, and P. San Pietro, “Bounded satisﬁability  checking of metric temporal logic speciﬁcations,” ACM Transactions  on Software Engineering and Methodology (TOSEM), 2013, to appear.  M. M. Bersani, A. Frigeri, A. Morzenti, M. Pradella, M. Rossi,  and P. San Pietro, “CLTL Satisﬁability Checking without Automata,”  arXiv:1205.0946v1, 2012.  ——, “Bounded reachability for temporal logic over constraint systems,” in TIME. IEEE Computer Society, 2010, pp. 43–50.  “Zot: a bounded satisﬁability checker,” available from  zot.googlecode.com.  Y. Hirshfeld and A. Rabinovich, “Quantitative temporal logic,” in  Computer Science Logic, ser. LNCS, 1999, vol. 1683, pp. 172–187.  Y. Hirshfeld and A. M. Rabinovich, “Logics for real time: Decidability  and complexity,” Fund. Inf., vol. 62, no. 1, pp. 1–28, 2004.  C. A. Furia, D. Mandrioli, A. Morzenti, and M. Rossi, Modeling Time  in Computing, ser. EATCS Monographs in Th. C. Sci. Springer, 2012.  “qtlsolver,” available from qtlsolver.googlecode.com. 