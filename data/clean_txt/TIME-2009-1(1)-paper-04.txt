On the Expressivity of RoCTL*  John Mc Cabe-DanstedÃ¢ÂˆÂ—, Tim French, Mark Reynolds  The University of Western Australia  Computer Science and Software Engineering  {john,tim,mark}@csse.uwa.edu.au  Abstract  Sophie Pinchinat  Campus Universitaire de Beaulieu  IRISA  Sophie.Pinchinat@irisa.fr  such as "even with n additional failures" to be built up by  chaining n simple unary Robustly operators together.  RoCTL* was proposed to model robustness in concur-  The RoCTL* Obligatory operator is similar to the Oblig-  rent systems. RoCTL* extended CTL* with the addition  atory operator in Standard Deontic Logic (SDL), although  of Obligatory and Robustly operators, which quantify over  in RoCTL* the operator quantifies over paths rather than  failure-free paths and paths with one more failure respec-  worlds. SDL has many paradoxes. Some of these, such  tively. Whether RoCTL* is more expressive than CTL* has  as the Ã¢Â€ÂœGentle MurdererÃ¢Â€Â paradox spring from the inade-  remained an open problem since the RoCTL* logic was  quacy of SDL for dealing with obligations caused by acting  proposed. We use the equivalence of LTL to counter-free  contrary to duty such as Ã¢Â€ÂœIf you murder, you must murder  automata to show that RoCTL* is expressively equivalent  gentlyÃ¢Â€Â. Contrary-to-Duty (CtD) obligations are important  to CTL*; the translation to CTL* provides the first model  for modeling a robust system, as it is often important to  checking procedure for RoCTL*. However, we show that  state that the system should achieve some goal and also that  RoCTL* is relatively succinct as all satisfaction preserving  if it fails it should in some way recover from the failure.  translations into CTL* are non-elementary in length. Draft:  RoCTL* can represent CtD obligations by specifying that  May 19, 2009  the agent must ensure that the CtD obligation is met even if  a failure occurs. For further discussion of CtD obligations  and motivations for RoCTL*, see [11]. The obligatory op-  1. Introduction  erator, as well as some uses of the robustly operator, are  easy to translate into CTL* [17].  Logic  When RoCTL* was originally proposed [11], it had  (RoCTL*) [11] is an extension of CTL* introduced to  The  Robust  Full  Computation  Tree  represent issues relating to robustness and reliability in  two accessibility relations, a success and failure transition.  However we may equivalently define RoCTL* with a single  systems. It does this by adding an Obligatory operator and  accessibility relation if we add a violation atom v to indi-  a Robustly operator. The Obligatory operator specifies how  cate that the previous transition was a failure transition (this  the systems should behave by quantifying over paths in  new definition was first used in [17]). Under this definition,  which no failures occur. The Robustly operator specifies  the RoCTL* models are CTL models, albeit with a special  that something must be true on the current path and similar  paths that "deviate" from the current path, having at most  violation atom not used in RoCTL* formulas. In this pa-  one more failure occurring. This notation allows phrases  in CTL* formulas, then we can express every RoCTL* for-  per we show that if we allow the violation atom to occur  mula into an equivalent CTL* formula. Although we will  Ã¢ÂˆÂ— This Project is supported by the Australian GovernmentÃ¢Â€Â™s International Science Linkages program  expose the violation atom, we do not extend the model, in  1  reliability. However their logic reasons about reliability us-  particular we do not add atoms to the model.  The addition of the Robustly operator and temporal  ing probabilities rather than numbers of failures, and their  operators to Deontic logic allows RoCTL* to deal with  paper does not contain any discussion of the relationship  Contrary-to-Duty obligations. SDL is able to distinguish  of their logic to Deontic logics. Like our embedding into  what ought to be true from what is true, but is unable to  QCTL*, Aldewereld et al [1] uses a Viol atom to represent  specify obligations that come into force only when we be-  failure. However, their logic also uses probability instead of  have incorrectly. For example, SDL is inadequate to represent the obligation Ã¢Â€Âœif you murder, you must murder gen-  failure counts and is thus suited to a different class of problems than RoCTL*. None of these logics appear to have an  tlyÃ¢Â€Â [10]. Addition of temporal operators to Deontic logic  operator that is substantially similar to the Robustly opera-  allows us to specify correct responses to failures that have  tor of RoCTL*.  occurred in the past [23]. However, this approach alone  Diagnosis problems in control theory [14, 2] also deals  is not sufficient [23] to represent obligations such as Ã¢Â€ÂœYou  with failures of systems. Diagnosis is in some sense the  must assist your neighbour, and you must warn them iff you  dual of the purpose of the RoCTL* logic, as diagnosis re-  will not assist themÃ¢Â€Â. In RoCTL* these obligations can be  quires that failure cause something (detection of the failure)  represented if the obligation to warn your neighbour is ro-  whereas robustness involves showing that failure will not  bust but the obligation to assist them is not.  cause something.  Other approaches to dealing with Contrary-to-Duty obli-  The translation we will present in this paper results in a  gations exist. Defeasible logic is often used [18], and logics  of agency, such as STIT [3], can be useful as they can allow  formula that is satisfied on a model iff the original formula  obligations to be conditional on the agentÃ¢Â€Â™s ability to carry  all the CTL* model checkers, decision procedures and so  out the obligation.  forth for RoCTL*.  is satisfied on the same model. This means that we can use  This paper provides some examples of robust systems  We will then show that although all RoCTL* formulas  that can be effectively represented in RoCTL*. It is easy  can be translated into CTL*, the length of the CTL* formula  to solve the coordinated attack problem if our protocol is  is not elementary in the length of the RoCTL* formula.  allowed to assume that only n messages will be lost. The  Hence some properties can be represented much more succinctly in RoCTL* than CTL*.  logic may also be useful to represent the resilience of some  economy to temporary failures to acquire or send some resource. For example, a remote mining colony may have in-  2. Definitions  teracting requirements for communications, food, electricity and fuel. RoCTL* may be more suitable than Resource  2.1. RoCTL-Structures and Trees  Logics (see e.g. [6]) for representing systems where a failure may cause a resource to become temporarily unavail-  Definition 1. We let V be our set of variables. The set V  able. This paper presents a simple example where the only  contains a special variable v. A valuation g is a map from  requirement is to provide a cat with food when it is hungry.  a set of worlds A to the power set of the variables. The  A number of other extensions of temporal logics have  statement p Ã¢ÂˆÂˆ g(w) means roughly Ã¢Â€Âœthe variable p is true at  been proposed to deal with Deontic or Robustness is-  world wÃ¢Â€Â.  sues [4, 16, 13, 1, 21]. Each of these logics are substantially different from RoCTL*. Some of these logics are de-  Definition 2. We say that a binary relation R on S is serial  signed specifically to deal with deadlines [4, 13]. An Agent  (total) if for every a in S there exists b in S such that aRb.  Communication Language was formed by adding Deontic  and other modal operators to CTL [21]; this language does  Definition 3. A structure M = (A, R, g) is a 3-tuple con-  not explicitly deal with robustness or failures. Hansson and  taining a set of worlds A, a serial binary relation R on A, a  Johnsson [13] proposed an extension of CTL to deal with  valuation g on the set of worlds A.  2  Definition 4. We call an ÄÂ‰-sequence ÄÂƒ = hw0 , w1 , . . .i of  follows:  worlds a fullpath iff for all non-negative integers i we have  M, ÄÂƒ  N ÄÂ† iff M, ÄÂƒÃ¢Â‰Ä½1  ÄÂ†  wi Rwi+1 . For all i in N we define ÄÂƒÃ¢Â‰Ä½i to be the fullpath  hwi , wi+1 , . . .i, we define ÄÂƒi to be wi and we define ÄÂƒÃ¢Â‰Â¤i to  M, ÄÂƒ  ÄÂ†U ÄÂˆ iff Ã¢ÂˆÂƒiÃ¢ÂˆÂˆN s.t. M, ÄÂƒÃ¢Â‰Ä½i  ÄÂˆ and  be the sequence hw0 , w1 , . . . , wi i.  Ã¢ÂˆÂ€jÃ¢ÂˆÂˆN j < i =Ã¢Â‡Â’ M, ÄÂƒÃ¢Â‰Ä½j  ÄÂ†  M, ÄÂƒ  AÄÂ† iff Ã¢ÂˆÂ€ÄÂ€Ã¢ÂˆÂˆSF (ÄÂƒ0 ) M, ÄÂ€  ÄÂ†  Definition 5. We say that a fullpath ÄÂƒ is failure-free iff for  M, ÄÂƒ  OÄÂ† iff Ã¢ÂˆÂ€ÄÂ€Ã¢ÂˆÂˆS(ÄÂƒ0 ) M, ÄÂ€  ÄÂ†  all i > 0 we have v Ã¢ÂˆÂˆ  / g (ÄÂƒi ). We define SF (w) to be the  M, ÄÂƒ  NÄÂ† iff Ã¢ÂˆÂ€ÄÂ€Ã¢ÂˆÂˆÃÂ´(ÄÂƒ) M, ÄÂ€  ÄÂ† and M, ÄÂƒ  ÄÂ†  set of all fullpaths starting with world w and S(w) to be the  set of all failure-free fullpaths starting with w. We call a  The definition for >, p, Ã‚Å¹ and Ã¢ÂˆÂ§ is as we would expect from  CTL structure a RoCTL structure iff S(w) is non-empty for  classical logic. The intuition behind the N operator is that it  every w Ã¢ÂˆÂˆ A.  quantifies over paths that could result if a single error was  introduced; the deviations only have at most one failure not  on the original path, and they are identical to the original  Definition 6. For two fullpaths ÄÂƒ and ÄÂ€ we say that ÄÂ€ is an  path until this failure occurs.  i-deviation from ÄÂƒ iff ÄÂƒÃ¢Â‰Â¤i = ÄÂ€Ã¢Â‰Â¤i and ÄÂ€Ã¢Â‰Ä½i+1 Ã¢ÂˆÂˆ S(ÄÂ€i+1 ).  We say that ÄÂ€ is a deviation from ÄÂƒ if there exists a non-  Definition 7. We say that a function ÄÂ„ from formulas to  negative integer i such that ÄÂ€ is an i-deviation from ÄÂƒ. We  formulas is satisfaction preserving iff for all M, ÄÂƒ and ÄÂ† it  define a function ÃÂ´ from fullpaths to sets of fullpaths such  is the case that M, ÄÂƒ  ÄÂ† Ã¢Â‡ÂÃ¢Â‡Â’ M, ÄÂƒ  ÄÂ„ (ÄÂ†).  that where ÄÂƒ and ÄÂ€ are fullpaths, ÄÂ€ is a member of ÃÂ´(ÄÂƒ) iff  We will now define a tree. A tree is similar to a structure,  ÄÂ€ is a deviation from ÄÂƒ.  but a tree need not be serial, and each node only has one  parent.  We see that S (ÄÂƒ0 ) Ã¢ÂŠÂ† ÃÂ´(ÄÂƒ) Ã¢ÂŠÂ† SF (ÄÂƒ0 ). Where p varies  Definition 8. We say T = (A, R, g) is a V-labelled tree,  over V, we define RoCTL* formulas according to the fol-  for some set V, iff  lowing abstract syntax  1. A is a non-empty set of nodes  ÄÂ† := > | p | Ã‚Å¹ÄÂ† | (ÄÂ† Ã¢ÂˆÂ§ ÄÂ†) | (ÄÂ†U ÄÂ†) | N ÄÂ† | AÄÂ† | OÄÂ† | NÄÂ† .  2. for all x, y, z Ã¢ÂˆÂˆ A if (x, z) Ã¢ÂˆÂˆ R and (y, z) Ã¢ÂˆÂˆ R then  x = y.  A formula that begins with A, Ã‚Å¹A, O, Ã‚Å¹O, p or Ã‚Å¹p  is called a state formula. For consistency with [11], we  3. there does not exist any cycle x0 R Ã‚Ë‡ Ã‚Ë‡ Ã‚Ë‡ Rx0 through R.  do not consider a formula that explicitly contains v to be  4. there exists a node x such that for all y Ã¢ÂˆÂˆ A, if y 6= x  a RoCTL* formula, although our translation into CTL*  there exists a sequence xRx1 R Ã‚Ë‡ Ã‚Ë‡ Ã‚Ë‡ Ry through R.  works equally well for such formulas. The >, Ã‚Å¹, Ã¢ÂˆÂ§, N, U  5. the valuation g (or labeling) is a function from A to 2V ,  and A are the familiar Ã¢Â€ÂœtrueÃ¢Â€Â, Ã¢Â€ÂœnotÃ¢Â€Â, Ã¢Â€ÂœandÃ¢Â€Â, Ã¢Â€ÂœnextÃ¢Â€Â, Ã¢Â€ÂœuntilÃ¢Â€Â  that is for each w Ã¢ÂˆÂˆ A, g (w) Ã¢ÂŠÂ† V.  and Ã¢Â€Âœall pathsÃ¢Â€Â operators from CTL. The abbreviations Ã¢ÂŠÄ½,  Ã¢ÂˆÂ¨, F , G, W , E Ã¢Â†Â’ and Ã¢Â†Â” are defined as in CTL* logic.  Definition 9. We define the height of a finite tree T =  As with Standard Deontic Logic (SDL) logic, we define  (A, R, g) as follows: root is a function from trees to nodes  P Ã¢Â‰Ä„ Ã‚Å¹OÃ‚Å¹. Finally, we define the dual 4 of N as the ab-  such that root (T ) is the root of the tree T . height (T ) =  breviation Ã¢ÂˆÂ† Ã¢Â‰Ä„ Ã‚Å¹NÃ‚Å¹. We call the O, P , N, Ã¢ÂˆÂ† operators  heightR (root (T )) where heightR is a function from A to  Obligatory, Permissible, Robustly and Prone respectively.  N such that for all x Ã¢ÂˆÂˆ A, we let heightR (x) be the smallest  We define truth of a RoCTL* formula ÄÂ† on a fullpath  non-negative integer such that heightR (x) > heightR (y)  ÄÂƒ = hw0 , w1 , . . .i in a RoCTL-structure M recursively as  for all y such that (x, y) Ã¢ÂˆÂˆ R.  3  Definition 10. We say C = hAC , RC , gC i is a subtree of  Every node, in the run of an SAA on an input structure  T = (A, R, g) iff there exists w Ã¢ÂˆÂˆ A such that AC is the  M , represents a world of M . However, a world w in the  subset of A reachable from w and RC and gC are the frag-  input structure M may occur many times in a run. Where  ments of R and g on AC respectively. We say C is a di-  a non-deterministic automata would non-deterministically  rect subtree of T = (A, R, g) if C is a subtree of T and  pick a next state, a SAA non-deterministically picks a con-  (root (T ) , root (C)) Ã¢ÂˆÂˆ R.  junction of elements of the form (, q) and (Ã¢Â™Åš, q); alternatively we may define SAA as deterministically picking a  2.2. Automata  Boolean combination of requirements of this form, see for  example [15]. Alternating automata can also be thought of  Definition 11. A BÄ‚Åºchi automaton A = (ÃÅ, S, S0 , ÃÂ´, F )  as a type of parity game, see for example [12]. An element  contains  of the form (, q)/(Ã¢Â™Åš, q) indicates for every/some child u  of the current world w of the input structure M , a run on M  ÃÅ: set of symbols (alphabet)  must have a branch which follows u and where q is the next  S: finite set of automaton states  state.  S0 : set of initial states Ã¢ÂŠÂ† S  ÃÂ´ : a transition function Ã¢ÂŠÂ† (S Ä‚Â— ÃÅ Ä‚Â— S)  Definition 13. A parity acceptance condition F of an au-  S  F : A set of accepting states Ã¢ÂŠÂ† 2  tomata (ÃÅ, S, S0 , ÃÂ´, F ) is a map from S to N. We say that  Ã¢ÂˆÂ—  We call the members of ÃÅ words. Unlike a path through  parity condition accepts an infinite path if the largest inte-  a structure, each transition of a path through an automa-  ger n, such that F (q) = n for some q that occurs infinitely  e  0  ton is labelled with an element e of ÃÅ. We say s0 Ã¢Â†Â’  e1  often on the path, is even.  enÃ¢ÂˆÂ’1  s1 Ã¢Â†Â’ Ã‚Ë‡ Ã‚Ë‡ Ã‚Ë‡ Ã¢Â†Â’ sn is a path of A if for all 0 Ã¢Â‰Â¤ i < n  the tuple hsi , ei , si+1 i is in ÃÂ´. The label of the path is  Definition 14. A symmetric alternating automata (SAA) is  he0 , e1 , . . . , en i. Let Lp,q (A) be the set of all labels of  a tuple (ÃÅ, S, S0 , ÃÂ´, F ) where ÃÅ, S and S0 are defined as in  paths through A from p to q.  BÄ‚Åºchi automata, and  ÃÂ´ : a transition function Ã¢ÂŠÂ† (S Ä‚Â— ÃÅ Ä‚Â— 2{,Ã¢Â™Åš}Ä‚Â—S )  A run ÄÂ of A is a path starting at a state in S0 . We say  an infinite run is accepting if a state in F occurs infinitely  We define the the acceptance condition F of an SAA  often in the run.  to be a parity acceptance condition, but note that we can  In this paper, ÃÅ = 2ÃÅš , for some set of state formulas  express BÄ‚Åºchi parity conditions as parity acceptance condi-  ÃÅš. Given a fixed structure M = (A, Ã¢Â†Â’, g) and path ÄÂƒ, we  tions. The SAA accepts a run iff every infinite path through  let gÃÅš (ÄÂƒi ) = {ÄÂ† : ÄÂ† Ã¢ÂˆÂˆ ÃÅš Ã¢ÂˆÂ§ M, ÄÂƒÃ¢Â‰Ä½i  ÄÂ†} and gÃÅš (ÄÂƒ) =  the run satisfies F .  hgÃÅš (ÄÂƒ0 ), gÃÅš (ÄÂƒ1 ), . . .i. Note that ÃÅš consists solely of state  A run R = hAR , RR , gR i of the SAA on a V-labelled  formulas so gÃÅš (ÄÂƒ0 ) = gÃÅš (ÄÂ€0 ) if ÄÂƒ0 = ÄÂ€0 .  input structure M is an AÄ‚Â—S-labelled tree structure. Where  Definition 12. A counter-free automaton is an automaton  gR (root (R)) = (w, q), it is the case that q Ã¢ÂˆÂˆ S and w =  such that for all positive integers m, states s Ã¢ÂˆÂˆ S and words  root (M ). For every wR in Ar , where (w, q) = gR (wR )  and e = g (w), there exists some set X Ã¢ÂˆÂˆ 2{,Ã¢Â™Åš}Ä‚Â—S such  u in ÃÅÃ¢ÂˆÂ— , if um Ã¢ÂˆÂˆ Ls,s then u Ã¢ÂˆÂˆ Ls,s [7].  that (wR , e, X) Ã¢ÂˆÂˆ ÃÂ´ and  Above we have defined linear automata. These are sufficient for the proof of expressive equivalence of RoCTL*  1. For each r Ã¢ÂˆÂˆ S such that (, r) Ã¢ÂˆÂˆ X, for each u such  and CTL*. However, in the proof that RoCTL* is relatively  that wRu there must exist uR such that wR RuR and  succinct, we will use tree automata. We will define a type  of tree automata called a symmetric alternating automata  (u, r) Ã¢ÂˆÂˆ gR (uR ).  (SAA) (see e.g. [15]), these are a subclass of alternating  2. For each r Ã¢ÂˆÂˆ S such that (Ã¢Â™Åš, r) Ã¢ÂˆÂˆ X, for some u such  automata, and can also be referred to as just alternating au-  that wRu there must exist uR such that wR RuR and  tomata (see e.g. [24]).  (u, r) Ã¢ÂˆÂˆ gR (uR ).  4  3. Examples  Let ÄÂ€ = hv, v, . . .i. We see that M, ÄÂ€  p. We see that  S(u) = {hu, v, v, . . .i}. Hence M, ÄÂƒ  ON p and it follows  In this section a number of examples are presented. The  that M, ÄÂƒ  Ã‚Å¹OÃ‚Å¹N p and so M, ÄÂƒ  Ã‚Å¹ON Ã‚Å¹p.  first example examines the difference between the formula  N OÄÂ† and the formula ON ÄÂ†. The second example shows  Hence M, ÄÂƒ  (ON p Ã¢ÂˆÂ§ Ã‚Å¹N Op) and so M, ÄÂƒ 2  (ON ÄÂ† Ã¢Â†Â’ N OÄÂ†) where ÄÂ† = p. Likewise M, ÄÂƒ   how RoCTL* may be used to specify a robust network pro-  (N OÃ‚Å¹p Ã¢ÂˆÂ§ Ã‚Å¹ON Ã‚Å¹p), so M, ÄÂƒ 2 (N OÄÂ† Ã¢Â†Â’ ON ÄÂ†) where  tocol. Then an example of feeding a cat will be introduced  ÄÂ† = Ã‚Å¹p.  to explain how we may reason about consequences of po-  Example 16. In the coordinated attack problem we have  lices. These examples will frequently use the N/Ã¢ÂˆÂ† operator  two generals X and Y . General X wants to organise an  to form the pair ON. In the final example we use the simple  attack with Y . A communication protocol will be presented  formula O(4F e Ã¢Â†Â’ F w) which nests N/Ã¢ÂˆÂ† in a less trivial  such that a coordinated attack will occur if no more than  way.  one message is lost.  Example 15. Here is an example of a simple Contrary-to-  AG (sX Ã¢Â†Â’ ON rY ): If X sends a message, Y should re-  Duty obligation. This provides a counter example to both  ceive it at the next step.  ON ÄÂ† Ã¢Â†Â’ N OÄÂ† and N OÄÂ† Ã¢Â†Â’ ON ÄÂ†.  AG (Ã‚Å¹sX Ã¢Â†Â’ Ã‚Å¹N rY ): If X does not send a message now,  ON (Gp): You should commit to the proper decision.  Y will not receive a message at the next step.  N O (GÃ‚Å¹p Ã¢ÂˆÂ¨ Gp): Once you have made your decision, you  AG(fX Ã¢Â†Â’ AGfX ): If X commits to an attack, X cannot  must stick with it.  withdraw.  It is consistent with the above that we do not make the  AG(fX Ã¢Â†Â’ Ã‚Å¹sX ): If X has committed to an attack, it is too  proper decision (N Ã‚Å¹p). Once we have made the wrong  late to send messages.  decision we cannot satisfy Gp, so we must stick with the  A (Ã‚Å¹fX W rX ): X cannot commit to an attack until X has  wrong decision GÃ‚Å¹p. Hence, in this case, both ON (Gp)  received plans from Y  and N O(GÃ‚Å¹p) are true. Likewise ON (GÃ‚Å¹p) and N O(Gp)  are false. This demonstrates how obligations can change  Similar constraints to the above also apply to Y . Below we  with time in RoCTL*. We will now give an example of a  add a constraints requiring X to be the general planning the  structure M = (A, R, g) that satisfies these formulÄ‚Åš:  attack  A (Ã‚Å¹sY W rY ): General Y will not send a message until Y  A = {u, v, w, w0 },  has received a message.  R = {(u, v), (v, v), (u, w0 ) , (w0 , w) (w, w)} ,  g(v) = {p} ,  g(w) = g (u) = Ã¢ÂˆÂ…,  No protocol exists to satisfy the original coordination prob-  g(w0 ) = {v} .  lem, since an unbounded number of messages can be lost.  Here we only attempt to ensure correct behaviour if one or  v{p}  fewer messages are lost.  u  A (sX U rX ): General X will send plans until a response is  w0 {v}  received.  w  AG (rX Ã¢Â†Â’ fX ): Once general X receives a response, X  will commit to an attack.  Let ÄÂƒ be the fullpath hu, w, w, . . . i corresponding to  making the wrong decision. We see that M, ÄÂƒÃ¢Â‰Ä½1  Ã‚Å¹p, so  A (Ã‚Å¹rY W (rY Ã¢ÂˆÂ§ (sY Ã¢ÂˆÂ§ N sY Ã¢ÂˆÂ§ N N fY ))): Once general  M, ÄÂƒÃ¢Â‰Ä½1  OÃ‚Å¹p and M, ÄÂƒÃ¢Â‰Ä½1  Ã‚Å¹Op. Thus M, ÄÂƒ  N OÃ‚Å¹p  Y receives plans, Y will send two messages to X and  and M, ÄÂƒ  N Ã‚Å¹Op. It follows that M, ÄÂƒ  Ã‚Å¹N Op.  then commit to an attack.  5  Having the formal statement of the policy above and the se-  be derived, indicating that following a policy requiring us  mantics of RoCTL* we may prove that the policy ÄÂ†ÄšÂ‚ is con-  to always attempt to fill the cat bowl ensures that we will  sistent and that it implies correct behaviour even if a single  not starve the cat even if we make a single mistake. Thus  failure occurs:  following this simpler policy is sufficient to discharge our  original obligation.  ÄÂ†ÄšÂ‚ Ã¢Â†Â’ ONF (fX Ã¢ÂˆÂ§ fY ) .  Example 18. Say that a bit ought to flip at every step, but  might fail to flip at any particular step. This may be rep-  Indeed, we have shown that such issues can be decided  resented with the RoCTL* statement AGO (b Ã¢Â†Â” Ã‚Å¹N b) Ã¢ÂˆÂ§  in finite time [19] .  AG4 (b Ã¢Â†Â” N b), which is satisfied by the following model:  For a more thorough specification of the Coordinated Attack problem, see for example [20, 22]. .  {}  {b}  Example 17. We have a cat that does not eat the hour after  it has eaten. If the cat bowl is empty we might forget to fill  {v}  it. We must ensure that the cat never goes hungry, even if  {b, v}  we forget to fill the cat bowl one hour. At the beginning of  the first hour, the cat bowl is full. We have the following  variables:  Then we may derive the following statements:  b Ã¢Â€ÂœThe cat bowl is full at the beginning of this hourÃ¢Â€Â  ON((b Ã¢ÂˆÂ§ N b) Ã¢Â†Â’ N G (b Ã¢Â†Â” Ã‚Å¹N b)) If a single failure occurs, and the bit fails to flip at the next step, it will  d Ã¢Â€ÂœThis hour is feeding timeÃ¢Â€Â  flip continuously from then on.  We can translate the statements above into RoCTL* stateONF G (b Ã¢Â†Â” Ã‚Å¹N b) Even if a single failure occurs, there  ments:  will be time at which the bit will flip correctly from  1. AG(d Ã¢Â†Â’ Ã‚Å¹N d): If this hour is feeding time, the next  then on.  is not.  However, we will not be able to derive OF NG (b Ã¢Â†Â” Ã‚Å¹N b),  2. AG((d Ã¢ÂˆÂ¨ Ã‚Å¹b) Ã¢Â†Â’ Ã¢ÂˆÂ†N Ã‚Å¹b): If it is feeding time or the  as this would mean that there was a time at which a failure  cat bowl was empty, a single failure may result in an  could not cause the bit to miss a step.  empty bowl at the next step  Example 19. We define a system that will warn the user if  3. AG((Ã‚Å¹d Ã¢ÂˆÂ§ b) Ã¢Â†Â’ N b): If the bowl is full and it is not  the system enters an unsafe state:  feeding time, the bowl will be full at the beginning of  the next hour.  1. AGON s: The system should always ensure that the  system reaches a safe state by the next step.  4. ONG (d Ã¢Â†Â’ b): It is obligatory that, even if a single  failure occurs, it is always the case that the bowl must  2. AG(s Ã¢Â†Â’ N Ã‚Å¹e): If the system is in a safe state an error  be full at feeding time.  e will not occur at the next step.  5. b: The cat bowl starts full.  3. s Ã¢ÂˆÂ§ Ã‚Å¹e: The system starts in a safe state with no error.  Having the formalised the policy it can be proven that the  4. AG(Ã‚Å¹s Ã¢Â†Â’ N w): If the system is in an unsafe state,  policy is consistent and that the policy implies ONGON b,  the system will warn the user at the next step.  indicating that the bowl must be filled at every step (in case  we forget at the next step), unless we have already failed  We may prove that if an error e almost occurs, the system  twice. The formula AGON b Ã¢Â†Â’ ONG (d Ã¢Â†Â’ b) can also  will finally warn the user, i.e. O(4F e Ã¢Â†Â’ F w).  6  Example 20. Say that we have wireless sensor and a base  ways have power (NGÄÂ†). As with the A operator in CTL*,  station. Upon detecting some event, the wireless sensor will  NGÄÂ† Ã¢Â†Â’ GNÄÂ† is valid in RoCTL* but GNÄÂ† Ã¢Â†Â’ NGÄÂ† is not.  activate and send three packets to the base station. The base  station will not know that the wireless sensor sent data if all  4. Expressivity  three packets were lost. Thus an error will be reported iff  the base station receives either one or two packets. This can  We will define a translation of 4ÄÂ† into CTL*, for any  be formalised as  CTL* formula ÄÂ†. We will first translate ÄÂ† into counter-free  s Ã¢ÂˆÂ§ N s Ã¢ÂˆÂ§ N N s Ã¢ÂˆÂ§ N N N GÃ‚Å¹s: The sensor will send three  BÄ‚Åºchi automata A, we will then define a function ÄÂ„4 from  packets.  automata to automata such ÄÂ„4 (A) is equivalent to 4ÄÂ†, and  AG (s Ã¢Â†Â’ ON r Ã¢ÂˆÂ§ Ã‚Å¹s Ã¢Â†Â’ N Ã‚Å¹s): If a packet is sent, it  translate ÄÂ„4 (A) into CTL*. This allows us to recursively  should be received at the next step. If it is not sent it will  translate any RoCTL* formula into an equivalent CTL* for-  not be received.  mula.  Ã‚Å¹N ((r Ã¢ÂˆÂ§ N r Ã¢ÂˆÂ§ N N r) Ã¢ÂˆÂ¨ GÃ‚Å¹r) Ã¢Â†Â’ N N N e: An error  4.1  will be detected if some packets, but not all three, are re-  CTL* and LTL  ceived.  Theorem 22. A language L is definable in LTL iff L is ac-  It follows that ON (4F eU Ã‚Å¹s), indicating that it is ro-  cepted by some counter-free BÄ‚Åºchi automaton [7].  bustly true that if an additional failure occurs, an error could  be detected. In this example a failure may not indicate a  It is well known that we can express a CTL* formula as  packet being dropped, e.g. it has not been specified whether  an LTL formula over a path, where that path includes state  the packet arrives corrupted. Thus the system cannot de-  formula as atoms; this is commonly used in model checking  tect all failures. In RoCTL* it is impossible to specify that  [8, 9, 5]. From the above theorem we can also express this  a failure will have an effect. At best we can specify that  LTL formula as a BÄ‚Åºchi automaton.  it is always possible for a failure to be detected. However,  Formally, for any CTL* formula ÄÂ† there exists a set  we can specify that some particular effect will be detected.  of state formulas ÃÅš and a counter-free automaton A =  For example, we can express the statement Ã¢Â€ÂœEven if two or  (2ÃÅš , S, S0 , ÃÂ´, F ) such that A accepts gÃÅš (ÄÂƒ) iff M, ÄÂƒ  ÄÂ†.  fewer packets are lost, either all packets arrive or an error is  We say an automaton A = (2ÃÅš , S, S0 , ÃÂ´, F ) is equivalent to  detectedÃ¢Â€Â as  a formula ÄÂ† iff  ONNN ((r Ã¢ÂˆÂ§ N r Ã¢ÂˆÂ§ N N r) Ã¢ÂˆÂ¨ F e) .  (Ã¢ÂˆÂ€M,ÄÂƒ M, ÄÂƒ  ÄÂ†) Ã¢Â‡ÂÃ¢Â‡Â’ (A accepts gÃÅš (ÄÂƒ)) .  Example 21. Say a system has a battery that can sustain  Definition 23. Let A be a function from CTL* formulas to  the system for a single step, even if a failure occurs (the  counter-free BÄ‚Åºchi automata such that A (ÄÂ†) is equivalent to  fuse blows). Let ÄÂ† represent Ã¢Â€Âœthe system has power now  ÄÂ†. Likewise let AÃ¢ÂˆÂ’1 be a function from counter-free BÄ‚Åºchi  and at the next stepÃ¢Â€Â. Then, even if a single failure occurs,  automata of the form A = (2ÃÅš , S, S0 , ÃÂ´, F ) to CTL* formu-  it will always be the case that even if a deviating event oc-  las, such that we have ÄÂƒ  AÃ¢ÂˆÂ’1 (A) iff A accepts gÃÅš (ÄÂƒ).  curs the system will have power now and at the next step  (OGNÄÂ†). It would not follow that even if a single failure  4.2  Construction of ÄÂ„4 (A) from A.  occurred the system would always have power (ONGÄÂ†);  the battery power would only last one step after the fuse  In this section we define the function ÄÂ„4 from counter-  blew. If we also specified that the fuse was an electronic  free BÄ‚Åºchi automata to automata as follows. The intention is  fuse that automatically reset, then if a single failure occurs,  that if A is equivalent to ÄÂ†, then ÄÂ„4 (A) will be equivalent to  the system would only have to rely on battery power for one  4ÄÂ†. For any counter-free automata A = 2ÃÅš , S, S0 , ÃÂ´, F ,  step. Then, if the fuse only blows once then system will al-  it is the case that ÄÂ„4 (A) = 2ÃÅš4 , S4 , S0 , ÃÂ´4 , F4 where  7  1. ÃÅš4 = ÃÅš Ã¢ÂˆÅ ÃÂ¨ where ÃÂ¨ = {ÄÂˆs : s Ã¢ÂˆÂˆ S} and ÄÂˆs is the  If s = sF then every word u is in Ls,s . If s 6= sF then  following state formula for each s in S:  every path from s to s in ÄÂ„4 (A) is also a path from s to s  in A, and A is counter-free.      E AÃ¢ÂˆÂ’1 2ÃÅš , S, {s} , ÃÂ´, F Ã¢ÂˆÂ§ N N GÃ‚Å¹v  4.3  Recursive Translation Function  ÄÂˆs is roughly equivalent to saying Ã¢Â€Âœif we are in state s,  We can now translate a RoCTL* formula ÄÂ† into a CTL*  we can deviate hereÃ¢Â€Â.  formula c (ÄÂ†) using the recursively defined function c:  2. We add a state sF indicating that there existed an accepting deviation from this path and so we shall accept  c(ÄÂ† Ã¢ÂˆÂ§ ÄÂˆ)  =  c (ÄÂ†) Ã¢ÂˆÂ§ c (ÄÂˆ)  c(Ã‚Å¹ÄÂ†)  =  Ã‚Å¹c(ÄÂ†)  c(AÄÂ†)  =  Ac (ÄÂ†)  c(OÄÂ†)  =  A (N GÃ‚Å¹v Ã¢Â†Â’ c (ÄÂ†))  c(N ÄÂ†)  =  N c(ÄÂ†)  is possible and remain in that state regardless of the  c(ÄÂ†U ÄÂˆ)  =  c(ÄÂ†)U c(ÄÂˆ)  input along the current path. That is, ÃÂ´4 it the minimal  c(NÄÂ†)  =  Ã‚Å¹f4 (Ã‚Å¹ÄÂ†)  relation satisfying:  f4 (ÄÂ†)  =  AÃ¢ÂˆÂ’1 (ÄÂ„4 (A (ÄÂ†))) .  regardless of further input. This input relates to the  original path rather than the deviation and is thus irrelevant. As such, S4 = S Ã¢ÂˆÅ sF and F4 = F Ã¢ÂˆÅ sF .  3. ÃÂ´4 is the relation that includes ÃÂ´ but at each state also  gives the option to branch into sF when a deviation  (a) For every tuple hs, e, ti in ÃÂ´ and set ÃÂ˜ Ã¢ÂˆÂˆ 2ÃÂ¨ the  4.4  tuple hs, e Ã¢ÂˆÅ ÃÂ˜, ti is in ÃÂ´4 . This is to ensure that  Proof of Correctness  wherever gÃÅš (ÄÂƒ) is a run of A, it is also the case  Lemma 25. For all structures M , fullpaths ÄÂƒ and CTL*  that gÃÅš4 (ÄÂƒ) is a run of ÄÂ„4 (A). The use of ÃÂ˜  formulas ÄÂ†, it is the case that M, ÄÂƒ  AÃ¢ÂˆÂ’1 (ÄÂ„4 (A (ÄÂ†))) iff  is only required because ÃÂ´4 has to deal with the  M, ÄÂƒ  4ÄÂ†.  atoms in ÃÂ¨, which are not in gÃÅš4 (ÄÂƒ) but not in  Proof. As above, let A = 2ÃÅš , S, S0 , ÃÂ´, F be A (ÄÂ†); let  gÃÅš (ÄÂƒ).  ÄÂ„4 (A) = 2ÃÅš4 , S4 , S0 , ÃÂ´4 , F4 be the automaton con-  (b) For each s Ã¢ÂˆÂˆ S and each e4 Ã¢ÂˆÂˆ 2ÃÅš4 such that  structed from A, and let ÄÂ†4 = AÃ¢ÂˆÂ’1 (ÄÂ„4 (A (ÄÂ†))).  ÄÂˆs Ã¢ÂˆÂˆ e4 we have hs, e4 , sF i in ÃÂ´4 .  Fix a structure M . We will write M, ÄÂƒ  ÄÂ† as ÄÂƒ  ÄÂ†.  (c) For each e4 in 2ÃÅš4 we have hsF , e4 , sF i in ÃÂ´4 .  (Ã¢Â‡Â=) Say that ÄÂƒ  4ÄÂ†.  Case 1: ÄÂƒ  ÄÂ†; then A accepts gÃÅš (ÄÂƒ). Thus ÄÂ„4 (A)  To understand (1) above, say we have read i symbols  from the current path ÄÂƒ, and are in state s.  accepts gÃÅš4 (ÄÂƒ) (see 3a above). Thus ÄÂƒ  ÄÂ†4 .  Clearly  accepts ÄÂƒÃ¢Â‰Ä½i then then A accepts  Case 2: ÄÂƒ 2 ÄÂ†; then there exists a path ÄÂ€  ÄÂ† and inte-  ÄÂƒ. As an i-deviation ÄÂ€ would share the prefix ÄÂƒÃ¢Â‰Â¤i , if  ger i such that ÄÂƒÃ¢Â‰Â¤i = ÄÂ€Ã¢Â‰Â¤i and ÄÂ€Ã¢Â‰Ä½i+1 is failure free. Hence  if  2ÃÅš , S, {s} , ÃÂ´, F  2ÃÅš , S, {s} , ÃÂ´, F  accepts ÄÂ€Ã¢Â‰Ä½i then A accepts ÄÂ€.  hgÃÅš (ÄÂ€0 ) , gÃÅš (ÄÂ€1 ) , . . .i Ã¢ÂˆÂˆ L (A). Thus there exists a se-  The  gÃÅš (ÄÂ€0 )  Ã¢Â†Â’ s1  gÃÅš (ÄÂ€1 )  Ã¢Â†Â’ Ã‚Ë‡Ã‚Ë‡Ã‚Ë‡  N N GÃ‚Å¹v ensures that ÄÂˆs is satisfied only on paths that de-  quence of states s0 , s1 , . . . such that s0  viate here, i.e. that are i-deviations.  is an accepting run for A. It is easy to show that si  si+1  The items (b) and (c) above allow us to ignore all further  gÃÅš (ÄÂ€i+1 )  Ã¢Â†Â’  Thus ÄÂ€iÃ¢Â‰Ä½i  input on the current path if we can satisfy ÄÂ† on a deviation.  gÃÅš (ÄÂ€i )  Ã¢Â†Â’  ÃÅš  Ã‚Ë‡ Ã‚Ë‡ Ã‚Ë‡ is an accepting run of 2 , S, {si } , ÃÂ´, F .     AÃ¢ÂˆÂ’1 2ÃÅš , S, {si } , ÃÂ´, F . As ÄÂ€Ã¢Â‰Ä½i+1 is fail-  ure free ÄÂ€Ã¢Â‰Ä½i  N N GÃ‚Å¹v, hence we have  Lemma 24. The automaton ÄÂ„4 (A) is counter-free.      E AÃ¢ÂˆÂ’1 2ÃÅš , S, {si } , ÃÂ´, F Ã¢ÂˆÂ§ N N GÃ‚Å¹v  Proof. Recall that a counter-free automaton is an automaton such that for all states s Ã¢ÂˆÂˆ S and words u in ÃÅÃ¢ÂˆÂ— , if  um Ã¢ÂˆÂˆ Ls,s then u Ã¢ÂˆÂˆ Ls,s .  From 3a above, s0  8  gÃÅš4 (ÄÂ€0 )  Ã¢Â†Â’  s1  gÃÅš4 (ÄÂ€1 )  Ã¢Â†Â’  =  Ã‚Ë‡Ã‚Ë‡Ã‚Ë‡  ÄÂˆsi Ã¢ÂˆÂˆ gÃÅš4 (ÄÂ€i ) .  gÃÅš4 (ÄÂ€iÃ¢ÂˆÂ’1 )  Ã¢Â†Â’  si  As ÄÂˆsi Ã¢ÂˆÂˆ gÃÅš4 (ÄÂ€i ) it fol-  We will do this by taking a class of labeled trees which  Ã¢ÂˆÂˆ ÃÂ´4 . Also  we will call (h, l)-utrees, where h represents the height h  hsF , e4 , sF i Ã¢ÂˆÂˆ ÃÂ´4 for all e4 in 2ÃÅš . As ÄÂƒÃ¢Â‰Â¤i = ÄÂ€Ã¢Â‰Â¤i it fol-  and l is the number of bits per label. We will show that the  is a path through ÄÂ„4 (A).  lows from 3b above that si , gÃÅš4 (si ) , sF  lows that s0  gÃÅš4 (ÄÂƒ0 )  Ã¢Â†Â’  s1  gÃÅš4 (ÄÂƒ1 )  Ã¢Â†Â’  number #(h, l), of pairwise non-isomorphic (h, l)-utrees,  Ã‚Ë‡ Ã‚Ë‡ Ã‚Ë‡ is an accepting run for  is non-elementary in h. We will then present Ã¢Â€ÂœsuffixÃ¢Â€Â and  Ã¢Â€ÂœprefixÃ¢Â€Â encodings of utrees into RoCTL-structures, and  ÄÂ„4 (A). Thus ÄÂƒ  AÃ¢ÂˆÂ’1 (ÄÂ„4 (A)) = ÄÂ†4 .  (=Ã¢Â‡Â’) Say that M, ÄÂƒ  ÄÂ†4 . Thus there is an accepting  run s0  gÃÅš4 (ÄÂƒ0 )  Ã¢Â†Â’  Case 1: s0  s1  gÃÅš4 (ÄÂƒ1 )  Ã¢Â†Â’  gÃÅš (ÄÂƒ0 )  Ã¢Â†Â’  gÃÅš (ÄÂƒ1 )  Ã¢Â†Â’  s1  will define a function u such that u(T, T 0 ) = M where  Ã‚Ë‡ Ã‚Ë‡ Ã‚Ë‡ for ÄÂ„4 (A).  M is the structure that results when the prefix encoding of  Ã‚Ë‡ Ã‚Ë‡ Ã‚Ë‡ is an accepting run for  T is joined/followed by the suffix encoding of T 0 . For each  A. Then ÄÂƒ  ÄÂ† and so ÄÂƒ  4ÄÂ†.  gÃÅš (ÄÂƒ0 )  Ã¢Â†Â’  Case 2: s0  gÃÅš (ÄÂƒ1 )  Ã¢Â†Â’  s1  positive h and l we define a RoCTL* formula f (h, l) such  Ã‚Ë‡ Ã‚Ë‡ Ã‚Ë‡ is not an accept-  that for any pair of utrees T and T 0 of height h it is the case  ing run for A. Thus the automaton must eventually enter  state sF , so the run has a prefix of the form s0  gÃÅš4 (ÄÂƒ1 )  gÃÅš4 (ÄÂƒiÃ¢ÂˆÂ’1 )  gÃÅš4 (ÄÂƒi )  that u(T, T 0 ) satisfies f (h, l) iff T, T 0 are isomorphic. For  gÃÅš4 (ÄÂƒ0 )  Ã¢Â†Â’  an automaton that accepts the tree-unwinding of u(T, T 0 )  We know  iff T and T 0 are isomorphic, once the automaton has read  from the definition of ÄÂ„4 above that ÄÂˆsi Ã¢ÂˆÂˆ gÃÅš4 (ÄÂƒi ).    Thus ÄÂƒiÃ¢Â‰Ä½1  E AÃ¢ÂˆÂ’1 (ÃÅ, S, {si } , ÃÂ´, F ) Ã¢ÂˆÂ§ N N GÃ‚Å¹v and  the prefix encoding, the state of the automaton must give  so there exists a path ÄÂ€ such that ÄÂ€Ã¢Â‰Â¤i = ÄÂƒÃ¢Â‰Â¤i , ÄÂ€Ã¢Â‰Ä½i+1 is  morphic equivalence classes T fell into. As #(h, l) is non-  failure-free and ÄÂ€Ã¢Â‰Ä½i  AÃ¢ÂˆÂ’1 (ÃÅ, S, {si } , ÃÂ´, F ). It follows  elementary in h, the number of states in the automata must  that hÃÅ, S, {si } , ÃÂ´, F i accepts ÄÂ€Ã¢Â‰Ä½i and so there exists an  also be non-elementary in h. Since there are elementary  Ã¢Â†Â’  s1  Ã‚Ë‡Ã‚Ë‡Ã‚Ë‡  Ã¢Â†Â’  g(ÄÂ€i )  accepting run si Ã¢Â†Â’ si+1  g(ÄÂƒ0 )  g(ÄÂƒ1 )  s0 Ã¢Â†Â’ s1 Ã¢Â†Â’ Ã‚Ë‡ Ã‚Ë‡ Ã‚Ë‡  g(ÄÂƒiÃ¢ÂˆÂ’1 )  Ã¢Â†Â’  si  g(ÄÂ€i+1 )  Ã¢Â†Â’  Ã¢Â†Â’  sF .  us enough information to determine which of #(h, l) iso-  translations of CTL* into automata, we will conclude that  Ã‚Ë‡ Ã‚Ë‡ Ã‚Ë‡ . We see that the path  there is no elementary translation of RoCTL* into CTL*.  si through ÄÂ„4 (A) is also a path  through A. Thus  g(ÄÂƒ0 )  Definition 27. We define isomorphism on finite labelled  g(ÄÂƒ1 )  g(ÄÂ€i )  s0 Ã¢Â†Â’ s1 Ã¢Â†Â’ Ã‚Ë‡ Ã‚Ë‡ Ã‚Ë‡ si Ã¢Â†Â’ si+1  is a run of A.  g(ÄÂ€i+1 )  Ã¢Â†Â’  trees recursively. We say that T = (A, R, g) and T 0 =  Ã‚Ë‡Ã‚Ë‡Ã‚Ë‡  (A0 , R0 , g 0 ) are isomorphic if g (root (T )) = g 0 (root (T 0 ))    0  and   there exist orderings C = C1 , . . . , C|C| and C =  0  C10 , . . . , C|C|  of the direct subtrees of T and T 0 respec-  States in F occur in finitely often in  si , si+1 , . . . and hence this run is an accepting run of A.  tively such that Ci and Ci0 are isomorphic for all i Ã¢ÂˆÂˆ [1, |C|].  Hence ÄÂ€  ÄÂ†. As ÄÂ€ is a deviation from ÄÂƒ it follows that  We define utrees below such that all (h, l)-utrees have  ÄÂƒ  4ÄÂ†.  the same number of direct subtrees, which are pairwise nonTheorem 26. There exists a satisfaction preserving trans-  isomorphic. For any pair T, T 0 of (h, l)-utrees, this ensures  lation function from RoCTL* to CTL*.  that if there is a direct subtree of T that is not isomorphic  Proof. Using Lemma 24 it is easy to show that the transla-  to any subtree of T 0 , there must also be a direct subtree of  tion function c from Section 4.3 is well defined, and from  T 0 that is not isomorphic to any subtree of T . This makes it  Lemma 25 it is easy to show that c is satisfaction preserv-  easier to test whether a pair of utrees are isomorphic.  ing.  Definition 28. We define the concept of a utree recursively.  We fix an infinite enumerated set VÄÂ‰ = {b1 , b2 , . . .}. A  tree T = hA, R, gi consisting of a single node n is a (0, l)-  5. Succinctness  utree iff g(n) Ã¢ÂŠÂ† Vl where Vl = {b1 , b2 , . . . bl }. We let  In the previous section we showed that a satisfaction pre-  # (h, l) be the number of pairwise non-isomorphic (h, l)-  serving translation from RoCTL* to CTL* exists. In this  utrees; then a tree T is a (h + 1, l)-utree iff g(root (T )) = Ã¢Âˆ  section we will show that any satisfaction preserving trans-  and T has b# (h, l) /2c direct subtrees, which are pairwise  lation is non-elementary in the length of the formulas.  non-isomorphic (h, l)-utrees.  9  Example 29. Here is an example (1, 2)-utree. We use Ã¢Â€Âœ11Ã¢Â€Â  I{  as shorthand for b1 , b2 and Ã¢Â€Âœ01Ã¢Â€Â as shorthand for b2 .  tion of a direct subtree of the tree we were describing. The current world also encodes the  n1  label of this subtree.  I}  n2 {01}  This atom indicates that we begin the descrip-  n3 {11}  This atom indicates that we are ending the description of some tree.  tC  Lemma 30. The function # (h, l) is at least (h + 1)-  This indicates that the description of the subtree C starts here. This is not used in function  exponential in l.  f below. It is only included to allow sections of  the encoding to be easily and unambiguously  referenced in the proof of correctness.  Proof. We see that the number of pairwise non-isomorphic  (0, l)-utrees is 2l . From the definition of utrees where n =  2 b# (h, l) /2c,  Hk  n!  of a tree of height k, we are at a node of height  n n  2  2!2!  n.n Ã¢ÂˆÂ’ 1 . . . n2 . . . 2.1   n    n  2 . . . . .2.1  2 . . . . .2.1    n (n Ã¢ÂˆÂ’ 1) . . . n2 + 1  n    Ã¢Â‰Ä½ 2( 2 )  n  .  .  .  .  .2.1  2  k. Thus I{ Ã¢ÂˆÂ§ H3 means we are beginning the  # (h + 1, l) Ã¢Â‰Ä½ nC  =  =  The current input character describes the start  n  =  definition of a tree of height 3 and I} Ã¢ÂˆÂ§ H3  means we are ending the definition of a tree of  height 3.  .  The final world in the prefix encoding is wZ ; the prefix en-  Thus when # (h, l) is j-exponential in l, it is the case that  coding is not a transition structure as wZ has no successor.  # (h + 1, l) is (j + 1)-exponential in l. As # (0, l) is one  Example 31. Below we present the prefix encoding of the  exponential in l it follows from induction that # (h, l) is at  utree T from Example 29.  least (h + 1)-exponential in l.  w0 {I{ , H1 , tT }  Algorithm 1 can be used to describe the structure of a tree  w1 {I{ , H0 , 01, t(n2 ,Ã¢ÂˆÂ…,{n2 7Ã¢Â†Â’01}) }  using a string of Ã¢Â€Â˜{Ã¢Â€Â™ and Ã¢Â€Â˜}Ã¢Â€Â™ characters; strictly speaking  for each must iterate over the subtrees in some order, but  w2 {I} , H0 }  the ordering chosen is unimportant and will not be defined  here. E.g. Ã¢Â€Âœ{}Ã¢Â€Â represents a tree with a single node, and  w3 {I{ , H0 , 11, t(n3 ,Ã¢ÂˆÂ…,{n3 7Ã¢Â†Â’11}) }  w4 {I} , H0 }  Ã¢Â€Âœ{{}{}}Ã¢Â€Â represents a tree where the root has two root nodes  as successors.  w5 {I} , H1 }  Algorithm 1 PrintTree(T )  1: Print Ã¢Â€Â˜{Ã¢Â€Â™  2: for each direct subtree D of T : PrintTree()  3: Print Ã¢Â€Â˜}Ã¢Â€Â™  wZ  Algorithm 2 T2prefix(T )  1: (g, i):=T2g(T ,Ã¢ÂˆÂ…,0)  2: A := domain (g) Ã¢ÂˆÅ {wZ }  3: Ã¢Â†Â’ := {(wjÃ¢ÂˆÂ’1 , wj ) : j Ã¢ÂˆÂˆ [1, i)} Ã¢ÂˆÅ (wi , wZ )  4: return(A, Ã¢Â†Â’, g)  Algorithms 2 and 3 for outputting the prefix encoding  prefix (T ) of T are similar. The function prefix is from  utrees to labelled trees where each node has degree of at  tree, the prefix encoding also uses the following atoms as  We now define the suffix encoding suffix (T ) of a tree    T = AT , RT , g T . In addition to the atoms used in the la-  labels, where h is the height of the tree and k Ã¢ÂˆÂˆ [0, h].  belling of the input tree T , the suffix encoding uses: the  most one. In addition to the atoms used to label the input  10  g(w) = g S (w) if w Ã¢ÂˆÂˆ AS , g (w) = g P (w) if w Ã¢ÂˆÂˆ AP ,  Algorithm 3 T2g(T ,g,i)    1: AT , RT , g T :=T  2: g[wi ]:={I{ , Hheight(T ) , tT } Ã¢ÂˆÅ g T (root (T )); i++  3: for each direct subtree C of T: (g, i):=T2g(C,g,i)  4: g[wi ]:={I} , Hheight(T ) }; i++  5: return(g, i)  R = RS Ã¢ÂˆÅ RP Ã¢ÂˆÅ {(wZ , root (T 0 ))}.  Definition 34. We say that a structure M satisfies a formula  ÄÂ† iff there exists a path ÄÂƒ such that M, ÄÂƒ  ÄÂ†.  Definition 35. Let us define a function f as follows from  pairs of natural numbers to RoCTL* formulas:  violation atom v from RoCTL*; and HkF for k in [0, h]  which is used to indicate the height of the current node  f (0, l) =  in the tree, much like Hk is used in the prefix encoding.    Let N = n1 , . . . , n|N | be the set of nodes in the tree  ^  bi Ã¢Â†Â’ F H0F Ã¢ÂˆÂ§ bi    Ã¢ÂˆÂ§  iÃ¢ÂˆÂˆ[1,l]  ^  T . Let N 0 bena numbered o  set such that |N | = |N 0 |;  0  0  0  that is N = n1 , . . . , n|N | . Then for all trees T , if  Ã‚Å¹bi Ã¢Â†Â’ F H0F Ã¢ÂˆÂ§ Ã‚Å¹bi    iÃ¢ÂˆÂˆ[1,l]  f (k, l) =  (A, R, g) = suffix (T ) we have  1. A = N Ã¢ÂˆÅ N 0 Ã¢ÂˆÅ {nZ }        I{ Ã¢ÂˆÂ§ HkÃ¢ÂˆÂ’1 Ã¢Â†Â’ 4f (k Ã¢ÂˆÂ’ 1, l) U I} Ã¢ÂˆÂ§ Hk    Ã¢ÂˆÂ§ F HkF Ã¢ÂˆÂ§ I{ Ã¢ÂˆÂ§ Hk  Recall that F ÄÂ† is shorthand for (>U ÄÂ†), and as such  2. R is the minimal relation satisfying: R Ã¢ÂŠÂ‡ RT ,  M, ÄÂƒ  F ÄÂ† Ã¢Â‡ÂÃ¢Â‡Â’ Ã¢ÂˆÂƒi M, ÄÂƒÃ¢Â‰Ä½i  ÄÂ†.  and {(ni, n0i ) , (n0i , nZ ) , (nZ , nZ )} Ã¢ÂŠÂ† R, for all i Ã¢ÂˆÂˆ  The intuition behind f is that a path ÄÂƒ through  [1, |N |].  u (T, T 0 ) = hA, R, gi can correspond to both a subtree of  T and a subtree T 0 ; if tC Ã¢ÂˆÂˆ g (ÄÂƒ0 ) then ÄÂƒ starts at the be-  3. the valuation g is the valuation satisfying g(ni ) =  ginning of the prefix encoding of some subtree C of T , and  {v}; g (nZ ) = Ã¢ÂˆÂ… and  g (n0i )  =  if n0C 0 is in ÄÂƒ then ÄÂƒ corresponds to some subtree C 0 of T 0 .  n  F  g T (ni ) Ã¢ÂˆÅ Hheight  o  RT  (ni )  The formula f (0, l) is satisfied if the labels of C and C 0  .  match, so f (0, l) is satisfied iff C and C 0 are isomorphic  Example 32. Below we present the suffix encoding of the  leafs. A deviation from the current path can only have one  utree from Example 29.  additional failure, and hence only one additional edge. So,  where n0C 0 is in ÄÂƒ, then for each subtree D0 of T 0 satisfying  n1 {v}  height (D0 ) = height (C) Ã¢ÂˆÂ’ 1 there exists a deviation from  ÄÂƒ containing n0D0 iff D0 is a direct subtree of C 0 . As such,  n3 {v}  n2 {v}  4f (0, l) is satisfied exactly on those paths that correspond  to subtrees C and D0 such that C has a direct subtree iso-  n01 {H1F }  n02 {01, H0F }  morphic to D0 . We use this intuition and recursion to prove  the following lemma.  n03 {11, H0F }  Lemma 36. For any integers u and l, if T and T 0 are (u, l)utrees then u (T, T 0 ) satisfies f (u, l) iff T and T 0 are iso-  nZ  morphic.  Definition 33. We let u (T, T 0 ) be the model that re-  Proof. For each subtree C of T , let wC be the world that is  sults when we join the prefix encoding of T to the suf-  the beginning of the suffix encoding of C, or more formally  0  0  the world where tC is true. For any path, ÄÂƒ we define ÄÂƒÃ¢Â‰Ä½C  fix encoding of T by adding (wZ , root (T )) to R. For  mally, where AP , RP , g P is the prefix encoding of T    and AS , RS , g S is the suffix encoding of T 0 , it is the  0  case that u (T, T ) = (A, R, g) where A = A  P  such that ÄÂƒÃ¢Â‰Ä½C = ÄÂƒÃ¢Â‰Ä½i where ÄÂƒi = wC .  (=Ã¢Â‡Â’) Say that u (T, T 0 ) , ÄÂƒ T  f (u, l) for some ÄÂƒ T .  S  We see that ÄÂƒ0T = w0 as f (u, l)  I{ Ã¢ÂˆÂ§ Hu . We define ÄÂƒ C  Ã¢ÂˆÅA ,  11    AT , R T , g T .  recursively for each subtree C of T . Say we have defined  the path ÄÂƒ C for some subtree C such that u (T, T 0 ) , ÄÂƒ C   Likewise let nC be the node that is the root of the sub-  f (k, l) where k is the height of C. Then for each direct  tree C. We define ÄÂƒ C recursively as follows: let ÄÂƒ T be  C  ÄÂƒÃ¢Â‰Ä½D   4f (k Ã¢ÂˆÂ’ 1, l) and thus  the fullpath starting at w0 that passes through n00 ; that is,  C  there must exist a deviation from ÄÂƒÃ¢Â‰Ä½D  satisfying f (kÃ¢ÂˆÂ’1, l),  D  we call this deviation ÄÂƒ .  ÄÂƒ T = hw0 , . . . , wZ , nT , n0T , nZ , nZ , . . .i. Say that D is  subtree D of C, we see that  0  the direct subtree of C, then where  n0C 0  We see that for each C there is a unique C such that  is in the path ÄÂƒ C . In the following paragraph we will show  ÄÂƒ C = hwC , . . . , wD , . . . , wZ , nT , . . . , nC , n0C , nZ , nZ , . . .i  that for each subtree C and direct subtree D of C, we can  we let  C  produce ÄÂƒ D from ÄÂƒÃ¢Â‰Ä½D  by replacing n0C 0 with nD0 n0D0 , and  hence that D0 is a direct subtree of C 0 .  Consider where ÄÂƒ  first world in ÄÂƒ  in both ÄÂƒ  C  D  D  deviates from  not in ÄÂƒ  C  C  ÄÂƒÃ¢Â‰Ä½D  .  ÄÂƒ D = hwD , . . . , wZ , nT , . . . , nC , nD , n0D , nZ , nZ , . . .i .  Say ny is the  and that nx is the last world  C  In other words, we produce ÄÂƒÃ¢Â‰Ä½D  from ÄÂƒ C by pruning ev-  and ÄÂƒ . From the definition of deviations we  C  erything prior to wD , and ÄÂƒ D from ÄÂƒÃ¢Â‰Ä½D  and replacing n0C  D  D  see that ÄÂƒÃ¢Â‰Ä½n  is failure-free and  y  0  must be nB . Since ÄÂƒ D  F HkF  D it follows that HkF Ã¢ÂˆÂˆ g (n0B );  so the next world on ÄÂƒ  D  with nD , n0D . This remains a full path, since D is a direct  where k is the height of  subtree of C, and so nD is a child of nC . Note also that ÄÂƒ D  from the structure of the  C  is a deviation from ÄÂƒÃ¢Â‰Ä½D  .  suffix encoding it is clear that B is a direct subtree of A,  As each  If height (C) = 0 it is easy to verify that ÄÂƒ C  f (0, l),      as g (wC ) Ã¢ÂˆÅ H0F = g (nC ) Ã¢ÂˆÅ H0 , tC , I{ . For C of  parent has a height greater than that of its direct subtrees, it  height k, it is likewise easy to see that ÄÂƒ C  F HkF . Assume  and height (A) = k + 1 and thus  follows that n  C0  n0C 0 ,  F  Hk+1  in  g (n0A ).  C  is the only world in ÄÂƒ such that  F  Hk+1  Ã¢ÂˆÂˆ  that ÄÂƒ C  f (k Ã¢ÂˆÂ’ 1, l) for all C of height k Ã¢ÂˆÂ’ 1 [expand].  and hence it follows that nx = nC 0 .  Now consider C of height k. It is easy to show that  Consider D of height 0. The path ÄÂƒ D is of the form  ÄÅÅ¤  ÄÅÅ›  _  ÄÂƒ C  ÄÅÂ­ I{ Ã¢ÂˆÂ§ HkÃ¢ÂˆÂ’1 Ã¢Â†Â’    hwD , . . . , wZ , nT , . . . , nC 0 , nD0 , n0D0 , nZ , nZ , . . .i  D  0  It is easy to show that D and D are isomorphic. For each    tD ÄÅÂ¸ U I} Ã¢ÂˆÂ§ Hk .  is child of C  By assumption ÄÂƒ D  f (kÃ¢ÂˆÂ’1, l), and ÄÂƒ D is a deviation from  C, we choose C 0 such that n0C 0 is in the full path ÄÂƒ C . Say  C  C  ÄÂƒÃ¢Â‰Ä½D  , so ÄÂƒÃ¢Â‰Ä½D   4f (k Ã¢ÂˆÂ’ 1, l). Thus  0  that for every D of height k it is the case that D and D are  isomorphic. Consider C of height k + 1. We have shown  that for each direct subtree D of C, it is the case that D0  ÄÂƒC   is a direct subtree of C 0 . As C must have the same height        I{ Ã¢ÂˆÂ§ HkÃ¢ÂˆÂ’1 Ã¢Â†Â’ 4f (k Ã¢ÂˆÂ’ 1) U I} Ã¢ÂˆÂ§ Hk .  Thus ÄÂƒ C  f (k, l). By induction u (T, T 0 ) , ÄÂƒ T  f (u, l).  F  as C 0 (otherwise the requirement that ÄÂƒ  F Hk+1  would  not be satisfied), C 0 and C have the same number of direct  subtrees, each of height k. We have show previously that  Example 37. In Lemma 36 above, we proved that  0  for each direct subtree D of C, it is also the case that D is  u (T, T 0 ) , ÄÂƒ T  f (u, l) for some ÄÂƒ T iff T and T 0 are iso-  a direct subtree of C 0 . By assumption, each pair D, D0 are  morphic. Using T as the tree in Example 29, let  isomorphic, and so C, C 0 are isomorphic. By induction T  ÄÂƒ 0 = hw0 , . . . , wZ , n1 , n01 , nZ , . . .i  and T 0 are isomorphic.  (Ã¢Â‡Â=) Say that T 0 and T are isomorphic. Clearly suf-  ÄÂƒ 1 = hw1 , . . . , wZ , n1 , n2 , n02 , nZ , . . .i  fix encodings of T 0 and T will also be isomorphic, and  ÄÂƒ 2 = hw3 , . . . , wZ , n1 , n3 , n03 , nZ , . . .i  so u (T, T 0 ) satisfies f (u, l) iff u (T, T ) does. Thus we  can assume without loss of generality that T = T 0 =  be paths through u (T, T ). We see that ÄÂƒ 1 and ÄÂƒ 2 sat12  0  isfy f (0, 2). As ÄÂƒ 1 and ÄÂƒ 2 are deviations from ÄÂƒÃ¢Â‰Ä½1  and  0  ÄÂƒÃ¢Â‰Ä½3  respectively, it is the case that  0  ÄÂƒÃ¢Â‰Ä½1  and  0  ÄÂƒÃ¢Â‰Ä½3  There are a number of translations of Ã‚Ä¾-calculus into al-  satisfy  ternating automata, Wilke gives a simple translation that  4f (0, 2). Thus wherever I{ Ã¢ÂˆÂ§ H0 is true, it is also the  does not assume that the tree has any particular struc-  0  case that 4f (0, 2) is true; hence u (T, T ) , ÄÂƒ  f (1, 2).  ture [24]. The states in the resulting automata are subfor-  Definition 38. We say an automaton A accepts a structure  mulas of the Ã‚Ä¾-calculus formula. Hence the translation into  alternating automata is linear.  M iff the tree unwinding of M is a member of L (A).  Lemma 39. For any arbitrary h, l Ã¢ÂˆÂˆ N, let A =  The translation via Ã‚Ä¾-calculus above is sufficient for this  (ÃÅ, S, S0 , ÃÂ´, F ) be an SAA such that for any pair T, T 0 of  paper. There are translations that result in more optimised  (h, l)-utrees A accepts u (T, T 0 ) iff T and T 0 are isomor-  model checking and decision procedure results [15].  phic; then 2|S| Ã¢Â‰Ä½ # (h, l).    Proof. Let T1 , T2 , . . . , T#(h,l)  Corollary 41. For all fixed h Ã¢Â‰Ä½ 1, there is no function e  non-isomorphic (h, l)-utrees.  which is less than (h Ã¢ÂˆÂ’ 1)-exponential, such that the length  be a set of pairwise  For each i, let Ri  |ÄÂ†l | of the shortest CTL* formula ÄÂ†l Ã¢Â‰Ä„ f (h, l) satisfies  =  hARi , gRi , RRi i be an accepting run of A on u (Ti , Ti ); let  |ÄÂ†l | < e (l) for all l.  Qi be the set of all states that the automata is in after read-  Proof. Say e exists. Since ÄÂ†l Ã¢Â‰Ä„ f (h, l) then there ex-  ing the prefix encoding of Ti ; formally let Qi Ã¢ÂŠÂ† S be the  ists a fullpath ÄÂƒ T starting at w0 through u(T, T 0 ) such that  set of states such that for all q Ã¢ÂˆÂˆ S we have q Ã¢ÂˆÂˆ Qi iff there  u(T, T 0 ), ÄÂƒ T  ÄÂ†l iff T and T 0 are isomorphic. As e is less  exists wR Ã¢ÂˆÂˆ ARi such that (root (Ti ) , q) Ã¢ÂˆÂˆ gRi (wR ). Re-  than (h Ã¢ÂˆÂ’ 1)-exponential, from Theorem 40 the size of the  call that root (Ti ) is the beginning of the suffix encoding of  SAA is less than h-exponential in l.  From Lemma 39, we have 2n Ã¢Â‰Ä½ # (h, l) where n is the  u (Ti , Ti ).  Say that Qi = Qj for some i 6= j. Let Aq be shorthand  size of the automata, and from Lemma 30 we know that  for (ÃÅ, S, {q} , ÃÂ´, F ). In the next paragraph we will define a  # (h, l) is (h + 1)-exponential in l. Hence 2n is at least  run  Rji  with the prefix from the run Rj and the suffix from  (h + 1)-exponential in l, and so n is at least h-exponential  Ri .  in l. By contradiction no such e exists.  Since all infinite paths of the run Ri are accepting, we see  that for each q Ã¢ÂˆÂˆ Q , the relevant subtree Rsuffix of R is an  i  Corollary 42. For all fixed h Ã¢Â‰Ä½ 2, there is no function  i  i,q  e which is less than (h Ã¢ÂˆÂ’ 2)-exponential such that for all  accepting run for Aq on the suffix encoding of Ti . Let Rji be  RoCTL* formulas ÄÂ† with at most h nested 4 (or N), the  the tree that results when we replace the subtree beginning  at w with Rsuffix , for each q Ã¢ÂˆÂˆ Q = Q and w Ã¢ÂˆÂˆ A  R  i,q  i  j  R  length |ÄÂˆ| of the shortest CTL* formula ÄÂˆ equivalent to ÄÂ†  Ri  is no more than e (|ÄÂ†|).  satisfying gRj (wR ) = (root (Tj ) , q). It is easy to show  that Rji is an accepting run of A on u (Tj , Ti ). However  Proof. This follows from the above corollary, and the fact  we have assumed that Ti is not isomorphic to Tj , and so A  that f (h, l) has at most h nested 4 and |f (h, l)| Ã¢ÂˆÂˆ  does not accept u (Tj , Ti ). By contradiction Qi 6= Qj for  O (h + l).  S  any i, j Ã¢ÂˆÂˆ [1, # (h, l)] such that i 6= j. As each Qi Ã¢ÂˆÂˆ 2 ,  Theorem 43. There is no satisfaction preserving transla-  we can conclude from the pigeon hole principle that 2|S| Ã¢Â‰Ä½  tion from RoCTL* to CTL* that is elementary in the length  # (h, l).  of the formula.  Theorem 40. Given a CTL* formula ÄÂˆ we can construct an  Obvious from the above Corollary; if there were an i-  SAA AÄÂˆ with a number of states that is singly exponential  exponential translation of RoCTL* into CTL* for any i Ã¢ÂˆÂˆ  in the length of ÄÂˆ.  N there would be an i-exponential translation of RoCTL*  formulas with i + 3 nested 4 operators.  Proof. Dam provides a translation of CTL* formulas into  We see that the only non-classical operators in f (h, l)  equivlent Ã‚Ä¾-calculus. The nodes are sets of formulas, so  are positively occurring Ã¢ÂˆÂ†, U and F . Since F ÄÂˆ is short  this is a singly exponential translation.  13  hand for >U ÄÂˆ we see that alternations between positively  las. While in other logics non-elementary blowup is fre-  occurring U and 4 are sufficient to produce non-elementary  quently the result of unbounded alternations between posi-  blowup. By slightly modifying f , we can similarly demon-  tive and negative occurrences of the same operator, we do  strate that alternation between positively occurring N and U  not need to alternate between 4 and N to demonstrate non-  are also sufficient to produce non-elementary blowup. For  example the following f 0 contains only operators equiva-  elementary blow up. Indeed, the only non-classical opera-  lent to negatively occurring U , where W is the weak until  W  operator and H F Ã¢Â‰Âˆ i HiF :  We may modify f slightly so that it only contains positively  tors in the function f were positively occurring U and 4.  occurring U and N.  RoCTL* is known to be decidable, but without a known  f 0 (0, l) =  ^  bi Ã¢Â†Â’ G H F Ã¢Â†Â’ H0F Ã¢ÂˆÂ§ bi    Ã¢ÂˆÂ§  elementary upper bound. Our succinctness result shows that  iÃ¢ÂˆÂˆ[1,l]  ^  a full translation into CTL* or Tree Automata cannot reÃ‚Å¹bi Ã¢Â†Â’ G H F Ã¢Â†Â’ H0F Ã¢ÂˆÂ§ Ã‚Å¹bi    sult in elementary decision procedures. The question still  iÃ¢ÂˆÂˆ[1,l]  f 0 (k, l) =  remains as to whether some other elementary decision pro-        I{ Ã¢ÂˆÂ§ HkÃ¢ÂˆÂ’1 Ã¢Â†Â’ 4f 0 (k Ã¢ÂˆÂ’ 1, l) W I} Ã¢ÂˆÂ§ Hk    Ã¢ÂˆÂ§ F HkF Ã¢ÂˆÂ§ I{ Ã¢ÂˆÂ§ Hk  cedure can be found for RoCTL*. The discovery of such  a procedure would be interesting, as this would be the first  modal logic which was elementary to decide but had only  Since there is no elementary translation of f and f 0 into  non-elementary translations into tree automata.  CTL*, there is also no elementary translation of Ã‚Å¹f and  Ã‚Å¹f 0 into CTL*.  References  [1] H. Aldewereld, D. Grossi, J. Vazquez-Salceda, and  6. Conclusion  F. Dignum. Designing normative behaviour by the use of  landmarks. In Agents, Norms and Institutions for Regulated  We have shown that all RoCTL* formulas can be expressed as an equivalent CTL* formula. This translation  Multiag. Syst., Utrecht, The Netherlands, Jul 2005.  [2] A. Arnold, A. Vincent, and I. Walukiewicz. Games for syn-  can also be used to translate RoBCTL* [17] formulas into  thesis of controllers with partial observation. TCS, 303(1):7Ã¢Â€Â“  BCTL* formulas. Once translated into CTL* formula we  34, 2003.  [3] N. Belnap. Backwards and forwards in the modal logic of  can use any of the standard methods for model checking, so  agency. Philos. Phenomen. Res., 51(4):777Ã¢Â€Â“807, Dec 1991.  [4] J. Broersen, F. Dignum, V. Dignum, and J.-J. C. Meyer. De-  this result provides us with a model checking procedure for  RoCTL*. As with CTL*, the model checking problem for  signing a Deontic Logic of Deadlines, volume 3065/2004 of  RoCTL* is linear with respect to the size of the model [8].  Classes of RoCTL* formulas with bounded N-complexity  LNCS, pages 43Ã¢Â€Â“56. Springer, 2004.  [5] E. M. Clarke, E. A. Emerson, and A. P. Sistla. Automatic  have linear translations into CTL*. Thus as with CTL* the  verification of finite-state concurrent systems using tempo-  model checking problem is also singly exponential [8] with  ral logic specifications. ACM Trans. Program. Lang. Syst.,  respect to the length of these formulas , and satisfiability  is doubly exponential. Multiple nestings of N (or 4) with-  8(2):244Ã¢Â€Â“263, 1986.  [6] M. de Weerdt, A. Bos, H. Tonino, and C. Witteveen. A re-  out any form of alternation can also be translated to CTL*  source logic for multi-agent plan merging. Annals of Math.  without increasing the complexity of the translation over a  and AI, 37(1-2):93Ã¢Â€Â“130, January 2003.  [7] V. Diekert and P. Gastin. First-order definable languages.  single N operator.  In J. Flum, E. GrÄ‚Â¤del, and T. Wilke, editors, Logic and  We have not shown the exact complexity of the transla-  Automata: History and Perspectives, volume 2 of Texts in  tion. However we will attempt to show that there is roughly  Logic and Games, pages 261Ã¢Â€Â“306. Amsterdam University  a single exponential blowup per alternation between Ã¢ÂˆÂ† (or  N) and U ; never-the-less we expect model checking to be  Press, 2008.  [8] J. Edmund M. Clarke, O. Grumberg, and D. A. Peled. Model  practical for some useful subclasses of RoCTL* formu-  Checking. MIT Press, 1999.  14  [9] E. A. Emerson and C.-L. Lei. Modalities for model checking  [23] L. W. N. van der Torre and Y. Tan. The temporal analysis of  (extended abstract): branching time strikes back. In POPL  ChisholmÃ¢Â€Â™s paradox. In T. Senator and B. Buchanan, editors,  Ã¢Â€Â™85: Proc. 12th ACM SIGACT-SIGPLAN symp. on Princi-  Proc. 14th Nation. Conf. on AI and 9th Innov. Applic. of AI  ples of programming languages, pages 84Ã¢Â€Â“96, New York,  Conf., pages 650Ã¢Â€Â“655. AAAI Press, 1998.  [24] T. Wilke and C. albrechts-universitt Zu Kiel. Alternating  NY, USA, 1985. ACM.  tree automata, parity games, and modal Ã‚Ä¾-calculus, 2000.  [10] J. W. Forrester. Gentle murder, or the adverbial samaritan.  J. Philos., 81(4):193Ã¢Â€Â“7, April 1984.  [11] T. French, J. C. Mc Cabe-Dansted, and M. Reynolds. A Temporal Logic of Robustness, volume 4720 of LNCS, pages  193Ã¢Â€Â“205.  2007.  http://dx.doi.org/10.1007/  978-3-540-74621-8_13.  [12] E. GrÄ‚Â¤del, W. Thomas, and T. Wilke. Automata, Logics, and  Infinite Games: A Guide to Current Research. 2002. LNCS,  Vol. 2500 http://www.springer.com/computer/  book/978-3-540-00388-5.  [13] H. Hansson and B. Jonsson. A logic for reasoning about time  and reliability. Formal Aspects of Computing, 6(5):512Ã¢Â€Â“535,  1994.  [14] T. JÄ‚Å ron, H. Marchand, S. Pinchinat, and M.-O. Cordier. Supervision patterns in discrete event systems diagnosis. In 8th  Internat. Workshop on Discrete Event Syst., pages 262Ã¢Â€Â“268,  July 2006.  [15] O. Kupferman and M. Y. Vardi. An automata-theoretic approach to reasoning about infinite-state systems. In Proc  CAVÃ¢Â€Â™00, LNCS, volume 1855, pages 36Ã¢Â€Â“52. Springer, 2000.  [16] W. Long, Y. Sato, and M. Horigome. Quantification of sequential failure logic for fault tree analysis. Reliab. Eng.  Syst. Safe., 67:269Ã¢Â€Â“274, 2000.  [17] J. C. McCabe-Dansted. A tableau for RoBCTL*. In S. HÄ‚Å›lldobler, C. Lutz, and H. Wansing, editors, JELIA, volume  5293 of LNCS, pages 298Ã¢Â€Â“310. Springer, 2008.  [18] L. T. McCarty. Defeasible deontic reasoning. Fundam. Inform., 21(1/2):125Ã¢Â€Â“148, 1994.  [19] J. C. Mc Cabe-Dansted, T. French, and M. Reynolds. A  temporal logic of robustness, RoCTL*.  Technical re-  port, UWA, 2007. http://www.csse.uwa.edu.au/  ~john/papers/RoCTL07.pdf.  [20] A. Pancones.  The coordinated attack and the jealous  amazons. http://www.dsi.uniroma1.it/~asd3/  dispense/attack+amazons.pdf.  [21] A. Rodrigo and A. Eduardo. Normative pragmatics for agent  communication languages. In Perspect. Concept. Model.  (LNCS), volume 3770, pages 172Ã¢Â€Â“181. Springer, 2005.  [22] F. van der Grijn. (im)possibility of a coordinated attack.  Technical report, University of Amsterdam, June 2004.  http://www.illc.uva.nl/Publications/  ResearchReports/X-2004-05.text.pdf.  15 