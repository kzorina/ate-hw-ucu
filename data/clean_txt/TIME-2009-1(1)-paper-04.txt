On the Expressivity of RoCTL*  John Mc Cabe-Danstedâ, Tim French, Mark Reynolds  The University of Western Australia  Computer Science and Software Engineering  {john,tim,mark}@csse.uwa.edu.au  Abstract  Sophie Pinchinat  Campus Universitaire de Beaulieu  IRISA  Sophie.Pinchinat@irisa.fr  such as "even with n additional failures" to be built up by  chaining n simple unary Robustly operators together.  RoCTL* was proposed to model robustness in concur-  The RoCTL* Obligatory operator is similar to the Oblig-  rent systems. RoCTL* extended CTL* with the addition  atory operator in Standard Deontic Logic (SDL), although  of Obligatory and Robustly operators, which quantify over  in RoCTL* the operator quantifies over paths rather than  failure-free paths and paths with one more failure respec-  worlds. SDL has many paradoxes. Some of these, such  tively. Whether RoCTL* is more expressive than CTL* has  as the âGentle Murdererâ paradox spring from the inade-  remained an open problem since the RoCTL* logic was  quacy of SDL for dealing with obligations caused by acting  proposed. We use the equivalence of LTL to counter-free  contrary to duty such as âIf you murder, you must murder  automata to show that RoCTL* is expressively equivalent  gentlyâ. Contrary-to-Duty (CtD) obligations are important  to CTL*; the translation to CTL* provides the first model  for modeling a robust system, as it is often important to  checking procedure for RoCTL*. However, we show that  state that the system should achieve some goal and also that  RoCTL* is relatively succinct as all satisfaction preserving  if it fails it should in some way recover from the failure.  translations into CTL* are non-elementary in length. Draft:  RoCTL* can represent CtD obligations by specifying that  May 19, 2009  the agent must ensure that the CtD obligation is met even if  a failure occurs. For further discussion of CtD obligations  and motivations for RoCTL*, see [11]. The obligatory op-  1. Introduction  erator, as well as some uses of the robustly operator, are  easy to translate into CTL* [17].  Logic  When RoCTL* was originally proposed [11], it had  (RoCTL*) [11] is an extension of CTL* introduced to  The  Robust  Full  Computation  Tree  represent issues relating to robustness and reliability in  two accessibility relations, a success and failure transition.  However we may equivalently define RoCTL* with a single  systems. It does this by adding an Obligatory operator and  accessibility relation if we add a violation atom v to indi-  a Robustly operator. The Obligatory operator specifies how  cate that the previous transition was a failure transition (this  the systems should behave by quantifying over paths in  new definition was first used in [17]). Under this definition,  which no failures occur. The Robustly operator specifies  the RoCTL* models are CTL models, albeit with a special  that something must be true on the current path and similar  paths that "deviate" from the current path, having at most  violation atom not used in RoCTL* formulas. In this pa-  one more failure occurring. This notation allows phrases  in CTL* formulas, then we can express every RoCTL* for-  per we show that if we allow the violation atom to occur  mula into an equivalent CTL* formula. Although we will  â This Project is supported by the Australian Governmentâs International Science Linkages program  expose the violation atom, we do not extend the model, in  1  reliability. However their logic reasons about reliability us-  particular we do not add atoms to the model.  The addition of the Robustly operator and temporal  ing probabilities rather than numbers of failures, and their  operators to Deontic logic allows RoCTL* to deal with  paper does not contain any discussion of the relationship  Contrary-to-Duty obligations. SDL is able to distinguish  of their logic to Deontic logics. Like our embedding into  what ought to be true from what is true, but is unable to  QCTL*, Aldewereld et al [1] uses a Viol atom to represent  specify obligations that come into force only when we be-  failure. However, their logic also uses probability instead of  have incorrectly. For example, SDL is inadequate to represent the obligation âif you murder, you must murder gen-  failure counts and is thus suited to a different class of problems than RoCTL*. None of these logics appear to have an  tlyâ [10]. Addition of temporal operators to Deontic logic  operator that is substantially similar to the Robustly opera-  allows us to specify correct responses to failures that have  tor of RoCTL*.  occurred in the past [23]. However, this approach alone  Diagnosis problems in control theory [14, 2] also deals  is not sufficient [23] to represent obligations such as âYou  with failures of systems. Diagnosis is in some sense the  must assist your neighbour, and you must warn them iff you  dual of the purpose of the RoCTL* logic, as diagnosis re-  will not assist themâ. In RoCTL* these obligations can be  quires that failure cause something (detection of the failure)  represented if the obligation to warn your neighbour is ro-  whereas robustness involves showing that failure will not  bust but the obligation to assist them is not.  cause something.  Other approaches to dealing with Contrary-to-Duty obli-  The translation we will present in this paper results in a  gations exist. Defeasible logic is often used [18], and logics  of agency, such as STIT [3], can be useful as they can allow  formula that is satisfied on a model iff the original formula  obligations to be conditional on the agentâs ability to carry  all the CTL* model checkers, decision procedures and so  out the obligation.  forth for RoCTL*.  is satisfied on the same model. This means that we can use  This paper provides some examples of robust systems  We will then show that although all RoCTL* formulas  that can be effectively represented in RoCTL*. It is easy  can be translated into CTL*, the length of the CTL* formula  to solve the coordinated attack problem if our protocol is  is not elementary in the length of the RoCTL* formula.  allowed to assume that only n messages will be lost. The  Hence some properties can be represented much more succinctly in RoCTL* than CTL*.  logic may also be useful to represent the resilience of some  economy to temporary failures to acquire or send some resource. For example, a remote mining colony may have in-  2. Definitions  teracting requirements for communications, food, electricity and fuel. RoCTL* may be more suitable than Resource  2.1. RoCTL-Structures and Trees  Logics (see e.g. [6]) for representing systems where a failure may cause a resource to become temporarily unavail-  Definition 1. We let V be our set of variables. The set V  able. This paper presents a simple example where the only  contains a special variable v. A valuation g is a map from  requirement is to provide a cat with food when it is hungry.  a set of worlds A to the power set of the variables. The  A number of other extensions of temporal logics have  statement p â g(w) means roughly âthe variable p is true at  been proposed to deal with Deontic or Robustness is-  world wâ.  sues [4, 16, 13, 1, 21]. Each of these logics are substantially different from RoCTL*. Some of these logics are de-  Definition 2. We say that a binary relation R on S is serial  signed specifically to deal with deadlines [4, 13]. An Agent  (total) if for every a in S there exists b in S such that aRb.  Communication Language was formed by adding Deontic  and other modal operators to CTL [21]; this language does  Definition 3. A structure M = (A, R, g) is a 3-tuple con-  not explicitly deal with robustness or failures. Hansson and  taining a set of worlds A, a serial binary relation R on A, a  Johnsson [13] proposed an extension of CTL to deal with  valuation g on the set of worlds A.  2  Definition 4. We call an Ď-sequence Ď = hw0 , w1 , . . .i of  follows:  worlds a fullpath iff for all non-negative integers i we have  M, Ď  N Ď iff M, ĎâĽ1  Ď  wi Rwi+1 . For all i in N we define ĎâĽi to be the fullpath  hwi , wi+1 , . . .i, we define Ďi to be wi and we define Ďâ¤i to  M, Ď  ĎU Ď iff âiâN s.t. M, ĎâĽi  Ď and  be the sequence hw0 , w1 , . . . , wi i.  âjâN j < i =â M, ĎâĽj  Ď  M, Ď  AĎ iff âĎâSF (Ď0 ) M, Ď  Ď  Definition 5. We say that a fullpath Ď is failure-free iff for  M, Ď  OĎ iff âĎâS(Ď0 ) M, Ď  Ď  all i > 0 we have v â  / g (Ďi ). We define SF (w) to be the  M, Ď  NĎ iff âĎâÎ´(Ď) M, Ď  Ď and M, Ď  Ď  set of all fullpaths starting with world w and S(w) to be the  set of all failure-free fullpaths starting with w. We call a  The definition for >, p, ÂŹ and â§ is as we would expect from  CTL structure a RoCTL structure iff S(w) is non-empty for  classical logic. The intuition behind the N operator is that it  every w â A.  quantifies over paths that could result if a single error was  introduced; the deviations only have at most one failure not  on the original path, and they are identical to the original  Definition 6. For two fullpaths Ď and Ď we say that Ď is an  path until this failure occurs.  i-deviation from Ď iff Ďâ¤i = Ďâ¤i and ĎâĽi+1 â S(Ďi+1 ).  We say that Ď is a deviation from Ď if there exists a non-  Definition 7. We say that a function Ď from formulas to  negative integer i such that Ď is an i-deviation from Ď. We  formulas is satisfaction preserving iff for all M, Ď and Ď it  define a function Î´ from fullpaths to sets of fullpaths such  is the case that M, Ď  Ď ââ M, Ď  Ď (Ď).  that where Ď and Ď are fullpaths, Ď is a member of Î´(Ď) iff  We will now define a tree. A tree is similar to a structure,  Ď is a deviation from Ď.  but a tree need not be serial, and each node only has one  parent.  We see that S (Ď0 ) â Î´(Ď) â SF (Ď0 ). Where p varies  Definition 8. We say T = (A, R, g) is a V-labelled tree,  over V, we define RoCTL* formulas according to the fol-  for some set V, iff  lowing abstract syntax  1. A is a non-empty set of nodes  Ď := > | p | ÂŹĎ | (Ď â§ Ď) | (ĎU Ď) | N Ď | AĎ | OĎ | NĎ .  2. for all x, y, z â A if (x, z) â R and (y, z) â R then  x = y.  A formula that begins with A, ÂŹA, O, ÂŹO, p or ÂŹp  is called a state formula. For consistency with [11], we  3. there does not exist any cycle x0 R Âˇ Âˇ Âˇ Rx0 through R.  do not consider a formula that explicitly contains v to be  4. there exists a node x such that for all y â A, if y 6= x  a RoCTL* formula, although our translation into CTL*  there exists a sequence xRx1 R Âˇ Âˇ Âˇ Ry through R.  works equally well for such formulas. The >, ÂŹ, â§, N, U  5. the valuation g (or labeling) is a function from A to 2V ,  and A are the familiar âtrueâ, ânotâ, âandâ, ânextâ, âuntilâ  that is for each w â A, g (w) â V.  and âall pathsâ operators from CTL. The abbreviations âĽ,  â¨, F , G, W , E â and â are defined as in CTL* logic.  Definition 9. We define the height of a finite tree T =  As with Standard Deontic Logic (SDL) logic, we define  (A, R, g) as follows: root is a function from trees to nodes  P âĄ ÂŹOÂŹ. Finally, we define the dual 4 of N as the ab-  such that root (T ) is the root of the tree T . height (T ) =  breviation â âĄ ÂŹNÂŹ. We call the O, P , N, â operators  heightR (root (T )) where heightR is a function from A to  Obligatory, Permissible, Robustly and Prone respectively.  N such that for all x â A, we let heightR (x) be the smallest  We define truth of a RoCTL* formula Ď on a fullpath  non-negative integer such that heightR (x) > heightR (y)  Ď = hw0 , w1 , . . .i in a RoCTL-structure M recursively as  for all y such that (x, y) â R.  3  Definition 10. We say C = hAC , RC , gC i is a subtree of  Every node, in the run of an SAA on an input structure  T = (A, R, g) iff there exists w â A such that AC is the  M , represents a world of M . However, a world w in the  subset of A reachable from w and RC and gC are the frag-  input structure M may occur many times in a run. Where  ments of R and g on AC respectively. We say C is a di-  a non-deterministic automata would non-deterministically  rect subtree of T = (A, R, g) if C is a subtree of T and  pick a next state, a SAA non-deterministically picks a con-  (root (T ) , root (C)) â R.  junction of elements of the form (, q) and (âŚ, q); alternatively we may define SAA as deterministically picking a  2.2. Automata  Boolean combination of requirements of this form, see for  example [15]. Alternating automata can also be thought of  Definition 11. A BĂźchi automaton A = (ÎŁ, S, S0 , Î´, F )  as a type of parity game, see for example [12]. An element  contains  of the form (, q)/(âŚ, q) indicates for every/some child u  of the current world w of the input structure M , a run on M  ÎŁ: set of symbols (alphabet)  must have a branch which follows u and where q is the next  S: finite set of automaton states  state.  S0 : set of initial states â S  Î´ : a transition function â (S Ă ÎŁ Ă S)  Definition 13. A parity acceptance condition F of an au-  S  F : A set of accepting states â 2  tomata (ÎŁ, S, S0 , Î´, F ) is a map from S to N. We say that  â  We call the members of ÎŁ words. Unlike a path through  parity condition accepts an infinite path if the largest inte-  a structure, each transition of a path through an automa-  ger n, such that F (q) = n for some q that occurs infinitely  e  0  ton is labelled with an element e of ÎŁ. We say s0 â  e1  often on the path, is even.  enâ1  s1 â Âˇ Âˇ Âˇ â sn is a path of A if for all 0 â¤ i < n  the tuple hsi , ei , si+1 i is in Î´. The label of the path is  Definition 14. A symmetric alternating automata (SAA) is  he0 , e1 , . . . , en i. Let Lp,q (A) be the set of all labels of  a tuple (ÎŁ, S, S0 , Î´, F ) where ÎŁ, S and S0 are defined as in  paths through A from p to q.  BĂźchi automata, and  Î´ : a transition function â (S Ă ÎŁ Ă 2{,âŚ}ĂS )  A run Ď of A is a path starting at a state in S0 . We say  an infinite run is accepting if a state in F occurs infinitely  We define the the acceptance condition F of an SAA  often in the run.  to be a parity acceptance condition, but note that we can  In this paper, ÎŁ = 2ÎŚ , for some set of state formulas  express BĂźchi parity conditions as parity acceptance condi-  ÎŚ. Given a fixed structure M = (A, â, g) and path Ď, we  tions. The SAA accepts a run iff every infinite path through  let gÎŚ (Ďi ) = {Ď : Ď â ÎŚ â§ M, ĎâĽi  Ď} and gÎŚ (Ď) =  the run satisfies F .  hgÎŚ (Ď0 ), gÎŚ (Ď1 ), . . .i. Note that ÎŚ consists solely of state  A run R = hAR , RR , gR i of the SAA on a V-labelled  formulas so gÎŚ (Ď0 ) = gÎŚ (Ď0 ) if Ď0 = Ď0 .  input structure M is an AĂS-labelled tree structure. Where  Definition 12. A counter-free automaton is an automaton  gR (root (R)) = (w, q), it is the case that q â S and w =  such that for all positive integers m, states s â S and words  root (M ). For every wR in Ar , where (w, q) = gR (wR )  and e = g (w), there exists some set X â 2{,âŚ}ĂS such  u in ÎŁâ , if um â Ls,s then u â Ls,s [7].  that (wR , e, X) â Î´ and  Above we have defined linear automata. These are sufficient for the proof of expressive equivalence of RoCTL*  1. For each r â S such that (, r) â X, for each u such  and CTL*. However, in the proof that RoCTL* is relatively  that wRu there must exist uR such that wR RuR and  succinct, we will use tree automata. We will define a type  of tree automata called a symmetric alternating automata  (u, r) â gR (uR ).  (SAA) (see e.g. [15]), these are a subclass of alternating  2. For each r â S such that (âŚ, r) â X, for some u such  automata, and can also be referred to as just alternating au-  that wRu there must exist uR such that wR RuR and  tomata (see e.g. [24]).  (u, r) â gR (uR ).  4  3. Examples  Let Ď = hv, v, . . .i. We see that M, Ď  p. We see that  S(u) = {hu, v, v, . . .i}. Hence M, Ď  ON p and it follows  In this section a number of examples are presented. The  that M, Ď  ÂŹOÂŹN p and so M, Ď  ÂŹON ÂŹp.  first example examines the difference between the formula  N OĎ and the formula ON Ď. The second example shows  Hence M, Ď  (ON p â§ ÂŹN Op) and so M, Ď 2  (ON Ď â N OĎ) where Ď = p. Likewise M, Ď   how RoCTL* may be used to specify a robust network pro-  (N OÂŹp â§ ÂŹON ÂŹp), so M, Ď 2 (N OĎ â ON Ď) where  tocol. Then an example of feeding a cat will be introduced  Ď = ÂŹp.  to explain how we may reason about consequences of po-  Example 16. In the coordinated attack problem we have  lices. These examples will frequently use the N/â operator  two generals X and Y . General X wants to organise an  to form the pair ON. In the final example we use the simple  attack with Y . A communication protocol will be presented  formula O(4F e â F w) which nests N/â in a less trivial  such that a coordinated attack will occur if no more than  way.  one message is lost.  Example 15. Here is an example of a simple Contrary-to-  AG (sX â ON rY ): If X sends a message, Y should re-  Duty obligation. This provides a counter example to both  ceive it at the next step.  ON Ď â N OĎ and N OĎ â ON Ď.  AG (ÂŹsX â ÂŹN rY ): If X does not send a message now,  ON (Gp): You should commit to the proper decision.  Y will not receive a message at the next step.  N O (GÂŹp â¨ Gp): Once you have made your decision, you  AG(fX â AGfX ): If X commits to an attack, X cannot  must stick with it.  withdraw.  It is consistent with the above that we do not make the  AG(fX â ÂŹsX ): If X has committed to an attack, it is too  proper decision (N ÂŹp). Once we have made the wrong  late to send messages.  decision we cannot satisfy Gp, so we must stick with the  A (ÂŹfX W rX ): X cannot commit to an attack until X has  wrong decision GÂŹp. Hence, in this case, both ON (Gp)  received plans from Y  and N O(GÂŹp) are true. Likewise ON (GÂŹp) and N O(Gp)  are false. This demonstrates how obligations can change  Similar constraints to the above also apply to Y . Below we  with time in RoCTL*. We will now give an example of a  add a constraints requiring X to be the general planning the  structure M = (A, R, g) that satisfies these formulĂŚ:  attack  A (ÂŹsY W rY ): General Y will not send a message until Y  A = {u, v, w, w0 },  has received a message.  R = {(u, v), (v, v), (u, w0 ) , (w0 , w) (w, w)} ,  g(v) = {p} ,  g(w) = g (u) = â,  No protocol exists to satisfy the original coordination prob-  g(w0 ) = {v} .  lem, since an unbounded number of messages can be lost.  Here we only attempt to ensure correct behaviour if one or  v{p}  fewer messages are lost.  u  A (sX U rX ): General X will send plans until a response is  w0 {v}  received.  w  AG (rX â fX ): Once general X receives a response, X  will commit to an attack.  Let Ď be the fullpath hu, w, w, . . . i corresponding to  making the wrong decision. We see that M, ĎâĽ1  ÂŹp, so  A (ÂŹrY W (rY â§ (sY â§ N sY â§ N N fY ))): Once general  M, ĎâĽ1  OÂŹp and M, ĎâĽ1  ÂŹOp. Thus M, Ď  N OÂŹp  Y receives plans, Y will send two messages to X and  and M, Ď  N ÂŹOp. It follows that M, Ď  ÂŹN Op.  then commit to an attack.  5  Having the formal statement of the policy above and the se-  be derived, indicating that following a policy requiring us  mantics of RoCTL* we may prove that the policy ĎĚ is con-  to always attempt to fill the cat bowl ensures that we will  sistent and that it implies correct behaviour even if a single  not starve the cat even if we make a single mistake. Thus  failure occurs:  following this simpler policy is sufficient to discharge our  original obligation.  ĎĚ â ONF (fX â§ fY ) .  Example 18. Say that a bit ought to flip at every step, but  might fail to flip at any particular step. This may be rep-  Indeed, we have shown that such issues can be decided  resented with the RoCTL* statement AGO (b â ÂŹN b) â§  in finite time [19] .  AG4 (b â N b), which is satisfied by the following model:  For a more thorough specification of the Coordinated Attack problem, see for example [20, 22]. .  {}  {b}  Example 17. We have a cat that does not eat the hour after  it has eaten. If the cat bowl is empty we might forget to fill  {v}  it. We must ensure that the cat never goes hungry, even if  {b, v}  we forget to fill the cat bowl one hour. At the beginning of  the first hour, the cat bowl is full. We have the following  variables:  Then we may derive the following statements:  b âThe cat bowl is full at the beginning of this hourâ  ON((b â§ N b) â N G (b â ÂŹN b)) If a single failure occurs, and the bit fails to flip at the next step, it will  d âThis hour is feeding timeâ  flip continuously from then on.  We can translate the statements above into RoCTL* stateONF G (b â ÂŹN b) Even if a single failure occurs, there  ments:  will be time at which the bit will flip correctly from  1. AG(d â ÂŹN d): If this hour is feeding time, the next  then on.  is not.  However, we will not be able to derive OF NG (b â ÂŹN b),  2. AG((d â¨ ÂŹb) â âN ÂŹb): If it is feeding time or the  as this would mean that there was a time at which a failure  cat bowl was empty, a single failure may result in an  could not cause the bit to miss a step.  empty bowl at the next step  Example 19. We define a system that will warn the user if  3. AG((ÂŹd â§ b) â N b): If the bowl is full and it is not  the system enters an unsafe state:  feeding time, the bowl will be full at the beginning of  the next hour.  1. AGON s: The system should always ensure that the  system reaches a safe state by the next step.  4. ONG (d â b): It is obligatory that, even if a single  failure occurs, it is always the case that the bowl must  2. AG(s â N ÂŹe): If the system is in a safe state an error  be full at feeding time.  e will not occur at the next step.  5. b: The cat bowl starts full.  3. s â§ ÂŹe: The system starts in a safe state with no error.  Having the formalised the policy it can be proven that the  4. AG(ÂŹs â N w): If the system is in an unsafe state,  policy is consistent and that the policy implies ONGON b,  the system will warn the user at the next step.  indicating that the bowl must be filled at every step (in case  we forget at the next step), unless we have already failed  We may prove that if an error e almost occurs, the system  twice. The formula AGON b â ONG (d â b) can also  will finally warn the user, i.e. O(4F e â F w).  6  Example 20. Say that we have wireless sensor and a base  ways have power (NGĎ). As with the A operator in CTL*,  station. Upon detecting some event, the wireless sensor will  NGĎ â GNĎ is valid in RoCTL* but GNĎ â NGĎ is not.  activate and send three packets to the base station. The base  station will not know that the wireless sensor sent data if all  4. Expressivity  three packets were lost. Thus an error will be reported iff  the base station receives either one or two packets. This can  We will define a translation of 4Ď into CTL*, for any  be formalised as  CTL* formula Ď. We will first translate Ď into counter-free  s â§ N s â§ N N s â§ N N N GÂŹs: The sensor will send three  BĂźchi automata A, we will then define a function Ď4 from  packets.  automata to automata such Ď4 (A) is equivalent to 4Ď, and  AG (s â ON r â§ ÂŹs â N ÂŹs): If a packet is sent, it  translate Ď4 (A) into CTL*. This allows us to recursively  should be received at the next step. If it is not sent it will  translate any RoCTL* formula into an equivalent CTL* for-  not be received.  mula.  ÂŹN ((r â§ N r â§ N N r) â¨ GÂŹr) â N N N e: An error  4.1  will be detected if some packets, but not all three, are re-  CTL* and LTL  ceived.  Theorem 22. A language L is definable in LTL iff L is ac-  It follows that ON (4F eU ÂŹs), indicating that it is ro-  cepted by some counter-free BĂźchi automaton [7].  bustly true that if an additional failure occurs, an error could  be detected. In this example a failure may not indicate a  It is well known that we can express a CTL* formula as  packet being dropped, e.g. it has not been specified whether  an LTL formula over a path, where that path includes state  the packet arrives corrupted. Thus the system cannot de-  formula as atoms; this is commonly used in model checking  tect all failures. In RoCTL* it is impossible to specify that  [8, 9, 5]. From the above theorem we can also express this  a failure will have an effect. At best we can specify that  LTL formula as a BĂźchi automaton.  it is always possible for a failure to be detected. However,  Formally, for any CTL* formula Ď there exists a set  we can specify that some particular effect will be detected.  of state formulas ÎŚ and a counter-free automaton A =  For example, we can express the statement âEven if two or  (2ÎŚ , S, S0 , Î´, F ) such that A accepts gÎŚ (Ď) iff M, Ď  Ď.  fewer packets are lost, either all packets arrive or an error is  We say an automaton A = (2ÎŚ , S, S0 , Î´, F ) is equivalent to  detectedâ as  a formula Ď iff  ONNN ((r â§ N r â§ N N r) â¨ F e) .  (âM,Ď M, Ď  Ď) ââ (A accepts gÎŚ (Ď)) .  Example 21. Say a system has a battery that can sustain  Definition 23. Let A be a function from CTL* formulas to  the system for a single step, even if a failure occurs (the  counter-free BĂźchi automata such that A (Ď) is equivalent to  fuse blows). Let Ď represent âthe system has power now  Ď. Likewise let Aâ1 be a function from counter-free BĂźchi  and at the next stepâ. Then, even if a single failure occurs,  automata of the form A = (2ÎŚ , S, S0 , Î´, F ) to CTL* formu-  it will always be the case that even if a deviating event oc-  las, such that we have Ď  Aâ1 (A) iff A accepts gÎŚ (Ď).  curs the system will have power now and at the next step  (OGNĎ). It would not follow that even if a single failure  4.2  Construction of Ď4 (A) from A.  occurred the system would always have power (ONGĎ);  the battery power would only last one step after the fuse  In this section we define the function Ď4 from counter-  blew. If we also specified that the fuse was an electronic  free BĂźchi automata to automata as follows. The intention is  fuse that automatically reset, then if a single failure occurs,  that if A is equivalent to Ď, then Ď4 (A) will be equivalent to  the system would only have to rely on battery power for one  4Ď. For any counter-free automata A = 2ÎŚ , S, S0 , Î´, F ,  step. Then, if the fuse only blows once then system will al-  it is the case that Ď4 (A) = 2ÎŚ4 , S4 , S0 , Î´4 , F4 where  7  1. ÎŚ4 = ÎŚ âŞ Î¨ where Î¨ = {Ďs : s â S} and Ďs is the  If s = sF then every word u is in Ls,s . If s 6= sF then  following state formula for each s in S:  every path from s to s in Ď4 (A) is also a path from s to s  in A, and A is counter-free.      E Aâ1 2ÎŚ , S, {s} , Î´, F â§ N N GÂŹv  4.3  Recursive Translation Function  Ďs is roughly equivalent to saying âif we are in state s,  We can now translate a RoCTL* formula Ď into a CTL*  we can deviate hereâ.  formula c (Ď) using the recursively defined function c:  2. We add a state sF indicating that there existed an accepting deviation from this path and so we shall accept  c(Ď â§ Ď)  =  c (Ď) â§ c (Ď)  c(ÂŹĎ)  =  ÂŹc(Ď)  c(AĎ)  =  Ac (Ď)  c(OĎ)  =  A (N GÂŹv â c (Ď))  c(N Ď)  =  N c(Ď)  is possible and remain in that state regardless of the  c(ĎU Ď)  =  c(Ď)U c(Ď)  input along the current path. That is, Î´4 it the minimal  c(NĎ)  =  ÂŹf4 (ÂŹĎ)  relation satisfying:  f4 (Ď)  =  Aâ1 (Ď4 (A (Ď))) .  regardless of further input. This input relates to the  original path rather than the deviation and is thus irrelevant. As such, S4 = S âŞ sF and F4 = F âŞ sF .  3. Î´4 is the relation that includes Î´ but at each state also  gives the option to branch into sF when a deviation  (a) For every tuple hs, e, ti in Î´ and set Î â 2Î¨ the  4.4  tuple hs, e âŞ Î, ti is in Î´4 . This is to ensure that  Proof of Correctness  wherever gÎŚ (Ď) is a run of A, it is also the case  Lemma 25. For all structures M , fullpaths Ď and CTL*  that gÎŚ4 (Ď) is a run of Ď4 (A). The use of Î  formulas Ď, it is the case that M, Ď  Aâ1 (Ď4 (A (Ď))) iff  is only required because Î´4 has to deal with the  M, Ď  4Ď.  atoms in Î¨, which are not in gÎŚ4 (Ď) but not in  Proof. As above, let A = 2ÎŚ , S, S0 , Î´, F be A (Ď); let  gÎŚ (Ď).  Ď4 (A) = 2ÎŚ4 , S4 , S0 , Î´4 , F4 be the automaton con-  (b) For each s â S and each e4 â 2ÎŚ4 such that  structed from A, and let Ď4 = Aâ1 (Ď4 (A (Ď))).  Ďs â e4 we have hs, e4 , sF i in Î´4 .  Fix a structure M . We will write M, Ď  Ď as Ď  Ď.  (c) For each e4 in 2ÎŚ4 we have hsF , e4 , sF i in Î´4 .  (â=) Say that Ď  4Ď.  Case 1: Ď  Ď; then A accepts gÎŚ (Ď). Thus Ď4 (A)  To understand (1) above, say we have read i symbols  from the current path Ď, and are in state s.  accepts gÎŚ4 (Ď) (see 3a above). Thus Ď  Ď4 .  Clearly  accepts ĎâĽi then then A accepts  Case 2: Ď 2 Ď; then there exists a path Ď  Ď and inte-  Ď. As an i-deviation Ď would share the prefix Ďâ¤i , if  ger i such that Ďâ¤i = Ďâ¤i and ĎâĽi+1 is failure free. Hence  if  2ÎŚ , S, {s} , Î´, F  2ÎŚ , S, {s} , Î´, F  accepts ĎâĽi then A accepts Ď.  hgÎŚ (Ď0 ) , gÎŚ (Ď1 ) , . . .i â L (A). Thus there exists a se-  The  gÎŚ (Ď0 )  â s1  gÎŚ (Ď1 )  â ÂˇÂˇÂˇ  N N GÂŹv ensures that Ďs is satisfied only on paths that de-  quence of states s0 , s1 , . . . such that s0  viate here, i.e. that are i-deviations.  is an accepting run for A. It is easy to show that si  si+1  The items (b) and (c) above allow us to ignore all further  gÎŚ (Ďi+1 )  â  Thus ĎiâĽi  input on the current path if we can satisfy Ď on a deviation.  gÎŚ (Ďi )  â  ÎŚ  Âˇ Âˇ Âˇ is an accepting run of 2 , S, {si } , Î´, F .     Aâ1 2ÎŚ , S, {si } , Î´, F . As ĎâĽi+1 is fail-  ure free ĎâĽi  N N GÂŹv, hence we have  Lemma 24. The automaton Ď4 (A) is counter-free.      E Aâ1 2ÎŚ , S, {si } , Î´, F â§ N N GÂŹv  Proof. Recall that a counter-free automaton is an automaton such that for all states s â S and words u in ÎŁâ , if  um â Ls,s then u â Ls,s .  From 3a above, s0  8  gÎŚ4 (Ď0 )  â  s1  gÎŚ4 (Ď1 )  â  =  ÂˇÂˇÂˇ  Ďsi â gÎŚ4 (Ďi ) .  gÎŚ4 (Ďiâ1 )  â  si  As Ďsi â gÎŚ4 (Ďi ) it fol-  We will do this by taking a class of labeled trees which  â Î´4 . Also  we will call (h, l)-utrees, where h represents the height h  hsF , e4 , sF i â Î´4 for all e4 in 2ÎŚ . As Ďâ¤i = Ďâ¤i it fol-  and l is the number of bits per label. We will show that the  is a path through Ď4 (A).  lows from 3b above that si , gÎŚ4 (si ) , sF  lows that s0  gÎŚ4 (Ď0 )  â  s1  gÎŚ4 (Ď1 )  â  number #(h, l), of pairwise non-isomorphic (h, l)-utrees,  Âˇ Âˇ Âˇ is an accepting run for  is non-elementary in h. We will then present âsuffixâ and  âprefixâ encodings of utrees into RoCTL-structures, and  Ď4 (A). Thus Ď  Aâ1 (Ď4 (A)) = Ď4 .  (=â) Say that M, Ď  Ď4 . Thus there is an accepting  run s0  gÎŚ4 (Ď0 )  â  Case 1: s0  s1  gÎŚ4 (Ď1 )  â  gÎŚ (Ď0 )  â  gÎŚ (Ď1 )  â  s1  will define a function u such that u(T, T 0 ) = M where  Âˇ Âˇ Âˇ for Ď4 (A).  M is the structure that results when the prefix encoding of  Âˇ Âˇ Âˇ is an accepting run for  T is joined/followed by the suffix encoding of T 0 . For each  A. Then Ď  Ď and so Ď  4Ď.  gÎŚ (Ď0 )  â  Case 2: s0  gÎŚ (Ď1 )  â  s1  positive h and l we define a RoCTL* formula f (h, l) such  Âˇ Âˇ Âˇ is not an accept-  that for any pair of utrees T and T 0 of height h it is the case  ing run for A. Thus the automaton must eventually enter  state sF , so the run has a prefix of the form s0  gÎŚ4 (Ď1 )  gÎŚ4 (Ďiâ1 )  gÎŚ4 (Ďi )  that u(T, T 0 ) satisfies f (h, l) iff T, T 0 are isomorphic. For  gÎŚ4 (Ď0 )  â  an automaton that accepts the tree-unwinding of u(T, T 0 )  We know  iff T and T 0 are isomorphic, once the automaton has read  from the definition of Ď4 above that Ďsi â gÎŚ4 (Ďi ).    Thus ĎiâĽ1  E Aâ1 (ÎŁ, S, {si } , Î´, F ) â§ N N GÂŹv and  the prefix encoding, the state of the automaton must give  so there exists a path Ď such that Ďâ¤i = Ďâ¤i , ĎâĽi+1 is  morphic equivalence classes T fell into. As #(h, l) is non-  failure-free and ĎâĽi  Aâ1 (ÎŁ, S, {si } , Î´, F ). It follows  elementary in h, the number of states in the automata must  that hÎŁ, S, {si } , Î´, F i accepts ĎâĽi and so there exists an  also be non-elementary in h. Since there are elementary  â  s1  ÂˇÂˇÂˇ  â  g(Ďi )  accepting run si â si+1  g(Ď0 )  g(Ď1 )  s0 â s1 â Âˇ Âˇ Âˇ  g(Ďiâ1 )  â  si  g(Ďi+1 )  â  â  sF .  us enough information to determine which of #(h, l) iso-  translations of CTL* into automata, we will conclude that  Âˇ Âˇ Âˇ . We see that the path  there is no elementary translation of RoCTL* into CTL*.  si through Ď4 (A) is also a path  through A. Thus  g(Ď0 )  Definition 27. We define isomorphism on finite labelled  g(Ď1 )  g(Ďi )  s0 â s1 â Âˇ Âˇ Âˇ si â si+1  is a run of A.  g(Ďi+1 )  â  trees recursively. We say that T = (A, R, g) and T 0 =  ÂˇÂˇÂˇ  (A0 , R0 , g 0 ) are isomorphic if g (root (T )) = g 0 (root (T 0 ))    0  and   there exist orderings C = C1 , . . . , C|C| and C =  0  C10 , . . . , C|C|  of the direct subtrees of T and T 0 respec-  States in F occur in finitely often in  si , si+1 , . . . and hence this run is an accepting run of A.  tively such that Ci and Ci0 are isomorphic for all i â [1, |C|].  Hence Ď  Ď. As Ď is a deviation from Ď it follows that  We define utrees below such that all (h, l)-utrees have  Ď  4Ď.  the same number of direct subtrees, which are pairwise nonTheorem 26. There exists a satisfaction preserving trans-  isomorphic. For any pair T, T 0 of (h, l)-utrees, this ensures  lation function from RoCTL* to CTL*.  that if there is a direct subtree of T that is not isomorphic  Proof. Using Lemma 24 it is easy to show that the transla-  to any subtree of T 0 , there must also be a direct subtree of  tion function c from Section 4.3 is well defined, and from  T 0 that is not isomorphic to any subtree of T . This makes it  Lemma 25 it is easy to show that c is satisfaction preserv-  easier to test whether a pair of utrees are isomorphic.  ing.  Definition 28. We define the concept of a utree recursively.  We fix an infinite enumerated set VĎ = {b1 , b2 , . . .}. A  tree T = hA, R, gi consisting of a single node n is a (0, l)-  5. Succinctness  utree iff g(n) â Vl where Vl = {b1 , b2 , . . . bl }. We let  In the previous section we showed that a satisfaction pre-  # (h, l) be the number of pairwise non-isomorphic (h, l)-  serving translation from RoCTL* to CTL* exists. In this  utrees; then a tree T is a (h + 1, l)-utree iff g(root (T )) = â  section we will show that any satisfaction preserving trans-  and T has b# (h, l) /2c direct subtrees, which are pairwise  lation is non-elementary in the length of the formulas.  non-isomorphic (h, l)-utrees.  9  Example 29. Here is an example (1, 2)-utree. We use â11â  I{  as shorthand for b1 , b2 and â01â as shorthand for b2 .  tion of a direct subtree of the tree we were describing. The current world also encodes the  n1  label of this subtree.  I}  n2 {01}  This atom indicates that we begin the descrip-  n3 {11}  This atom indicates that we are ending the description of some tree.  tC  Lemma 30. The function # (h, l) is at least (h + 1)-  This indicates that the description of the subtree C starts here. This is not used in function  exponential in l.  f below. It is only included to allow sections of  the encoding to be easily and unambiguously  referenced in the proof of correctness.  Proof. We see that the number of pairwise non-isomorphic  (0, l)-utrees is 2l . From the definition of utrees where n =  2 b# (h, l) /2c,  Hk  n!  of a tree of height k, we are at a node of height  n n  2  2!2!  n.n â 1 . . . n2 . . . 2.1   n    n  2 . . . . .2.1  2 . . . . .2.1    n (n â 1) . . . n2 + 1  n    âĽ 2( 2 )  n  .  .  .  .  .2.1  2  k. Thus I{ â§ H3 means we are beginning the  # (h + 1, l) âĽ nC  =  =  The current input character describes the start  n  =  definition of a tree of height 3 and I} â§ H3  means we are ending the definition of a tree of  height 3.  .  The final world in the prefix encoding is wZ ; the prefix en-  Thus when # (h, l) is j-exponential in l, it is the case that  coding is not a transition structure as wZ has no successor.  # (h + 1, l) is (j + 1)-exponential in l. As # (0, l) is one  Example 31. Below we present the prefix encoding of the  exponential in l it follows from induction that # (h, l) is at  utree T from Example 29.  least (h + 1)-exponential in l.  w0 {I{ , H1 , tT }  Algorithm 1 can be used to describe the structure of a tree  w1 {I{ , H0 , 01, t(n2 ,â,{n2 7â01}) }  using a string of â{â and â}â characters; strictly speaking  for each must iterate over the subtrees in some order, but  w2 {I} , H0 }  the ordering chosen is unimportant and will not be defined  here. E.g. â{}â represents a tree with a single node, and  w3 {I{ , H0 , 11, t(n3 ,â,{n3 7â11}) }  w4 {I} , H0 }  â{{}{}}â represents a tree where the root has two root nodes  as successors.  w5 {I} , H1 }  Algorithm 1 PrintTree(T )  1: Print â{â  2: for each direct subtree D of T : PrintTree()  3: Print â}â  wZ  Algorithm 2 T2prefix(T )  1: (g, i):=T2g(T ,â,0)  2: A := domain (g) âŞ {wZ }  3: â := {(wjâ1 , wj ) : j â [1, i)} âŞ (wi , wZ )  4: return(A, â, g)  Algorithms 2 and 3 for outputting the prefix encoding  prefix (T ) of T are similar. The function prefix is from  utrees to labelled trees where each node has degree of at  tree, the prefix encoding also uses the following atoms as  We now define the suffix encoding suffix (T ) of a tree    T = AT , RT , g T . In addition to the atoms used in the la-  labels, where h is the height of the tree and k â [0, h].  belling of the input tree T , the suffix encoding uses: the  most one. In addition to the atoms used to label the input  10  g(w) = g S (w) if w â AS , g (w) = g P (w) if w â AP ,  Algorithm 3 T2g(T ,g,i)    1: AT , RT , g T :=T  2: g[wi ]:={I{ , Hheight(T ) , tT } âŞ g T (root (T )); i++  3: for each direct subtree C of T: (g, i):=T2g(C,g,i)  4: g[wi ]:={I} , Hheight(T ) }; i++  5: return(g, i)  R = RS âŞ RP âŞ {(wZ , root (T 0 ))}.  Definition 34. We say that a structure M satisfies a formula  Ď iff there exists a path Ď such that M, Ď  Ď.  Definition 35. Let us define a function f as follows from  pairs of natural numbers to RoCTL* formulas:  violation atom v from RoCTL*; and HkF for k in [0, h]  which is used to indicate the height of the current node  f (0, l) =  in the tree, much like Hk is used in the prefix encoding.    Let N = n1 , . . . , n|N | be the set of nodes in the tree  ^  bi â F H0F â§ bi    â§  iâ[1,l]  ^  T . Let N 0 bena numbered o  set such that |N | = |N 0 |;  0  0  0  that is N = n1 , . . . , n|N | . Then for all trees T , if  ÂŹbi â F H0F â§ ÂŹbi    iâ[1,l]  f (k, l) =  (A, R, g) = suffix (T ) we have  1. A = N âŞ N 0 âŞ {nZ }        I{ â§ Hkâ1 â 4f (k â 1, l) U I} â§ Hk    â§ F HkF â§ I{ â§ Hk  Recall that F Ď is shorthand for (>U Ď), and as such  2. R is the minimal relation satisfying: R â RT ,  M, Ď  F Ď ââ âi M, ĎâĽi  Ď.  and {(ni, n0i ) , (n0i , nZ ) , (nZ , nZ )} â R, for all i â  The intuition behind f is that a path Ď through  [1, |N |].  u (T, T 0 ) = hA, R, gi can correspond to both a subtree of  T and a subtree T 0 ; if tC â g (Ď0 ) then Ď starts at the be-  3. the valuation g is the valuation satisfying g(ni ) =  ginning of the prefix encoding of some subtree C of T , and  {v}; g (nZ ) = â and  g (n0i )  =  if n0C 0 is in Ď then Ď corresponds to some subtree C 0 of T 0 .  n  F  g T (ni ) âŞ Hheight  o  RT  (ni )  The formula f (0, l) is satisfied if the labels of C and C 0  .  match, so f (0, l) is satisfied iff C and C 0 are isomorphic  Example 32. Below we present the suffix encoding of the  leafs. A deviation from the current path can only have one  utree from Example 29.  additional failure, and hence only one additional edge. So,  where n0C 0 is in Ď, then for each subtree D0 of T 0 satisfying  n1 {v}  height (D0 ) = height (C) â 1 there exists a deviation from  Ď containing n0D0 iff D0 is a direct subtree of C 0 . As such,  n3 {v}  n2 {v}  4f (0, l) is satisfied exactly on those paths that correspond  to subtrees C and D0 such that C has a direct subtree iso-  n01 {H1F }  n02 {01, H0F }  morphic to D0 . We use this intuition and recursion to prove  the following lemma.  n03 {11, H0F }  Lemma 36. For any integers u and l, if T and T 0 are (u, l)utrees then u (T, T 0 ) satisfies f (u, l) iff T and T 0 are iso-  nZ  morphic.  Definition 33. We let u (T, T 0 ) be the model that re-  Proof. For each subtree C of T , let wC be the world that is  sults when we join the prefix encoding of T to the suf-  the beginning of the suffix encoding of C, or more formally  0  0  the world where tC is true. For any path, Ď we define ĎâĽC  fix encoding of T by adding (wZ , root (T )) to R. For  mally, where AP , RP , g P is the prefix encoding of T    and AS , RS , g S is the suffix encoding of T 0 , it is the  0  case that u (T, T ) = (A, R, g) where A = A  P  such that ĎâĽC = ĎâĽi where Ďi = wC .  (=â) Say that u (T, T 0 ) , Ď T  f (u, l) for some Ď T .  S  We see that Ď0T = w0 as f (u, l)  I{ â§ Hu . We define Ď C  âŞA ,  11    AT , R T , g T .  recursively for each subtree C of T . Say we have defined  the path Ď C for some subtree C such that u (T, T 0 ) , Ď C   Likewise let nC be the node that is the root of the sub-  f (k, l) where k is the height of C. Then for each direct  tree C. We define Ď C recursively as follows: let Ď T be  C  ĎâĽD   4f (k â 1, l) and thus  the fullpath starting at w0 that passes through n00 ; that is,  C  there must exist a deviation from ĎâĽD  satisfying f (kâ1, l),  D  we call this deviation Ď .  Ď T = hw0 , . . . , wZ , nT , n0T , nZ , nZ , . . .i. Say that D is  subtree D of C, we see that  0  the direct subtree of C, then where  n0C 0  We see that for each C there is a unique C such that  is in the path Ď C . In the following paragraph we will show  Ď C = hwC , . . . , wD , . . . , wZ , nT , . . . , nC , n0C , nZ , nZ , . . .i  that for each subtree C and direct subtree D of C, we can  we let  C  produce Ď D from ĎâĽD  by replacing n0C 0 with nD0 n0D0 , and  hence that D0 is a direct subtree of C 0 .  Consider where Ď  first world in Ď  in both Ď  C  D  D  deviates from  not in Ď  C  C  ĎâĽD  .  Ď D = hwD , . . . , wZ , nT , . . . , nC , nD , n0D , nZ , nZ , . . .i .  Say ny is the  and that nx is the last world  C  In other words, we produce ĎâĽD  from Ď C by pruning ev-  and Ď . From the definition of deviations we  C  erything prior to wD , and Ď D from ĎâĽD  and replacing n0C  D  D  see that ĎâĽn  is failure-free and  y  0  must be nB . Since Ď D  F HkF  D it follows that HkF â g (n0B );  so the next world on Ď  D  with nD , n0D . This remains a full path, since D is a direct  where k is the height of  subtree of C, and so nD is a child of nC . Note also that Ď D  from the structure of the  C  is a deviation from ĎâĽD  .  suffix encoding it is clear that B is a direct subtree of A,  As each  If height (C) = 0 it is easy to verify that Ď C  f (0, l),      as g (wC ) âŞ H0F = g (nC ) âŞ H0 , tC , I{ . For C of  parent has a height greater than that of its direct subtrees, it  height k, it is likewise easy to see that Ď C  F HkF . Assume  and height (A) = k + 1 and thus  follows that n  C0  n0C 0 ,  F  Hk+1  in  g (n0A ).  C  is the only world in Ď such that  F  Hk+1  â  that Ď C  f (k â 1, l) for all C of height k â 1 [expand].  and hence it follows that nx = nC 0 .  Now consider C of height k. It is easy to show that  Consider D of height 0. The path Ď D is of the form  ďŁŤ  ďŁś  _  Ď C  ďŁ­ I{ â§ Hkâ1 â    hwD , . . . , wZ , nT , . . . , nC 0 , nD0 , n0D0 , nZ , nZ , . . .i  D  0  It is easy to show that D and D are isomorphic. For each    tD ďŁ¸ U I} â§ Hk .  is child of C  By assumption Ď D  f (kâ1, l), and Ď D is a deviation from  C, we choose C 0 such that n0C 0 is in the full path Ď C . Say  C  C  ĎâĽD  , so ĎâĽD   4f (k â 1, l). Thus  0  that for every D of height k it is the case that D and D are  isomorphic. Consider C of height k + 1. We have shown  that for each direct subtree D of C, it is the case that D0  ĎC   is a direct subtree of C 0 . As C must have the same height        I{ â§ Hkâ1 â 4f (k â 1) U I} â§ Hk .  Thus Ď C  f (k, l). By induction u (T, T 0 ) , Ď T  f (u, l).  F  as C 0 (otherwise the requirement that Ď  F Hk+1  would  not be satisfied), C 0 and C have the same number of direct  subtrees, each of height k. We have show previously that  Example 37. In Lemma 36 above, we proved that  0  for each direct subtree D of C, it is also the case that D is  u (T, T 0 ) , Ď T  f (u, l) for some Ď T iff T and T 0 are iso-  a direct subtree of C 0 . By assumption, each pair D, D0 are  morphic. Using T as the tree in Example 29, let  isomorphic, and so C, C 0 are isomorphic. By induction T  Ď 0 = hw0 , . . . , wZ , n1 , n01 , nZ , . . .i  and T 0 are isomorphic.  (â=) Say that T 0 and T are isomorphic. Clearly suf-  Ď 1 = hw1 , . . . , wZ , n1 , n2 , n02 , nZ , . . .i  fix encodings of T 0 and T will also be isomorphic, and  Ď 2 = hw3 , . . . , wZ , n1 , n3 , n03 , nZ , . . .i  so u (T, T 0 ) satisfies f (u, l) iff u (T, T ) does. Thus we  can assume without loss of generality that T = T 0 =  be paths through u (T, T ). We see that Ď 1 and Ď 2 sat12  0  isfy f (0, 2). As Ď 1 and Ď 2 are deviations from ĎâĽ1  and  0  ĎâĽ3  respectively, it is the case that  0  ĎâĽ1  and  0  ĎâĽ3  There are a number of translations of Âľ-calculus into al-  satisfy  ternating automata, Wilke gives a simple translation that  4f (0, 2). Thus wherever I{ â§ H0 is true, it is also the  does not assume that the tree has any particular struc-  0  case that 4f (0, 2) is true; hence u (T, T ) , Ď  f (1, 2).  ture [24]. The states in the resulting automata are subfor-  Definition 38. We say an automaton A accepts a structure  mulas of the Âľ-calculus formula. Hence the translation into  alternating automata is linear.  M iff the tree unwinding of M is a member of L (A).  Lemma 39. For any arbitrary h, l â N, let A =  The translation via Âľ-calculus above is sufficient for this  (ÎŁ, S, S0 , Î´, F ) be an SAA such that for any pair T, T 0 of  paper. There are translations that result in more optimised  (h, l)-utrees A accepts u (T, T 0 ) iff T and T 0 are isomor-  model checking and decision procedure results [15].  phic; then 2|S| âĽ # (h, l).    Proof. Let T1 , T2 , . . . , T#(h,l)  Corollary 41. For all fixed h âĽ 1, there is no function e  non-isomorphic (h, l)-utrees.  which is less than (h â 1)-exponential, such that the length  be a set of pairwise  For each i, let Ri  |Ďl | of the shortest CTL* formula Ďl âĄ f (h, l) satisfies  =  hARi , gRi , RRi i be an accepting run of A on u (Ti , Ti ); let  |Ďl | < e (l) for all l.  Qi be the set of all states that the automata is in after read-  Proof. Say e exists. Since Ďl âĄ f (h, l) then there ex-  ing the prefix encoding of Ti ; formally let Qi â S be the  ists a fullpath Ď T starting at w0 through u(T, T 0 ) such that  set of states such that for all q â S we have q â Qi iff there  u(T, T 0 ), Ď T  Ďl iff T and T 0 are isomorphic. As e is less  exists wR â ARi such that (root (Ti ) , q) â gRi (wR ). Re-  than (h â 1)-exponential, from Theorem 40 the size of the  call that root (Ti ) is the beginning of the suffix encoding of  SAA is less than h-exponential in l.  From Lemma 39, we have 2n âĽ # (h, l) where n is the  u (Ti , Ti ).  Say that Qi = Qj for some i 6= j. Let Aq be shorthand  size of the automata, and from Lemma 30 we know that  for (ÎŁ, S, {q} , Î´, F ). In the next paragraph we will define a  # (h, l) is (h + 1)-exponential in l. Hence 2n is at least  run  Rji  with the prefix from the run Rj and the suffix from  (h + 1)-exponential in l, and so n is at least h-exponential  Ri .  in l. By contradiction no such e exists.  Since all infinite paths of the run Ri are accepting, we see  that for each q â Q , the relevant subtree Rsuffix of R is an  i  Corollary 42. For all fixed h âĽ 2, there is no function  i  i,q  e which is less than (h â 2)-exponential such that for all  accepting run for Aq on the suffix encoding of Ti . Let Rji be  RoCTL* formulas Ď with at most h nested 4 (or N), the  the tree that results when we replace the subtree beginning  at w with Rsuffix , for each q â Q = Q and w â A  R  i,q  i  j  R  length |Ď| of the shortest CTL* formula Ď equivalent to Ď  Ri  is no more than e (|Ď|).  satisfying gRj (wR ) = (root (Tj ) , q). It is easy to show  that Rji is an accepting run of A on u (Tj , Ti ). However  Proof. This follows from the above corollary, and the fact  we have assumed that Ti is not isomorphic to Tj , and so A  that f (h, l) has at most h nested 4 and |f (h, l)| â  does not accept u (Tj , Ti ). By contradiction Qi 6= Qj for  O (h + l).  S  any i, j â [1, # (h, l)] such that i 6= j. As each Qi â 2 ,  Theorem 43. There is no satisfaction preserving transla-  we can conclude from the pigeon hole principle that 2|S| âĽ  tion from RoCTL* to CTL* that is elementary in the length  # (h, l).  of the formula.  Theorem 40. Given a CTL* formula Ď we can construct an  Obvious from the above Corollary; if there were an i-  SAA AĎ with a number of states that is singly exponential  exponential translation of RoCTL* into CTL* for any i â  in the length of Ď.  N there would be an i-exponential translation of RoCTL*  formulas with i + 3 nested 4 operators.  Proof. Dam provides a translation of CTL* formulas into  We see that the only non-classical operators in f (h, l)  equivlent Âľ-calculus. The nodes are sets of formulas, so  are positively occurring â, U and F . Since F Ď is short  this is a singly exponential translation.  13  hand for >U Ď we see that alternations between positively  las. While in other logics non-elementary blowup is fre-  occurring U and 4 are sufficient to produce non-elementary  quently the result of unbounded alternations between posi-  blowup. By slightly modifying f , we can similarly demon-  tive and negative occurrences of the same operator, we do  strate that alternation between positively occurring N and U  not need to alternate between 4 and N to demonstrate non-  are also sufficient to produce non-elementary blowup. For  example the following f 0 contains only operators equiva-  elementary blow up. Indeed, the only non-classical opera-  lent to negatively occurring U , where W is the weak until  W  operator and H F â i HiF :  We may modify f slightly so that it only contains positively  tors in the function f were positively occurring U and 4.  occurring U and N.  RoCTL* is known to be decidable, but without a known  f 0 (0, l) =  ^  bi â G H F â H0F â§ bi    â§  elementary upper bound. Our succinctness result shows that  iâ[1,l]  ^  a full translation into CTL* or Tree Automata cannot reÂŹbi â G H F â H0F â§ ÂŹbi    sult in elementary decision procedures. The question still  iâ[1,l]  f 0 (k, l) =  remains as to whether some other elementary decision pro-        I{ â§ Hkâ1 â 4f 0 (k â 1, l) W I} â§ Hk    â§ F HkF â§ I{ â§ Hk  cedure can be found for RoCTL*. The discovery of such  a procedure would be interesting, as this would be the first  modal logic which was elementary to decide but had only  Since there is no elementary translation of f and f 0 into  non-elementary translations into tree automata.  CTL*, there is also no elementary translation of ÂŹf and  ÂŹf 0 into CTL*.  References  [1] H. Aldewereld, D. Grossi, J. Vazquez-Salceda, and  6. Conclusion  F. Dignum. Designing normative behaviour by the use of  landmarks. In Agents, Norms and Institutions for Regulated  We have shown that all RoCTL* formulas can be expressed as an equivalent CTL* formula. This translation  Multiag. Syst., Utrecht, The Netherlands, Jul 2005.  [2] A. Arnold, A. Vincent, and I. Walukiewicz. Games for syn-  can also be used to translate RoBCTL* [17] formulas into  thesis of controllers with partial observation. TCS, 303(1):7â  BCTL* formulas. Once translated into CTL* formula we  34, 2003.  [3] N. Belnap. Backwards and forwards in the modal logic of  can use any of the standard methods for model checking, so  agency. Philos. Phenomen. Res., 51(4):777â807, Dec 1991.  [4] J. Broersen, F. Dignum, V. Dignum, and J.-J. C. Meyer. De-  this result provides us with a model checking procedure for  RoCTL*. As with CTL*, the model checking problem for  signing a Deontic Logic of Deadlines, volume 3065/2004 of  RoCTL* is linear with respect to the size of the model [8].  Classes of RoCTL* formulas with bounded N-complexity  LNCS, pages 43â56. Springer, 2004.  [5] E. M. Clarke, E. A. Emerson, and A. P. Sistla. Automatic  have linear translations into CTL*. Thus as with CTL* the  verification of finite-state concurrent systems using tempo-  model checking problem is also singly exponential [8] with  ral logic specifications. ACM Trans. Program. Lang. Syst.,  respect to the length of these formulas , and satisfiability  is doubly exponential. Multiple nestings of N (or 4) with-  8(2):244â263, 1986.  [6] M. de Weerdt, A. Bos, H. Tonino, and C. Witteveen. A re-  out any form of alternation can also be translated to CTL*  source logic for multi-agent plan merging. Annals of Math.  without increasing the complexity of the translation over a  and AI, 37(1-2):93â130, January 2003.  [7] V. Diekert and P. Gastin. First-order definable languages.  single N operator.  In J. Flum, E. GrĂ¤del, and T. Wilke, editors, Logic and  We have not shown the exact complexity of the transla-  Automata: History and Perspectives, volume 2 of Texts in  tion. However we will attempt to show that there is roughly  Logic and Games, pages 261â306. Amsterdam University  a single exponential blowup per alternation between â (or  N) and U ; never-the-less we expect model checking to be  Press, 2008.  [8] J. Edmund M. Clarke, O. Grumberg, and D. A. Peled. Model  practical for some useful subclasses of RoCTL* formu-  Checking. MIT Press, 1999.  14  [9] E. A. Emerson and C.-L. Lei. Modalities for model checking  [23] L. W. N. van der Torre and Y. Tan. The temporal analysis of  (extended abstract): branching time strikes back. In POPL  Chisholmâs paradox. In T. Senator and B. Buchanan, editors,  â85: Proc. 12th ACM SIGACT-SIGPLAN symp. on Princi-  Proc. 14th Nation. Conf. on AI and 9th Innov. Applic. of AI  ples of programming languages, pages 84â96, New York,  Conf., pages 650â655. AAAI Press, 1998.  [24] T. Wilke and C. albrechts-universitt Zu Kiel. Alternating  NY, USA, 1985. ACM.  tree automata, parity games, and modal Âľ-calculus, 2000.  [10] J. W. Forrester. Gentle murder, or the adverbial samaritan.  J. Philos., 81(4):193â7, April 1984.  [11] T. French, J. C. Mc Cabe-Dansted, and M. Reynolds. A Temporal Logic of Robustness, volume 4720 of LNCS, pages  193â205.  2007.  http://dx.doi.org/10.1007/  978-3-540-74621-8_13.  [12] E. GrĂ¤del, W. Thomas, and T. Wilke. Automata, Logics, and  Infinite Games: A Guide to Current Research. 2002. LNCS,  Vol. 2500 http://www.springer.com/computer/  book/978-3-540-00388-5.  [13] H. Hansson and B. Jonsson. A logic for reasoning about time  and reliability. Formal Aspects of Computing, 6(5):512â535,  1994.  [14] T. JĂŠron, H. Marchand, S. Pinchinat, and M.-O. Cordier. Supervision patterns in discrete event systems diagnosis. In 8th  Internat. Workshop on Discrete Event Syst., pages 262â268,  July 2006.  [15] O. Kupferman and M. Y. Vardi. An automata-theoretic approach to reasoning about infinite-state systems. In Proc  CAVâ00, LNCS, volume 1855, pages 36â52. Springer, 2000.  [16] W. Long, Y. Sato, and M. Horigome. Quantification of sequential failure logic for fault tree analysis. Reliab. Eng.  Syst. Safe., 67:269â274, 2000.  [17] J. C. McCabe-Dansted. A tableau for RoBCTL*. In S. HĂślldobler, C. Lutz, and H. Wansing, editors, JELIA, volume  5293 of LNCS, pages 298â310. Springer, 2008.  [18] L. T. McCarty. Defeasible deontic reasoning. Fundam. Inform., 21(1/2):125â148, 1994.  [19] J. C. Mc Cabe-Dansted, T. French, and M. Reynolds. A  temporal logic of robustness, RoCTL*.  Technical re-  port, UWA, 2007. http://www.csse.uwa.edu.au/  ~john/papers/RoCTL07.pdf.  [20] A. Pancones.  The coordinated attack and the jealous  amazons. http://www.dsi.uniroma1.it/~asd3/  dispense/attack+amazons.pdf.  [21] A. Rodrigo and A. Eduardo. Normative pragmatics for agent  communication languages. In Perspect. Concept. Model.  (LNCS), volume 3770, pages 172â181. Springer, 2005.  [22] F. van der Grijn. (im)possibility of a coordinated attack.  Technical report, University of Amsterdam, June 2004.  http://www.illc.uva.nl/Publications/  ResearchReports/X-2004-05.text.pdf.  15 