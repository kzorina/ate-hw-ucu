2012 19th International Symposium on Temporal Representation and Reasoning  A Metric Temporal Logic for Dealing with Zero-time Transitions  Luca Ferrucci, Dino Mandrioli, Angelo Morzenti, Matteo Rossi  Dipartimento di Elettronica e Informazione - Politecnico di Milano, 20133 Milano, Italy  Email: {ferrucci,mandrioli,morzenti,rossi}@elet.polimi.it  Abstract—Many industrial systems include components interacting with each other that evolve with possibly very  different speeds. To deal with this situation many formalisms  adopt the abstraction of “zero-time transitions”, which do not  consume time. These, however, have several drawbacks in terms  of naturalness and logic consistency, as a system is modeled to  be in different states at the same time. We introduce a metric  temporal logic, called X-TRIO, that uses non-standard analysis  to elegantly deal with zero-time transitions in an abstract,  descriptive way. We study the decidability of the logic, and  we introduce a decision procedure for a subset thereof. XTRIO has been applied in companion works to the design and  veriﬁcation of industrial systems.  occurs in many practical cases, like in hardware devices  where several gate-switches occur during a single clock  period, or in heterogeneous control systems, where different  components evolve at sharply different time granularities,  say microseconds vs. seconds or minutes or even longer  ones.  In such cases, the literature often proposes a sharp distinction between micro- and macro-steps. Normally, only  macro-steps are assumed to ”consume time” — often just  one unit — whereas micro-steps are considered as zerotime transitions. Various operational formalisms, like Timed  Petri nets or variants of the Statecharts notations adopt this  assumption [3]. For such systems, however, the use of ﬁxedduration next-time operator is inadequate.  In temporal logics that adopt a view of system state as  a function of time such a notion of zero-time transition is  however counterintuitive (when a zero-time micro-step is  performed more than one state is associated with a single  time instant), and may lead to logical contradiction.  Some temporal logics adopt instead a time structure where  more than one system state may be associated with a single  time instant [4] and therefore must provide distinct notations  to refer to time and state change. In these notations, the  progress of time and state evolution are fully decoupled,  which is rather unnatural in most practical cases.  In previous work [5], we proposed the adoption of NonStandard Analysis (NSA) to formalize micro-steps. Intuitively, in NSA the domain of any variable is extended by  introducing non-standard numbers, which, roughly speaking,  include inﬁnitesimal quantities: an inﬁnitesimal number is  strictly less than any positive standard one. We exploited  this idea by formalizing micro-steps in terms of transitions  that take a non-null, inﬁnitesimal time in the context of our  metric temporal logic language TRIO.  In this paper, we develop the approach by deﬁning a  framework consisting of: a time domain T enriched with  non-standard numbers; the TRIO temporal logic, providing  a metric on time through the Dist(•, d) operator; a sequence  σ of instants in – the augmented version of – T , in which  the modeled system changes state; a new next operator X to  refer to the next system state, which occurs in a non-standard  time instant in case of a micro-step, or in a standard one in  case of an ordinary (macro-) step.  The overall framework is called X-TRIO: we provide  its syntax and semantics, and prove that the logic is in  I. I NTRODUCTION  In a traditional view of time-dependent systems the state  is a function of time, i.e., the system is in exactly one state  at each time instant. Some (though not all) temporal logics  also adopt this view: formulae refer to an (implicit) time  instant, the (sub)formulae are evaluated with respect to the  unique system state associated with it, and the logic’s modal  operators refer to other time instants and related states.  If the modeled system evolves by discrete computation  steps then a correspondingly discrete underlying time structure is naturally adopted, and the next-time operator (and  possibly, in addition, a previous-time operator) are provided,  such as the X (respectively, Y) operators of Linear Temporal  Logic. The time domain, then consists of the set of the naturals or the integers ; the time taken by each computation  step is uniform, and it corresponds to the adopted time unit,  say, seconds or microseconds.  If a genuinely quantitative notion of time is adopted for  modeling strict real-time features, or a need arises to characterize asynchronous behaviors, the underlying time domain  may be dense or continuous, like the set of real numbers,  and modal operators are provided such as Dist(•, d) of  TRIO [1], or similar operators in MTL [2], to refer to  the time point at a generic distance d from the current  time. Then, the next operator X, which adopts a ﬁxed time  displacement, becomes just an abbreviation for Dist(•, 1).  This assumption, however, becomes too simplistic if the  various computational steps that move the system from one  state to the next one take a variable amount of time to  complete. In some cases, the duration of some steps is orders  of magnitude smaller than others so that, at some level  of abstraction, it can be neglected entirely. This situation  N  Z  1530-1311/12 $26.00 © 2012 IEEE  DOI 10.1109/TIME.2012.22  81  general undecidable; we then deﬁne a decidable fragment  that is expressive enough to model computing devices that  are typically embedded in many industrial systems, such as  Flexible Manufacturing Systems (FMS). The decidability of  this subset of X-TRIO is obtained through its encoding into  the Propositional Linear Temporal Logic with Both future  and past operators (PLTLB); from this encoding, we built a  prototype veriﬁcation tool using decision procedures based  on bounded model-checking implemented in the Zot tool  [6].  Two companion papers apply the X-TRIO language to  formalize the semantics of the Stateﬂow notation used in  many application ﬁelds, and to automatically analyze properties of critical system: [7] focuses on the modeling and  analysis of single Stateﬂow components whereas [8] deals  with the integration of several cooperating modules.  Notions of zero-time transitions appear very naturally  when reasoning about computations of embedded systems.  For instance, in [9], while developing and analyzing a  formal model of an aerospace satellite system, the authors  repeatedly emphasize the need for ”algorithmic detection of  Zeno behavior”. An early approach in the ﬁeld of temporal  logics introduced a time structure suitable to support the  notion of micro- and macro-steps [2]. Our approach, based  on NSA, allows us to frame the problem in a general and  elegant way, and provides means to equip the resulting logic  with suitable veriﬁcation mechanisms. In the literature, other  works have used NSA to provide a formal and rigorous  semantics to timing features of various kinds of notations for  system modeling: in [10] NSA is used to describe a hybrid  system modeled in Simulink in presence of cascaded mode  changes, while in [11] a complete system theory is deﬁned,  adopting a theoretical approach to investigate computability  issues.  This paper is structured as follows. Section II deﬁnes  the syntax and semantics of X-TRIO. Section III studies  decidability issues, identiﬁes a decidable fragment of the  logic, and provides its encoding into PLTLB. Section IV  draws conclusions and hints at possible extensions of this  work.  the current instant. TRIO formulae can be interpreted both  in discrete and dense time domains.  X-TRIO extends TRIO along two main lines. First, the  temporal domain T is augmented with inﬁnitesimal numbers  from the theory of non-standard analysis founded by A.  Robinson [12], which has already been exploited in TRIO  [5] to deal with time-critical systems. Intuitively, for any  numerical domain D,  is inﬁnitesimal in D if  ≥ 0 and   is smaller than any number in D>0 . The original values of D  are classiﬁed as standard and are characterized by predicate  st, that is, x is standard iff st(x) holds. D is augmented with  inﬁnitesimal numbers and all numbers resulting from adding  and subtracting inﬁnitesimal non-zero numbers to and from  standard ones, respectively. Predicate ns(x) denotes that x  is non-standard. For each x, st(x) holds if and only if  ns(x) does not hold. Notice that 0 is the only inﬁnitesimal  standard number and that non-standard numbers are of the  form v ± , where st(v) holds, and  is inﬁnitesimal greater  than 0. NSA provides an axiomatization that allows one to  apply all arithmetic operations and properties of traditional  analysis in an intuitive way: for instance, the sum of two  standard numbers is standard, the sum of two inﬁnitesimal  numbers is an inﬁnitesimal and the sum of an inﬁnitesimal  with a standard number is a non-standard number. The  theory of NSA introduces, in addition to the notion of  inﬁnitesimal numbers and operations on them, the notion  of inﬁnite numbers (which are, intuitively, greater than any  value in D), plus a rich set of results that make NSA an  appealing framework for reasoning on both familiar and new  objects. In this paper we exploit some of the terminology and  concepts of NSA to provide an elegant characterization of  zero-time steps, but we do not make use of the full power  of the theory; for example, we do not deal with inﬁnite  numbers (i.e., we have that ns(x) iff x = v ± , with st(v)  and  inﬁnitesimal), as they are of no use when modeling  zero-time steps.  We assume as the original time domain D either N or  R≥0 and denote its extension with inﬁnitesimal numbers as  T . T is a totally ordered set of numbers.  The second major novelty of X-TRIO is the introduction  of the next operator X which is typical to describe the  evolution of dynamical systems as a sequence of discrete  steps. Unlike the traditional use of the operator in a metric  setting, however, the time distance between two consecutive  states is not implicitly assumed as a time unit; on the  contrary, it can be any standard or non-standard positive  number. Precisely, we introduce two different types of X  operator, namely, Xst and Xns . Intuitively, the formula  Xst (φ) is true in the current instant iff φ is true in the  next state entered by the system and this occurs at a  time instant that is a standard number; conversely, formula  Xns (φ) is true iff, in the next state, φ is true and the  occurrence time is a non-standard number. We will use these  two operators to distinguish between two typical ways of  II. T HE X-TRIO LOGIC  In this section, we ﬁrst introduce some necessary background, then we deﬁne the syntax and semantics of X-TRIO.  A. Syntax  The original TRIO language [1] is a general-purpose speciﬁcation language suitable for modeling real-time systems.  It is a temporal logic supporting a metric on time. TRIO  formulae are built out of the usual ﬁrst-order connectives,  operators, and quantiﬁers, and the single basic modal operator Dist: for any formula φ and term t indicating a  time distance, formula Dist(φ, t) speciﬁes that φ holds at  a time instant whose distance is exactly t time units from  82  OPERATOR  DEFINITION  AlwF(φ)  SomF(φ)  ∀t(t ≥ 0 → Dist(φ, t))  ∃t(t ≥ 0 ∧ Dist(φ, t))  ∃t ≥ 0(Dist(ψ, t) ∧  ∀v(0 ≤ v < t → Dist(φ, v)))  ∃t ≥ 0(Dist(ψ, −t) ∧  ∀v(−t < v ≤ 0 → Dist(φ, v)))  Until(φ, ψ)  Since(φ, ψ)  S, t   S, t   S, t   S, t   S, t   S, t   S, t   S, t   Table I  X-TRIO DERIVED TEMPORAL OPERATORS .  S, t   S, t   modeling system evolution: Xst will formalize macro-steps  i.e., transitions that ”consume real, tangible time”, whereas  Xns will describe micro-steps, which are often formalized as  zero-time transitions. Yesterday operators Yst and Yns are  introduced in a similar manner.  The syntax of X-TRIO is deﬁned as follows:  φ  :=  τ  :=  N  N  N  N  Table II  S EMANTICS OF X-TRIO.  III. D ECIDABILITY OF X-TRIO  p | ¬φ | φ1 ∧ φ2 | Dist(φ, k) |  Xst (φ) | Xns (φ) | Yst (φ) | Yns (φ) | ∀t.τ  φ | Dist(φ, t) | t = k | t < k | τ1 ∧ τ2 | ¬τ  Let us consider the following syntactic fragment of XTRIO, which we name X-TRION :  φ :=  In this paper, we restrict the set of atomic propositions  AP to propositional variables p, and the set V of temporal  terms to variables t and constants k. Temporal terms t take  values in the time domain T and can appear only in closed  formulae. We leave ﬁrst-order extensions of the logic to  future work. Symbols , ⊥, ∨, →, ∃, etc. are derived as  usual. We introduce the derived operators of X-TRIO as in  TRIO; Table I shows those used in this paper.  p | ¬φ | φ1 ∧ φ2 | Dist(φ, 1) | Dist(φ, ) |  Dist(φ, −1) | Dist(φ, −) | Until(φ1 , φ2 ) |  Since(φ1 , φ2 ) | Xst (φ) | Xns (φ) | Yst (φ) | Yns (φ)  As the name suggests, we interpret X-TRION formulae  over the non-standard temporal domain . In X-TRION ,  Dist(φ, 1 + ) is an abbreviation for Dist(Dist(φ, ) , 1);  similarly for Dist(φ, 1 − ). The Until and Since operators  are now primitive, and we have the following abbreviations:  SomF(φ) = Until(, φ) and AlwF(φ) = ¬SomF(¬φ).  Notice that, as the syntax of X-TRION does not allow  variables, its temporal structures become triples of the form  S = T , β, σ . We also restrict the interpretation domain  of the form v + k, where v, k ∈  to the numbers of  and  is an inﬁnitesimal number. Thus, standard numbers  are identiﬁed by the coefﬁcient k = 0. We indicate this  domain by + . In addition, since by deﬁnition for all k ∈ ,  v + k < v + 1 − k, due to the restriction above we have  v − k ∈  / + for all k. Hence, for all φ, Dist(φ, −) is false  in all standard instants t (i.e., such that st(t)).  Despite the restrictions introduced in X-TRION , however,  the logic is undecidable, and the following holds.  N  B. Semantics  A model-theoretic semantics for X-TRIO is deﬁned by  following a fairly standard path on the basis of a temporal  structure S = T , β, ν, σ , where:  (i) T is the time domain such that ∀t ∈ T it is t ≥ 0.  (ii) β : T −→ 2AP is an interpretation function that  associates each instant of time t with the set of atomic  propositions β(t) that are true in t.  (iii) ν : V −→ T is an evaluation function that associates  with each temporal term of the set V a value in T .  (iv) σ = {σi |i ∈ : σi ∈ T ∧ σ0 = 0 ∧ ∀j ∈ (j < i ⇒  σj < σi ) ∧ ∀t ∈ T (σi < t < σi+1 ⇒ β(σi ) = β(t))} is the  distinguishing element of the X-TRIO temporal structure. It  is a (possibly inﬁnite) sequence of time instants starting from  the initial instant 0, called History. Intuitively, it represents  the discrete sequence of instants when the system changes  state. Thus, the X operator represents a step moving from  σi to σi+1 . Then, the satisfaction relation  of an X-TRIO  formula φ by structure S = T , β, ν, σ at a time instant  t ∈ T is deﬁned as in Table II. A formula φ is satisﬁable in  a structure S = T , β, ν, σ when S, 0  φ.  In the rest of this paper, we study some relevant properties  of the X-TRIO logic, with focus on the case T = .  N  p iff p ∈ β(t)  ¬φ iff S, t  φ  φ1 ∧ φ2 iff S, t  φ1 and S, t  φ2  Dist(φ, k) iff t + ν(k) ∈ T and S, t + ν(k)  φ  Dist(φ, d) iff t + ν(d) ∈ T and S, t + ν(d)  φ  Xst (φ) iff there is i ∈  s.t. σi ≤ t < σi+1 , st(σi+1 )  and S, σi+1  φ  Xns (φ) iff there is i ∈  s.t. σi ≤ t < σi+1 , ns(σi+1 )  and S, σi+1  φ  Yst (φ) iff there is i ∈  s.t. σi−1 < t ≤ σi , i > 0,  st(σi−1 ) and S, σi−1  φ  Yns (φ) iff there is i ∈  s.t. σi−1 < t ≤ σi , i > 0,  ns(σi−1 ) and S, σi−1  φ  ∀d.φ iff for all ν  that differ from ν at most for d,  T , β, ν  , σ , t  φ  N  N  N  N  N  N  Theorem 1. The satisﬁability problem of the X-TRION logic  is undecidable.  Proof sketch. : In classic fashion (see, e.g., [13]), we  reduce the halting problem of a 2-counter machine to the  satisﬁability problem of X-TRION formulae, by deﬁning a  set of X-TRION formulae that formalize the increment and  decrement of the 2 counters.  We associate one counter with the sequence of even standard numbers, and one with the sequence of odd standard  N  83  (v + 1) + (k + 1), whose inﬁnitesimal distance from v + 1  increases of  w.r.t to the distance of v + k from v. This  generality, however, is unnecessary for interesting classes of  applications such as those tackled in [7], [8], for which we  do not need the full expressive power of X-TRION . In the  next section, we investigate a sufﬁcient condition that allows  us to build a decision procedure for a subset of the logic  that can be used in many relevant practical applications. The  study of other sufﬁcient conditions is left for future work.  numbers, as detailed below. We associate two propositional  letters, E and O, with each standard instant of σ so that  when the current standard instant is even (resp., odd) then  only E (resp., O) holds. They do not hold in non-standard  instants. These constraints are represented by the following  X-TRION formulae (we show the case of even instants):  E⇒  E⇔  Xst (O) ∨  Xns (Until(¬O ∧ ¬E, Xst (O) ∧ ¬O ∧ ¬E))  Dist(O, 1)  A. A decision procedure for X-TRIO  Given two consecutive standard instants σj and σi in σ  (i.e., such that σi = σj + 1), there is a ﬁnite (possibly  empty) sequence σ[j,i) of length i − (j + 1) of non-standard  instants in σ between them since σ is discrete. We introduce  X-TRION formulae (not shown here for brevity) to partition  σ[j,i) into two subsequences such that, at each instant, either  propositional letter A or propositional letter B) holds. We  use letters A and B to “mark” each instant in σ[j,i) as  shown in Figure 1. The sequence of B’s ends in the last  non-standard instant of σ[j,i) .  In this section, we show the decidability of a fragment  of X-TRION by reducing its satisﬁability problem to that  of PLTLB. The transformation is effective and has been  implemented in the Zot satisﬁability checker.  PLTLB extends classic LTL [14] with past operators; its  syntax (as used in the rest of this paper) is the following:  φ := p| ¬φ | φ1 ∧ φ2 | XL (φ) | YL (φ) | φ1 UL φ2 | φ1 SL φ2  We have also the usual abbreviations FL (φ) =  UL φ  and GL (φ) = ¬FL (¬φ). The semantics of PLTLB is  deﬁned over discrete traces. A trace is an inﬁnite word  π = π(0)π(1) . . . over the ﬁnite alphabet Σ = 2AP , where  each π(i) represents the set of atomic propositions that are  true in i. L denotes the satisﬁability relation of PLTLB.  The deﬁnition of L is straightforward if one considers that,  for any φ, YL (φ) is false at 0 [14].  As a ﬁrst step to encode X-TRION into PLTLB, we  restrict histories σ according to the following constraints:  1) Either all standard natural numbers or a bounded  interval thereof including 0 belong to σ.  2) If σi+1 is non-standard (ns(σi+1 )), then σi+1 −σi = .  These constraints are not strictly necessary to obtain  decidability, but they are not overly restrictive and they simplify the encoding for our purposes. Notice also that, if σi+1  is standard (st(σi+1 )), then between σi and σi+1 there is an  inﬁnite sequence of nonstandard numbers σi + , σi + 2, . . .  such that, for all k ∈ N, β(σi + k) = β(σi ).  In order to reduce the satisﬁability problem of X-TRION  (which is in general undecidable) to that of PLTLB (which  is decidable), we need to apply further restrictions to the  former. As mentioned above, the key to encoding a counting  mechanism in X-TRION is to evaluate operator Dist(•, v +  k) (with v ≥ 1) in non-standard instants. This suggests, to  obtain decidability, to make the evaluation of this operator  meaningful only in standard instants. For this, we introduce  an X-TRION predicate, NowST, that evaluates to true only  in standard instants. Such a predicate corresponds to the  following X-TRION formula:  O  E  O  E  A A A B B B B B A A B B A B  t  t+ε t+2ε ...  Figure 1.  t+1  t+2  t+3  Part of trace representing counters.  We use the sequence of A and B to represent the two  counters: the numbers of A’s starting from standard numbers  marked with E (resp. O) represent the ﬁrst (resp. second)  counter. We encode the operations increase/decrease/check  if 0, by manipulating the length of the sequence of A’s.  For example, the counter associated with E increases its  current value if the sequence of A’s that starts at the  next even standard instant is such that the last A of that  sequence dists 2 +  from the last A of the current sequence  of A’s. This is encoded through the following X-TRION  formula, reminding that all the naturals numbers belong to  the temporal domain:  E→  (A → Until(A, B ∧ Dist(A ∧ Xns (B) , 2)))∧  (B → Dist(A ∧ Xns (B) , 2))  The other cases are omitted for brevity.  The counter is zero when the sequence of A’s is empty.  In the case of the counter associated with even standard  numbers we can encode this check with the formula E ∧ B.  Finally, at the initial instant of the sequence σ, which is an  even number, E holds and the corresponding counter value  is 0 (i.e., E ∧ B holds at 0).  The halting of the formalized machine is expressed simply  as reachability of a ﬁnal state. Hence, we conclude that the  satisﬁability problem of X-TRION is undecidable.  The counting mechanism can be simulated by X-TRION  thanks to the Dist(•, 1 + ) operator, which allows us to  move from a non-standard instant v +k to the non-standard  NowST ≡ ¬Dist(, −)  (1)  In fact, Dist(, −) holds in t ∈ N+ iff t −  ∈  /  which is true iff st(t). Then, every occurrence of  N+ ,  84  Dist(φ, v + k), with v ≥ 1, will be intended as an abbreviation for Dist(φ, v + k) ∧ NowST. Hence, by convention  Dist(φ, v + k) is false in all non-standard instants if v ≥ 1.  In addition, we introduce a further restriction that allows  us to obtain a quite simple decision procedure for the logic,  with a rather limited cost in expressiveness, as discussed  below. The restriction consists of imposing that the value of  formulae is meaningful only in instants that are “covered”  by the history σ. In fact, by deﬁnition of σ in Section II-B,  there can be instants t ∈ T such that, for all i, σi < t.  In this case, σ shows a classic “Zeno behavior” [3], where  it accumulates at a ﬁnite instant, signaling a model that  changes state inﬁnitely often in a ﬁnite interval. Then, by  convention, we state that formulae that are evaluated after  one such accumulation point are false. This can be achieved  by considering every subformula ψ of an X-TRION formula  φ as an abbreviation for ψ ∧ SomF(Xst () ∨ Xns ()). We  have the following result.  there is an instant t̄ such that the subformulae of φ have the  same value in all t ∈ [t̄, σi+1 ). In addition, t̄ is a number  of non-standard instants that is equal to the maximum  nesting depth δ of Dist(•, −) operators far from σi . More  precisely, given a formula φ, the nesting δ(φ) of Dist(•, −)  operators is deﬁned as follows: δ(p) = 0; δ(ψ1 ∧ ψ2 ) =  max(δ(ψ1 ), δ(ψ2 )), and similarly for the Until and Since  operators; δ(¬ψ) = δ(ψ) (similarly for Dist(ψ, ±1) and for  Dist(ψ, )); ﬁnally, δ(Dist(ψ, −)) = 1 + δ(ψ). Then, we  have the following result.  Lemma 3. Given an X-TRION formula φ and a structure  S=  + , β, σ , if st(σi+1 ), then for any two instants j, k ∈  such  that σi + δ(φ) < j < k < σi+1 , S, j  φ iff  +  S, k  φ.  N  Proof: First of all, we notice that it must be ns(j) and  ns(k), as, by constraint 1, σi ≥ σi+1 − 1. Then, the proof  proceeds by induction on the structure of φ.  If φ = p ∈ AP , then p ∈ β(j) iff p ∈ β(k), as β(j) =  β(k) by deﬁnition of σ, hence the result.  If φ = ¬ψ, S, j |= φ iff S, j |= ψ, which holds iff S, k |=  ψ by inductive hypothesis, as δ(φ) = δ(ψ), i.e., iff S, k |= φ.  The case for Dist(ψ, ) is similar.  If φ = ψ1 ∧ ψ2 , S, j |= φ iff both S, j |= ψ1 and S, j |=  ψ2 , which, by inductive hypothesis, holds iff both S, k |= ψ1  and S, k |= ψ2 , as δ(φ) ≥ δ(ψ1 ) and δ(φ) ≥ δ(ψ2 ).  If φ = Dist(ψ, 1), then both S, j  φ and S, k  φ, as  Dist(ψ, 1) is by convention false in non-standard instants.  Similarly when φ = Dist(ψ, −1).  If φ = Until(ψ1 , ψ2 ), we have that S, k  φ iff there is a  t ≥ k s.t. S, t  ψ2 , and for all k ≤ t < t it is S, t  ψ1 .  By inductive hypothesis, since δ(φ) ≥ δ(ψ1 ), for all t , t  s.t. j ≤ t < k ≤ t < σi+1 , we have that S, t  ψ1 iff  S, t  ψ1 . Hence, S, t  ψ1 holds for all k ≤ t < t iff  also for all j ≤ t < t it is S, t  ψ1 . Then, S, k  φ iff  S, j  φ. The case φ = Since(ψ1 , ψ2 ) is similar.  If φ = Xst (ψ), S, j  φ iff S, σi+1  ψ, as st(σi+1 ). We  have also S, k  φ iff S, σi+1  ψ, hence the result.  If φ = Xns (ψ), both S, j  φ and S, k  φ, as st(σi+1 ).  If φ = Yst (ψ), both S, j  φ and S, k  φ hold iff st(σi )  and S, σi  ψ. Similarly for the case φ = Yns (ψ).  If φ = Dist(ψ, −), S, j |= φ iff S, j −  |= ψ; since  j −  > σi + (δ(φ) − 1) and δ(φ) = δ(ψ) + 1, then k −  >  j −  > σi + δ(ψ) hence, by inductive hypothesis, we have  S, k −  |= ψ, i.e., S, k |= φ.  Notice that Lemma 3 does not hold if j = σi + δ(φ).  For example, if j = σ0 = 0, σ1 = 1, and p ∈ β(σ0 ), with  δ(φ) = 0, then Yst (p) holds in k = σ0 + , but not in j.  Lemma 2. Given an X-TRION formula φ in which all subformulae have the form ψ ∧ SomF(Xst () ∨ Xns ()), and  given two structures S1 =  + , β1 , σ , S2 =  + , β2 , σ  (i.e., which have the same history σ) such that, for all  such that t < σi , it is  t ∈ + for which there is i ∈  β1 (t) = β2 (t), then S1 , 0 |= φ iff S2 , 0 |= φ.  N  N  N  N  Proof sketch. : We show a stronger result, from which  Lemma 2 descends as corollary. More precisely, we show  that, given any t ∈ + , S1 , t |= φ iff S2 , t |= φ. First  of all, we remark that, if for each t ∈ + there is a σi  such that t < σi , then for all t ∈ + it is β1 (t) = β2 (t),  hence the desired result. In addition, notice that, in this case,  condition SomF(Xst () ∨ Xns ()) is true for all t ∈ + ,  so the value of φ does not depend on it.  In the rest of the proof, we consider the case in which  there are instants t such that, for all i, σi < t. The set of  such instants can be shown to have a minimum, which we  indicate with t, such that st(t). Then, history σ accumulates  at t, and we separate two cases: t < t and t ≥ t. In the case  t ≥ t, SomF(Xst () ∨ Xns ()) is false, hence for all φ both  S1 , t |= φ and S2 , t |= φ. Then, we only need to consider  the case t < t. The rest of the proof is by induction on the  structure of φ: consider a subformula ψ of φ.  If ψ = p, by hypothesis β1 (t) = β2 (t); hence the result.  If ψ = Dist(ζ, 1), then S1 , t |= ψ iff S1 , t + 1 |= ζ, hence,  by inductive hypothesis, iff S2 , t + 1 |= ζ, and iff S2 , t |= ψ.  All other cases are similar and are omitted for brevity.  As a consequence of Lemma 2, and also of the next  lemma 3, given the restrictions introduced above, in order  to determine whether an X-TRION formula is satisﬁable we  only need to focus on the sequence σ, and we can disregard  the instants following an accumulation point, if any.  In order to introduce our PLTLB-based decision procedure  for X-TRION , we need a further intermediate result. We  show that, in each interval (σi , σi+1 ) such that st(σi+1 ),  N  N  N  N  N  The basic idea of the encoding is, given an X-TRION  formula φ, to build a corresponding PLTLB formula τ (φ)  such that each model S =  + , β, σ of φ corresponds to  a trace π that is a model of τ (φ), where each t ∈ + such  that there is σi > t is mapped onto an element π(ρS (t)),  N  85  N  σ  σ0  σ1  σ2  σ3  0  ε  2ε  3ε  sp nsp nsp  ep  0  3  τ (p) = p  σ4  1  1+ε ...     fp  sp  nsp  4  5  6  4ε  ...  τ (¬φ) = ¬τ (φ)  τ (φ1 ∧ φ2 ) = τ (φ1 ) ∧ τ (φ2 )  ρS  π  1  Figure 2.  2  τ (Xns (φ)) = XL (nsp ∧ τ (φ))  τ (Xst (φ)) = XL ((ep ∨ fp ) UL (sp ∧ τ (φ)))  τ (Yns (φ)) = YL ((ep ∨ fp ) SL (nsp ∧ τ (φ)))  τ (Yst (φ)) = YL ((ep ∨ fp ) SL (sp ∧ τ (φ)))  ...   An example of ρS (with δ(φ) = 1).  N  τ (Dist(φ, 0)) = τ (φ)  τ (Dist(φ, )) = (¬fp ∧ XL (τ (φ))) ∨ (fp ∧ τ (φ))  τ (Dist(φ, −)) = ¬sp ∧  ((¬fp ∧ YL (τ (φ))) ∨ (fp ∧ τ (φ)))  N  and β(t) = π(ρS (t)), where ρS : + →  is monotonic.  Then, we represent the transition σi −→ σi+1 through the  PLTLB operator XL . Constraints 1 and 2 guarantee that the  difference between σi+1 and σi = v + k is either 1 − k or  , depending on whether σi+1 is standard or not.  The encoding ”ﬂattens” the history σ over π: it represents  each σi through an element of π. Then, to separate the  elements of π that represent standard instants from those  that represent non-standard ones, we introduce a PLTLB  propositional letter sp such that sp ∈ π(i) iff i in π  corresponds to a standard number. In addition, we need to  introduce “ﬁlling” elements in π to represent the (inﬁnite)  non-standard instants between σi and σi+1 when st(σi+1 ).  Lemma 3 suggests that the required number of these elements is ﬁnite, equal to δ(φ) + 1; in fact, all non-standard  instants such that σi + δ(φ) < t < σi+1 are equivalent from  the point of view of the truth of subformulae, hence they  can be “condensed” in one single element. We mark the  ﬁrst δ(φ) elements of π following the one corresponding to  σi with proposition ep , and the element corresponding to all  instants σi + δ(φ) < t < σi+1 with fp . Figure 2 depicts an  example of history σ, and its corresponding trace π.  Then, trace π must obey the following PLTLB constraint,  where nsp is an abbreviation for ¬sp ∧ ¬fp ∧ ¬ep :  sp ∧  GL ((ep → ¬fp ∧ ¬sp ) ∧ (fp → ¬sp ) ∧  (sp →       δ(φ) k  XL (ep )∧  k=1  XL nsp UL  δ(φ)+1  XL  (fp ∧ XL (sp ))  ∨  XL (GL (ns  p ))) ∧  (ep ∨ fp → p∈AP p ↔ YL (p)))  τ (Dist(φ, 1)) = sp ∧ XL (¬sp UL (sp ∧ τ (φ)))  τ (Dist(φ, −1)) = sp ∧ YL (¬sp SL (sp ∧ τ (φ)))  τ (Until(φ, ψ)) = τ (φ) UL τ (ψ)  τ (Since(φ, ψ)) = τ (φ) SL (fp ∧ τ (φ) ∧ τ (ψ)) ∨  τ (φ) SL (¬fp ∧ τ (ψ))  Table III  T RANSLATION SCHEMA τ .  N  N  N  Given a structure S =  + , β, σ , for all t ∈  + such  that there is σi > t, we deﬁne function ρS : + →  as follows(see Figure 2 for a graphical representation): (i)  ρS (0) = 0 (σ0 = 0); (ii) if ns(t), and ∃i s.t. t = σi (hence  t = σi−1 + ), then ρS (t) = ρS (σi−1 ) + 1; (iii) if ns(t),  and ∃i s.t. σi + δ(φ) < t < σi+1 (hence st(σi+1 )), then  ρS (t) = ρS (σi ) + δ(φ) + 1; (iv) if t > 0 and st(t) (hence  there is i > 0 s.t. t = σi ), then ρS (t) = ρS (σi−1 )+δ(φ)+2;  (v) if ns(t), and ∃i s.t. σi < t ≤ σi + δ(φ) < σi+1 , then  there is k s.t. t = σi + k, and ρS (t) = ρS (σi ) + k; Notice  that rule (iii) is applied to all nonstandard instants in between  σi +δ(φ) and σi+1 , and it maps each of them onto a “ﬁlling”  element in π. As a consequence, rule (iv) maps a standard  instant onto ρS (σi−1 ) + δ(φ) + 2, i.e., to the element in  π that follows a “ﬁlling” one. Then, if t < t , we have  ρS (t) ≤ ρS (t ). The following result holds.  (2)  N  Theorem 4. Given an X-TRION formula φ, there is a  structure S =  + , β, σ such that S, 0  φ iff there exists  a trace π such that π L τ (φ) ∧ (2).  N  N  PLTLB formula (2) imposes, respectively, that (i) sp holds  in π(0), (ii) ep , fp and sp are mutually exclusive, (iii) each  element marked sp is followed either by an inﬁnity of nsp  elements or by a ﬁnite number of nsp elements, until there  is a sequence of exactly δ(φ) ep elements followed, in turn,  by a fp element, which is in turn followed by a sp element,  (iv) if ep or fp ∈ π(i + 1), then all propositions that hold  in π(i + 1) also hold in π(i). In other words, traces π have  δ(φ)  one of the following two forms: sp (ns∗p ep  fp sp )ω or  ∗ δ(φ)  ∗  ω  sp (nsp ep fp sp ) (nsp ) .  Transformation τ of Table III takes an X-TRION formula  φ and produces an equisatisﬁable PLTLB formula φL .  Proof: Suppose we have a structure S =  + , β, σ .  The corresponding inﬁnite word π is built from S as follows  (where AP are the atomic propositions in φ): for each p ∈  AP and t ∈ + such that there is σi > t (hence ρS (t)  is deﬁned), p ∈ β(t) iff p ∈ π(ρS (t)). In addition, sp ∈  π(ρS (t)) iff st(t), fp ∈ π(ρS (t)) iff there i s.t. σi + δ(φ) <  t < σi+1 and st(σi+1 ), and ep ∈ ρS (t) iff σi < t ≤ σi +  δ(φ) < σi+1 . It can be shown that trace π built in this way  satisﬁes formula (2).  Dually, if π is such that π L τe (φ) ∧ (2), structure S =  ,  + , β, σ is obtained in the following way. Given an l ∈  / π(l) (i.e., l is not a “ﬁlling” element), l0 . . . lv  if ep , fp ∈  N  N  86  N  N  (where ∀j ∈ [0, v), we have lj < lj+1 ) are all the elements  of the inﬁnite word π such that lv ≤ l and ∀j ∈ [0, v] :  sp ∈ π(lj ) (i.e., they are all the elements that correspond to  standard instants in π preceding element l), and k = l − lv  (i.e., k is the number of elements between π(l) and π(lv )),  then σl = v + k. This entails that, since σl is a standard  number iff it is of the form v + 0, we have that st(σl ) iff  sp ∈ π(l). In addition, by (2), sp ∈ π(0), hence σ0 = 0  as expected. This deﬁnes the points of the history σ of S,  which in turn deﬁnes ρS . β is deﬁned as follows: for each  t such that there is σi > t, for each p ∈ AP , p ∈ β(t)  iff p ∈ π(ρS (t)). If, instead, there is no σi > t, we can  chose the value of β(t) arbitrarily, as, by Lemma 2, it does  not affect the truth of φ in S; then, in this case we have  p∈  / β(t) for all p ∈ AP .  We prove Theorem 4 by induction on the structure of  formula φ. First of all, by Lemma 2, if there is an accumulation point t, instants t ≥ t do not affect the satisﬁability  of φ, hence we need only analyze instants t < t. Then,  we show that, for all t < t (where t = +∞ if there is no  accumulation point), it is S, t |= ψ (where ψ is a subformula  of φ) iff π, ρS (t)L τ (ψ).  If ψ = p, then S, t |= p iff p ∈ β(t), which holds,  by construction, iff p ∈ π(ρS (t)), i.e. iff π, ρS (t)L p,  and τ (p) = p, hence the result. The cases ψ = ¬ζ and  ψ = ψ1 ∧ ψ2 are immediate.  If ψ = Xns (ζ), S, t |= ψ iff σi ≤ t < σi+1 , ns(σi+1 )  and S, σi+1 |= ζ; by inductive hypothesis this holds  /  iff π, ρS (σi+1 )L τ (ζ), and by construction sp , fp , ep ∈  π(ρS (σi+1 )), hence π, ρS (σi+1 ) − 1L XL (τ (ζ) ∧ nsp ), and  by construction ρS (t) + 1 = ρS (σi+1 ), since it must be  t = σi , because σi+1 = σi + .  If ψ = Xst (ζ), S, t |= ψ iff σi ≤ t < σi+1 , st(σi+1 )  and S, σi+1 |= ζ; by inductive hypothesis this holds iff  π, ρS (σi+1 )L τ (ζ), and by construction sp ∈ π(ρS (σi+1 )),  hence π, ρS (σi+1 )L τ (ζ) ∧ sp . It is either σi < t, or  σi = t. If σi < t, fp ∈ π(ρS (t)) or ep ∈ π(ρS (t))  and ρS (σi+1 ) ≥ ρS (t) + 1. If σi = t, fp , ep ∈  / π(ρS (t)),  and ρS (σi+1 ) = ρS (t) + δ(φ) + 2. In both cases for all  ρS (t) < l < ρS (σi+1 ) it is fp ∈ π(ρS (t)) or ep ∈  π(ρS (t)), hence π, ρS (t)L XL ((fp ∨ ep ) UL (sp ∧ τ (ζ))),  i.e., π, ρS (t)L τ (ψ). The cases for the Yns and Yst operators are similar.  Dist(ψ, 0) is equivalent to ψ, hence this case is trivial.  If ψ = Dist(ζ, ), S, t |= ψ iff S, t +  |= ζ, which,  by inductive hypothesis, holds iff π, ρS (t + )L τ (ζ). We  have two cases: σi ≤ t ≤ δ(φ) < σi+1 and σi + δ(φ) <  / ρS (t),  t < σi+1 (hence st(σi+1 )). In the ﬁrst case, fp ∈  ρS (t + ) = ρS (t) + 1, hence π, ρS (t)L ¬fp ∧ XL (τ (ζ)). In  the second case, fp ∈ ρS (t), and by Lemma 3 S, t +  |= ζ  iff S, t |= ζ, which in turn holds iff π, ρS (t)L τ (ζ),  hence π, ρS (t)L fp ∧ τ (ζ). All in all, π, ρS (t)L ¬fp ∧  XL (¬sp ∧ τ (ζ)) ∨ fp ∧ τ (ζ), i.e., π, ρS (t)L τ (ψ).  The case ψ = Dist(ζ, −) is similar to the previous  one, with the addition that S, t |= ψ only if t −  ∈ +  (i.e., ns(t)) which, by inductive hypothesis, holds iff sp ∈  /  π(ρS (t)), i.e., π, ρS (t)L ¬sp .  If ψ = Dist(ζ, 1), S, t |= ψ iff st(t), t + 1 < t, and  S, t + 1 |= ζ. It is st(t) iff sp ∈ π(ρS (t)). Also, t + 1 < t  holds iff there is σi > t + 1, i.e., iff ρS (t + 1) is deﬁned, and  sp ∈ π(ρS (t + 1)). In addition, when ρS (t + 1) is deﬁned,  S, t+1 |= ζ iff π, ρS (t+1)L τ (ζ), by inductive hypothesis.  As ρS (t + 1) > ρS (t), and there are no standard instants in  between, then π, ρS (t)L sp ∧ XL (¬sp UL (sp ∧ τ (ζ))), i.e.,  π, ρS (t)L τ (ψ). The case ψ = Dist(ζ, −1) is similar.  If ψ = Since(ψ1 , ψ2 ), then S, t |= ψ iff there is 0 ≤ t ≤ t  s.t. S, t |= ψ2 and for all t < t ≤ t it is S, t |= ψ1 . By  inductive hypothesis we have π, ρS (t )L τ (ψ2 ). We have  two cases: σi ≤ t ≤ σi + δ(φ) < σi+1 for some i, or  σi + δ(φ) < t < σi+1 . In the former case, then for all  t < t ≤ t it is also ρS (t ) < ρS (t ) ≤ ρS (t), hence, by  inductive hypothesis, for all ρS (t ) < ρS (t ) ≤ ρS (t) it is  π, ρS (t )L τ (ψ1 ), hence π, ρS (t)L τ (ψ1 ) SL τ (ψ2 ). In the  latter case, instead, there are some t < t < σi+1 hence,  by Lemma 3, S, t |= ψ1 , and also ρS (t ) = ρS (t ) and  fp ∈ π(ρS (t )). Then, by inductive hypothesis, we have  π, ρS (t )L τ (ψ2 ) and for all ρS (t ) ≤ ρS (t ) ≤ ρS (t) it is  π, ρS (t )L τ (ψ1 ). Then, π, ρS (t)L τ (ψ1 ) SL (fp ∧ τ (ψ1 ) ∧  τ (ψ2 )). Overall, π, ρS (t)L τ (ψ1 ) SL τ (ψ2 )∨τ (ψ1 ) SL (fp ∧  τ (ψ1 )∧τ (ψ2 )), i.e., π, ρS (t)L τ (ψ). The case for the Until  operator is similar.  Remark 5. As mentioned above, Lemma 3 does not hold if  we relax the condition on j and allow it to be j = σi +δ(φ).  However, if we allow σi + δ(φ) ≤ j < k < σi+1 , the  only cases where the proof fails are those for Yns , Yst , and  Dist(•, 1) (when st(σi ) and δ(φ) = 0). This suggests that,  if φ does not include instances of operator Dist(•, −) (in  which case δ(φ) = 0, and, by constraint (2), no elements  marked with ep appear in π), nor instances of the Yns and  Yst operators, the encoding can be simpliﬁed. In fact, in  this case we can use the following modiﬁed encoding τf  (we only show the cases that differ from τ ):  τf (Xns (φ)) = XL (τf (φ) ∧ ¬sp )  τf (Xst (φ)) = XL (sp ∧ τf (φ)) ∨ (fp ∧ XL (τf (φ)))  τf (Dist(φ, )) = XL (¬sp ∧ τf (φ)) ∨ (XL (sp ) ∧ τf (φ))  τf (Since(φ, ψ)) = τf (φ) SL (XL (¬sp ) ∧ τf (ψ)) ∨  τf (φ) SL (XL (sp ) ∧ τf (φ) ∧ τf (ψ))  Also, constraint (2) is replaced by the following formula:    sp ∧GL  (sp → XL (fp ∨ ¬sp )) ∧ (f  p → (YL (sp ) ∧  ¬sp ∧ XL (sp ))) ∧ (fp → p∈AP p ↔ YL (p))    As it happens with other logic formalisms, past operators  allow users to obtain more succinct and intuitive formulae,  paying a little price in terms of computational complexity.  87  Finally, from translation schema τ and Theorem 4 we can  prove the following.  say, module A must reach a stable state after a sequence of  micro-steps always before module B does.  Acknowledgments. : Work supported by the European  Commission, Programme IDEAS-ERC, Project 227977SMScom. We thank the anonymous reviewers for their  comments.  Theorem 6. The satisﬁability problem of the fragment of  X-TRION deﬁned above is PSPACE-complete.  Proof: First of all, we remark that the satisﬁability  problem of PLTLB is PSPACE-complete [14]. Then, to  show the PSPACE-hardness of the satisﬁability problem for  X-TRION we reduce the satisﬁability problem of PLTLB to  that of X-TRION . To achieve this, given a PLTLB formula  φL , we can build a corresponding X-TRION formula simply  by applying the following transformation: UL → Until,  SL → Since, XL → Dist(•, 1), YL → Dist(•, −1), and by  including the constraint AlwF(¬Xns ()).  To show the PSPACE-completeness, it is enough to note  that, given an X-TRION formula φ, transformation τ produces an equisatisﬁable PLTLB formula φL , whose size is  polynomial in the size of φ.  R EFERENCES  [1] C. Ciapessoni, P. Mirandola, A. Coen-Porisini, D. Mandrioli,  and A. Morzenti, “From formal models to formally-based  methods: an industrial experience,” ACM TOSEM, vol. 8,  no. 1, pp. 79–113, 1999.  [2] R. Koymans, “Specifying real-time properties with metric  temporal logic,” Real-Time Systems, vol. 2, no. 4, pp. 255–  299, 1990.  [3] C. A. Furia, D. Mandrioli, A. Morzenti, and M. Rossi,  “Modeling time in computing: a taxonomy and a comparative  survey,” ACM CSUR, vol. 42, no. 2, pp. 6:1–59, 2010.  IV. C ONCLUSIONS AND F UTURE W ORK  [4] J. S. Ostroff, Temporal Logic for Real Time Sytems, ser. Adv.  Soft. Dev. Series. John Wiley & Sons, 1989.  We presented a novel approach to model and analyze  systems evolving through discrete steps in a generic time  domain, which can be either discrete or continuous; these  steps may have quite different durations, up to the point that  some are negligible w.r.t. others. The language supporting  our approach, X-TRIO, extends the TRIO metric temporal  logic with non-standard numbers and the next-state operator  X. It can be used to model many types of heterogeneous  real-time systems, and to give formal semantics to many  informal or semiformal notations widely adopted in the  practice of industrial applications, as done for Stateﬂow and  FMS [7], [8]. The approach could also be applied to other  logic languages for real-time systems such as MTL [2].  In its full generality X-TRIO is undecidable. In this  context, however, we are motivated by the need to offer users  fully automated ”push-button” analysis tools. We obtained  such a goal by suitable restrictions in the syntax of the language and by encoding the resulting subset into the ”kernel  PLTLB” supported by the Zot tool (zot.googlecode.com).  Theorem 1 provides a basic hint on where the obstacles  to achieve decidability abide, and it also suggests a few  guidelines to ﬁnd new sufﬁcient conditions that lead to  other, possibly more general, decidable versions of the basic  language X-TRIO.  This is the direction of our ongoing research. For instance,  we are interested in macro- and micro-steps with time  durations not ﬁxed a priori. In particular, the assumption  that every micro-step takes exactly a constant inﬁnitesimal  value  is adequate for applications such as those examined  so far where the effects of many micro-steps become visible  only at the beginning and end of macro-steps, but a ﬁner  view could become necessary when, e.g., synchronizing several components whose micro-steps have incommensurable  durations but still have to guarantee some critical properties,  [5] A. Gargantini, D. Mandrioli, and A. Morzenti, “Dealing with  zero-time transitions in axiom systems,” Information and  Computation, vol. 150, no. 2, pp. 119–131, 1999.  [6] M. Pradella, A. Morzenti, and P. San Pietro, “Reﬁning  real-time system speciﬁcations through bounded model- and  satisﬁability-checking,” in Proc. of ASE, 2008, pp. 119–127.  [7] L. Ferrucci, D. Mandrioli, A. Morzenti, and M. Rossi, “Nonnull inﬁnitesimal micro-steps: a metric temporal logic approach,” Online at http://arxiv.org/abs/1206.0911, 2012.  [8] ——, “Modular automated veriﬁcation of ﬂexible manufacturing systems with metric temporal logic and non-standard  analysis,” in Proc. of FMICS, 2012, to appear.  [9] M.-A. Esteve, J.-P. Katoen, V. Y. Nguyen, B. Postma, and  Y. Yushtein, “Formal correctness, safety, dependability, and  performance analysis of a satellite,” in Proc. of ICSE, 2012,  pp. 1022–1031.  [10] A. Benveniste, T. Bourke, B. Caillaud, and M. Pouzet, “Nonstandard semantics of hybrid systems modelers,” J. of Comp.  and Sys. Sci., vol. 78, no. 3, pp. 877 – 910, 2012.  [11] S. Bliudze and D. Krob, “Modelling of complex systems:  Systems as dataﬂow machines,” F. Inf., vol. 91, pp. 251–274,  2009.  [12] A. Robinson, Non-standard analysis.  Press, 1996.  Princeton University  [13] R. Alur and T. A. Henzinger, “A really temporal logic,”  Journal of the ACM, vol. 41, pp. 181 – 203, 1994.  [14] P. Schnoebelen, “The complexity of temporal logic model  checking,” in Adv. in Modal Logic, 2002, pp. 393–436.  88 