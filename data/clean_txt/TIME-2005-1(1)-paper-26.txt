Deterministic CTL Query Solvingâ  Marko Samer  Institute of Information Systems (DBAI)  Vienna University of Technology, Austria  samer@dbai.tuwien.ac.at  Abstract  Temporal logic queries provide a natural framework to extend the realm of model checking from mere  veriďŹcation of engineersâ speciďŹcations to computing  previously unknown temporal properties of a system.  Formally, temporal logic queries are patterns of temporal logic speciďŹcations which contain placeholders for subformulas; a solution to a temporal logic  query is an instantiation which renders the speciďŹcation true. In this paper, we investigate temporal logic  queries that can be solved deterministically, i.e., solving such queries can be reduced in a deterministic  manner to solving their subqueries at appropriate system states. We show that this kind of determinism is  intimately related to the notion of intermediate collecting queries studied by the authors in previous work.  We describe a large class of deterministically solvable  CTL queries and devise a BDD-based symbolic algorithm for this class.  1 Introduction and Overview  Temporal logic query solving is an extension of  model checking introduced in a seminal paper by  Chan [2]. A temporal logic query is a temporal logic  formula containing one or more occurrences of a distinguished proposition â?â which is treated as a placeholder. Given a system model K and a query Îł, a solution to Îł in K is a formula Ď satisfying K |= Îł[Ď].  Thus, in contrast to a model checker which essentially  â  This work was jointly funded by the European network  CoLogNET (IST-2001-33123) and the EU Network of Excellence  REWERSE (506779). The results presented in this paper have  been developed as part of [7].  Helmut Veith  Institut fuĚr Informatik (I7)  Technische UniversitaĚt MuĚnchen, Germany  veith@in.tum.de  returns a truth value and possibly a counterexample,  the task of a query solver is to infer a set of formulas.  Essentially, the query can be viewed as a âspeciďŹcation  skeletonâ which describes the solution space. Query  solving provides a versatile framework which facilitates diverse veriďŹcation tasks including legacy code  analysis, counterexample understanding, and vacuity  detection [2, 1, 5, 3, 4, 9].  The current paper focuses on the notion of deterministic query solving. We say that a query can be  solved deterministically if solving the query can be  reduced in a deterministic manner to solving its subqueries at appropriate system states. Note that deterministic query solving is not possible for arbitrary  queries. The Kripke structure K in Figure 1 illustrates deterministic query solving for the query Îł =  A(Ď U AG ?). This query Îł has the following property: A formula Ď is a solution to Îł in K if Ď is a solution to Îłâs immediate subquery ÎłĚ = AG ? at a set S of  states that is reachable from s0 by going only through  states at which Ď holds. This follows immediately  from the semantics of the until operator U. Examples  of such sets are the set S1 = {s2 , s4 , s5 , s8 , s9 } and  the set S2 = {s4 , s6 , s7 , s9 , s10 , s11 , s12 } in Figure 1.  Thus, we know that S1 |= ÎłĚ[Ď] as well as S2 |= ÎłĚ[Ď]  imply that Ď is a solution to Îł in K. Conversely, if Ď  is a solution to Îł in K, we know that there exists some  set S as above such that S |= ÎłĚ[Ď] but we do in general  not know which one. Therefore, in a naive approach,  to obtain all solutions to the query Îł = A(Ď U AG ?)  we would have to loop through all possibilities for S.  For certain queries such as Îł considered above,  however, it is possible to determine a single set S  which gives already all solutions. In this case we speak  of deterministic query solving. In our example above,  Proceedings of the 12th International Symposium on Temporal Representation and Reasoning (TIMEâ05)  1530-1311/05 $20.00 ÂŠ 2005 IEEE  s1  Ď  s4  ÂŹĎ . . .  Ď  s0  Ď  s2  Ď  s3  Ď  s5  s6  ÂŹĎ . . .  s10  ÂŹĎ . . .  s11  ÂŹĎ . . .  s7  ÂŹĎ . . .  Ď  s8  s12  ÂŹĎ . . .  s9  ÂŹĎ . . .  Figure 1. Example of solving A(Ď U AG ?)  the set S2 is this set S. To see this, note that all other  possibilities for S âare located to the left of S2 â in Figure 1. Moreover, the subquery ÎłĚ is looking for an invariant. Since everything that is an invariant to the left  of S2 must remain an invariant at S2 , it sufďŹces to compute the solutions at S2 .  From this example we see that solving Îł can be reduced to solving its subquery at a deterministically determined set of states. In this paper, we will investigate query solving algorithms which are based on such  efďŹcient deterministic reductions. Since deterministic  reductions are not possible for all queries, the development of deterministic query solving algorithms ďŹrst  requires a (quite complicated) analysis of those queries  which have the required property.  Our main results show that (i) deterministic query  solving is closely related to the notion of intermediate collecting queries. Exploiting this relationship,  we show (ii) how deterministic query solving gives  rise to symbolic query solving algorithms. Our work  achieves (iii) an extension of Chanâs algorithm to a  much wider class of queries.  In order to explain the results of this paper in more  detail, we ďŹrst need to review some of the previous  research about temporal logic queries. In [2], Chan investigated CTL queries Îł that are guaranteed to have  an exact solution in every model, i.e., a solution Îž  that implies all other solutions to Îł. Chan presented  a syntactic fragment of such queries and a symbolic  BDD-based algorithm for solving them, albeit without  proofs and with incorrect results. A systematic study  by the authors aimed at an extension and correction of  Chanâs work by identifying exact queries, i.e., queries  that have an exact solution if there exists any solution but that are not guaranteed to have a solution in  every model. This research resulted in (i) the deďŹnition of an exact CTL query language which corrects  the errors found in Chanâs fragment [6, 8] and (ii) a  syntactic characterization of exact LTL queries by a  template grammar [7, 10]. Chanâs symbolic algorithm  is still poorly understood and has not been systematically investigated so far. Given the errors found in  Chanâs query language, and the absence of proofs in  Chanâs posthumous paper, the correctness and principles of his algorithm have remained unclear.  The current paper as a ďŹrst result reports on a significant extension of the previously known class of exact  CTL queries (cf. Table 1). The main result in this paper, however, concerns CTL query solving algorithms.  Based on our insights on exact CTL queries, we give  an exact and novel exposition of symbolic query solving algorithms and argue why the class of exact queries  is amenable to classical BDD-based symbolic ďŹxpoint  algorithms. Since symbolic algorithms build up sets  of states, they can only collect solutions, but not account for case distinctions. Consequently, reductions  of solving queries to solving their subqueries can only  be performed by symbolic algorithms when the set of  states at which the subqueries have to be solved can  be computed deterministically. This situation is intuitively accounted for in Chanâs algorithm; his algorithm reduces the computation of solutions to a CTL  query at a given set of states to the computation of  solutions of a subquery at another set of states. This  reduction is repeatedly applied until the placeholder is  reached.  Our results also have the following intuitively appealing logical interpretation: Since exact queries are  characterized by distributivity (i.e., Îł[Ď] â§ Îł[Ď] â  Îł[Ď â§ Ď]) [7, 10], it is natural to expect that distributivity holds in cases where the placeholder is universally quantiďŹed and is violated otherwise. Consequently, our results give an intuitive high-level explanation which fragments of LTL and CTL are exact.  This paper is organized as follows: In Section 2,  we shortly summarize the formalisms used in the remainder of this paper. Afterwards, in Section 3,  we formally introduce temporal logic queries and we  present our syntactic fragment CTLQx of exact CTL  queries. Then, we systematically investigate proper-  Proceedings of the 12th International Symposium on Temporal Representation and Reasoning (TIMEâ05)  1530-1311/05 $20.00 ÂŠ 2005 IEEE  ties of queries in CTLQx in Section 4 consisting of  two subsections. In Section 4.1, we show how nondeterminism in the sense of existential choices can be  eliminated when solving queries in CTLQx . Based  on these insights, we present our extension of Chanâs  symbolic algorithm and state its correctness in Section 4.2. Finally, we conclude in Section 5.  2 Preliminaries  We assume the reader is familiar with the basics of  (symbolic) model checking, i.e., Kripke structures, the  computation tree logic CTL based on the temporal operators X (ânextâ), F (âfutureâ), G (âglobalâ), and  U (âuntilâ), the least and greatest ďŹxpoint-operators Âľ  and Î˝, etc.  Let K = (Q, Q0 , â, ) be a Kripke structure over  the set A of atomic propositions, where Q is a set of  states, Q0 â Q is the set of initial states, â â Q Ă Q  is a total transition relation, and  : Q â â(A) is a  total labeling function. A computation path or simply  path Ď in K is an inďŹnite sequence of states Ď : N â Q  such that (Ď(i), Ď(i + 1)) â â for all i â N. We  write Ď n to denote the computation path satisfying  Ď n (i) = Ď(n + i) for all i â N. As usual we write  K, s |= Ď to denote that the CTL formula Ď is satisďŹed at state s in K, and we write K |= Ď to denote  K, s0 |= Ď, where s0 is the initial state of K. For simplicity, we also write K, Ď |= Ď to denote K, Ď(0) |= Ď  and K, S |= Ď to denote K, s |= Ď for all s â S. We  omit K if it is clear from the context.  Following Chan [2], we use some additional temporal operators. In particular, we use the weak until  operator Ď W Ď â (G Ď) â¨ (Ď U Ď). The other operators are variants of the strong until operator U and the  weak until operator W:  Ď UĚ Ď â Ď U (Ď â§ Ď)  Ď UĚ Ď â Ď U (ÂŹĎ â§ Ď)  Ď WĚ Ď â Ď W (Ď â§ Ď)  Ď WĚ Ď â Ď W (ÂŹĎ â§ Ď)  The additional operators will give rise to stronger  temporal logic queries although they do not increase  the expressive power of CTL. We call an n-ary temporal operator O monotonic in its k-th operand iff for  all formulas Î¸1 , . . . , Î¸kâ1 , Î¸k+1 , . . . , Î¸n it holds that  Ď â Ď implies O(Î¸1 , . . . , Î¸kâ1 , Ď, Î¸k+1 , . . . , Î¸n ) â  O(Î¸1 , . . . , Î¸kâ1 , Ď, Î¸k+1 , . . . , Î¸n ) for all formulas Ď  and Ď.  3 Exact CTL Queries  In this section, we survey some basic properties of  temporal logic queries.  DeďŹnition 1 (CTL query). A CTL query is a CTL formula where some subformulas are replaced by a special variable ?, called placeholder. We write Îł[Ď] to  denote the result of substituting all occurrences of the  placeholder in Îł by Ď. We denote the set of all CTL  queries by CTLQ.  DeďŹnition 2 (Solution). Let Îł be a query, K be a  Kripke structure, and Ď be a formula. If K |= Îł[Ď],  then we say that Ď is a solution to Îł in K. We denote the set of all solutions to Îł in K by sol(K, Îł) =  {Ď | K |= Îł[Ď]}. A solution Îž to a query Îł in a  Kripke structure K is exact iff it holds that sol(K, Îł) =  {Ď | Îž â Ď}.  We call a query Îł monotonic iff Ď â Ď implies  Îł[Ď] â Îł[Ď] for all formulas Ď and Ď. Note that  it follows immediately from this deďŹnition that Îł (if  monotonic) has a solution in K iff K |= Îł[ ] and every  formula is a solution to Îł in K iff K |= Îł[âĽ]. We are  now able to give a formal deďŹnition of exact queries.  DeďŹnition 3 (Exact query). A query is exact iff it has  an exact solution in every Kripke structure where the  set of solutions is not empty.  In analogy to Chanâs E XP T IME-completeness proof  for deciding validity of CTL queries [2] it can be  shown by reduction from and to the validity of CTL  formulas that deciding exactness of CTL queries is  also E XP T IME-complete [7]. The main implication  of this result is the fact that no simple grammar can  recognize all exact CTL queries. Therefore, we deďŹne  an extensive syntactic fragment CTLQx such that all  queries in this fragment are exact. To this aim, consider the deterministic context-free template grammar  in Table 1, where is a special wildcard symbol representing any CTL formula. For example, the template A( U Îł) represents all CTL queries of the form  A(Ď U Îł), where Ď is a CTL formula. In the following, we write CTLQ1 for the language derived from  non-terminal Q1, CTLQ2 for the language derived  Q2, and so on. The language CTLQx is deďŹned  from  10  as i=1 CTLQi . Although the deďŹnition of CTLQx  seems to be messy when considering the grammar in  Proceedings of the 12th International Symposium on Temporal Representation and Reasoning (TIMEâ05)  1530-1311/05 $20.00 ÂŠ 2005 IEEE  '  $  collecting (r = 0), and every intermediate collect$    '  ing query is also weak collecting (n = 0). There'  Q6 Q    ?  fore, we say a query is collecting iff it is at least  k    $    QQ  iP  Q3 P    K  A  Q  Q  weak  collecting. The following result can be shown  3  Q PP  A  QQ      k  Q    PP   Q  Q  Q  ?        Q      ?  A  6    by inductive proofs on the structure and the number of  s  Q  P  s ?  Q  +    Q  P  q  Q1   Q2  Q5  Q9  - Q8  queries in the sublanguages of CTLQx .              kQ  Q    3      Q  3    6    ?  66 QQ     KA  A  +    s  Q      Lemma 1 ([7]). Every query in CTLQ1 and CTLQ2      )      Q4   ?    %  A    +  is weak collecting. Every query in CTLQ3 , CTLQ4 ,   Q7   6  &    and CTLQ5 is intermediate collecting. Every query  %  &  %  in CTLQ6 and CTLQ7 is boundary collecting. Every  Figure 2. CTLQ dependence diagram  Table 1, it becomes very symmetric when considering the dependencies of the non-terminals as shown in  Figure 2. Note that the vertex corresponding to nonterminal Q10 was omitted for simplicity because it  has only incoming edges (from Q2, Q5, and Q9) but  no outgoing edges.  By a series of nested inductive proofs, the following  theorem can be shown.  x  Theorem 1 ([7]). Every query in CTLQ is exact.  The major complication in the proof arises from the  fact that the dependencies between the sublanguages  are circular. Therefore, we need to use the following  auxiliary properties.  DeďŹnition 4. Let Îł be a CTL query.  â˘ We say Îł is strong collecting iff:  If Ď |= Îł[Ď] and Ď n |= Îł[Ď] for some n â N, then  Ď n |= Îł[Ď â§ Ď].  â˘ We say Îł is boundary collecting iff:  If Ď |= Îł[Ď] and Ď n |= Îł[Ď] for some n â N, then  Ď n |= Îł[Ď â§ Ď] or Ď |= Îł[âĽ].  â˘ We say Îł is intermediate collecting iff:  If Ď |= Îł[Ď] and Ď n |= Îł[Ď] for some n â N,  then Ď n |= Îł[Ď â§ Ď] or there exists r < n such  that Ď r |= Îł[âĽ].  â˘ We say Îł is weak collecting iff:  If s |= Îł[Ď] and s |= Îł[Ď], then s |= Îł[Ď â§ Ď].  It follows immediately from DeďŹnition 4 that every  strong collecting query is also boundary collecting,  every boundary collecting query is also intermediate  query in CTLQ8 , CTLQ9 , and CTLQ10 is strong  collecting.  Now, recall that CTLQx consists of the above CTL  query languages, i.e., all queries in CTLQx are at least  weak collecting. Moreover, it can be easily shown that  all queries Îł in CTLQx are monotonic. Hence, by the  following theorem, we obtain Theorem 1 above.  Theorem 2 ([7, 10]). A query is exact iff it is  monotonic and collecting.  Remark 1. In contrast to the characterization  of LTLQx [7, 10], we are unfortunately not able to  prove the maximality of CTLQx in the sense that all  simple queries, i.e., queries whose subformulas are  atomic and occur only once in the query, not in CTLQx  are not exact. Quite the contrary, CTLQx is not maximal in this sense and therefore not a characterization of  exact CTL queries. For example, consider the simple  query Îł = AF(a â§ AF(b â¨ AG ?)). It can be easily  veriďŹed that Îł â  / CTLQx although Îł is collecting.  Finally, let us remark that a proof of maximality by  counterexample construction as in the case of LTLQx  is much more difďŹcult in the case of CTLQx since a  counterexample to the collecting property for queries  in CTLQx is in general a computation tree instead of  a computation path as in the case of LTLQx .  4 Solving Queries in CTLQx  In this section, we show how to symbolically compute an exact solution to queries in CTLQx . The connection between computing an exact solution and the  collecting properties introduced in the previous section is: The collecting properties enable us to eliminate  non-determinism in the sense of existential choices. In  order to locate the cause of non-determinism in this  Proceedings of the 12th International Symposium on Temporal Representation and Reasoning (TIMEâ05)  1530-1311/05 $20.00 ÂŠ 2005 IEEE  Q1  ::=  ?  AX Q3  A( Q3 UĚ )  A( UĚ Q2 )  A( Q3 WĚ )  A( WĚ Q4 )  AX Q1  A( WĚ Q1 )  |  |  |  |  |  |  |  ;  â§ Q3  AX Q4  A( Q4 UĚ )  A( UĚ Q3 )  A( Q4 WĚ )  A( WĚ Q5 )  A( Q1 UĚ )  |  |  |  |  |  |  |  â§ Q4  AX Q6  A( UĚ Q4 )  A( UĚ Q4 )  A( WĚ Q2 )  â§ Q1  A( UĚ Q1 )  |  |  |  |  |  |  |  â¨ Q2  AX Q7  A( UĚ Q5 )  A( UĚ Q5 )  A( WĚ Q3 )  â¨ Q1  A( Q1 WĚ )  |  |  |  |  |  |  |  Q2  ::=  â§ Q5  A( Q5 WĚ )  â§ Q2  |  |  |  AX Q5  A( WĚ Q3 )  AX Q2  |  |  |  A( Q5 UĚ )  A( WĚ Q4 )  A( Q2 UĚ )  |  |  |  A( UĚ Q3 )  A( WĚ Q5 )  A( Q2 WĚ )  |  |  ;  Q3  ::=  AF Q6  A( Q5 U )  â¨ Q3  |  |  |  A( Q1 U )  A( Q6 U )  AF Q3  |  |  |  A( Q2 U )  A( Q7 U )  A( Q3 U )  |  |  |  A( Q4 U )  A( U Q6 )  A( U Q3 )  |  |  ;  Q4  ::=  â¨ Q5  A( Q7 UĚ )  A( UĚ Q6 )  A( Q3 W )  A( Q6 WĚ )  A( W Q6 )  â¨ Q4  A( W Q4 )  |  |  |  |  |  |  |  ;  AF Q5  A( U Q5 )  A( UĚ Q7 )  A( Q5 W )  A( Q7 WĚ )  A( W Q7 )  AF Q4  |  |  |  |  |  |  |  AF Q7  A( U Q7 )  A( Q1 W )  A( Q6 W )  A( W Q3 )  A( WĚ Q6 )  A( U Q4 )  |  |  |  |  |  |  |  A( Q6 UĚ )  A( UĚ Q7 )  A( Q2 W )  A( Q7 W )  A( W Q5 )  A( WĚ Q7 )  A( Q4 W )  |  |  |  |  |  |  |  Q5  ::=  A( UĚ Q6 )  |  A( WĚ Q6 )  |  A( WĚ Q7 )  ;  Q6  ::=  A( Q8 U )  |  A( Q9 U )  |  â¨ Q6  ;  Q7  ::=  â§ Q6  A( Q9 W )  |  |  |  |  â¨ Q9  â¨ Q7  |  ;  A( Q8 W )  |  Q8  ::=  AF Q9  AG Q6  A( UĚ Q9 )  AX Q8  A( U Q8 )  A( W Q8 )  |  |  |  |  |  |  AG Q1  AG Q7  A( W Q9 )  AF Q8  A( UĚ Q8 )  A( WĚ Q8 )  |  |  |  |  |  ;  AG Q3  A( U Q9 )  A( WĚ Q9 )  AG Q8  A( UĚ Q8 )  |  |  |  |  |  AG Q4  A( UĚ Q9 )  â§ Q8  A( Q8 UĚ )  A( Q8 WĚ )  |  |  |  |  |  Q9  ::=  A( WĚ Q8 )  A( Q9 WĚ )  |  |  â§ Q9  A( WĚ Q9 )  |  ;  AX Q9  |  A( Q9 UĚ )  |  Q10  ::=  AG Q2  â¨ Q10  A( Q10 U )  A( UĚ Q10 )  A( WĚ Q10 )  |  |  |  |  |  AG Q5  AX Q10  A( Q10 UĚ )  A( Q10 W )  A( WĚ Q10 )  |  |  |  |  ;  AG Q9  AF Q10  A( U Q10 )  A( Q10 WĚ )  |  |  |  |  â§ Q10  AG Q10  A( UĚ Q10 )  A( W Q10 )  |  |  |  |  â¨ Q8  â§ Q7  Table 1. CTLQx production rules  Proceedings of the 12th International Symposium on Temporal Representation and Reasoning (TIMEâ05)  1530-1311/05 $20.00 ÂŠ 2005 IEEE  context more systematically, note that temporal operators can be divided into universal and existential ones.  Let us consider some examples.  Example 1. For every path Ď and formula Ď it holds  that Ď |= G ÎłĚ[Ď] if and only if âi â N. Ď i |= ÎłĚ[Ď].  Thus, solving a query G ÎłĚ can be reduced to solving  its subquery ÎłĚ at universally quantiďŹed positions on a  path. Hence, we classify the global operator G to be a  universal operator.  In contrast, consider path Ď in Figure 3. Obviously,  it holds that Ď |= a U ÎłĚ[Ď] for every solution Ď to Îł =  a U ÎłĚ on Ď, but solving Îł cannot be reduced to solving  its subquery ÎłĚ at universally quantiďŹed positions on Ď.  However, for every path Ď it holds that Ď |= Î¸ U ÎłĚ[Ď]  if and only if âi â {j â N | j â¤ n}. Ď i |= ÎłĚ[Ď],  where n â N is the least number such that Ď n |= Î¸.  Thus, solving a query Î¸ U ÎłĚ can be reduced to solving its subquery ÎłĚ at existentially quantiďŹed positions  on a path. Hence, we classify the strong until operator U with respect to its second argument to be an existential operator. Note, however, that the strong until  operator with respect to its ďŹrst argument is universal.  To see this, let n â N be the least number such that  Ď n |= Î¸ for any path Ď and formula Î¸. Then, for every  formula Ď, it holds that Ď |= ÎłĚ[Ď] U Î¸ if and only if  âi â {j â N | j < n}. Ď i |= ÎłĚ[Ď].  The kind of non-determinism we consider in this  section arises from existential choices when solving  a query top-down by a reduction to solving its subqueries as demonstrated in Example 1. The formal  starting point of our investigations is therefore:  DeďŹnition 5 (Universal, Existential). Let O be an  n-ary temporal operator that is monotonic in its kth operand. Then, we deďŹne O to be universal  with respect to its k-th operand iff for all paths Ď  and formulas Ď1 , . . . , Ďkâ1 , Ďk+1 , . . . , Ďn satisfying  Ď |= O(Ď1 , . . . , Ďkâ1 , , Ďk+1 , . . . , Ďn ) there exists a set I â N, called reduction set, such that  Ď |= O(Ď1 , . . . , Ďkâ1 , Ď, Ďk+1 , . . . , Ďn ) iff âi â  I. Ď i |= Ď. We deďŹne O to be existential with  respect to its k-th operand iff O is not universal  with respect to its k-th operand and for all paths Ď  and formulas Ď1 , . . . , Ďkâ1 , Ďk+1 , . . . , Ďn satisfying  Ď |= O(Ď1 , . . . , Ďkâ1 , âĽ, Ďk+1 , . . . , Ďn ) there exists a set I â N, called reduction set, such that  Ď |= O(Ď1 , . . . , Ďkâ1 , Ď, Ďk+1 , . . . , Ďn ) iff âi â  I. Ď i |= Ď. If O is an n-ary operator that is universal (resp. existential) with respect to its k-th operand  and O(Ď1 , . . . , Ďkâ1 , ÎłĚ, Ďk+1 , . . . , Ďn ) occurs in a  query Îł for any formulas Ď1 , . . . , Ďkâ1 , Ďk+1 , . . . , Ďn ,  then we say that ÎłĚ is a universally (resp. existentially)  occurring subquery of Îł.  Note that all temporal operators used in this paper are either universal or existential with respect to  a selected operand. This fact is summarized in Table 2, where the placeholder indicates the corresponding operand. For example, consider the query Îł =  AG(a â¨ A(b U AX ÎłĚ)). Then, AX ÎłĚ is existentially  occurring in Îł, whereas ÎłĚ is universally occurring in Îł.  Remark 2. Note that the restrictions to paths on  which O(Ď1 , . . . , Ďkâ1 , , Ďk+1 , . . . , Ďn ) holds and  O(Ď1 , . . . , Ďkâ1 , âĽ, Ďk+1 , . . . , Ďn ) does not hold respectively in the above deďŹnition are necessary in order to achieve our desired classiďŹcation. For example,  the strong until operator U with respect to its ďŹrst argument would not be universal if we omitted the ďŹrst  condition, since it would not be universal on paths that  do not satisfy its second argument at any state. On  the other hand, the weak until operator W with respect  to its second argument would not be existential if we  omitted the second condition, since it would not be existential on paths that satisfy its ďŹrst argument globally.  The following deďŹnition will enable us to easily describe an appropriate reduction set I according to DeďŹnition 5 for the existential operators in Table 2.  DeďŹnition 6 (PreďŹx indices). A set I â N of natural  numbers is a set of preďŹx indices iff for each n â I  it holds that for all i < n, i â I. In particular, for  any path Ď and formula Ď, we deďŹne the set of preďŹx  indices IĎ (Ď) = {n â N | âi < n. Ď i |= Ď}.  Note that a set of preďŹx indices is either an initial  segment of N (i.e., a set of the form {i â N | i â¤ n}  for some n â N) or N itself. For example, let Ď be  the path shown in Figure 3. Then, IĎ (a) = {0, 1, 2},  IĎ (b) = {0}, and IĎ (a â¨ b) = N. The following  lemma shows that for the strong until operator with  respect to its second argument, the set of preďŹx indices is an appropriate reduction set according to Definition 5. It follows immediately from the deďŹnition of  the strong until operator.  Proceedings of the 12th International Symposium on Temporal Representation and Reasoning (TIMEâ05)  1530-1311/05 $20.00 ÂŠ 2005 IEEE  Universal  X?  G?  ?UĎ  ?WĎ  ? UĚ Ď  ? WĚ Ď  Existential  Ď UĚ ?  Ď WĚ ?  F?  ĎU?  Ď UĚ ?  ĎW?  Ď WĚ ?  Table 2. ClassiďŹcation of temporal operators      P  q  - a  - b +  a      Figure 3. PreďŹx index example  Lemma 2. For every path Ď and formula Ď it holds  that Ď |= Ď U Ď iff âi â IĎ (Ď). Ď i |= Ď.  versal quantiďŹcation has a higher priority in DeďŹnition 5, we obtain our desired classiďŹcation.  4.1 Eliminating Non-determinism  The following fact enables us to build up on the auxiliary results of our exactness proof in the previous section. It can be easily veriďŹed by the grammar deďŹning  CTLQx in Table 1.  Example 2. Consider path Ď shown in Figure 3 and  query Îł = a U ÎłĚ. Assume that we want to solve Îł  on Ď by reducing it to solving ÎłĚ on Ď. Since the strong  until operator with respect to its second argument is an  existential operator (cf. Table 2), i.e., ÎłĚ is an existentially occurring subquery, we know that there exists a  reduction of the form Ď |= Îł[Ď] iff âi â I. Ď i |= ÎłĚ[Ď]  for some set I â N. By Lemma 2, we are allowed to  choose I = IĎ (a) = {0, 1, 2}. Hence, we know that  solving Îł on Ď can be reduced to solving ÎłĚ at states  with indices in I, i.e., we obtain all solutions to Îł on Ď  by computing the solutions to ÎłĚ on Ď 0 , Ď 1 , and Ď 2 .  Intuitively, this means whenever in a CTLQx query  we meet an operator which has an existential semantics (such as Ď U ? ), then its context in the CTLQx  grammar ensures that a deterministic reduction is possible. This follows immediately from the intermediate collecting property and allows an algorithmic interpretation in order to eliminate existential choices as  described below.  Note that all existential operators in Table 2 are variants of the strong until operator. Thus, as we will see  in Section 4.2, it sufďŹces to have an appropriate reduction set for the strong until operator U.  Lemma 3 ([7]). Let Îł be an intermediate collecting  query and Ď be a path. Suppose that Ď n |= Îł[ ] for  some n â N. If Ď i |= Îł[âĽ] for all i < n, then every  solution to Îł on Ď is a solution to Îł on Ď n .  Remark 3. Not surprisingly, there is a close relationship between the classiďŹcation into universal and existential temporal operators and the ďŹrst-order quantiďŹcation of the corresponding operands in the deďŹnition of their semantics. However, there are also universal operators whose corresponding operand is existentially quantiďŹed, e.g., the disjoint strong until operator UĚ with respect to its second operand. But in these  cases it is easy to see that the semantics of the operators can be equivalently redeďŹned by using the uniqueness quantiďŹer â! instead of the existential quantiďŹer.  Consequently, since the reduction set in such cases is  a singleton set, universal and existential quantiďŹcation  over this set would be equivalent. However, since uni-  In other words, it sufďŹces to perform several simple model checking calls to achieve a deterministic reduction for query solving, and thus we can alleviate  the problem posed by the existential quantiďŹer. Since  it takes one call to a symbolic model checker to verify Îł[âĽ] for all states, the complexity of the model  checking step is signiďŹcantly lower than it were for  query solving. Based on this principle, we describe  a symbolic algorithm which computes exact solutions  for all queries in CTLQx . Chanâs algorithm then can  be obtained as a special case of our algorithm.  Since solving an existentially occurring query has  in general to be done at several states on a path, we  need the following deďŹnition.  Proposition 1. All existentially occurring subqueries  of queries in our fragment CTLQx are intermediate  collecting.  Proceedings of the 12th International Symposium on Temporal Representation and Reasoning (TIMEâ05)  1530-1311/05 $20.00 ÂŠ 2005 IEEE  DeďŹnition 7. Let Îł be a query, Ď be a path, and I â N.  Then, we deďŹne the set ofsolutions to Îł at positions  in I on Ď by solI (Ď, Îł) = iâI {Ď | Ď i |= Îł[Ď]}.  For our purposes, the set I will be a set of preďŹx indices representing the existential choices of positions on Ď when solving an existentially occurring subquery Îł. Thus, in order to obtain all solutions, Îł has  in general to be solved at all states with indices in I.  Note that if there exists i â I such that Ď i |= Îł[âĽ],  then, if Îł is monotonic, every formula is an element  of solI (Ď, Îł) and therefore the solutions at other states  with indices in I do not affect solI (Ď, Îł). This case is  somehow exceptional since it can be simply checked  by evaluating the formula Îł[âĽ] at all states with indices in I, which can be performed by a single symbolic model checking call.  Otherwise, if no such a preďŹx index exists, it follows immediately from the intermediate collecting  property by repeated application of Lemma 3 that  sol{i0 } (Ď, Îł) â sol{i1 } (Ď, Îł) â sol{i2 } (Ď, Îł) â Âˇ Âˇ Âˇ ,  where i0 < i1 < i2 < Âˇ Âˇ Âˇ and Ď n |= Îł[ ] for all  n â {i1 , i2 , i3 , . . .} â I. Hence, when solving an intermediate collecting query at several states on a path,  it sufďŹces to solve the query at states with indices as  high as possible. In particular, if there exists a highest  index n â I such that Ď n |= Îł[ ], it sufďŹces to solve  the query at this state.  Example 3. Recall Example 2 and let us now consider  the case where ÎłĚ is intermediate collecting. In this case  we can determinize the reduction in such a way that I  becomes a singleton set. In particular, if Ď i |= ÎłĚ[ ]  and Ď i |= ÎłĚ[âĽ] for all i â IĎ (a), it follows from the intermediate collecting property according to Lemma 3  that sol{0} (Ď, ÎłĚ) â sol{1} (Ď, ÎłĚ) â sol{2} (Ď, ÎłĚ). Thus,  the solutions obtained by solving ÎłĚ on Ď 0 and Ď 1 are  also solutions on Ď 2 . Hence, it sufďŹces to solve ÎłĚ  on Ď 2 , i.e., the state with highest index in IĎ (a). So  we know that Ď |= Îł[Ď] iff Ď 2 |= ÎłĚ[Ď] for all Ď.  We are now going to state this insight formally  which will enable us to extend the Chan algorithm and  can be used in order to prove its correctness.  Lemma 4 ([7]). Let Îł be an intermediate collecting  query, Ď be a path, and I â N. Suppose that there is  a least index m â I and a highest index n â I such  that Ď m |= Îł[ ] and Ď n |= Îł[ ]. If Ď i |= Îł[âĽ] for all  m â¤ i < n, then sol{n} (Ď, Îł) = solI (Ď, Îł).  Note that Lemma 4 does not cover all cases that  may appear when solving a query. In particular, it says  nothing about the case where the highest index n â I  does not exist. This case occurs if I contains an inďŹnite number of indices i satisfying Ď i |= Îł[ ]. Note  that such indices must refer to states in a cycle, since  only states in a cycle have an inďŹnite number of indices. For every path Ď, let us deďŹne the set of cycle  indices cycle(Ď) = {i â N | i âĽ k}, where k is  the length of the path preďŹx of Ď before the ďŹrst cycle  starts. Thus, we are able to state the following lemma.  Lemma 5 ([7]). Let Îł be an intermediate collecting  query, Ď be a path, and I â N. Suppose that there is  a least index m â I and an index n â cycle(Ď) âŠ I  such that Ď m |= Îł[ ] and Ď n |= Îł[ ]. If Ď i |= Îł[âĽ]  for all i âĽ m, then sol{n} (Ď, Îł) = solI (Ď, Îł).  4.2 The Extended Chan Algorithm  The Chan algorithm was introduced by William  Chan [2] in order to solve queries in his syntactic fragment of valid CTL queries, i.e., CTL queries that are  guaranteed to have an exact solution in every model.  However, Chan neither proved the correctness of his  algorithm nor did he describe its functionality. With  our insights above, it is possible to prove the correctness of Chanâs algorithm when applied to valid queries  within our fragment CTLQx . Note that such queries  can be simply obtained by restricting the grammar in  Table 1 to those operators that guarantee validity.  In the following, we are interested in a generalization of Chanâs algorithm that is able to solve queries in  the whole fragment CTLQx , i.e., queries that have an  exact solution if there exists any solution.  DeďŹnition 8 (Auxiliary sets). Following Chan, we  introduce the following three macros (parameterized  by Ď and Îł) as abbreviations:  RĎ = ÂľZ. ((Q âŞ postâ (Z)) âŠ Ď)  CĎÎł  BĎÎł  = Î˝Z. (RĎâ§ÂŹÎł[âĽ] âŠ postâ (Z))  = (Q âŞ postâ (RĎâ§ÂŹÎł[âĽ] )) \ (Ď âŞ Îł[âĽ])  The intuitive meaning of these three auxiliary sets  is illustrated in Figure 4, where the initial set Q is assumed to consist of the four double-circled states. The  Proceedings of the 12th International Symposium on Temporal Representation and Reasoning (TIMEâ05)  1530-1311/05 $20.00 ÂŠ 2005 IEEE  Algorithm 1 The extended Chan algorithm  function FSol(Îł, Ď, Q, cycle) begin  if cycle then C = CĎÎł else C = â ;  U1 = Î˝Z. ((C \ Îł[]) âŠ postâ (Z)) ;  Îł  \ Îł[]) ;  U2 = U1 âŞ (BĎ  U3 = ÂľZ. (((U2 âŞ preâ (Z)) âŠ RĎâ§ÂŹÎł[âĽ] ) \ Îł[]) ;  Îł  âŞ C) âŠ Îł[] ;  ret ((preâ (U3 ) âŠ RĎâ§ÂŹÎł[âĽ] ) âŞ BĎ  end  function ESol(Îł, Q) begin  case Îł of  ? :  return Q ;  Î¸ â§ ÎłĚ :  return ESol(ÎłĚ, Q) ;  Î¸ â¨ ÎłĚ :  return ESol(ÎłĚ, Q \ Î¸) ;  AX ÎłĚ :  return ESol(ÎłĚ, postâ (Q)) ;  AF ÎłĚ :  return ESol(A( U ÎłĚ), Q) ;  AG ÎłĚ :  return ESol(A(ÎłĚ WĚ âĽ), Q) ;  A(ÎłĚ U Î¸) :  return ESol(A((Î¸ â¨ ÎłĚ) WĚ Î¸), Q) ;  A(ÎłĚ UĚ Î¸) :  return ESol(A(ÎłĚ WĚ Î¸), Q) ;  A(Î¸ U ÎłĚ) :  return ESol(ÎłĚ, FSol(ÎłĚ, Î¸, Q, true)) ;  A(Î¸ UĚ ÎłĚ) :  return ESol(A(Î¸ U (Î¸ â§ ÎłĚ)), Q) ;  A(Î¸ UĚ ÎłĚ) :  return ESol(A(Î¸ WĚ ÎłĚ), Q) ;  A(ÎłĚ W Î¸) : return ESol(A((Î¸ â¨ ÎłĚ) WĚ Î¸), Q) ;  A(ÎłĚ WĚ Î¸) : return ESol(ÎłĚ, Q âŞ postâ (RÂŹÎ¸ )) ;  A(Î¸ W ÎłĚ) : return ESol(ÎłĚ, FSol(ÎłĚ, Î¸, Q, false)) ;  A(Î¸ WĚ ÎłĚ) : return ESol(A(Î¸ W (Î¸ â§ ÎłĚ)), Q) ;  A(Î¸ WĚ ÎłĚ) : return ESol(ÎłĚ, (Q âŞ postâ (RÎ¸ )) \ Î¸) ;  esac  end  set RĎâ§ÂŹÎł[âĽ] consists of those states that are reachable  from states in Q by going only through states at which  Ďâ§ÂŹÎł[âĽ] holds. In particular, R consists of all states  that are reachable from states in Q. The set CĎÎł consists of all states within a cycle in RĎâ§ÂŹÎł[âĽ] . Finally,  the set BĎÎł consists of the boundary of RĎâ§ÂŹÎł[âĽ] , i.e.,  the ďŹrst states on each path starting from Q that are  not in RĎâ§ÂŹÎł[âĽ] and at which Îł[âĽ] does not hold. The  following lemma states the meaning of these sets more  formally.  Lemma 6 ([7]). Let Îł be a query, Ď be a formula, and  Q be a set of states in a Kripke structure. Moreover,  let Î  â paths(Q) such that Ď â Î  iff Ď i |= Îł[âĽ] for  all i â IĎ (Ď). Then, RĎ , CĎÎł , and BĎÎł are the sets of  states on paths Ď â paths(Q) such that  1. Ď(n) â RĎ iff for all i â¤ n it holds that Ď i |= Ď.  2. Ď(n) â CĎÎł iff Ď â Î , IĎ (Ď) is inďŹnite, and n â  cycle(Ď).  3. Ď(n) â BĎÎł iff Ď â Î , IĎ (Ď) is ďŹnite, and n =  max(IĎ (Ď)).  Ď  ÂŹÎł[âĽ]  Ď  Îł[âĽ]  Ď  ÂŹÎł[âĽ]  ÂŹĎ  ÂŹÎł[âĽ]  Ď  ÂŹÎł[âĽ]  ...  Ď  ÂŹÎł[âĽ]  Ď  ÂŹÎł[âĽ]  Îł  BĎ  ...  ÂŹĎ  ÂŹÎł[âĽ]  ...  Ď  ÂŹÎł[âĽ]  Ď  ÂŹÎł[âĽ]  RĎâ§ÂŹÎł[âĽ]  Ď  ÂŹÎł[âĽ]  Ď  ÂŹÎł[âĽ]  CĎÎł  Figure 4. Auxiliary sets in Chanâs algorithm  It is thus easy to see that the states in BĎ are those  with the highest index on each path satisfying the conditions of Lemma 4, and the states in CĎ are those  within a cycle on each path satisfying the conditions  of Lemma 5. Hence, according to Lemma 4 and  Lemma 5, solving a query in our fragment can be reduced to solving its existentially occurring valid subqueries at the set of states BĎ and CĎ without existential choices. Although this kind of determinization is not possible in general, it can be extended to  the whole fragment CTLQx . However, when extending Chanâs algorithm (see Algorithm 1) to the whole  fragment CTLQx , the existence of a solution at each  state is no longer guaranteed. Therefore, the required  set of states satisfying the conditions of Lemma 4 and  Lemma 5 such that solving a query can be reduced to  solving its subqueries at this set, has to be computed  in a more sophisticated way. In particular, we compute the set of states that correspond to highest indices  resp. cycle indices in I. Afterwards, we traverse the  corresponding paths backwards until a state on each  path is found at which Îł has a solution. These are  then the states with highest indices among the states at  which Îł has a solution, i.e., it sufďŹces to solve Îł at this  uniquely determined set of states. This idea of computing the states at which Îł has a solution and that are  furthest away is implemented by the function FSol in  Algorithm 1. Intuitively, the sets U1 and U2 together  consist of all states with highest indices but on which  Îł has no solution. The set U3 consists then of all states  that can be reached by going backwards as long as Îł  does not have a solution. Thus, by making a further  Proceedings of the 12th International Symposium on Temporal Representation and Reasoning (TIMEâ05)  1530-1311/05 $20.00 ÂŠ 2005 IEEE  step backwards, we obtain the desired set of states, i.e.,  the states with highest indices at which Îł has a solution. In this way, it is possible to prove the correctness  of the extended Chan algorithm.  DeďŹnition 9 (Solution states). Let Îł be a query and Q  be a set of states in a Kripke structure. A set of states  S is the unique set of solution states to Îł at Q iff it  holds that S |= Ď iff Q |= Îł[Ď] for all formulas Ď.  The following theorem states our main result. It can  be proved by structural induction on Îł.  Theorem 3 ([7]). Let Îł â CTLQx and Q be a set  of states in a Kripke structure. Moreover, let ESol  be the function deďŹned in Algorithm 1. Suppose that  Q |= Îł[ ], i.e., Îł has a solution at each state in Q.  Then, ESol(Îł, Q) returns the unique set of solution  states to Îł at Q.  In particular, the following corollary shows how to  obtain a propositional exact solution by the extended  Chan algorithm.  Corollary 1 ([7]). Let Îł â CTLQx and s0 be the initial state of a Kripke structure K. Moreover, let ESol  be the function deďŹned in Algorithm 1. Then, the characteristic function of the set returned by ESol(Îł, {s0 })  is a propositional exact solution to Îł in K.  5 Conclusion  In this paper we have systematically investigated  symbolic algorithms for query solving and have argued that symbolic algorithms work for queries which  can be solved by a recursive deterministic descent.  To conclude this paper, let us consider the question  of exact queries and their relevance. It is evident that  temporal logic queries will in many cases have multiple incomparable solutions; algorithms for computing multiple solutions as well as extensions to multiple placeholders have been the subject of important  related work [1, 5, 3, 4]. However, the only existing implementation TLQSolver [3] we are aware of  is based on a multi-valued model checker. Since the  multi-valued setting is essential to their approach, we  believe that the results and methods in the current paper are orthogonal to the multi-valued approach. We  speculate that the central role of determinism in the  Chan style approach in combination with the highly  optimized environment of tools such as SMV will incur algorithmic advantages, leading to a trade-off in  our case between lower expressibility and higher expected performance. A ďŹnal assertion on the practical  performance of both approaches can of course only be  achieved by systematic experiments. Therefore, natural future work includes the implementation and experimental evaluation of our algorithm.  References  [1] G. Bruns and P. Godefroid. Temporal logic query  checking. In Proc. of the 16th Annual IEEE Symposium on Logic in Computer Science (LICS), pages  409â417. IEEE Computer Society, 2001.  [2] W. Chan. Temporal-logic queries. In Proc. of the 12th  International Conference on Computer Aided VeriďŹcation (CAV), volume 1855 of LNCS, pages 450â463.  Springer-Verlag, 2000.  [3] M. Chechik and A. GurďŹnkel. TLQSolver: A temporal logic query checker. In Proc. of the 15th International Conference on Computer Aided VeriďŹcation (CAV), volume 2725 of LNCS, pages 210â214.  Springer-Verlag, 2003.  [4] A. GurďŹnkel, M. Chechik, and B. Devereux. Temporal logic query checking: A tool for model exploration. IEEE Transactions on Software Engineering  (TSE), 29(10):898â914, 2003.  [5] A. GurďŹnkel, B. Devereux, and M. Chechik. Model  exploration with temporal logic query checking. In  Proc. of the 10th ACM Symposium on Foundations of  Software Engineering (FSE), pages 139â148. ACM,  2002.  [6] M. Samer. Temporal logic queries in model checking.  Masterâs thesis, TU Vienna, May 2002.  [7] M. Samer. Reasoning about SpeciďŹcations in Model  Checking. PhD thesis, TU Vienna, Sept. 2004.  [8] M. Samer and H. Veith. Validity of CTL queries  revisited. In Proc. of the 12th Annual Conference  of the European Association for Computer Science  Logic (CSL), volume 2803 of LNCS, pages 470â483.  Springer-Verlag, 2003.  [9] M. Samer and H. Veith. Parameterized vacuity. In  Proc. of the 5th International Conference on Formal  Methods in Computer-Aided Design (FMCAD), volume 3312 of LNCS, pages 322â336. Springer-Verlag,  2004.  [10] M. Samer and H. Veith. A syntactic characterization  of distributive LTL queries. In Proc. of the 31st International Colloquium on Automata, Languages and  Programming (ICALP), volume 3142 of LNCS, pages  1099â1110. Springer-Verlag, 2004.  Proceedings of the 12th International Symposium on Temporal Representation and Reasoning (TIMEâ05)  1530-1311/05 $20.00 ÂŠ 2005 IEEE 