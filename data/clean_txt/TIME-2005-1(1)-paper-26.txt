Deterministic CTL Query SolvingÃ¢ÂˆÂ—  Marko Samer  Institute of Information Systems (DBAI)  Vienna University of Technology, Austria  samer@dbai.tuwien.ac.at  Abstract  Temporal logic queries provide a natural framework to extend the realm of model checking from mere  veriÄÅ¹Âcation of engineersÃ¢Â€Â™ speciÄÅ¹Âcations to computing  previously unknown temporal properties of a system.  Formally, temporal logic queries are patterns of temporal logic speciÄÅ¹Âcations which contain placeholders for subformulas; a solution to a temporal logic  query is an instantiation which renders the speciÄÅ¹Âcation true. In this paper, we investigate temporal logic  queries that can be solved deterministically, i.e., solving such queries can be reduced in a deterministic  manner to solving their subqueries at appropriate system states. We show that this kind of determinism is  intimately related to the notion of intermediate collecting queries studied by the authors in previous work.  We describe a large class of deterministically solvable  CTL queries and devise a BDD-based symbolic algorithm for this class.  1 Introduction and Overview  Temporal logic query solving is an extension of  model checking introduced in a seminal paper by  Chan [2]. A temporal logic query is a temporal logic  formula containing one or more occurrences of a distinguished proposition Ã¢Â€Âœ?Ã¢Â€Â which is treated as a placeholder. Given a system model K and a query ÃÅ‚, a solution to ÃÅ‚ in K is a formula ÄÂ• satisfying K |= ÃÅ‚[ÄÂ•].  Thus, in contrast to a model checker which essentially  Ã¢ÂˆÂ—  This work was jointly funded by the European network  CoLogNET (IST-2001-33123) and the EU Network of Excellence  REWERSE (506779). The results presented in this paper have  been developed as part of [7].  Helmut Veith  Institut fuÄšÂˆr Informatik (I7)  Technische UniversitaÄšÂˆt MuÄšÂˆnchen, Germany  veith@in.tum.de  returns a truth value and possibly a counterexample,  the task of a query solver is to infer a set of formulas.  Essentially, the query can be viewed as a Ã¢Â€ÂœspeciÄÅ¹Âcation  skeletonÃ¢Â€Â which describes the solution space. Query  solving provides a versatile framework which facilitates diverse veriÄÅ¹Âcation tasks including legacy code  analysis, counterexample understanding, and vacuity  detection [2, 1, 5, 3, 4, 9].  The current paper focuses on the notion of deterministic query solving. We say that a query can be  solved deterministically if solving the query can be  reduced in a deterministic manner to solving its subqueries at appropriate system states. Note that deterministic query solving is not possible for arbitrary  queries. The Kripke structure K in Figure 1 illustrates deterministic query solving for the query ÃÅ‚ =  A(ÄÂ• U AG ?). This query ÃÅ‚ has the following property: A formula ÄÂˆ is a solution to ÃÅ‚ in K if ÄÂˆ is a solution to ÃÅ‚Ã¢Â€Â™s immediate subquery ÃÅ‚ÄšÂ„ = AG ? at a set S of  states that is reachable from s0 by going only through  states at which ÄÂ• holds. This follows immediately  from the semantics of the until operator U. Examples  of such sets are the set S1 = {s2 , s4 , s5 , s8 , s9 } and  the set S2 = {s4 , s6 , s7 , s9 , s10 , s11 , s12 } in Figure 1.  Thus, we know that S1 |= ÃÅ‚ÄšÂ„[ÄÂˆ] as well as S2 |= ÃÅ‚ÄšÂ„[ÄÂˆ]  imply that ÄÂˆ is a solution to ÃÅ‚ in K. Conversely, if ÄÂˆ  is a solution to ÃÅ‚ in K, we know that there exists some  set S as above such that S |= ÃÅ‚ÄšÂ„[ÄÂˆ] but we do in general  not know which one. Therefore, in a naive approach,  to obtain all solutions to the query ÃÅ‚ = A(ÄÂ• U AG ?)  we would have to loop through all possibilities for S.  For certain queries such as ÃÅ‚ considered above,  however, it is possible to determine a single set S  which gives already all solutions. In this case we speak  of deterministic query solving. In our example above,  Proceedings of the 12th International Symposium on Temporal Representation and Reasoning (TIMEÃ¢Â€Â™05)  1530-1311/05 $20.00 Ã‚Å  2005 IEEE  s1  ÄÂ•  s4  Ã‚Å¹ÄÂ• . . .  ÄÂ•  s0  ÄÂ•  s2  ÄÂ•  s3  ÄÂ•  s5  s6  Ã‚Å¹ÄÂ• . . .  s10  Ã‚Å¹ÄÂ• . . .  s11  Ã‚Å¹ÄÂ• . . .  s7  Ã‚Å¹ÄÂ• . . .  ÄÂ•  s8  s12  Ã‚Å¹ÄÂ• . . .  s9  Ã‚Å¹ÄÂ• . . .  Figure 1. Example of solving A(ÄÂ• U AG ?)  the set S2 is this set S. To see this, note that all other  possibilities for S Ã¢Â€Âœare located to the left of S2 Ã¢Â€Â in Figure 1. Moreover, the subquery ÃÅ‚ÄšÂ„ is looking for an invariant. Since everything that is an invariant to the left  of S2 must remain an invariant at S2 , it sufÄÅ¹Âces to compute the solutions at S2 .  From this example we see that solving ÃÅ‚ can be reduced to solving its subquery at a deterministically determined set of states. In this paper, we will investigate query solving algorithms which are based on such  efÄÅ¹Âcient deterministic reductions. Since deterministic  reductions are not possible for all queries, the development of deterministic query solving algorithms ÄÅ¹Ârst  requires a (quite complicated) analysis of those queries  which have the required property.  Our main results show that (i) deterministic query  solving is closely related to the notion of intermediate collecting queries. Exploiting this relationship,  we show (ii) how deterministic query solving gives  rise to symbolic query solving algorithms. Our work  achieves (iii) an extension of ChanÃ¢Â€Â™s algorithm to a  much wider class of queries.  In order to explain the results of this paper in more  detail, we ÄÅ¹Ârst need to review some of the previous  research about temporal logic queries. In [2], Chan investigated CTL queries ÃÅ‚ that are guaranteed to have  an exact solution in every model, i.e., a solution ÃÅ¾  that implies all other solutions to ÃÅ‚. Chan presented  a syntactic fragment of such queries and a symbolic  BDD-based algorithm for solving them, albeit without  proofs and with incorrect results. A systematic study  by the authors aimed at an extension and correction of  ChanÃ¢Â€Â™s work by identifying exact queries, i.e., queries  that have an exact solution if there exists any solution but that are not guaranteed to have a solution in  every model. This research resulted in (i) the deÄÅ¹Ânition of an exact CTL query language which corrects  the errors found in ChanÃ¢Â€Â™s fragment [6, 8] and (ii) a  syntactic characterization of exact LTL queries by a  template grammar [7, 10]. ChanÃ¢Â€Â™s symbolic algorithm  is still poorly understood and has not been systematically investigated so far. Given the errors found in  ChanÃ¢Â€Â™s query language, and the absence of proofs in  ChanÃ¢Â€Â™s posthumous paper, the correctness and principles of his algorithm have remained unclear.  The current paper as a ÄÅ¹Ârst result reports on a significant extension of the previously known class of exact  CTL queries (cf. Table 1). The main result in this paper, however, concerns CTL query solving algorithms.  Based on our insights on exact CTL queries, we give  an exact and novel exposition of symbolic query solving algorithms and argue why the class of exact queries  is amenable to classical BDD-based symbolic ÄÅ¹Âxpoint  algorithms. Since symbolic algorithms build up sets  of states, they can only collect solutions, but not account for case distinctions. Consequently, reductions  of solving queries to solving their subqueries can only  be performed by symbolic algorithms when the set of  states at which the subqueries have to be solved can  be computed deterministically. This situation is intuitively accounted for in ChanÃ¢Â€Â™s algorithm; his algorithm reduces the computation of solutions to a CTL  query at a given set of states to the computation of  solutions of a subquery at another set of states. This  reduction is repeatedly applied until the placeholder is  reached.  Our results also have the following intuitively appealing logical interpretation: Since exact queries are  characterized by distributivity (i.e., ÃÅ‚[ÄÂ•] Ã¢ÂˆÂ§ ÃÅ‚[ÄÂˆ] Ã¢Â‡Â”  ÃÅ‚[ÄÂ• Ã¢ÂˆÂ§ ÄÂˆ]) [7, 10], it is natural to expect that distributivity holds in cases where the placeholder is universally quantiÄÅ¹Âed and is violated otherwise. Consequently, our results give an intuitive high-level explanation which fragments of LTL and CTL are exact.  This paper is organized as follows: In Section 2,  we shortly summarize the formalisms used in the remainder of this paper. Afterwards, in Section 3,  we formally introduce temporal logic queries and we  present our syntactic fragment CTLQx of exact CTL  queries. Then, we systematically investigate proper-  Proceedings of the 12th International Symposium on Temporal Representation and Reasoning (TIMEÃ¢Â€Â™05)  1530-1311/05 $20.00 Ã‚Å  2005 IEEE  ties of queries in CTLQx in Section 4 consisting of  two subsections. In Section 4.1, we show how nondeterminism in the sense of existential choices can be  eliminated when solving queries in CTLQx . Based  on these insights, we present our extension of ChanÃ¢Â€Â™s  symbolic algorithm and state its correctness in Section 4.2. Finally, we conclude in Section 5.  2 Preliminaries  We assume the reader is familiar with the basics of  (symbolic) model checking, i.e., Kripke structures, the  computation tree logic CTL based on the temporal operators X (Ã¢Â€ÂœnextÃ¢Â€Â), F (Ã¢Â€ÂœfutureÃ¢Â€Â), G (Ã¢Â€ÂœglobalÃ¢Â€Â), and  U (Ã¢Â€ÂœuntilÃ¢Â€Â), the least and greatest ÄÅ¹Âxpoint-operators Ã‚Ä¾  and ÃË, etc.  Let K = (Q, Q0 , Ã¢ÂˆÂ†, ) be a Kripke structure over  the set A of atomic propositions, where Q is a set of  states, Q0 Ã¢ÂŠÂ† Q is the set of initial states, Ã¢ÂˆÂ† Ã¢ÂŠÂ† Q Ä‚Â— Q  is a total transition relation, and  : Q Ã¢Â†Â’ Ã¢Â„Â˜(A) is a  total labeling function. A computation path or simply  path ÄÂ€ in K is an inÄÅ¹Ânite sequence of states ÄÂ€ : N Ã¢Â†Â’ Q  such that (ÄÂ€(i), ÄÂ€(i + 1)) Ã¢ÂˆÂˆ Ã¢ÂˆÂ† for all i Ã¢ÂˆÂˆ N. We  write ÄÂ€ n to denote the computation path satisfying  ÄÂ€ n (i) = ÄÂ€(n + i) for all i Ã¢ÂˆÂˆ N. As usual we write  K, s |= ÄÂ• to denote that the CTL formula ÄÂ• is satisÄÅ¹Âed at state s in K, and we write K |= ÄÂ• to denote  K, s0 |= ÄÂ•, where s0 is the initial state of K. For simplicity, we also write K, ÄÂ€ |= ÄÂ• to denote K, ÄÂ€(0) |= ÄÂ•  and K, S |= ÄÂ• to denote K, s |= ÄÂ• for all s Ã¢ÂˆÂˆ S. We  omit K if it is clear from the context.  Following Chan [2], we use some additional temporal operators. In particular, we use the weak until  operator ÄÂ• W ÄÂˆ Ã¢Â‡Â” (G ÄÂ•) Ã¢ÂˆÂ¨ (ÄÂ• U ÄÂˆ). The other operators are variants of the strong until operator U and the  weak until operator W:  ÄÂ• UÄšÂŠ ÄÂˆ Ã¢Â‡Â” ÄÂ• U (ÄÂ• Ã¢ÂˆÂ§ ÄÂˆ)  ÄÂ• UÄšÂ„ ÄÂˆ Ã¢Â‡Â” ÄÂ• U (Ã‚Å¹ÄÂ• Ã¢ÂˆÂ§ ÄÂˆ)  ÄÂ• WÄšÂŠ ÄÂˆ Ã¢Â‡Â” ÄÂ• W (ÄÂ• Ã¢ÂˆÂ§ ÄÂˆ)  ÄÂ• WÄšÂ„ ÄÂˆ Ã¢Â‡Â” ÄÂ• W (Ã‚Å¹ÄÂ• Ã¢ÂˆÂ§ ÄÂˆ)  The additional operators will give rise to stronger  temporal logic queries although they do not increase  the expressive power of CTL. We call an n-ary temporal operator O monotonic in its k-th operand iff for  all formulas ÃÂ¸1 , . . . , ÃÂ¸kÃ¢ÂˆÂ’1 , ÃÂ¸k+1 , . . . , ÃÂ¸n it holds that  ÄÂ• Ã¢Â‡Â’ ÄÂˆ implies O(ÃÂ¸1 , . . . , ÃÂ¸kÃ¢ÂˆÂ’1 , ÄÂ•, ÃÂ¸k+1 , . . . , ÃÂ¸n ) Ã¢Â‡Â’  O(ÃÂ¸1 , . . . , ÃÂ¸kÃ¢ÂˆÂ’1 , ÄÂˆ, ÃÂ¸k+1 , . . . , ÃÂ¸n ) for all formulas ÄÂ•  and ÄÂˆ.  3 Exact CTL Queries  In this section, we survey some basic properties of  temporal logic queries.  DeÄÅ¹Ânition 1 (CTL query). A CTL query is a CTL formula where some subformulas are replaced by a special variable ?, called placeholder. We write ÃÅ‚[ÄÂ•] to  denote the result of substituting all occurrences of the  placeholder in ÃÅ‚ by ÄÂ•. We denote the set of all CTL  queries by CTLQ.  DeÄÅ¹Ânition 2 (Solution). Let ÃÅ‚ be a query, K be a  Kripke structure, and ÄÂ• be a formula. If K |= ÃÅ‚[ÄÂ•],  then we say that ÄÂ• is a solution to ÃÅ‚ in K. We denote the set of all solutions to ÃÅ‚ in K by sol(K, ÃÅ‚) =  {ÄÂ• | K |= ÃÅ‚[ÄÂ•]}. A solution ÃÅ¾ to a query ÃÅ‚ in a  Kripke structure K is exact iff it holds that sol(K, ÃÅ‚) =  {ÄÂ• | ÃÅ¾ Ã¢Â‡Â’ ÄÂ•}.  We call a query ÃÅ‚ monotonic iff ÄÂ• Ã¢Â‡Â’ ÄÂˆ implies  ÃÅ‚[ÄÂ•] Ã¢Â‡Â’ ÃÅ‚[ÄÂˆ] for all formulas ÄÂ• and ÄÂˆ. Note that  it follows immediately from this deÄÅ¹Ânition that ÃÅ‚ (if  monotonic) has a solution in K iff K |= ÃÅ‚[ ] and every  formula is a solution to ÃÅ‚ in K iff K |= ÃÅ‚[Ã¢ÂŠÄ½]. We are  now able to give a formal deÄÅ¹Ânition of exact queries.  DeÄÅ¹Ânition 3 (Exact query). A query is exact iff it has  an exact solution in every Kripke structure where the  set of solutions is not empty.  In analogy to ChanÃ¢Â€Â™s E XP T IME-completeness proof  for deciding validity of CTL queries [2] it can be  shown by reduction from and to the validity of CTL  formulas that deciding exactness of CTL queries is  also E XP T IME-complete [7]. The main implication  of this result is the fact that no simple grammar can  recognize all exact CTL queries. Therefore, we deÄÅ¹Âne  an extensive syntactic fragment CTLQx such that all  queries in this fragment are exact. To this aim, consider the deterministic context-free template grammar  in Table 1, where is a special wildcard symbol representing any CTL formula. For example, the template A( U ÃÅ‚) represents all CTL queries of the form  A(ÄÂ• U ÃÅ‚), where ÄÂ• is a CTL formula. In the following, we write CTLQ1 for the language derived from  non-terminal Q1, CTLQ2 for the language derived  Q2, and so on. The language CTLQx is deÄÅ¹Âned  from  10  as i=1 CTLQi . Although the deÄÅ¹Ânition of CTLQx  seems to be messy when considering the grammar in  Proceedings of the 12th International Symposium on Temporal Representation and Reasoning (TIMEÃ¢Â€Â™05)  1530-1311/05 $20.00 Ã‚Å  2005 IEEE  '  $  collecting (r = 0), and every intermediate collect$    '  ing query is also weak collecting (n = 0). There'  Q6 Q    ?  fore, we say a query is collecting iff it is at least  k    $    QQ  iP  Q3 P    K  A  Q  Q  weak  collecting. The following result can be shown  3  Q PP  A  QQ      k  Q    PP   Q  Q  Q  ?        Q      ?  A  6    by inductive proofs on the structure and the number of  s  Q  P  s ?  Q  +    Q  P  q  Q1   Q2  Q5  Q9  - Q8  queries in the sublanguages of CTLQx .              kQ  Q    3      Q  3    6    ?  66 QQ     KA  A  +    s  Q      Lemma 1 ([7]). Every query in CTLQ1 and CTLQ2      )      Q4   ?    %  A    +  is weak collecting. Every query in CTLQ3 , CTLQ4 ,   Q7   6  &    and CTLQ5 is intermediate collecting. Every query  %  &  %  in CTLQ6 and CTLQ7 is boundary collecting. Every  Figure 2. CTLQ dependence diagram  Table 1, it becomes very symmetric when considering the dependencies of the non-terminals as shown in  Figure 2. Note that the vertex corresponding to nonterminal Q10 was omitted for simplicity because it  has only incoming edges (from Q2, Q5, and Q9) but  no outgoing edges.  By a series of nested inductive proofs, the following  theorem can be shown.  x  Theorem 1 ([7]). Every query in CTLQ is exact.  The major complication in the proof arises from the  fact that the dependencies between the sublanguages  are circular. Therefore, we need to use the following  auxiliary properties.  DeÄÅ¹Ânition 4. Let ÃÅ‚ be a CTL query.  Ã¢Â€Ë˜ We say ÃÅ‚ is strong collecting iff:  If ÄÂ€ |= ÃÅ‚[ÄÂ•] and ÄÂ€ n |= ÃÅ‚[ÄÂˆ] for some n Ã¢ÂˆÂˆ N, then  ÄÂ€ n |= ÃÅ‚[ÄÂ• Ã¢ÂˆÂ§ ÄÂˆ].  Ã¢Â€Ë˜ We say ÃÅ‚ is boundary collecting iff:  If ÄÂ€ |= ÃÅ‚[ÄÂ•] and ÄÂ€ n |= ÃÅ‚[ÄÂˆ] for some n Ã¢ÂˆÂˆ N, then  ÄÂ€ n |= ÃÅ‚[ÄÂ• Ã¢ÂˆÂ§ ÄÂˆ] or ÄÂ€ |= ÃÅ‚[Ã¢ÂŠÄ½].  Ã¢Â€Ë˜ We say ÃÅ‚ is intermediate collecting iff:  If ÄÂ€ |= ÃÅ‚[ÄÂ•] and ÄÂ€ n |= ÃÅ‚[ÄÂˆ] for some n Ã¢ÂˆÂˆ N,  then ÄÂ€ n |= ÃÅ‚[ÄÂ• Ã¢ÂˆÂ§ ÄÂˆ] or there exists r < n such  that ÄÂ€ r |= ÃÅ‚[Ã¢ÂŠÄ½].  Ã¢Â€Ë˜ We say ÃÅ‚ is weak collecting iff:  If s |= ÃÅ‚[ÄÂ•] and s |= ÃÅ‚[ÄÂˆ], then s |= ÃÅ‚[ÄÂ• Ã¢ÂˆÂ§ ÄÂˆ].  It follows immediately from DeÄÅ¹Ânition 4 that every  strong collecting query is also boundary collecting,  every boundary collecting query is also intermediate  query in CTLQ8 , CTLQ9 , and CTLQ10 is strong  collecting.  Now, recall that CTLQx consists of the above CTL  query languages, i.e., all queries in CTLQx are at least  weak collecting. Moreover, it can be easily shown that  all queries ÃÅ‚ in CTLQx are monotonic. Hence, by the  following theorem, we obtain Theorem 1 above.  Theorem 2 ([7, 10]). A query is exact iff it is  monotonic and collecting.  Remark 1. In contrast to the characterization  of LTLQx [7, 10], we are unfortunately not able to  prove the maximality of CTLQx in the sense that all  simple queries, i.e., queries whose subformulas are  atomic and occur only once in the query, not in CTLQx  are not exact. Quite the contrary, CTLQx is not maximal in this sense and therefore not a characterization of  exact CTL queries. For example, consider the simple  query ÃÅ‚ = AF(a Ã¢ÂˆÂ§ AF(b Ã¢ÂˆÂ¨ AG ?)). It can be easily  veriÄÅ¹Âed that ÃÅ‚ Ã¢ÂˆÂˆ  / CTLQx although ÃÅ‚ is collecting.  Finally, let us remark that a proof of maximality by  counterexample construction as in the case of LTLQx  is much more difÄÅ¹Âcult in the case of CTLQx since a  counterexample to the collecting property for queries  in CTLQx is in general a computation tree instead of  a computation path as in the case of LTLQx .  4 Solving Queries in CTLQx  In this section, we show how to symbolically compute an exact solution to queries in CTLQx . The connection between computing an exact solution and the  collecting properties introduced in the previous section is: The collecting properties enable us to eliminate  non-determinism in the sense of existential choices. In  order to locate the cause of non-determinism in this  Proceedings of the 12th International Symposium on Temporal Representation and Reasoning (TIMEÃ¢Â€Â™05)  1530-1311/05 $20.00 Ã‚Å  2005 IEEE  Q1  ::=  ?  AX Q3  A( Q3 UÄšÂŠ )  A( UÄšÂ„ Q2 )  A( Q3 WÄšÂŠ )  A( WÄšÂ„ Q4 )  AX Q1  A( WÄšÂ„ Q1 )  |  |  |  |  |  |  |  ;  Ã¢ÂˆÂ§ Q3  AX Q4  A( Q4 UÄšÂŠ )  A( UÄšÂ„ Q3 )  A( Q4 WÄšÂŠ )  A( WÄšÂ„ Q5 )  A( Q1 UÄšÂŠ )  |  |  |  |  |  |  |  Ã¢ÂˆÂ§ Q4  AX Q6  A( UÄšÂŠ Q4 )  A( UÄšÂ„ Q4 )  A( WÄšÂ„ Q2 )  Ã¢ÂˆÂ§ Q1  A( UÄšÂ„ Q1 )  |  |  |  |  |  |  |  Ã¢ÂˆÂ¨ Q2  AX Q7  A( UÄšÂŠ Q5 )  A( UÄšÂ„ Q5 )  A( WÄšÂ„ Q3 )  Ã¢ÂˆÂ¨ Q1  A( Q1 WÄšÂŠ )  |  |  |  |  |  |  |  Q2  ::=  Ã¢ÂˆÂ§ Q5  A( Q5 WÄšÂŠ )  Ã¢ÂˆÂ§ Q2  |  |  |  AX Q5  A( WÄšÂŠ Q3 )  AX Q2  |  |  |  A( Q5 UÄšÂŠ )  A( WÄšÂŠ Q4 )  A( Q2 UÄšÂŠ )  |  |  |  A( UÄšÂŠ Q3 )  A( WÄšÂŠ Q5 )  A( Q2 WÄšÂŠ )  |  |  ;  Q3  ::=  AF Q6  A( Q5 U )  Ã¢ÂˆÂ¨ Q3  |  |  |  A( Q1 U )  A( Q6 U )  AF Q3  |  |  |  A( Q2 U )  A( Q7 U )  A( Q3 U )  |  |  |  A( Q4 U )  A( U Q6 )  A( U Q3 )  |  |  ;  Q4  ::=  Ã¢ÂˆÂ¨ Q5  A( Q7 UÄšÂŠ )  A( UÄšÂ„ Q6 )  A( Q3 W )  A( Q6 WÄšÂŠ )  A( W Q6 )  Ã¢ÂˆÂ¨ Q4  A( W Q4 )  |  |  |  |  |  |  |  ;  AF Q5  A( U Q5 )  A( UÄšÂ„ Q7 )  A( Q5 W )  A( Q7 WÄšÂŠ )  A( W Q7 )  AF Q4  |  |  |  |  |  |  |  AF Q7  A( U Q7 )  A( Q1 W )  A( Q6 W )  A( W Q3 )  A( WÄšÂ„ Q6 )  A( U Q4 )  |  |  |  |  |  |  |  A( Q6 UÄšÂŠ )  A( UÄšÂŠ Q7 )  A( Q2 W )  A( Q7 W )  A( W Q5 )  A( WÄšÂ„ Q7 )  A( Q4 W )  |  |  |  |  |  |  |  Q5  ::=  A( UÄšÂŠ Q6 )  |  A( WÄšÂŠ Q6 )  |  A( WÄšÂŠ Q7 )  ;  Q6  ::=  A( Q8 U )  |  A( Q9 U )  |  Ã¢ÂˆÂ¨ Q6  ;  Q7  ::=  Ã¢ÂˆÂ§ Q6  A( Q9 W )  |  |  |  |  Ã¢ÂˆÂ¨ Q9  Ã¢ÂˆÂ¨ Q7  |  ;  A( Q8 W )  |  Q8  ::=  AF Q9  AG Q6  A( UÄšÂ„ Q9 )  AX Q8  A( U Q8 )  A( W Q8 )  |  |  |  |  |  |  AG Q1  AG Q7  A( W Q9 )  AF Q8  A( UÄšÂŠ Q8 )  A( WÄšÂ„ Q8 )  |  |  |  |  |  ;  AG Q3  A( U Q9 )  A( WÄšÂ„ Q9 )  AG Q8  A( UÄšÂ„ Q8 )  |  |  |  |  |  AG Q4  A( UÄšÂŠ Q9 )  Ã¢ÂˆÂ§ Q8  A( Q8 UÄšÂŠ )  A( Q8 WÄšÂŠ )  |  |  |  |  |  Q9  ::=  A( WÄšÂŠ Q8 )  A( Q9 WÄšÂŠ )  |  |  Ã¢ÂˆÂ§ Q9  A( WÄšÂŠ Q9 )  |  ;  AX Q9  |  A( Q9 UÄšÂŠ )  |  Q10  ::=  AG Q2  Ã¢ÂˆÂ¨ Q10  A( Q10 U )  A( UÄšÂ„ Q10 )  A( WÄšÂŠ Q10 )  |  |  |  |  |  AG Q5  AX Q10  A( Q10 UÄšÂŠ )  A( Q10 W )  A( WÄšÂ„ Q10 )  |  |  |  |  ;  AG Q9  AF Q10  A( U Q10 )  A( Q10 WÄšÂŠ )  |  |  |  |  Ã¢ÂˆÂ§ Q10  AG Q10  A( UÄšÂŠ Q10 )  A( W Q10 )  |  |  |  |  Ã¢ÂˆÂ¨ Q8  Ã¢ÂˆÂ§ Q7  Table 1. CTLQx production rules  Proceedings of the 12th International Symposium on Temporal Representation and Reasoning (TIMEÃ¢Â€Â™05)  1530-1311/05 $20.00 Ã‚Å  2005 IEEE  context more systematically, note that temporal operators can be divided into universal and existential ones.  Let us consider some examples.  Example 1. For every path ÄÂ€ and formula ÄÂ• it holds  that ÄÂ€ |= G ÃÅ‚ÄšÂ„[ÄÂ•] if and only if Ã¢ÂˆÂ€i Ã¢ÂˆÂˆ N. ÄÂ€ i |= ÃÅ‚ÄšÂ„[ÄÂ•].  Thus, solving a query G ÃÅ‚ÄšÂ„ can be reduced to solving  its subquery ÃÅ‚ÄšÂ„ at universally quantiÄÅ¹Âed positions on a  path. Hence, we classify the global operator G to be a  universal operator.  In contrast, consider path ÄÂ€ in Figure 3. Obviously,  it holds that ÄÂ€ |= a U ÃÅ‚ÄšÂ„[ÄÂ•] for every solution ÄÂ• to ÃÅ‚ =  a U ÃÅ‚ÄšÂ„ on ÄÂ€, but solving ÃÅ‚ cannot be reduced to solving  its subquery ÃÅ‚ÄšÂ„ at universally quantiÄÅ¹Âed positions on ÄÂ€.  However, for every path ÄÂ€ it holds that ÄÂ€ |= ÃÂ¸ U ÃÅ‚ÄšÂ„[ÄÂ•]  if and only if Ã¢ÂˆÂƒi Ã¢ÂˆÂˆ {j Ã¢ÂˆÂˆ N | j Ã¢Â‰Â¤ n}. ÄÂ€ i |= ÃÅ‚ÄšÂ„[ÄÂ•],  where n Ã¢ÂˆÂˆ N is the least number such that ÄÂ€ n |= ÃÂ¸.  Thus, solving a query ÃÂ¸ U ÃÅ‚ÄšÂ„ can be reduced to solving its subquery ÃÅ‚ÄšÂ„ at existentially quantiÄÅ¹Âed positions  on a path. Hence, we classify the strong until operator U with respect to its second argument to be an existential operator. Note, however, that the strong until  operator with respect to its ÄÅ¹Ârst argument is universal.  To see this, let n Ã¢ÂˆÂˆ N be the least number such that  ÄÂ€ n |= ÃÂ¸ for any path ÄÂ€ and formula ÃÂ¸. Then, for every  formula ÄÂ•, it holds that ÄÂ€ |= ÃÅ‚ÄšÂ„[ÄÂ•] U ÃÂ¸ if and only if  Ã¢ÂˆÂ€i Ã¢ÂˆÂˆ {j Ã¢ÂˆÂˆ N | j < n}. ÄÂ€ i |= ÃÅ‚ÄšÂ„[ÄÂ•].  The kind of non-determinism we consider in this  section arises from existential choices when solving  a query top-down by a reduction to solving its subqueries as demonstrated in Example 1. The formal  starting point of our investigations is therefore:  DeÄÅ¹Ânition 5 (Universal, Existential). Let O be an  n-ary temporal operator that is monotonic in its kth operand. Then, we deÄÅ¹Âne O to be universal  with respect to its k-th operand iff for all paths ÄÂ€  and formulas ÄÂˆ1 , . . . , ÄÂˆkÃ¢ÂˆÂ’1 , ÄÂˆk+1 , . . . , ÄÂˆn satisfying  ÄÂ€ |= O(ÄÂˆ1 , . . . , ÄÂˆkÃ¢ÂˆÂ’1 , , ÄÂˆk+1 , . . . , ÄÂˆn ) there exists a set I Ã¢ÂŠÂ† N, called reduction set, such that  ÄÂ€ |= O(ÄÂˆ1 , . . . , ÄÂˆkÃ¢ÂˆÂ’1 , ÄÂ•, ÄÂˆk+1 , . . . , ÄÂˆn ) iff Ã¢ÂˆÂ€i Ã¢ÂˆÂˆ  I. ÄÂ€ i |= ÄÂ•. We deÄÅ¹Âne O to be existential with  respect to its k-th operand iff O is not universal  with respect to its k-th operand and for all paths ÄÂ€  and formulas ÄÂˆ1 , . . . , ÄÂˆkÃ¢ÂˆÂ’1 , ÄÂˆk+1 , . . . , ÄÂˆn satisfying  ÄÂ€ |= O(ÄÂˆ1 , . . . , ÄÂˆkÃ¢ÂˆÂ’1 , Ã¢ÂŠÄ½, ÄÂˆk+1 , . . . , ÄÂˆn ) there exists a set I Ã¢ÂŠÂ† N, called reduction set, such that  ÄÂ€ |= O(ÄÂˆ1 , . . . , ÄÂˆkÃ¢ÂˆÂ’1 , ÄÂ•, ÄÂˆk+1 , . . . , ÄÂˆn ) iff Ã¢ÂˆÂƒi Ã¢ÂˆÂˆ  I. ÄÂ€ i |= ÄÂ•. If O is an n-ary operator that is universal (resp. existential) with respect to its k-th operand  and O(ÄÂˆ1 , . . . , ÄÂˆkÃ¢ÂˆÂ’1 , ÃÅ‚ÄšÂ„, ÄÂˆk+1 , . . . , ÄÂˆn ) occurs in a  query ÃÅ‚ for any formulas ÄÂˆ1 , . . . , ÄÂˆkÃ¢ÂˆÂ’1 , ÄÂˆk+1 , . . . , ÄÂˆn ,  then we say that ÃÅ‚ÄšÂ„ is a universally (resp. existentially)  occurring subquery of ÃÅ‚.  Note that all temporal operators used in this paper are either universal or existential with respect to  a selected operand. This fact is summarized in Table 2, where the placeholder indicates the corresponding operand. For example, consider the query ÃÅ‚ =  AG(a Ã¢ÂˆÂ¨ A(b U AX ÃÅ‚ÄšÂ„)). Then, AX ÃÅ‚ÄšÂ„ is existentially  occurring in ÃÅ‚, whereas ÃÅ‚ÄšÂ„ is universally occurring in ÃÅ‚.  Remark 2. Note that the restrictions to paths on  which O(ÄÂˆ1 , . . . , ÄÂˆkÃ¢ÂˆÂ’1 , , ÄÂˆk+1 , . . . , ÄÂˆn ) holds and  O(ÄÂˆ1 , . . . , ÄÂˆkÃ¢ÂˆÂ’1 , Ã¢ÂŠÄ½, ÄÂˆk+1 , . . . , ÄÂˆn ) does not hold respectively in the above deÄÅ¹Ânition are necessary in order to achieve our desired classiÄÅ¹Âcation. For example,  the strong until operator U with respect to its ÄÅ¹Ârst argument would not be universal if we omitted the ÄÅ¹Ârst  condition, since it would not be universal on paths that  do not satisfy its second argument at any state. On  the other hand, the weak until operator W with respect  to its second argument would not be existential if we  omitted the second condition, since it would not be existential on paths that satisfy its ÄÅ¹Ârst argument globally.  The following deÄÅ¹Ânition will enable us to easily describe an appropriate reduction set I according to DeÄÅ¹Ânition 5 for the existential operators in Table 2.  DeÄÅ¹Ânition 6 (PreÄÅ¹Âx indices). A set I Ã¢ÂŠÂ† N of natural  numbers is a set of preÄÅ¹Âx indices iff for each n Ã¢ÂˆÂˆ I  it holds that for all i < n, i Ã¢ÂˆÂˆ I. In particular, for  any path ÄÂ€ and formula ÄÂ•, we deÄÅ¹Âne the set of preÄÅ¹Âx  indices IÄÂ€ (ÄÂ•) = {n Ã¢ÂˆÂˆ N | Ã¢ÂˆÂ€i < n. ÄÂ€ i |= ÄÂ•}.  Note that a set of preÄÅ¹Âx indices is either an initial  segment of N (i.e., a set of the form {i Ã¢ÂˆÂˆ N | i Ã¢Â‰Â¤ n}  for some n Ã¢ÂˆÂˆ N) or N itself. For example, let ÄÂ€ be  the path shown in Figure 3. Then, IÄÂ€ (a) = {0, 1, 2},  IÄÂ€ (b) = {0}, and IÄÂ€ (a Ã¢ÂˆÂ¨ b) = N. The following  lemma shows that for the strong until operator with  respect to its second argument, the set of preÄÅ¹Âx indices is an appropriate reduction set according to Definition 5. It follows immediately from the deÄÅ¹Ânition of  the strong until operator.  Proceedings of the 12th International Symposium on Temporal Representation and Reasoning (TIMEÃ¢Â€Â™05)  1530-1311/05 $20.00 Ã‚Å  2005 IEEE  Universal  X?  G?  ?UÄÂ•  ?WÄÂ•  ? UÄšÂŠ ÄÂ•  ? WÄšÂŠ ÄÂ•  Existential  ÄÂ• UÄšÂ„ ?  ÄÂ• WÄšÂ„ ?  F?  ÄÂ•U?  ÄÂ• UÄšÂŠ ?  ÄÂ•W?  ÄÂ• WÄšÂŠ ?  Table 2. ClassiÄÅ¹Âcation of temporal operators      P  q  - a  - b +  a      Figure 3. PreÄÅ¹Âx index example  Lemma 2. For every path ÄÂ€ and formula ÄÂˆ it holds  that ÄÂ€ |= ÄÂˆ U ÄÂ• iff Ã¢ÂˆÂƒi Ã¢ÂˆÂˆ IÄÂ€ (ÄÂˆ). ÄÂ€ i |= ÄÂ•.  versal quantiÄÅ¹Âcation has a higher priority in DeÄÅ¹Ânition 5, we obtain our desired classiÄÅ¹Âcation.  4.1 Eliminating Non-determinism  The following fact enables us to build up on the auxiliary results of our exactness proof in the previous section. It can be easily veriÄÅ¹Âed by the grammar deÄÅ¹Âning  CTLQx in Table 1.  Example 2. Consider path ÄÂ€ shown in Figure 3 and  query ÃÅ‚ = a U ÃÅ‚ÄšÂ„. Assume that we want to solve ÃÅ‚  on ÄÂ€ by reducing it to solving ÃÅ‚ÄšÂ„ on ÄÂ€. Since the strong  until operator with respect to its second argument is an  existential operator (cf. Table 2), i.e., ÃÅ‚ÄšÂ„ is an existentially occurring subquery, we know that there exists a  reduction of the form ÄÂ€ |= ÃÅ‚[ÄÂ•] iff Ã¢ÂˆÂƒi Ã¢ÂˆÂˆ I. ÄÂ€ i |= ÃÅ‚ÄšÂ„[ÄÂ•]  for some set I Ã¢ÂŠÂ† N. By Lemma 2, we are allowed to  choose I = IÄÂ€ (a) = {0, 1, 2}. Hence, we know that  solving ÃÅ‚ on ÄÂ€ can be reduced to solving ÃÅ‚ÄšÂ„ at states  with indices in I, i.e., we obtain all solutions to ÃÅ‚ on ÄÂ€  by computing the solutions to ÃÅ‚ÄšÂ„ on ÄÂ€ 0 , ÄÂ€ 1 , and ÄÂ€ 2 .  Intuitively, this means whenever in a CTLQx query  we meet an operator which has an existential semantics (such as ÄÂ• U ? ), then its context in the CTLQx  grammar ensures that a deterministic reduction is possible. This follows immediately from the intermediate collecting property and allows an algorithmic interpretation in order to eliminate existential choices as  described below.  Note that all existential operators in Table 2 are variants of the strong until operator. Thus, as we will see  in Section 4.2, it sufÄÅ¹Âces to have an appropriate reduction set for the strong until operator U.  Lemma 3 ([7]). Let ÃÅ‚ be an intermediate collecting  query and ÄÂ€ be a path. Suppose that ÄÂ€ n |= ÃÅ‚[ ] for  some n Ã¢ÂˆÂˆ N. If ÄÂ€ i |= ÃÅ‚[Ã¢ÂŠÄ½] for all i < n, then every  solution to ÃÅ‚ on ÄÂ€ is a solution to ÃÅ‚ on ÄÂ€ n .  Remark 3. Not surprisingly, there is a close relationship between the classiÄÅ¹Âcation into universal and existential temporal operators and the ÄÅ¹Ârst-order quantiÄÅ¹Âcation of the corresponding operands in the deÄÅ¹Ânition of their semantics. However, there are also universal operators whose corresponding operand is existentially quantiÄÅ¹Âed, e.g., the disjoint strong until operator UÄšÂ„ with respect to its second operand. But in these  cases it is easy to see that the semantics of the operators can be equivalently redeÄÅ¹Âned by using the uniqueness quantiÄÅ¹Âer Ã¢ÂˆÂƒ! instead of the existential quantiÄÅ¹Âer.  Consequently, since the reduction set in such cases is  a singleton set, universal and existential quantiÄÅ¹Âcation  over this set would be equivalent. However, since uni-  In other words, it sufÄÅ¹Âces to perform several simple model checking calls to achieve a deterministic reduction for query solving, and thus we can alleviate  the problem posed by the existential quantiÄÅ¹Âer. Since  it takes one call to a symbolic model checker to verify ÃÅ‚[Ã¢ÂŠÄ½] for all states, the complexity of the model  checking step is signiÄÅ¹Âcantly lower than it were for  query solving. Based on this principle, we describe  a symbolic algorithm which computes exact solutions  for all queries in CTLQx . ChanÃ¢Â€Â™s algorithm then can  be obtained as a special case of our algorithm.  Since solving an existentially occurring query has  in general to be done at several states on a path, we  need the following deÄÅ¹Ânition.  Proposition 1. All existentially occurring subqueries  of queries in our fragment CTLQx are intermediate  collecting.  Proceedings of the 12th International Symposium on Temporal Representation and Reasoning (TIMEÃ¢Â€Â™05)  1530-1311/05 $20.00 Ã‚Å  2005 IEEE  DeÄÅ¹Ânition 7. Let ÃÅ‚ be a query, ÄÂ€ be a path, and I Ã¢ÂŠÂ† N.  Then, we deÄÅ¹Âne the set ofsolutions to ÃÅ‚ at positions  in I on ÄÂ€ by solI (ÄÂ€, ÃÅ‚) = iÃ¢ÂˆÂˆI {ÄÂ• | ÄÂ€ i |= ÃÅ‚[ÄÂ•]}.  For our purposes, the set I will be a set of preÄÅ¹Âx indices representing the existential choices of positions on ÄÂ€ when solving an existentially occurring subquery ÃÅ‚. Thus, in order to obtain all solutions, ÃÅ‚ has  in general to be solved at all states with indices in I.  Note that if there exists i Ã¢ÂˆÂˆ I such that ÄÂ€ i |= ÃÅ‚[Ã¢ÂŠÄ½],  then, if ÃÅ‚ is monotonic, every formula is an element  of solI (ÄÂ€, ÃÅ‚) and therefore the solutions at other states  with indices in I do not affect solI (ÄÂ€, ÃÅ‚). This case is  somehow exceptional since it can be simply checked  by evaluating the formula ÃÅ‚[Ã¢ÂŠÄ½] at all states with indices in I, which can be performed by a single symbolic model checking call.  Otherwise, if no such a preÄÅ¹Âx index exists, it follows immediately from the intermediate collecting  property by repeated application of Lemma 3 that  sol{i0 } (ÄÂ€, ÃÅ‚) Ã¢ÂŠÂ† sol{i1 } (ÄÂ€, ÃÅ‚) Ã¢ÂŠÂ† sol{i2 } (ÄÂ€, ÃÅ‚) Ã¢ÂŠÂ† Ã‚Ë‡ Ã‚Ë‡ Ã‚Ë‡ ,  where i0 < i1 < i2 < Ã‚Ë‡ Ã‚Ë‡ Ã‚Ë‡ and ÄÂ€ n |= ÃÅ‚[ ] for all  n Ã¢ÂˆÂˆ {i1 , i2 , i3 , . . .} Ã¢ÂŠÂ† I. Hence, when solving an intermediate collecting query at several states on a path,  it sufÄÅ¹Âces to solve the query at states with indices as  high as possible. In particular, if there exists a highest  index n Ã¢ÂˆÂˆ I such that ÄÂ€ n |= ÃÅ‚[ ], it sufÄÅ¹Âces to solve  the query at this state.  Example 3. Recall Example 2 and let us now consider  the case where ÃÅ‚ÄšÂ„ is intermediate collecting. In this case  we can determinize the reduction in such a way that I  becomes a singleton set. In particular, if ÄÂ€ i |= ÃÅ‚ÄšÂ„[ ]  and ÄÂ€ i |= ÃÅ‚ÄšÂ„[Ã¢ÂŠÄ½] for all i Ã¢ÂˆÂˆ IÄÂ€ (a), it follows from the intermediate collecting property according to Lemma 3  that sol{0} (ÄÂ€, ÃÅ‚ÄšÂ„) Ã¢ÂŠÂ† sol{1} (ÄÂ€, ÃÅ‚ÄšÂ„) Ã¢ÂŠÂ† sol{2} (ÄÂ€, ÃÅ‚ÄšÂ„). Thus,  the solutions obtained by solving ÃÅ‚ÄšÂ„ on ÄÂ€ 0 and ÄÂ€ 1 are  also solutions on ÄÂ€ 2 . Hence, it sufÄÅ¹Âces to solve ÃÅ‚ÄšÂ„  on ÄÂ€ 2 , i.e., the state with highest index in IÄÂ€ (a). So  we know that ÄÂ€ |= ÃÅ‚[ÄÂ•] iff ÄÂ€ 2 |= ÃÅ‚ÄšÂ„[ÄÂ•] for all ÄÂ•.  We are now going to state this insight formally  which will enable us to extend the Chan algorithm and  can be used in order to prove its correctness.  Lemma 4 ([7]). Let ÃÅ‚ be an intermediate collecting  query, ÄÂ€ be a path, and I Ã¢ÂŠÂ† N. Suppose that there is  a least index m Ã¢ÂˆÂˆ I and a highest index n Ã¢ÂˆÂˆ I such  that ÄÂ€ m |= ÃÅ‚[ ] and ÄÂ€ n |= ÃÅ‚[ ]. If ÄÂ€ i |= ÃÅ‚[Ã¢ÂŠÄ½] for all  m Ã¢Â‰Â¤ i < n, then sol{n} (ÄÂ€, ÃÅ‚) = solI (ÄÂ€, ÃÅ‚).  Note that Lemma 4 does not cover all cases that  may appear when solving a query. In particular, it says  nothing about the case where the highest index n Ã¢ÂˆÂˆ I  does not exist. This case occurs if I contains an inÄÅ¹Ânite number of indices i satisfying ÄÂ€ i |= ÃÅ‚[ ]. Note  that such indices must refer to states in a cycle, since  only states in a cycle have an inÄÅ¹Ânite number of indices. For every path ÄÂ€, let us deÄÅ¹Âne the set of cycle  indices cycle(ÄÂ€) = {i Ã¢ÂˆÂˆ N | i Ã¢Â‰Ä½ k}, where k is  the length of the path preÄÅ¹Âx of ÄÂ€ before the ÄÅ¹Ârst cycle  starts. Thus, we are able to state the following lemma.  Lemma 5 ([7]). Let ÃÅ‚ be an intermediate collecting  query, ÄÂ€ be a path, and I Ã¢ÂŠÂ† N. Suppose that there is  a least index m Ã¢ÂˆÂˆ I and an index n Ã¢ÂˆÂˆ cycle(ÄÂ€) Ã¢ÂˆÅ  I  such that ÄÂ€ m |= ÃÅ‚[ ] and ÄÂ€ n |= ÃÅ‚[ ]. If ÄÂ€ i |= ÃÅ‚[Ã¢ÂŠÄ½]  for all i Ã¢Â‰Ä½ m, then sol{n} (ÄÂ€, ÃÅ‚) = solI (ÄÂ€, ÃÅ‚).  4.2 The Extended Chan Algorithm  The Chan algorithm was introduced by William  Chan [2] in order to solve queries in his syntactic fragment of valid CTL queries, i.e., CTL queries that are  guaranteed to have an exact solution in every model.  However, Chan neither proved the correctness of his  algorithm nor did he describe its functionality. With  our insights above, it is possible to prove the correctness of ChanÃ¢Â€Â™s algorithm when applied to valid queries  within our fragment CTLQx . Note that such queries  can be simply obtained by restricting the grammar in  Table 1 to those operators that guarantee validity.  In the following, we are interested in a generalization of ChanÃ¢Â€Â™s algorithm that is able to solve queries in  the whole fragment CTLQx , i.e., queries that have an  exact solution if there exists any solution.  DeÄÅ¹Ânition 8 (Auxiliary sets). Following Chan, we  introduce the following three macros (parameterized  by ÄÂ• and ÃÅ‚) as abbreviations:  RÄÂ• = Ã‚Ä¾Z. ((Q Ã¢ÂˆÅ postÃ¢ÂˆÂƒ (Z)) Ã¢ÂˆÅ  ÄÂ•)  CÄÂ•ÃÅ‚  BÄÂ•ÃÅ‚  = ÃËZ. (RÄÂ•Ã¢ÂˆÂ§Ã‚Å¹ÃÅ‚[Ã¢ÂŠÄ½] Ã¢ÂˆÅ  postÃ¢ÂˆÂƒ (Z))  = (Q Ã¢ÂˆÅ postÃ¢ÂˆÂƒ (RÄÂ•Ã¢ÂˆÂ§Ã‚Å¹ÃÅ‚[Ã¢ÂŠÄ½] )) \ (ÄÂ• Ã¢ÂˆÅ ÃÅ‚[Ã¢ÂŠÄ½])  The intuitive meaning of these three auxiliary sets  is illustrated in Figure 4, where the initial set Q is assumed to consist of the four double-circled states. The  Proceedings of the 12th International Symposium on Temporal Representation and Reasoning (TIMEÃ¢Â€Â™05)  1530-1311/05 $20.00 Ã‚Å  2005 IEEE  Algorithm 1 The extended Chan algorithm  function FSol(ÃÅ‚, ÄÂ•, Q, cycle) begin  if cycle then C = CÄÂ•ÃÅ‚ else C = Ã¢ÂˆÂ… ;  U1 = ÃËZ. ((C \ ÃÅ‚[]) Ã¢ÂˆÅ  postÃ¢ÂˆÂƒ (Z)) ;  ÃÅ‚  \ ÃÅ‚[]) ;  U2 = U1 Ã¢ÂˆÅ (BÄÂ•  U3 = Ã‚Ä¾Z. (((U2 Ã¢ÂˆÅ preÃ¢ÂˆÂƒ (Z)) Ã¢ÂˆÅ  RÄÂ•Ã¢ÂˆÂ§Ã‚Å¹ÃÅ‚[Ã¢ÂŠÄ½] ) \ ÃÅ‚[]) ;  ÃÅ‚  Ã¢ÂˆÅ C) Ã¢ÂˆÅ  ÃÅ‚[] ;  ret ((preÃ¢ÂˆÂƒ (U3 ) Ã¢ÂˆÅ  RÄÂ•Ã¢ÂˆÂ§Ã‚Å¹ÃÅ‚[Ã¢ÂŠÄ½] ) Ã¢ÂˆÅ BÄÂ•  end  function ESol(ÃÅ‚, Q) begin  case ÃÅ‚ of  ? :  return Q ;  ÃÂ¸ Ã¢ÂˆÂ§ ÃÅ‚ÄšÂ„ :  return ESol(ÃÅ‚ÄšÂ„, Q) ;  ÃÂ¸ Ã¢ÂˆÂ¨ ÃÅ‚ÄšÂ„ :  return ESol(ÃÅ‚ÄšÂ„, Q \ ÃÂ¸) ;  AX ÃÅ‚ÄšÂ„ :  return ESol(ÃÅ‚ÄšÂ„, postÃ¢ÂˆÂƒ (Q)) ;  AF ÃÅ‚ÄšÂ„ :  return ESol(A( U ÃÅ‚ÄšÂ„), Q) ;  AG ÃÅ‚ÄšÂ„ :  return ESol(A(ÃÅ‚ÄšÂ„ WÄšÂŠ Ã¢ÂŠÄ½), Q) ;  A(ÃÅ‚ÄšÂ„ U ÃÂ¸) :  return ESol(A((ÃÂ¸ Ã¢ÂˆÂ¨ ÃÅ‚ÄšÂ„) WÄšÂŠ ÃÂ¸), Q) ;  A(ÃÅ‚ÄšÂ„ UÄšÂŠ ÃÂ¸) :  return ESol(A(ÃÅ‚ÄšÂ„ WÄšÂŠ ÃÂ¸), Q) ;  A(ÃÂ¸ U ÃÅ‚ÄšÂ„) :  return ESol(ÃÅ‚ÄšÂ„, FSol(ÃÅ‚ÄšÂ„, ÃÂ¸, Q, true)) ;  A(ÃÂ¸ UÄšÂŠ ÃÅ‚ÄšÂ„) :  return ESol(A(ÃÂ¸ U (ÃÂ¸ Ã¢ÂˆÂ§ ÃÅ‚ÄšÂ„)), Q) ;  A(ÃÂ¸ UÄšÂ„ ÃÅ‚ÄšÂ„) :  return ESol(A(ÃÂ¸ WÄšÂ„ ÃÅ‚ÄšÂ„), Q) ;  A(ÃÅ‚ÄšÂ„ W ÃÂ¸) : return ESol(A((ÃÂ¸ Ã¢ÂˆÂ¨ ÃÅ‚ÄšÂ„) WÄšÂŠ ÃÂ¸), Q) ;  A(ÃÅ‚ÄšÂ„ WÄšÂŠ ÃÂ¸) : return ESol(ÃÅ‚ÄšÂ„, Q Ã¢ÂˆÅ postÃ¢ÂˆÂƒ (RÃ‚Å¹ÃÂ¸ )) ;  A(ÃÂ¸ W ÃÅ‚ÄšÂ„) : return ESol(ÃÅ‚ÄšÂ„, FSol(ÃÅ‚ÄšÂ„, ÃÂ¸, Q, false)) ;  A(ÃÂ¸ WÄšÂŠ ÃÅ‚ÄšÂ„) : return ESol(A(ÃÂ¸ W (ÃÂ¸ Ã¢ÂˆÂ§ ÃÅ‚ÄšÂ„)), Q) ;  A(ÃÂ¸ WÄšÂ„ ÃÅ‚ÄšÂ„) : return ESol(ÃÅ‚ÄšÂ„, (Q Ã¢ÂˆÅ postÃ¢ÂˆÂƒ (RÃÂ¸ )) \ ÃÂ¸) ;  esac  end  set RÄÂ•Ã¢ÂˆÂ§Ã‚Å¹ÃÅ‚[Ã¢ÂŠÄ½] consists of those states that are reachable  from states in Q by going only through states at which  ÄÂ•Ã¢ÂˆÂ§Ã‚Å¹ÃÅ‚[Ã¢ÂŠÄ½] holds. In particular, R consists of all states  that are reachable from states in Q. The set CÄÂ•ÃÅ‚ consists of all states within a cycle in RÄÂ•Ã¢ÂˆÂ§Ã‚Å¹ÃÅ‚[Ã¢ÂŠÄ½] . Finally,  the set BÄÂ•ÃÅ‚ consists of the boundary of RÄÂ•Ã¢ÂˆÂ§Ã‚Å¹ÃÅ‚[Ã¢ÂŠÄ½] , i.e.,  the ÄÅ¹Ârst states on each path starting from Q that are  not in RÄÂ•Ã¢ÂˆÂ§Ã‚Å¹ÃÅ‚[Ã¢ÂŠÄ½] and at which ÃÅ‚[Ã¢ÂŠÄ½] does not hold. The  following lemma states the meaning of these sets more  formally.  Lemma 6 ([7]). Let ÃÅ‚ be a query, ÄÂ• be a formula, and  Q be a set of states in a Kripke structure. Moreover,  let ÃÂ  Ã¢ÂŠÂ† paths(Q) such that ÄÂ€ Ã¢ÂˆÂˆ ÃÂ  iff ÄÂ€ i |= ÃÅ‚[Ã¢ÂŠÄ½] for  all i Ã¢ÂˆÂˆ IÄÂ€ (ÄÂ•). Then, RÄÂ• , CÄÂ•ÃÅ‚ , and BÄÂ•ÃÅ‚ are the sets of  states on paths ÄÂ€ Ã¢ÂˆÂˆ paths(Q) such that  1. ÄÂ€(n) Ã¢ÂˆÂˆ RÄÂ• iff for all i Ã¢Â‰Â¤ n it holds that ÄÂ€ i |= ÄÂ•.  2. ÄÂ€(n) Ã¢ÂˆÂˆ CÄÂ•ÃÅ‚ iff ÄÂ€ Ã¢ÂˆÂˆ ÃÂ , IÄÂ€ (ÄÂ•) is inÄÅ¹Ânite, and n Ã¢ÂˆÂˆ  cycle(ÄÂ€).  3. ÄÂ€(n) Ã¢ÂˆÂˆ BÄÂ•ÃÅ‚ iff ÄÂ€ Ã¢ÂˆÂˆ ÃÂ , IÄÂ€ (ÄÂ•) is ÄÅ¹Ânite, and n =  max(IÄÂ€ (ÄÂ•)).  ÄÂ•  Ã‚Å¹ÃÅ‚[Ã¢ÂŠÄ½]  ÄÂ•  ÃÅ‚[Ã¢ÂŠÄ½]  ÄÂ•  Ã‚Å¹ÃÅ‚[Ã¢ÂŠÄ½]  Ã‚Å¹ÄÂ•  Ã‚Å¹ÃÅ‚[Ã¢ÂŠÄ½]  ÄÂ•  Ã‚Å¹ÃÅ‚[Ã¢ÂŠÄ½]  ...  ÄÂ•  Ã‚Å¹ÃÅ‚[Ã¢ÂŠÄ½]  ÄÂ•  Ã‚Å¹ÃÅ‚[Ã¢ÂŠÄ½]  ÃÅ‚  BÄÂ•  ...  Ã‚Å¹ÄÂ•  Ã‚Å¹ÃÅ‚[Ã¢ÂŠÄ½]  ...  ÄÂ•  Ã‚Å¹ÃÅ‚[Ã¢ÂŠÄ½]  ÄÂ•  Ã‚Å¹ÃÅ‚[Ã¢ÂŠÄ½]  RÄÂ•Ã¢ÂˆÂ§Ã‚Å¹ÃÅ‚[Ã¢ÂŠÄ½]  ÄÂ•  Ã‚Å¹ÃÅ‚[Ã¢ÂŠÄ½]  ÄÂ•  Ã‚Å¹ÃÅ‚[Ã¢ÂŠÄ½]  CÄÂ•ÃÅ‚  Figure 4. Auxiliary sets in ChanÃ¢Â€Â™s algorithm  It is thus easy to see that the states in BÄÂ• are those  with the highest index on each path satisfying the conditions of Lemma 4, and the states in CÄÂ• are those  within a cycle on each path satisfying the conditions  of Lemma 5. Hence, according to Lemma 4 and  Lemma 5, solving a query in our fragment can be reduced to solving its existentially occurring valid subqueries at the set of states BÄÂ• and CÄÂ• without existential choices. Although this kind of determinization is not possible in general, it can be extended to  the whole fragment CTLQx . However, when extending ChanÃ¢Â€Â™s algorithm (see Algorithm 1) to the whole  fragment CTLQx , the existence of a solution at each  state is no longer guaranteed. Therefore, the required  set of states satisfying the conditions of Lemma 4 and  Lemma 5 such that solving a query can be reduced to  solving its subqueries at this set, has to be computed  in a more sophisticated way. In particular, we compute the set of states that correspond to highest indices  resp. cycle indices in I. Afterwards, we traverse the  corresponding paths backwards until a state on each  path is found at which ÃÅ‚ has a solution. These are  then the states with highest indices among the states at  which ÃÅ‚ has a solution, i.e., it sufÄÅ¹Âces to solve ÃÅ‚ at this  uniquely determined set of states. This idea of computing the states at which ÃÅ‚ has a solution and that are  furthest away is implemented by the function FSol in  Algorithm 1. Intuitively, the sets U1 and U2 together  consist of all states with highest indices but on which  ÃÅ‚ has no solution. The set U3 consists then of all states  that can be reached by going backwards as long as ÃÅ‚  does not have a solution. Thus, by making a further  Proceedings of the 12th International Symposium on Temporal Representation and Reasoning (TIMEÃ¢Â€Â™05)  1530-1311/05 $20.00 Ã‚Å  2005 IEEE  step backwards, we obtain the desired set of states, i.e.,  the states with highest indices at which ÃÅ‚ has a solution. In this way, it is possible to prove the correctness  of the extended Chan algorithm.  DeÄÅ¹Ânition 9 (Solution states). Let ÃÅ‚ be a query and Q  be a set of states in a Kripke structure. A set of states  S is the unique set of solution states to ÃÅ‚ at Q iff it  holds that S |= ÄÂ• iff Q |= ÃÅ‚[ÄÂ•] for all formulas ÄÂ•.  The following theorem states our main result. It can  be proved by structural induction on ÃÅ‚.  Theorem 3 ([7]). Let ÃÅ‚ Ã¢ÂˆÂˆ CTLQx and Q be a set  of states in a Kripke structure. Moreover, let ESol  be the function deÄÅ¹Âned in Algorithm 1. Suppose that  Q |= ÃÅ‚[ ], i.e., ÃÅ‚ has a solution at each state in Q.  Then, ESol(ÃÅ‚, Q) returns the unique set of solution  states to ÃÅ‚ at Q.  In particular, the following corollary shows how to  obtain a propositional exact solution by the extended  Chan algorithm.  Corollary 1 ([7]). Let ÃÅ‚ Ã¢ÂˆÂˆ CTLQx and s0 be the initial state of a Kripke structure K. Moreover, let ESol  be the function deÄÅ¹Âned in Algorithm 1. Then, the characteristic function of the set returned by ESol(ÃÅ‚, {s0 })  is a propositional exact solution to ÃÅ‚ in K.  5 Conclusion  In this paper we have systematically investigated  symbolic algorithms for query solving and have argued that symbolic algorithms work for queries which  can be solved by a recursive deterministic descent.  To conclude this paper, let us consider the question  of exact queries and their relevance. It is evident that  temporal logic queries will in many cases have multiple incomparable solutions; algorithms for computing multiple solutions as well as extensions to multiple placeholders have been the subject of important  related work [1, 5, 3, 4]. However, the only existing implementation TLQSolver [3] we are aware of  is based on a multi-valued model checker. Since the  multi-valued setting is essential to their approach, we  believe that the results and methods in the current paper are orthogonal to the multi-valued approach. We  speculate that the central role of determinism in the  Chan style approach in combination with the highly  optimized environment of tools such as SMV will incur algorithmic advantages, leading to a trade-off in  our case between lower expressibility and higher expected performance. A ÄÅ¹Ânal assertion on the practical  performance of both approaches can of course only be  achieved by systematic experiments. Therefore, natural future work includes the implementation and experimental evaluation of our algorithm.  References  [1] G. Bruns and P. Godefroid. Temporal logic query  checking. In Proc. of the 16th Annual IEEE Symposium on Logic in Computer Science (LICS), pages  409Ã¢Â€Â“417. IEEE Computer Society, 2001.  [2] W. Chan. Temporal-logic queries. In Proc. of the 12th  International Conference on Computer Aided VeriÄÅ¹Âcation (CAV), volume 1855 of LNCS, pages 450Ã¢Â€Â“463.  Springer-Verlag, 2000.  [3] M. Chechik and A. GurÄÅ¹Ânkel. TLQSolver: A temporal logic query checker. In Proc. of the 15th International Conference on Computer Aided VeriÄÅ¹Âcation (CAV), volume 2725 of LNCS, pages 210Ã¢Â€Â“214.  Springer-Verlag, 2003.  [4] A. GurÄÅ¹Ânkel, M. Chechik, and B. Devereux. Temporal logic query checking: A tool for model exploration. IEEE Transactions on Software Engineering  (TSE), 29(10):898Ã¢Â€Â“914, 2003.  [5] A. GurÄÅ¹Ânkel, B. Devereux, and M. Chechik. Model  exploration with temporal logic query checking. In  Proc. of the 10th ACM Symposium on Foundations of  Software Engineering (FSE), pages 139Ã¢Â€Â“148. ACM,  2002.  [6] M. Samer. Temporal logic queries in model checking.  MasterÃ¢Â€Â™s thesis, TU Vienna, May 2002.  [7] M. Samer. Reasoning about SpeciÄÅ¹Âcations in Model  Checking. PhD thesis, TU Vienna, Sept. 2004.  [8] M. Samer and H. Veith. Validity of CTL queries  revisited. In Proc. of the 12th Annual Conference  of the European Association for Computer Science  Logic (CSL), volume 2803 of LNCS, pages 470Ã¢Â€Â“483.  Springer-Verlag, 2003.  [9] M. Samer and H. Veith. Parameterized vacuity. In  Proc. of the 5th International Conference on Formal  Methods in Computer-Aided Design (FMCAD), volume 3312 of LNCS, pages 322Ã¢Â€Â“336. Springer-Verlag,  2004.  [10] M. Samer and H. Veith. A syntactic characterization  of distributive LTL queries. In Proc. of the 31st International Colloquium on Automata, Languages and  Programming (ICALP), volume 3142 of LNCS, pages  1099Ã¢Â€Â“1110. Springer-Verlag, 2004.  Proceedings of the 12th International Symposium on Temporal Representation and Reasoning (TIMEÃ¢Â€Â™05)  1530-1311/05 $20.00 Ã‚Å  2005 IEEE 