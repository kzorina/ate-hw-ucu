Information and Computation 205 (2007) 25–64  www.elsevier.com/locate/ic  Axiomatisation and decidability of multi-dimensional  Duration Calculus  Andreas Schäfer  Department of Computing Science, University of Oldenburg, 26111 Oldenburg, Germany  Received 1 December 2005; revised 15 July 2006  Available online 23 October 2006  Communicated by Jan Chomicki and David Toman  Abstract  The Shape Calculus is a spatio-temporal logic based on an n-dimensional Duration Calculus tailored for  the speciﬁcation and veriﬁcation of mobile real-time systems. After showing non-axiomatisability, we give  a complete embedding in n-dimensional interval temporal logic and present two different decidable subsets,  which are important for tool support and practical use.  © 2006 Elsevier Inc. All rights reserved.  Keywords: Real-time systems; Mobile systems; Spatial logic; Temporal logic; Duration Calculus  1. Introduction  1.1. Motivation  Mobile real-time systems are omnipresent today, e.g., in airplane and railroad control systems.  Failures in these systems may have severe consequences which can even endanger lives. Formal  speciﬁcation and automatic veriﬁcation are promising approaches to increase the safety of such  systems. However, for these systems real-time aspects as well as spatial aspects are important.  E-mail address: schaefer@informatik.uni-oldenburg.de  0890-5401/$ - see front matter © 2006 Elsevier Inc. All rights reserved.  doi:10.1016/j.ic.2006.08.005  26  A. Schäfer / Information and Computation 205 (2007) 25–64  Thus, commonly used formalisms that concentrate on either timing or spatial behaviour fall short  in these cases because they need to abstract from important issues.  A pivotal task in the UniForM [32] project in cooperation with the industrial partner Elpro was  the development of a control for a single-tracked line segment (SLS) for tramways. The problem is  to ensure the safety of trams if only one track is available and this track is passed in both directions  and occupied by up to two trams simultaneously as long as they head into the same direction. A  controller has been derived, simulated, and partially veriﬁed using techniques for real-time systems, namely PLC-Automata [19]. However, the main safety requirement, i.e., mutual exclusion of  trams with opposite directions on the critical section, is a spatio-temporal property and cannot be  expressed in purely time-dependent models like PLC Automata [18].  Similar problems arise in the speciﬁcations of mobile robots [42]. Each robot itself constitutes a  real-time system, whereas the speciﬁcation of the overall system behaviour has additional spatial  requirements, for example collision avoidance.  1.2. Research contributions  The shortcomings described above led us to the idea to extend the Duration Calculus, a wellknown formalism for real-time systems, with proven applicability [28], to be able to describe also  spatial properties. The use of the formalism is similar to the use of the original Duration Calculus  when no spatial reasoning is required. Thus, experienced users of temporal logics can easily adopt  the new features.  We present the Shape Calculus1 (SC), a spatio-temporal logic based on the Duration Calculus,  extending   the results in [42] and [43]. Shape Calculus is interval based and possesses an integral operator for measuring time as well as space. We elaborate that this formalism is well suited for the  application domain of mobile real-time systems. We present four major results for this formalism.  First, we prove that the full logic is undecidable and non axiomatisable, even for discrete inﬁnite  models of time and space. To this end, we present a reduction of its validity problem to the emptiness  problem of tiling languages. The full real-time logic Duration Calculus is known to be non-axiomatisable for continuous temporal domains, but still decidable for a subset in the discrete setting  which shows to be undecidable in the multi-dimensional case. This relates to the undecidability of  multi-dimensional products of decidable modal logics as discussed in [24]. Second, we present  an ax  iomatisation of Shape Calculus relatively to an n-dimensional interval logic without the operator,  a result similar to the one for continuous time Duration Calculus. In practice, acceptance of formal  methods is increased dramatically by tool support. Hence, we discuss decidable subsets of the Shape  Calculus. Our third contribution is a decidable subset of Shape Calculus based on results for discrete Duration Calculus. There the subset assumes a discrete and inﬁnite temporal domain but ﬁnite  spatial domains. The decision procedure reduces validity to emptiness of regular languages. This  subset has already led to a prototypical implementation of a model checker [38]. Forth, we elaborate  a decidable subset of discrete Shape Calculus using ideas from logic combination [24] and relating  a syntactical subset of Shape Calculus without chop alternation to fusions of Duration Calculus.  This approach proceeds by reducing validity to iteratively checking emptiness of regular languages.  1 The name Shape Calculus was proposed by A. Ravn during a presentation of early ideas.  A. Schäfer / Information and Computation 205 (2007) 25–64  27  Technical context. We review the technical context of our contribution.  1.3. Real-time systems  Concerning real-time aspects, the operational model of Timed Automata [2] is the most popular  and widespread. Due to its decidable emptiness problem, it allows for the automatic veriﬁcation  of real-time properties. Thus, it enables the development of tools like Uppaal [4,5] and Kronos [8],  which contributed much to the applicability of Times Automata as shown in several case studies  [29,33].  The temporal logics Duration Calculus (DC) [12,28], TCTL [30], and TPTL [3] provide the possibility to specify and reason about real-time behaviour. The tool DCValid [36] is able to verify a  restricted subset of Duration Calculus using the second order model checker MONA [31] as backend.  A detailed discussion on decidability for subsets of Duration Calculus is given in [22]. However,  neither the automata theoretic nor the logical formalism do provide support for specifying and  verifying spatial properties.  Except for our approach, other extensions of Duration Calculus consider hybrid aspects [13] and  superdense time [37].  1.4. Process calculi  For modelling mobility of concurrent processes, the  calculus was introduced by R. Milner [35].  However, it considers a notion of mobility different from the Shape Calculus. In the  calculus  mobility stems from the change of links between processes. A spatial logic for the  calculus is proposed in [9]. This logic integrates support for reasoning about the behaviour and the structure of  systems of concurrent  calculus systems. A model checker for a subset of this logic is implemented  in [44].  Inspired by the  calculus, the Ambient Calculus [10] considers processes that are executed in  hierarchically nested environments (called ambients) and that may be transfered from one ambient  to another. For grasping the structure of the nested ambients and the process behaviour, in [34] a  spatial logic for the Ambient Calculus based on TLA is proposed. Similarly to [9], the ambient logic  based on modal logic is introduced in [11]. The model checking problem of the full logic against ambient calculus processes is undecidable and for ﬁnite processes (without replication) still PSPACE  hard [16,15,14]. A compositional approach is proposed in [21]. It investigates the combination of  logics via fusion and product. The notion of location and space is covered by a hybrid logic using  nominals [7] whereas the temporal properties are expressed in a temporal logic. The combined logic  is used to describe the overall system behaviour. However, all these approaches do not facilitate  quantitative measuring, neither of time nor of space. Thus, it is impossible to express, for example, an upper bound on the reaction time or a minimal distance of two robots that needs to be  kept.  1.5. Spatial and spatio-temporal logics  The Region Connection Calculus (RCC) [39] constitutes a spatial logic having regions as basic entities. Thereby, it permits qualitative reasoning about relations, e.g., the part-of-relation or  28  A. Schäfer / Information and Computation 205 (2007) 25–64  tangentiality. Its main area of application is AI. As there is no notion of time in RCC, it has been  extended in [25] to a spatio-temporal formalism for describing mobility qualitatively.  Spatio-temporal logics based on modal logics are proposed in [6,1,40] and different techniques  of combining modal logics—namely fusion and product—is extensively investigated in [23,24]. The  logical and mathematical background developed therein can be used to create various spatio-temporal logics. However, none of these logics proposed allows for quantitative spatial and temporal  measures as needed for our intended application domain of physically mobile real-time systems.  Yet, the second decidable subset we present in this paper is gained by treating our formalism as a  fusion of instances of Duration Calculus.  1.6. Organisation of the paper  After giving a short introduction to SC in Section 2, we show in Section 3 that SC is not axiomatisable, but nevertheless it can be completely axiomatised relatively to the n-dimensional extension  of interval temporal logic, which is presented in Section 4. In Section 5 we present two decidable  subsets of discrete SC: one obtained by imposing restrictions on the class of models, another one  by imposing restrictions on the class of formulae.  2. Shape Calculus  In this section, we introduce the Shape Calculus originally proposed in [42]. Here we make use  of a simpliﬁed version.  In Duration Calculus [12], the behaviour of a system is modelled by a set of time-dependent  variables (observables) whose values change over time. We adopt this approach and use Boolean  observables that depend on space and time. We may choose to have discrete or continuous time and  space depending on the current application. With the number of spatial and temporal dimensions,  say n, being ﬁxed a priori, the semantics of an observable X is given by a trajectory I  I [[X ]] : ⺢n 0 → {0, 1}  in the continuous case or as a function with domain ⺞n for the discrete case. In general, we denote  the spatio-temporal domain by ⺤.  Example 1. To model a mobile robot moving on the ﬂoor, we need two spatial and one temporal  dimension, so we ﬁx n = 3. We employ two observables R and A. The observable R is true for a  point in space and time if and only if the robot occupies this point in space at the given moment in  time. Similarly, the bounded safe area is modelled by the observable A.  As we will measure time and space, we have to guarantee that an integral exists and therefore  require Riemann-integrability of all functions.  The language of SC is built from state expressions, terms, and formulae. A state expression characterises properties of one point in time and space. They are denoted by  and built from Boolean  combinations of observables. The semantics is given by a function I [[]] : ⺢n 0 → {0, 1} deﬁned as  a straightforward extension of trajectories of observables.  A. Schäfer / Information and Computation 205 (2007) 25–64  29  df  I [[¬]](z ) = 1 − I [[]](z )  df  I [[ ∧  ]](z ) = I [[]](z ) · I [[ ]](z )  State expressions are formulae of propositional logic. Like in propositional logic, we therefore  deﬁne two state expressions  and  to be equivalent, denoted by  ≡  , if for all interpretations  I the equality I [[]] = I [[ ]] holds.  Example 2. The state expression R ∧ ¬A describes exactly the points in space-time where the robot  is outside its restricted area. The interpretation assigns 1 to all points satisfying the condition and  0 to all others.    A term  is either a measure , where  is a state expression, a rigid variable x, i.e., a variable that  does not change over time, the special symbol ei denoting the diameter of the n-dimensional interval (hypercube) under consideration along the i-th unit vector ei or the application of a function f .  Commonly used functions are summation or multiplication.     ::=  | x | ei | f(1 , . . . , k )  The value of a rigid variable is a real number or a natural number, depending on the time domain.  It is determined by a valuation V which is a function mapping the variables to the spatio-temporal  domain. The set of valuations is denoted by Val. The semantics of terms assigns a real number to  df  each n-dimensional interval from the set Intn ={[b1 , f1 ] × · · · × [bn , fn ]|bi , fi ∈ ⺢} of all n-dimensional intervals. Thus, it is a function I [[]] : Intn × Val → ⺢ and deﬁned in the expected way, i.e.,  let  M = [b1 , f1 ] × · · · × [bi , fi ] × · · · × [bn , fn ] ∈ Intn  and V ∈ Val then    df    I [[ ]](V , M) =  I [[]]  M  df  I [[ei ]](V , M) = fi − bi  df  I [[x]](V , M) = V (x)  df  I [[f(1 , . . . , k )]](V , M) = fI (I [[1 ]](V , M), . . . , I [[k ]](V , M))    Example 3. The term (R ∧ ¬A) is the measure of all points violating the requirement.  Formulae are interpreted over n-dimensional intervals and incorporate a special “chop” operator  (  ) to partition the current interval into two parts. A formula F ex  G is evaluated to true, if the  interval can be split along the x-axis into two parts, the ﬁrst satisfying F and the second satisfying  30  A. Schäfer / Information and Computation 205 (2007) 25–64  Fig. 1. Illustration for F ex  G.  G. This is sketched in Fig. 1. As we consider a many-dimensional logic, we allow chops along each  cartesian axis. Formally, we deﬁne the set of formulae by  F ::= F1 ei  F2 | p(1 , . . . , k ) | ¬F1 | F1 ∧ F2 | ∃x : F  where p is a predicate symbol like = or , x a rigid variable that does not change over time and ei the  ith unit vector. The other Boolean connectives can be deﬁned as the usual abbreviations. We only  give the deﬁnition of “chop” here as the other operators and the existential quantiﬁer are deﬁned  according to in First-Order Logic.  We employ the following notation for describing the application of the chop operation on  intervals.  Deﬁnition 4 (Notation). Let M = [b1 , f1 ] × · · · × [bm , fm ] denote an m-dimensional interval. We  denote the lower bound bi of the ith dimension by mini M and the upper bound ei by maxi M,  df  respectively. Furthermore, denote by M ≺i r =[b1 , f1 ] × · · · × [bi , r] × · · · × [bm , fm ] the ﬁrst subinterval obtained by chopping the original interval along the ith axis at position r and the second  df  part by M i r =[b1 , f1 ] × · · · × [r, fi ] × · · · × [bm , fm ]. The “interior” M− of M is deﬁned by  M− = [b1 , f1 ) × · · · × [bm , fm ).  Using this notation the semantics of the chop operator is deﬁned as follows.  I [[F1 ei  F2 ]](V , M) = true  iff there is an m ∈ [mini M, maxi M] such that  I [[F1 ]](V , M ≺i m) = true and  I [[F2 ]](V , M i m) = true.  A. Schäfer / Information and Computation 205 (2007) 25–64  31  The satisfaction relation |= is deﬁned by  I , V , M |= F iff I [[F ]](V , M) = true.  We deﬁne some abbreviations to make speciﬁcations more concise. The almost everywhere operator  expresses that a state assertion  holds almost everywhere in the interval and the interval  is non-empty. The empty interval is denoted by . The n-dimensional volume is measured by the  term .  df  =    df    =(  =  ∧  > 0)  1    = 1=0  df  The somewhere operator ♦ei F chops the n-dimensional interval twice in the ith direction such that  in the middle interval F holds, hence it expresses that F holds on some region along the ith axis.  df  ♦ei F = true ei  F ei  true  The dual globally operator is ei deﬁned by  df  ei = ¬♦ei ¬F  and expresses that F holds in every region along the ith axis. Although chop is associative only  for chopping in the same direction, ♦e1 ♦e2 F still is equivalent to ♦e2 ♦e1 F . We will denote the unit  vector corresponding to the time dimension by et and to spatial dimensions by ex , ey , etc.  Example 5. The initial requirement, that at most 10 cm2 of the robot R is ever outside a restricted  area deﬁned by A can be expressed by      et (R ∧ ¬A)  (10 · et )  where the unit is omitted. The formula reads as follows: for every temporal interval the volume of  all points of R outside of A is less than 10 multiplied by the temporal length. The scenario is sketched  in Fig. 2a. The observable R modelling the robot is true for all points between the solid lines, the  observable A is true for all points between the dashed lines. For simplicity we omitted the second  spatial dimension in the drawing.  Example 6 (Ensuring a minimal distance). Consider the scenario of two moving robots using a collision avoidance system as depicted in Fig. 2b. We require that the minimal distance is always at  least than 1 cm. This is speciﬁed by    et ex (♦ex  ♦et  R1 ∧ ♦ex R2 ) ⇒  ((♦ex R1 ∧ ¬♦ex R2 ) ex   ( ¬R1 ∧ ¬R2 ∧ ex  1) ex     (♦ex R2 ∧ ¬♦ex R1 ))  32  A. Schäfer / Information and Computation 205 (2007) 25–64  a  b  Fig. 2. (a) Moving robot scenario and (b) Minimal distance scenario.  This formula reads as follows. For all spatio-temporal subintervals such that Robot R1 and Robot  R2 are contained somewhere in this interval, there is a temporal subinterval such that we can split  space into three parts such that  (1) the lower part contains R1  (2) the middle part neither contains Robot R1 nor R2 and it has length greater than or equal to 1  (3) and the upper part contains R2 .  As indicated in Fig. 2b arbitrarily large temporal intervals do not need to satisfy the Condition  (2).  Deﬁnition 7 (Validity/satisﬁability). A formula F is valid iff it evaluates to true for all interpretations,  valuations and intervals. It is satisﬁable iff there is an interpretation, a valuation and an interval  such that F holds.  Note 1. Duration Calculus and one-dimensional Shape Calculus coincide. In this sense the extention  of Duration Calculus is conservative.  3. Undecidability and non-axiomatisability  In this section, we show that validity for Shape Calculus is undecidable and even not recursively  enumerable. Henceforth, Shape Calculus is not recursively axiomatisable by Craig’s Theorem [17].  In [28] it is shown that Duration Calculus is decidable for the discrete time domain and for the  formulae restricted to phase expressions · , chop and Boolean operators. This result does not transfer to Shape Calculus when considering more than one dimension. Since one-dimensional Shape  A. Schäfer / Information and Computation 205 (2007) 25–64  33  Calculus and Duration Calculus coincide, for one-dimensional discrete Shape Calculus and this  restricted subset, validity is still decidable.  Theorem 8. For two dimensions and above, the set of valid SC formulae is not recursively enumerable,  neither interpreted in the continuous nor in the discrete domain.  By Craig’s Theorem [17] a theory is recursively axiomatisable if and only if the set of valid  formulas is recursively enumerable. Therefore from the above theorem, we obtain the following  corollary.  Corollary 9. There is not a sound and complete proof system for SC .  Extending the undecidability proof in [42], we provide a reduction from a non recursively enumerable tiling problem.  For this proof we restrict ourselves to the class of formulae given by  F ::=  | F ∧ G | ¬F | F e1  G | F e2  G | ei = r  for some ﬁxed r. The corresponding subset of Duration Calculus interpreted in discrete or continuous time domain is known to be decidable [28]. Without loss of generality, we choose r = 1.  3.1. Tiling systems  The theory of string languages can be extended to two-dimensional (also called picture) languages. We shortly review the main deﬁnitions and results. A detailed discussion can be found in  [26].  We ﬁx an alphabet  and a fresh boundary character #. A two-dimensional string (picture) over   is a two-dimensional rectangular matrix of elements of  such that the boundary is marked by  the fresh symbol #.  A tile p is a 2 × 2 matrix with elements in  ∪ # and a tiling system  is a ﬁnite set of  tiles. The local language L() for a tiling system  is the set of all n × m matrices such that  each 2 × 2 block is in  and the boundaries of the matrix consist only of # and # does not  occur in the interior.  Giammarresi and Restivo show in [26] that the emptiness problem  Given a tiling system , is L() = ∅ ?  is undecidable. This problem can be reformulated as follows:  There is no n × m matrix for n, m ∈ ⺞ such that every 2 × 2 submatrix is contained in the set   and the boundaries of the matrix consist of # only and # does not occur in the interior.  They provide a reduction such that a Turing Machine M has no successful computation  iff L() is empty. With this reduction to the termination problem, the emptiness problem for  tiling systems is not recursively enumerable. Both problems are co-recursively enumerable.  3.2. Encoding tilings in Shape Calculus  We provide a reduction of the emptiness problem for tiling systems as described above to the  validity problem of Shape Calculus. For a set of tiles  = {p1 , . . . , pk }, we deﬁne a formula F in  SC, such that L() =  / ∅ iff F is satisﬁable which is equivalent to L() = ∅ iff ¬F is valid.  34  A. Schäfer / Information and Computation 205 (2007) 25–64  We present an encoding which does not rely on continuous or discrete time and space domain.  Therefore, to avoid chopping at arbitrary positions, we impose a chess-board marking by a fresh  observable  as a region marker to clearly identify 2 × 2 blocks in the continuous case. We specify  the grid by a formula Fgrid as follows:  df  Fgrid = e1  2 ∧ e2  2 ∧   ⇐⇒ (1 ⇐⇒ 2 ) ∧    e1 (( 1 e1  e1 = 1 ⇒ 1 e1  ¬1 ) ∧    ( ¬1 e1  e1 = 1 ⇒ ¬1 e1  1 ) ∧  e1  1 ⇒ ( 1 ∧ e1 = 1 e1  true) ∧    e2 (( 2 e2  e2 = 1 ⇒ 2 e2  ¬2 ) ∧    ( ¬2 e2  e2 = 1 ⇒ ¬2 e2  2 ) ∧  e2  1 ⇒ ( 2 ∧ e2 = 1 e2  true)  (∗)  (∗∗)  (∗ ∗ ∗)  (∗∗)  (∗ ∗ ∗)  We use two auxiliary observables 1 and 2 . The observable 1 is true on intervals [i, i +  1] × [a, b] and false on [i + 1, i + 2] × [a, b] when i is even and a, b are arbitrary. The same  holds for 2 and intervals [a, b] × [i, i + 1] and [a, b] × [i + 1, i + 2], respectively. This fact can  be easily proven by induction on i. The quantiﬁed subformulae (∗∗) specify that a i slice  is succeeded by a ¬i slice and vice versa. The initial condition that the ﬁrst slice has a  size of 1 and satisﬁes 1 , respectively 2 , is speciﬁed separately by (∗ ∗ ∗). The chessboard marking by  is obtained using the equivalence operation on 1 and 2 in (∗). This  idea is formalised in the following lemma.  Lemma 10. Let I be an interpretation and k ∈ ⺞, a, b ∈ ⺤. Then I , [0, k] × [a, b] |= Fgrid if and only if  k  2, b − a  2, and for all i ∈ ⺞, i  k and arbitrary [a , b ] ⊆ [a, b] the following holds:  () I , [i, i + 1] × [a , b ] |=  ()          I , [a , b ] × [i, i + 1] |=    ()  I , [i, i + 1] × [j, j + 1] |=  1  ¬1  if i is even,  otherwise  2  ¬2  if i is even,  otherwise   if i, j are both even or both odd  ¬  otherwise.  To describe a 2 × 2 block in this grid satisfying the observables P1 , P2 , P3 , P4 in its four cells starting  with P1 in the lower left corner, we use the pattern  df  F2×2 (P1 , P2 , P3 , P4 ) = ((  ∧ P1 ) e1  ( ¬ ∧ P2 ) e2   ( ¬ ∧ P3 ) e1  (  ∧ P4 )) ∨  (( ¬ ∧ P1 ) e1  (  ∧ P2 ) e2   (  ∧ P3 ) e1  ( ¬ ∧ P4 ))  A. Schäfer / Information and Computation 205 (2007) 25–64  35  Fig. 3. Sample encoding of tilings in a grid structure.    and assign to every tile pi =  cd  ab    df  a formula Fpi = F2×2 (a, b, c, d). With these sub-formulae we  deﬁne F to be  df  F = Fgrid    k  ∧e1 e2 F2×2 (true, true, true, true) ⇒  Fpi  (∗)  i=1  ∧ # e1  ( # e2  ¬# e2  # ) e1  #  ∧  s ⇒ ¬s    (∗∗)  (∗ ∗ ∗)  s,s ∈,s=s  /   The second conjunct (∗) states that each 2 × 2 block in the grid must be in , whereas the third  conjunct (∗∗) states that the picture must be framed by # and # does not occur in the interior, as  sketched in Fig. 3. The last conjunct ensures mutual exclusion of symbols. With this deﬁnition, F  is satisﬁable if and only if the local language L() is not empty, so ¬F is valid if and only if the  local language L() is empty.  Proof  “only if” Let I be a satisfying interpretation and [0, k1 ] × [0, k2 ] an interval such that I , [0, k1 ] ×  [0, k2 ] |= F . Note that by deﬁnition of the grid and F a satisfying interval must have  integer bounds. Let (pi,j )i,j be the matrix deﬁned by  pi,j = a ⇐⇒ I , [i, i + 1] × [j, j + 1] |= a  36  A. Schäfer / Information and Computation 205 (2007) 25–64  for a ∈  ∪ {#}. By (∗ ∗ ∗) there is at most one observable a ∈  ∪ {#} satisﬁed on [i, i +  1] × [j, j + 1] and by (∗) there is at least one observable satisﬁed. Therefore (pi,j )i,j is welldeﬁned. By (∗) each interval of size 2 × 2 satisﬁes some Fpi . Therefore by construction  each 2 × 2 submatrix in (pi,j )i,j is in . Furthermore, since the boundary satisﬁes # the  matrix boundaries of (pi,j )i,j consists of #. So, (pi,j )i,j ∈ L().  “if”  Let (pi,j )i,j ∈ L(). Deﬁne an interpretation I for the observables a ∈  ∪ {#} by    I [[a]](x, y) =  1 if pi,j = a ∧ x ∈ [i, i + 1], y ∈ [j, j + 1],  0 otherwise  and for the auxiliary observables by    1 if there is an even i such that x ∈ [i, i + 1],  0 otherwise    1 if there is an even i such that y ∈ [i, i + 1],  I [[2 ]](x, y) =  0 otherwise    1 if I [[1 ]](x, y) ⇐⇒ I [[2 ]](x, y),  I [[]](x, y) =  0 otherwise.  I [[1 ]](x, y) =  It is straightforward to see that I , [0, i + 1] × [0, j + 1] |= F .    We haven proven so far that satisﬁability corresponds to non-emptiness of local picture languages for tiling systems. Therefore validity corresponds to language emptiness, which is known  to be undecidable and not recursively enumerable. By Craig’s Theorem [17] this proves: SC is not  recursively enumerable and not axiomatisable.  4. Relative completeness  In the previous section, we have demonstrated that Shape Calculus is not axiomatisable.  Despite this negative result, it is still possible to give an axiomatisation relatively to an n-dimensional extension of Interval Temporal Logic (ITLn ). We assume an inference system for  ITLn , i.e, a set of inference rules such that every valid ITLn formula can be derived by ﬁnitely  many applications of the inference rules. The inference relation is denoted by ITLn . Assuming the existence of this inference system for ITLn , we derive a system for the Shape Calculus  such that every valid Shape Calculus formula can be derived. Therefore, this system is called  complete relatively to ITLn .  Thereby, we extend the axiomatisation result for the Duration Calculus presented in [27]  to the Shape Calculus. Duration Calculus itself allows an axiomatisation relatively to interval  temporal logic (ITL). For this axiomatisation, we require a stronger ﬁnite variability assumption, namely every ﬁnite n-dimensional interval can be partitioned into ﬁnitely many sub-intervals such that I is constant on each sub-interval. Considering arbitrary integrable functions  A. Schäfer / Information and Computation 205 (2007) 25–64  37  would require an axiomatisation of the integral calculus which is out of scope for this paper.  The axiomatisation result for Duration Calculus presented in [27,28] relies on the same requirement, namely ﬁnite variability. Our proof follows the lines of [27,28] and considers only  the two-dimensional case, but it can easily be generalised to more dimensions.  4.1. Interval temporal logic (ITL)  We shortly introduce the n-dimensional ITL. One-dimensional ITL is discussed in [20,28].  ITLn does not use state assertions nor the integral operator but instead uses ﬂexible variables v whose values depend on the interval. Furthermore, it incorporates rigid variables x  and lengths ei as terms.  n  n  n   ITL ::= x | v | ei | f 1ITL , . . . , kITL  The semantics of ﬂexible variables is given by an interpretation IITLn that assigns a real number  to each n-dimensional interval. This is extended to terms as follows:  IITLn [[x]](V , M)  df  IITLn [[v]](V , M)  df  = V (x)  = I (v)(M)  df  IITLn [[ei ]](V , M)  = fi − bi  n  n  n  df  IITLn [[f 1ITL , . . . , kITL ]](V , M) = fIITLn (IITLn [1ITL ]](V , M),  ...,  n  IITLn [kITL ]](V , M))  Like in Shape Calculus, V is a valuation of the rigid variables, i.e., variables that do not change  over time and M = [b1 , f1 ] × · · · × [bn , fn ] is an n-dimensional interval. Furthermore, we deﬁne the  df  abbreviation  = e1 · e2 to measure the two-dimensional area. For formulae, ITLn incorporates  Boolean combinations, chop and quantiﬁcation as in SC. Formally, it is given by the following  BNF.  n  n  n  n  n  n  n  n  F ITL ::= F1ITL ei  F2ITL | p 1ITL , . . . , kITL | ¬F1ITL | F1ITL ∧ F2ITL |  n  ∃x : F ITL  The semantics of the Boolean connectives and quantiﬁers is the same as in ﬁrst order logic. The  semantics of the chop operator is the same as in Shape Calculus.  4.2. Axiomatisation  We present the main theorem of this section and give a short proof sketch. To make the presendf  tation more concise, we introduce negated unit vectors and deﬁne F −ei  G = G ei  F  38  A. Schäfer / Information and Computation 205 (2007) 25–64  Theorem 11. Two-dimensional SC is axiomatised relatively to ITL2 by the following axioms.    0=0    1=    0          1 + 2 = (1 ∨ 2 ) + (1 ∧ 2 )         = x ei   = y ⇒  = x + y  ∨ ((  ∨ ((  ∨ ((  ∨ ((          ∨  ∨  ∨  ∨  ¬  ¬  ¬  ¬  e1  true) e2  true)  e1  true) −e2  true)  −e1  true) e2  true)  −e1  true) −e2  true)  (SC1)  (SC2)  (SC3)  (SC4)  (SC5)  (FV1)  (FV2)  (FV3)  (FV4)  The set of axioms can be separated into two groups. The ﬁrst group (SC1) up to (SC5) specify properties of the integral calculus need for piecewise constant functions. The second group  (FV1)–(FV4) speciﬁes ﬁnite variability, by demanding that for every point we can ﬁnd 4 rectangles to the lower left, lower right, upper left and upper right, respectively, such that the  value of a state expression is constant. The proof of relative completeness proceeds as follows. For a valid SC formula F we have to construct a derivation using the set of axioms  deﬁned previously. To this end, we construct a valid ITLn formula. As we consider relative  completeness, we can assume an ITLn deduction of this formula. This deduction is lifted to  a Shape Calculus deduction of F .  4.3. From Shape Calculus to ITLn  For a given valid Shape Calculus formula F , we ﬁrst elaborate an encoding of all Shape Calculus  axioms that are possibly needed for the proof of F into one ITLn formula.  Encoding the axioms in ITLn . Let F be an arbitrary valid SC formula and let X1 , . . . , Xl be the set  of Boolean observables occurring in F and S the set of all state expressions built from these observables. Note that, since state expressions are formulae of propositional logic, only ﬁnitely many  state expressions can be nonequivalent. Let  df  [] ={ |  ≡ }  denote such an equivalence class and S≡ = {[]| ∈ S } denote the set of equivalence classes. For  n  every equivalence class [] we   introduce an ITL ﬂexible variable v[] with the intuition thatn  v[] models the the value of . We encode the SC Axioms by the following ﬁnite sets of ITL  formulae.  df  H1 ={v[0] = 0}  df  H2 ={v[1] = }  A. Schäfer / Information and Computation 205 (2007) 25–64  39  df  H3 ={v[]  0 | [] ∈ S≡ }  df  H4 ={(v[1 ] + v[2 ] ) = (v[1 ∨2 ] + v[1 ∧2 ] ) | [1 ], [2 ] ∈ S≡ }  df  H5 ={(v[] = x ei  v[] = y) ⇒ (v[] = x + y) | [] ∈ S≡ }  df  H6 ={ ∨ (( v[] ∨ v[¬] d1  true) d2  true) |  [] ∈ S≡ , di ∈ {ei , −ei }}  df  df  where v[] =(v[] =  ∧  > 0) and =(1 = 0 ∨ 2 = 0). We deﬁne HFI to be the conjunction  of all formulae in H1 to H6 and F I to be the ITLn formula obtained from F by replacing every  occurrence of  by v[] . Note, that this formula depends on F .  We will now show, that an ITLn interpretation IITLn and a valuation V that satisfy the axioms encoded in HFI can already be used to derive a Shape Calculus interpretation. We will  use such interpretations, valuations and intervals frequently in what follows, so we aggregate  them in triples.  Deﬁnition 12 (H-Triple). A triple (IITLn , V , [b1 , f1 ] × [b2 , f2 ]) is called an H-triple if  IITLn , V , [b1 , f1 ] × [b2 , f2 ] |=ITLn e1 e2 HFI  i.e., HFI holds for every subrectangle of [b1 , f1 ] × [b2 , f2 ].  Using this deﬁnition and the axioms, we derive some properties of H-Triples that will be used in  the completeness proof. A complete proof of this lemma can be found in [28].  Lemma 13. Let (IITLn , V , [b1 , f1 ] × [b2 , f2 ]) be an H-Triple. Then the following holds:  (1) IITLn , V , [b1 , f1 ] × [b2 , f2 ] |=ITLn  (2) IITLn , V , [b1 , f1 ] × [b2 , f2 ] |=ITLn  (3) IITLn , V , [b1 , f1 ] × [b2 , f2 ] |=ITLn  (4) IITLn , V , [b1 , f1 ] × [b2 , f2 ] |=ITLn  k = 1, 2.  v[] + v[¬] =   v[]    v[1 ]  v[1 ∨2 ]  v[] impliesI , V , [c1 , d1 ] × [c2 , d2 ] |= v[] for[ck , dk ] ⊆ [bk , fk ],  Deriving the piecewise constant property. As we require Shape Calculus interpretations to be  piecewise constant, i.e., there is a partition of time and space into intervals such that the interpretation of observables is constant on each interval, we show that this property can be  derived in ITLn from the encoded axioms. We need the instances in H6 and the Theorem of  Heine Borel [41].  40  A. Schäfer / Information and Computation 205 (2007) 25–64  Lemma 14. Given an arbitrary H-triple (IITLn , V , [b1 , f1 ] × [b2 , f2 ]) such that b1 < f1 and b2 < f2 , i.e.,  the interval is non-empty, then for every  ∈ S there is a ﬁnite partition in sub-rectangles [b11 , f11 ] ×  [b12 , f21 ], . . . , [bn1 , f1n ] × [bn2 , f2n ] such that for every rectangle [bi1 , f1i ] × [bi2 , f2i ] holds either  IITLn , V , [bi1 , f1i ] × [bi2 , f2i ] |=ITLn v[] or IITLn , V , [bi1 , f1i ] × [bi2 , f2i ] |=ITLn v[¬]  Proof. Let (x, y) ∈ [b1 , f1 ] × [b2 , f2 ]. Then by H6 there exists x1  x  x2 and y1  y  y2 such that  IITLn , V , [x1 , x] × [y1 , y] |=ITLn  IITLn , V , [x1 , x] × [y, y2 ] |=ITLn  IITLn , V , [x, x2 ] × [y1 , y] |=ITLn  IITLn , V , [x, x2 ] × [y, y2 ] |=ITLn  v[]  v[]  v[]  v[]  ∨  ∨  ∨  ∨  v[¬]  v[¬]  v[¬]  v[¬]  and  and  and  Now (x1 , x2 ) × (y1 , y2 ) is an open interval covering the point (x, y) and the closed interval [x1 , x2 ] ×  [y1 , y2 ] has the desired property. Then by Heine-Borels Theorem there is a ﬁnite subset of this inﬁnite  partition covering [b1 , f1 ] × [b2 , f2 ] . The cases where (x, y) is on the border are handled similarly.  This yields the ﬁnite partition as required.   From ITLn interpretations toSC interpretations. We have to show that for every valid SC formula  there is a valid ITLn formula such that we can lift the derivation of the ITLn formula to a derivation  of the SC formula. We will show the contrapositive, i.e., that an ITLn interpretation satisfying the  axioms, corresponds to an SC interpretation. Let (IITLn , V , [b1 , f1 ] × [b2 , f2 ]), be an H-triple. We  construct an SC-interpretation ISC by deﬁning for every observable X the interpretation ISC (X) to  be    1 if there are x1 , x2 , y1 , y2        df  x1  x < x2 , y1  y < y2 such that  (1)  ISC (X)((x, y)) =  IITLn , V , [x1 , x2 ] × [y1 , y2 ] |=ITLn v[X ]        0 otherwise  This interpretation has the required ﬁnite variability property: each interval can be partitioned into ﬁnitely many subintervals such that the value of each observable X is constant  on each subinterval. It is to be shown that the SC interpretation given by this deﬁnition satisﬁes  if and only if the ITLn interpretation satisﬁes v[] . This result is established by  the following lemma.  Lemma 15. For an H-triple (IITLn , V , [b1 , f1 ] × [b2 , f2 ]), a state assertion , and an SC-Interpretation  o−1  n  o  as deﬁned in Equation 1, there is a ﬁnite partition [m11 , m21 ] × [m12 , m22 ], . . . , [mn−1  1 , m1 ] × [m2 , m2 ] of  j  j+1  the two-dimensional interval [b1 , f1 ] × [b2 , f2 ] such that for every point (x, y) ∈ [mi1 , mi+1  1 ) × [m2 , m2 )  holds  j  j+1  n  IITLn , V , [mi1 , mi+1  1 ) × [m2 , m2 ) |=ITL v[] ∨ v[¬]  and  (2)  A. Schäfer / Information and Computation 205 (2007) 25–64      ISC [[]] (x, y) =    j  41  j+1  n  1 if I , V , [mi1 , mi+1  1 ) × [m2 , m2 ) |=ITL v[]  j  j+1  i+1  i  0 if I , V , [m1 , m1 ) × [m2 , m2 ) |=ITLn v[¬] .  This lemma can be proven by induction on the structure of . As the integral  summation over the piecewise constant parts we obtain the following corollary.  (3)     is derived by  Corollary 16. For the interpretation ISC and every state assertion  and interval [b1 , f1 ] × [b2 , f2 ]    ISC [[ ]]([b1 , f1 ] × [b2 , f2 ]) = IITLn [[v[] ]]([b1 , f1 ] × [b2 , f2 ])  4.4. Proving relative completeness  Starting with a valid Shape Calculus formula F , we have shown how to construct an Shape  Calculus interpretation for every ITLn interpretation that satisﬁes certain instances of the Shape  Calculus axioms in the ITLn formula e1 e2 HFI .  Corresponding  to the Shape Calculus formula F , we deﬁne the ITLn formula F I by replacing the    measure  with a variable v[] . Using the above result, we can construct for every ITLn interpretation IITLn which violates e1 e2 HFI ⇒ F I , i.e, the interpretation satisﬁes e1 e2 HFI but violates F I ,  an SC interpretation ISC violating F .  This proves the following lemma.  Lemma 17. |=SC F implies |=ITLn e1 e2 HFI ⇒ F I .  To show the converse implication, let ISC be an SC interpretation violating F . Deﬁne the violating  ITLn interpretation IITLn by    df  IITLn (v[] )([b1 , f1 ] × [b2 , f2 ]) = ISC [[ ]]([b1 , f1 ] × [b2 , f2 ]).  Using this interpretation and the soundness of our axiomatisation, we obtain  Lemma 18. |=ITLn e1 e2 HFI ⇒ F I implies |=SC F.  To prove the relative completeness, suppose |=SC F . Then by Lemma 17 holds |=ITLn e1 e2 HFI  ⇒ FI . Take the ITLn derivation of |=ITLn e1 e2 HFI ⇒ F I and replace every occurrence of v[]  by  to obtain an SC derivation. As HF is a boxed conjunction of instances of SC axioms, it can be easily deduced in SC and therefore we obtain a derivation of F by modus  ponens.  5. Decidable subsets  For acceptance of formal methods in practice, tool support is essential. Decidable subsets  therefore play an import role as they facilitate the implementation of model-checkers. Restricted discrete Duration Calculus is known to be decidable [28] and a model-checking method  is implemented in DCValid [36]. In this section, we present two different types of decidable  subsets of SC. The ﬁrst is obtained by imposing restrictions on the class of models and the  second by imposing restrictions on the class of formulae. Duration Calculus is already unde-  42  A. Schäfer / Information and Computation 205 (2007) 25–64  cidable in the continuous case except for very restricted subsets which, e.g., miss the possibility  of taking quantitative measures. Henceforth we assume the time-space-domain to be discrete  throughout this section. As First-Order logic is undecidable, we also omit ﬁrst order variables.  We assume all interpretations to change their values only at points in ⺞ and all variables to  have a range in ⺞. A detailed discussion of decidable subsets and undecidability results for  Duration Calculus can be found in [28] and [22].  5.1. Finite space with inﬁnite time  This ﬁrst subset SCfin imposes a restriction on the class of models: we allow one inﬁnite temporal  dimension and require the other spatial dimensions to be ﬁnite and the size to known beforehand.  As we have shown in the previous section, Shape Calculus is already undecidable for two and more  discrete inﬁnite dimensions.  We give a decision procedure for the set of formulae given by the following BNF:  F ::= P | F ∧ G | ¬F | F ei  G  where ei denotes a spatial or temporal unit vector. The more general integral operator is replaced  by the more specialised everywhere operation · omitting the use of SC terms. We will see later  that other operators can be deﬁned as abbreviations in the discrete setting. The approach for the  decision procedure is sketched in Fig. 4. As there are only ﬁnitely many observables, a conﬁguration  for a point in space-time can be represented by the ﬁnite set of observables evaluating to true. In  Fig. 4b this set is represented as a bitvector.  We generalise this idea to an arbitrary number of spatial dimensions. All spatial dimensions are ﬁnite, so the spatial conﬁguration for a moment in time can be represented by a  ﬁnite function mapping the ﬁnite space to the powerset of the observables. Due to the ﬁniteness of the domain, there are only ﬁnitely many spatial conﬁgurations and therefore only  ﬁnitely many functions representing a temporal snapshot. For the decision procedure, we use  these functions as an alphabet and represent interpretations over space and time by words  over this alphabet. It proceeds by inductively constructing a regular language representing all  satisfying interpretations. Conjunction is constructed by intersection, negation by complement,  temporal chop by concatenation and spatial chop using inverse homomorphisms for “gluing”  two words letterwise.  Deﬁnition 19 (Alphabet F ). Let F be an n-dimensional SCfin formula, Obs the set of observables  occurring in F and D a ﬁnite rectangular subset of ⺞n−1 . The alphabet F (D) of F for space D if  deﬁned by  F (D) = {c|c : D → P (Obs)}.  Let space be the subset of ⺞n−1 denoting the ﬁnite space, we deﬁne    F (D).  F =  D⊆space, D rectangular  A. Schäfer / Information and Computation 205 (2007) 25–64  a  43  b  Fig. 4. (a) Two objects in ﬁnite space. (b) Their representation using a ﬁnite alphabet.  Each function in F represents a temporal snapshot of a spatial conﬁguration for a point in time.  The intuition is that c((x1 , . . . , xn−1 )) collects all observables that are true on the interval [x1 , x1 +  1) × · · · × [xn−1 , xn−1 + 1). As we use discrete time and space, all interpretations are constant on these  intervals. Therefore we can deﬁne the satisfaction relation  for a state assertions , a function  c ∈ F (D) and a spatial point x ∈ D inductively by  c(x)X  iff X ∈ c(x)  c(x)1 ∧ 2 iff c(x)1 and c(x)2  c(x)¬  iff c(x)    Note that F is ﬁnite since space and the set of observables are both ﬁnite.  For handling the chop-operation, we need to restrict the domain of functions in F . This is  done via a functional hD→D restricting the domain from D to a subset D . This functional is  extended to a homomorphism on words in ∗F and using the inverse of this homomorphism,  we can generate all possible spatial extentions to space D of the word describing space D .  Deﬁnition 20 (Homomorphism hD→D ). Let F (D) and F (D ) be alphabets as given by Deﬁnition  19 and D ⊆ D. The function hD→D deﬁned by    F (D) → F (D )  hD→D :  c → c|D    : F (D)∗ → F (D )∗ in the usual way, i.e.,  can be extended to a language homomorphism hD→D  df    (ε) = ε and hD→D    (aw) = hD→D (a) ◦ hD→D    (w). We omit the distinction between hD→D and  hD→D    in the following.  hD→D  44  A. Schäfer / Information and Computation 205 (2007) 25–64  Deﬁnition 21 (Language L(F)). Let F be an n-dimensional SCfin formula, F the alphabet and  D ⊆ space. Using the notation from Deﬁnition 4 the regular language LD (F) over the alphabet  F (D) is deﬁned inductively by  df  LD (  ) =    ∅  if ∃ i : mini (D)  maxi (D)  {c ∈ F |∀ x ∈ D− : c(x)}+  otherwise  df  LD (¬F) = F (D)∗ \ LD (F)  df  LD (F1 ∧ F2 ) = LD (F1 ) ∩ LD (F2 )  df  LD (F1 et  F2 ) = LD (F1 ) ◦ LD (F2 )  The deﬁnition for the spatial chop in direction ei is more technical.    df  LD (F1 ei  F2 ) =  −1  h−1  D→(D≺i r) (LD≺i r (F1 )) ∩ hD→(D  i r)  (LD  ir  (F2 ))  r∈[mini D,maxi D]  The r ∈ [mini D, maxi D] is the point to chop the interval. We construct the language for  the formula F1 and the lower part of interval and use the inverse homomorphism, i.e. the  preimage, to generate all possible extensions. The same approach is done for the upper part  and formula F2 . The intersection assures that F1 holds on the lower and F2 on the upper part  of the interval. n)  By deﬁnition, a formula is satisﬁable if there is an interval satisfying it. Therefore, all ﬁnitely  many spatial subintervals have to be considered for the language of F  df  L(F) =    LD (F)  D⊆space  As regular languages are closed under all operations used in this deﬁnition, L(F) is regular. The  correspondence between words and interpretations is established by the following lemma which is  proven by structural induction.  Lemma 22. Let F be an n-dimensional SCfin formula, [0, t] a temporal interval and D = [b1 , f1 ] × · · · ×  [bn−1 , fn−1 ] a spatial interval. Then the following holds:  () Let I be an interpretation satisfying F on the interval D × [0, t], then the word  F (D)∗ representing I with  df  ck (x) ={X ∈ Obs | I (X)(x, k) = 1}  for k ∈ {0, . . . , t − 1} is in LD (F).  df  = c0 . . . ct−1 ∈  A. Schäfer / Information and Computation 205 (2007) 25–64  () Let  45  = c0 . . . ct−1 ∈ LD (F), then the corresponding interpretation I deﬁned by  df  I (X)(x, t) =    1 if X ∈ ct (x)  0 otherwise  satisﬁes I , D × [0, t] |= F.  The following corollary establishes the correctness of the construction.  Corollary 23. An n-dimensional SCfin Formula F is satisﬁable on an interval D × [0, t] where D is a  (n − 1)-dimensional spatial and [0, t] is a temporal interval iff LD (F) is non-empty.  As the emptiness problem for regular languages is decidable, this proves the decidability.  Theorem 24. The validity and satisﬁability problems for SCfin are decidable.  The complexity of the decision procedure is non-elementary as each negation may cause an  exponential blow-up due to the complementation of ﬁnite automata. The complexity is polynomial in the assumed ﬁnite spatial cardinality, the degree of the polynomial is determined  by the number of nested chops. The complexity of deciding validity for Duration Calculus is  also already non-elementary [28]. Although non-elementary seems to be a serious concern, the  application of the procedure for Duration Calculus on several case studies[36] demonstrates  the feasibility of this approach.  Example 25. We illustrate the language construction for the decision procedure by constructing  the language L( P ey  ¬P ). We assume Obs = {P }, a two-dimensional space, and a maximal spatial cardinality of 2 in each dimension. For convenience the functions c are represented  by matrices.  L[0,2]×[0,0] ( P ) = ∅  L[0,2]×[2,2] ( ¬P ) = ∅  L[0,2]×[0,1] ( P ) = {({P } {P })}+  L[0,2]×[1,2] ( ¬P ) = {({} {})}+  +  +      {P } {P }  {} {}  L[0,2]×[0,2] ( P ) =  L[0,2]×[0,2] ( ¬P ) =  {P } {P }  {} {}  −1  L[0,2]×[0,2] ( P ey  ¬P )  = h[0,2]×[0,2]→[0,2]×[0,0] (L[0,2]×[0,0] ( P )) ∩  h−1  [0,2]×[0,2]→[0,2]×[0,2] (L[0,2]×[0,2] ( ¬P ))  ∪  −1  h[0,2]×[0,2]→[0,2]×[0,1] (L[0,2]×[0,1] ( P )) ∩  h−1  [0,2]×[0,2]→[0,2]×[1,2] (L[0,2]×[1,2] ( ¬P ))  ∪  −1  h[0,2]×[0,2]→[0,2]×[0,2] (L[0,2]×[0,2] ( P )) ∩  h−1  (L[0,2]×[2,2] ( ¬P ))  [0,2]×[0,2]→[0,2]×[2,2]    +  {P } {P }  =  {} {}  46  A. Schäfer / Information and Computation 205 (2007) 25–64  Expressivity. Although the subset SCfin seems to be rather limited, there are several expressions of  the original language that can be obtained as abbreviations using the restricted set and the fact that  the temporal and spatial domain are discrete. The terms ei are obtained because it is impossible in  a discrete domain to chop an interval of length 1 into two parts of positive length. So, for k ∈ ⺞+ ,  we obtain measures as follows.  df  ⇐⇒ ¬ 1  ei = 1 ∧ ¬  ei = k + 1 ∧ ¬  ei > k ∧ ¬  df  ⇐⇒ 1 ∧ ¬( 1 ei  1 )  df  ⇐⇒ (ei = k ∧ ¬ ) ei  (ei = 1 ∧ ¬ )  df  ⇐⇒ (ei = k ∧ ¬ ) ei  1 ;  The deﬁnition of the other operators ,,<  is analogue. As interpretations may only change    their value at discrete points, the measure P can be expressed as follows:    df  P = 0 ⇐⇒ ¬P ∨      df  P = 1 ⇐⇒ P = 0        ex  P = 0 et  ( P ∧ x = 1 ∧ t = 1) et  P = 0    ex  P = 0            df  P = k1 ex  P = k2 ∨  P = k ⇐⇒  k1 , k2 > 0  k1 + k2 = k          P = k1 et  P = k2  k1 , k2 > 0  k1 + k2 = k  5.2. Non-alternating chop.  Another possibility of deriving a decidable subset is to use the ﬁbrings and dovetailing  ideas presented by Gabbay et al [23,24] to combine modal logics. In order to create a structure for the combined logic, they start with a structure for the ﬁrst one, associate to each  world a structure for the second logic and so on. The idea is depicted in Fig. 5a. Using this  approach a lot of important properties like axiomatisability and decidability are inherited by  the combination.  As we are interested in models isomorphic to the grid, we need to rule out models like those  sketched in 5b where going up and right is not equivalent to going right ﬁrst and up afterwards because our main goal is to reason about objects in ⺞n . To this end, we do not allow chop-alternation.  On the innermost nesting level we only allow formulae using e2  nested in formulae using e1   and so on. To preserve decidability, we restrict the interaction of formulae by adding a constraint  on the length.  A. Schäfer / Information and Computation 205 (2007) 25–64  a  b  47  c  X2  X1  X1  X0  X0  X0  w w’  f1  f2  f1  f3  f1  f3  Fig. 5. (a) Dovetailing linear modal structures. (b) Points w and w need not to be equal. (c) Dovetailing SC.  The language of this n-dimensional subset SCnAlt is the set of formulae F n generated by the  following BNF:  F 1 ::= P | F11 e1  F21 | F11 ∧ F21 | ¬F11      F n+1 ::= F1n+1 en+1  F2n+1 | F1n+1 ∧ F2n+1 | ¬F1n+1 | F n ∧ en+1 = 1  Let (F) denote the index of chop used on the topmost level, i.e, the minimal i such that F can be  generated from F i .  Note, that without this restriction, it is already possible to encode the tiling problem and the  resulting subset is undecidable.  Remark 26. An SCnAlt formula of type (F) = n can not only be interpreted by n-dimensional inter    pretations I n : Obs × Intn → {0, 1} but also by k-dimensional functions I k Obs × Intk → {0, 1}  for any k  n.  A simple consequence is obtained immediately.  Lemma 27. Let F be an SCnAlt formula of type (F) = n.  () Assume I k for k  n to be a k-dimensional interpretation and D a k-dimensional interval such  df  that I k , D |= F. Deﬁne I k→k+1 as a k + 1-dimensional interpretation by I k→k+1 (X)(x, y) = I k (x).  Then any interval [b, f] satisﬁes I k→k+1 , D × [b, f] |= F.  () Conversely, assume I k+1 , D × [b, b + 1] |= F for b ∈ ⺞, then for an interpretation I k+1→k (X)(x)  df  = I k+1 (x, b) we obtain I k+1→k , D |= F.  () Let I , I  be two n-dimensional interpretations, [0, f] a one-dimensional interval and D, D two  (n − 1)-dimensional intervals such that  I , D × [j, j + 1] |= F n−1 ∧ en = 1 iff I  , D × [j, j + 1] |= F n−1 ∧ en = 1  for all subformulae F n−1 of type (n − 1) occurring in F and all j ∈ [0, f). Then I , D × [0, f] |=  F iff I  , D × [0, f] |= F.  The last proposition states that if validity for two interpretations coincides on every slice and  every subformula then validity coincides for the whole formula. Like that for ﬁnite spatial  48  A. Schäfer / Information and Computation 205 (2007) 25–64  domains, the decision procedure constructs regular languages associated to fulﬁlling interpretations. For a model of an n-dimensional formula, we encode each (n − 1)-dimensional slice  of this model by one letter. As this spatial slice is still inﬁnite, we use the set of all (n − 1)dimensional subformulae that are true in this slice as a representative of the slice. Conversely,  having no chop alternation, it is possible to obtain an n-dimensional model by joining (n − 1)dimensional slices.  This idea gives rise to the following deﬁnition of the alphabets where the dimension n is indicated  by a superscript n if necessary for clarity and omitted if it is clear from the context  Deﬁnition 28 (Alphabet nnA (F)). Let F be an n-dimensional SCnAlt formula.  Case (F) = n = 1. If F is a pure DC formula (i.e. n = 1) a letter characterises which observables  are true at the current position. Henceforth, we deﬁne the alphabet to be the powerset of the  observables Obs as 1nA (F) = P (Obs).  Case (F) = n > 1. In this case, the subformulae of type (n − 1) play the role of the observables. Let Subn−1 (F) = {F1 , . . . , Fy } be the set of subformulae of F with type (Fi ) = n − 1.  A subset of Subn−1 (F) is used to characterise the set of all true formulae that hold for  an interval of length one in direction n. Therefore the alphabet is deﬁned by nnA (F) =  P (Subn−1 (F)).  The construction of the language LnnA (F) proceeds inductively on the structure of the formula.  Case (F) = 1. In this case F is a pure DC formula and we construct the language in the same way  as for discrete DC. Let Obs = {X0 , . . . , Xz } be the Boolean observables occurring in F . Then a subset  a of Obs represents a valuation of these observables for an interval of unit length. Deﬁne L1nA (F)  inductively by  df  L1nA (  ) = {a | a}+ ,  df  df  L1nA (F1 ∧ F2 ) = L1nA (F1 ) ∩ L1nA (F2 ),  L1nA (F1 e1  F2 ) = L1nA (F1 ) ◦ L1nA (F2 ),  df  L1nA (¬F1 ) = L1nA (F1 ).  Case (F) = n + 1. In this case the subformulae of type n play the role of the observables. Let  Subn (F) = {F1 , . . . , Fy } be the set of subformulae of F with (Fi ) = n. Then a set a ⊆ Subn (F) can  be used to describe which formulae are required to hold for an interval of length one. At ﬁrst we  construct an auxiliary regular language L (F) for the formula F in the same way as in the above  case such that for every word holds: if for every letter, i.e. a set of subformulae of F , there is a model  satisfying all the formulae in this set and the models can be joined to obtain a model for the whole  formula F .  df  L (F n ∧ en+1 = 1) = {a|F ∈ a}  df  L (¬F n+1 ) = L (F n+1 )  df  L (F1n+1 en+1  F2n+1 ) = L (F1n+1 ) ◦ L (F2n+1 )  df  L (F1n+1 ∧ F2n+1 ) = L (F1n+1 ) ∩ L (F2n+1 )  A. Schäfer / Information and Computation 205 (2007) 25–64  49  Different from the simple case, the language L does not represent the set of satisfying interpretations, since a word in L does not guarantee that there is a satisfying interpretation. A requirement  that two subformulae F1n and F2n of type n hold jointly for the very same interval may not be  satisﬁable. Additionally, we have to ensure that  • for each letter occurring in a word, i.e., subset a ⊂ Subn (F), there is an interpretation which  satisﬁes exactly those formulae F where F ∈ a and  • there is a common length k such that for all letters occurring in words, there is a satisfying interpretation of this length such that joining these models yields a rectangular  model.  To capture these requirements, we introduce the notion of consistency, i.e. the existence of  a common model, ﬁrst for letters and then for alphabets. A letter a ∈ n+1  nA (F) denotes a set  of formulae of type n. It is consistent if there is an n-dimensional interpretation satisfying all  formulae in a. For one formula F ∈ a, there is such an interpretation if the language LnnA (F)  is not empty. A set a of formulae is consistent if there is a word in the conjunction of all  such languages and only built from consistent letters of the lower dimensional type n − 1. A  set of letters  ⊆ n+1  nA (F) is consistent if there are satisfying n-dimensional interpretations  and intervals for each letter having all the same size such that they can be concatenated to  form an n + 1-dimensional interpretation. Therefore, for every word over a consistent alphabet  ⊆ n+1  nA (F), there is an interpretation such that each letter corresponds to a slice of  length one in direction (n + 1) satisfying all the n-dimensional subformulae occurring in the  letter.  For regarding only the length of a word, we employ the following homomorphism, which  “obscures” the actual letters of the word leaving only its pure shape.  Deﬁnition 29. Let be an arbitrary symbol and h : ∗ → { }∗ be the homomorphism that replaces  every letter by .  For deﬁning consistency formally, we extend the deﬁnition of an associated language for a formula F to a set of characteristic formulae a by  df  LnnA (a) =    F  ∈a  LnnA (F  ) ∩    F   ∈a  LnnA (F  ).  Using this deﬁnition, the intuition depicted above is formalised inductively as follows.  n+1 (F) ⊆ n+1 (F) for n > 1 is called consistent iff there is a consistent  Deﬁnition  30. A subset  nA      n (G) such that  n ⊆    n+1  (F)  a∈  G∈a nA    h (LnnA (a) ∩ (  n ∗  ) )=  / ∅  a∈  The basic case is handled directly, every subset  1 (F)  ⊆ 1nA (F) is consistent.  50  A. Schäfer / Information and Computation 205 (2007) 25–64  Combining consistency—the existence of interpretations satisfying the formulae for each slice  that can be concatenated—and the property of L that piecewise satisfaction of subformulae yields  satisfaction of the whole formula, we deﬁne the language by      df     Ln+1  nA (F) = L (F) ∩         .  ∗  ⊆  is consistent  The correspondence between words in LnnA (F) and n-dimensional interpretations is established  by the following deﬁnition and lemma.  Deﬁnition 31 (word-interpretation correspondence). Let F be an n-dimensional SCnAlt formula, I  be an n-dimensional interpretation, D an (n − 1)-dimensional interval and [0, f] a one-dimensional interval. We associate a word wI = aI0 . . . aIf−1 ∈ nnA (F)∗ to this interpretation such that for  n=1  df  aIj ={X |X is an observable occurring in F and I , D × [j, j + 1] |= X }  and, for n > 1,  df  aIj = F  |F  ∈ Subn−1 (F) and I , D × [j, j + 1] |= F  ,  respectively. Vice versa, we associate to a word w ∈ nnA (F)∗ the set of interpretations and intervals  [w] such that  (I , D) ∈ [w] ⇐⇒ w = wI .  Lemma 32. Let F be an n-dimensional SCnAlt formula.  () A subset ⊆ nnA (F) is consistent iff for every w = a0 . . . ak ∈ ∗ , there is an n-dimensional  interpretation I , an (n − 1)-dimensional interval D such that I , D × [j, j + 1) |= G ⇐⇒ G ∈ aj  holds for every j ∈ [0, k] and every G ∈ Subn−1 (F).  () I , D × [0, f] |= F implies wI ∈ LnnA (F).  / ∅ and ∀ (I , D) ∈ [w] : I , D × [0, |w|] |= F  () w ∈ LnnA (F) implies [w] =  An easy consequence is the following lemma.  Lemma 33. L(F) =  / ∅ iff F is satisﬁable  And as all these constructions can be done effectively this proves the following theorem.  Theorem 34. Satisﬁability and validity for SCnAlt are decidable.  Like for SCfin the complexity is non-elementary due to the complementation of ﬁnite automata for  each negation.  A. Schäfer / Information and Computation 205 (2007) 25–64  51  Example 35. These constructions are illustrated in Fig. 5c. Assume a formula  df  F = (F1 ∧ e1 = 1 e1  F1 ∧ e1 = 1 e1  F1 ∧ e1 = 1) ∧  (F2 ∧ e1 = 1 e1  F3 ∧ e1 = 1 e1  F3 ∧ e1 = 1)  with  df  F1 = X1 e2  true,  df  F2 = true e2  X2 ,  df  F3 = true e2  X3 .  The word (1, 1, 0)(1, 0, 1)(1, 0, 1) is in L (F) and as the alphabet is consistent also in L(F). Therefore  the models for F1 , F2 , F3 can be combined to form a model for F .  Expressivity. Like in SCfin operators can be obtained in SCnAlt . We illustrate the two-dimensional  case here. At ﬁrst we give deﬁnitions for formulae of type 1 which are to be used in the context of  “ ∧ e2 = 1”. We use the superscript 1 here to stress this restriction.  df  true1 ⇐⇒ 1 1 ∨ ¬ 1  df  1e1 = 0 ⇐⇒ ¬ 1  1e1 = 1 ∧ ¬  1  1  df  ⇐⇒ 1 1 ∧ ¬( 1 1 e1  1 1 )  df  1e1 = k + 1 ⇐⇒ (1e1 = k) e1  (1e1 = 1)  df  1e1 > k ⇐⇒ (11 = k) e1  1  1  1  df  P = 0 ⇐⇒ ¬P 1 ∨ 1e1 = 0  1  1  1  df  P = 1 ⇐⇒  P = 0 e1  P 1 ∧ 1e1 = 1 e1  P = 0  1  1  1  df  P = k + 1 ⇐⇒  P = k e1  P = 1  For formulae of type 2 the deﬁnitions are more complicated. At ﬁrst “true” can be deﬁned in the  standard way.  df  true ⇐⇒ ( 1 ∧ e2 = 1) ∨ ¬( 1 ∧ e2 = 1)  As e2 is nearly a primitive in SCnAlt , it can be deﬁned as follows:  df  e2 = 1 ⇐⇒ (true1 ) ∧ e2 = 1  df  e2 = k + 1 ⇐⇒ (e2 = k) e2  (e2 = 1)  52  A. Schäfer / Information and Computation 205 (2007) 25–64    The measure P is non-zero iff there is a subinterval of length 1 on which the measure is non-zero.  1  Therefore the measure can be deﬁned using the type 1 formula P = 0.    df  P = 0 ⇐⇒ ¬ true e2   ¬  Using the same idea, we can deﬁne    df  P = 1 ⇐⇒    P = 0 e2   1  1    P =0  ∧ e2 = 1 e2  true  P = 1.    P = 1 ∧ e2 = 1 e2  P = 0    On an interval of length m the measure P equals k iff it is equal to k1 on the leftmost subinterval  of length m − 1, is equal to k2 on the rightmost subinterval of length 1 and k = k1 + k2 .      df  P = k ⇐⇒    P = k1 e2  P = k2  k1 , k2 ∈ ⺞0  k1 + k2 = k  6. Conclusion  In this paper, we investigated properties of a multi-dimensional extension of Duration  Calculus. We showed that it is not axiomatisable and therefore not decidable. Nevertheless,  we give an axiomatisation relative to an n-dimensional interval temporal logic. Tool support  is crucial for applications of such a formalism in practice. For model-checking tools, decidable subsets play an important role. We presented two different subset for discrete spatial  and temporal domains, one obtained by restricting the models to ﬁnite space while preserving inﬁnite time and the other by restricting the class of formulae by excluding chop  alternation.  In the future, we would like to apply this formalism to several case studies to derive a set  of lightweight rules that make the handling of this formalism in practice easier. To give tool  support, this should be accompanied by extending and implementing the decision procedures  found so far.  Acknowledgments  The author thanks the anonymous referees for many helpful comments, and E.-R. Olderog and  the members of the “Correct System Design” group, especially J. Hoenicke, R. Meyer, and A.  Platzer, for fruitful discussions on this topic.  A. Proofs  Lemma 10. Let I be an interpretation and k ∈ ⺞, a, b ∈ ⺤ and Fgrid deﬁned by  A. Schäfer / Information and Computation 205 (2007) 25–64  df  Fgrid = e1  2 ∧ e2  2 ∧   ⇐⇒ (1 ⇐⇒ 2 ) ∧    e1 (( 1 e1  e1 = 1 ⇒ 1 e1  ¬1 ) ∧    ( ¬1 e1  e1 = 1 ⇒ ¬1 e1  1 ) ∧  53  (A.1a)  (A.1b)  (A.1c)  (A.1d)  e1  1 ⇒ ( 1 ∧ e1 = 1 e1  true) ∧    e2 (( 2 e2  e2 = 1 ⇒ 2 e2  ¬2 ) ∧    ( ¬2 e2  e2 = 1 ⇒ ¬2 e2  2 ) ∧  (A.1e)  (A.1f)  (A.1g)  e2  1 ⇒ ( 2 ∧ e2 = 1 e2  true)  (A.1h)  Then:  I , [0, k] × [a, b] |= Fgrid  if and only if k  2, b − a  2, and for all i ∈ ⺞, i  k and arbitrary a  b ∈ [a, b] the following  holds.        ) I , [i, i + 1] × [a , b ] |=  )        I , [a , b ] × [i, i + 1] |=    ) I , [i, i + 1] × [j, j + 1] |=  1  ¬1  if i is even  otherwise  2  ¬2  if i is even  otherwise    if i, j are both even or both odd  ¬ otherwise  Proof  “only if” To prove ), we proceed by induction on i.  Case i = 0. This case is clear by (A.1a).  Case ii + 1. Without loss of generality, assume i is even, the other case is similar.  { By (IH)}  I , [i − 1, i] × [a , b ] |=  ⇒ I , [i − 1, i + 1] × [a , b ] |=  {Fgrid A.1d} ⇒ I , [i − 1, i + 1] × [a , b ] |=  {1 ∧ ¬1 ≡ false} ⇒ I , [i, i + 1] × [a , b ] |=  ¬1  ¬1 e1  e1 = 1  ¬1 e1  1  1  Case ) is analogue to case ). For case ) assume without loss of generality i and j to  be even, the other cases are similar.  { By ) and )}  I , [i − 1, i] × [j, j + 1] |= 1 ∧ 2  {A.1b} ⇒ I , [i − 1, i] × [j, j + 1] |=   54  A. Schäfer / Information and Computation 205 (2007) 25–64  “if” The Condition (A.1a) follows from the assumption on the interval and Conditions (A.1b),  (A.1e) and (A.1h) are direct consequences of ), ), and ). To prove (A.1c) assume    I , [a1 , b1 ] × [a, b] |= 1 e1  e1 = 1.  ⇒ I , [a1 , b1 − 1] × [a, b] |= 1    ∃i ∈ ⺞ :  ⇒ I , [a1 , i + 1] × [a, b] |= 1  i  a1  b1 − 1  i + 1  {)} ⇒ I , [i + 1, i + 2] × [a, b] |= ¬1  {b1  i + 2} ⇒ I , [i + 1, b1 ] × [a, b] |= ¬1  ⇒ I , [a1 , b1 ] × [a, b] |= 1 e1  ¬1  The other cases are proven similarly.   Lemma 15. For an H-triple (IITLn , V , [b1 , f1 ] × [b2 , f2 ]), a state assertion , and an SC-Interpretation  o−1  n  o  as deﬁned in equation 1 there is a ﬁnite partition [m11 , m21 ] × [m12 , m22 ], . . . , [mn−1  1 , m1 ] × [m2 , m2 ] of  j  j+1  i+1  the two-dimensional interval [b1 , f1 ] × [b2 , f2 ] such that for every point (x, y) ∈ [mi1 , m1 ) × [m2 , m2 )  holds  j  j+1  n  IITLn , V , [mi1 , mi+1  1 ) × [m2 , m2 ) |=ITL v[] ∨ v[¬]  and      ISC [[]] (x, y) =    j  (A.2)  j+1  n  1 if I , V , [mi1 , mi+1  1 ) × [m2 , m2 ) |=ITL v[]  j  j+1  i+1  i  0 if I , V , [m1 , m1 ) × [m2 , m2 ) |=ITLn v[¬] .  (A.3)  Proof. We prove this lemma by induction on the structure of .  Case 1 . Observable X .  This case is clear from the deﬁnition of ISC and Lemma 14.  Case 2 . ¬.  By the induction hypothesis the lemma holds for  and we use the same partition. Let  j  j+1  (x, y) ∈ [m1 , m1 ) × [mi2 , mi+1  2 ). From the induction hypothesis we obtain  j  j+1  n  IITLn , V , [mi1 , mi+1  1 ) × [m2 , m2 ) |=ITL v[] ∨ v[¬] .  As  ≡ ¬¬, we obtain v[] = v[¬(¬)] and therefore  i+1  i  n  IITLn , V , [mi1 , mi+1  1 ) × [m2 , m2 ) |=ITL v[¬¬)] ∨ v[¬] .  (1)  i+1  i  n  If IITLn , V , [mi1 , mi+1  1 ) × [m2 , m2 ) |=ITL v[¬¬] then by the hypothesis ISC [[]](x, y) =  1 and by deﬁnition of negation we obtain ISC [[¬]](x, y) = 1 − ISC [[]](x, y) = 0 as  required.  A. Schäfer / Information and Computation 205 (2007) 25–64  (2)  55  i+1  i  n  If IITLn , V , [mi1 , mi+1  1 ) × [m2 , m2 ) |=ITL v[¬] then by the hypothesis ISC [[]](x, y) = 0  and we obtain ISC [[¬]](x, y) = 1 − ISC [[]](x, y) = 1 as required.  Case 3 . 1 ∨ 2 .      Applying the induction hypothesis on 1 and 2 , we obtain two partitions. Let [m11 , m21 ] ×                  [m12 , m22 ], . . . [mn1 −1 , mn1 ] × [mo2 −1 , mo2 ] be a common reﬁnement of both partitions. By  Lemma 13 (3) this is also a valid partition for 1 and 2 . On every interval one of the following  cases holds.  Case 3 .1 . At least one disjunct 1 or 2 is true throughout the interval, i.e. v[1 ] or v[2 ] .  Without loss of generality, we assume  j      j+1   IITLn , V , [mi1 , mi+1  1 ) × [m2 , m2  ) |=ITLn v[1 ] .  Applying the induction hypothesis yields for each      j  j+1   (x, y) ∈ [mi1 , mi+1  1 ) × [m2 , m2 )  ISC [[1 ]](V , (x, y)) = 1  and by the deﬁnition of the semantics of state assertions in SC we obtain ISC [[1 ∨      j  j+1   n  evaluation is derived as  2 ]](V , [mi1 , mi+1  1 ) × [m2 , m2 )) = 1. The ITL  follows:  { By Lemma 13(3)}      j  j+1       j  j+1       j  j+1       j  j+1       j  j+1   IITLn , V , [mi1 , mi+1  1 ) × [m2 , m2  { and by Lemma 13(2)}  ) |=ITLn v[1 ]  v[1 ∨2 ]  IITLn , V , [mi1 , mi+1  1 ) × [m2 , m2  { By the assumption holds }  ) |=ITLn v[1 ∨2 ]    n  IITLn , V , [mi1 , mi+1  1 ) × [m2 , m2 ) |=ITL v[1 ] = .  { Combining the equations we obtain}  IITLn , V , [mi1 , mi+1  1 ) × [m2 , m2  { By deﬁnition we conclude}  ) |=ITLn v[1 ∨2 ] =   IITLn , V , [mi1 , mi+1  1 ) × [m2 , m2  ) |=ITLn v[1 ∨2 ] .  Case 3 .2 . Both 1 and 2 are false throughout the interval, i.e.  j      j+1   IITLn , V , [mi1 , mi+1  1 ) × [m2 , m2  ) |=ITLn v[¬1 ] ∧ v[¬2 ]  Applying the induction hypothesis yields      j  j+1   ISC [[1 ]](V , [mi1 , mi+1  1 ) × [m2 , m2  )) = 0  56  A. Schäfer / Information and Computation 205 (2007) 25–64  and  j      j+1   ISC [[2 ]](V , [mi1 , mi+1  1 ) × [m2 , m2  )) = 0  and hence  j      j+1   ISC [[1 ∨ 2 ]](V , [mi1 , mi+1  1 ) × [m2 , m2  )) = 0.  The derivation of the ITLn evaluation proceeds as follows:  { By the assumptions}      j  j+1   n  IITLn , V , [mi1 , mi+1  1 ) × [m2 , m2 ) |=ITL v[1 ] =          j  j+1  i+1  IITLn , V , [mi1 , m1 ) × [m2 , m2 ) |=ITLn v[2 ]  0 and  =0  { and by Lemma 13 holds}      j  j+1   n  IITLn , V , [mi1 , mi+1  1 ) × [m2 , m2 ) |=ITL v[1 ∨2 ]           j  j+1  n  IITLn , V , [mi1 , mi+1  1 ) × [m2 , m2 ) |=ITL v[1 ∧2 ]  0 and  0  { By H4 }      j  j+1   i+1  i  IITLn , V , [m1 , m1 ) × [m2 , m2 )  |=ITLn v[1 ∨2 ] = 0  { and by Lemma 13 (13) holds}      j  j+1   IITLn , V , [mi1 , mi+1  1 ) × [m2 , m2  ) |=ITLn v[¬(1 ∨2 )]    Lemma 22. Let F be an n-dimensional SCfin Formula, [0, t] a temporal interval and D = [b1 , f1 ] ×  · · · × [bn−1 , fn−1 ] a spatial interval. Then the following holds:  () Let I be an interpretation satisfying F on the interval D × [0, t], then the word  F (D)∗ representing I with  df  = c0 . . . ct−1 ∈  df  ck (x) ={X ∈ Obs | I (X)(x, k) = 1}  for k ∈ {0, . . . , t − 1} is in LD (F).  () Let = c0 · · · ct−1 ∈ LD (F), then the corresponding interpretation I deﬁned by    df 1 if X ∈ ct (  x)  I (X)(x, t) =  0 otherwise  satisﬁes I , D × [0, t] |= F.  Proof. We proceed inductively on the structure of F .  Case  . () Let I be an interpretation such that I , D × [0, t] |=  . Then—by deﬁnition—  I [[]](x, t  ) = 1 and fk > bk holds for all x ∈ D− , t  ∈ [0, t) and k ∈ {1, . . . n}. By deﬁnition of  we obtain ck (x) for all x ∈ [b1 , f1 ) × · · · × [bn−1 , fn−1 ) and therefore  ∈ LD (  )  A. Schäfer / Information and Computation 205 (2007) 25–64  57  () Let = c0 . . . cn−1 ∈ LD (  ). The deﬁnition of LD (  ) and  immediately yields  I , D × [0, t] |=  as required.  Case F1 ∧ F2 . () Suppose that I , D × [0, t] |= F1 ∧ F2 . By deﬁnition of ∧ we obtain I , D × [0, t] |=  F1 and I , D × [0, t] |= F2 and by the induction hypothesis and deﬁnition 21 ∈  LD (F1 ) ∩ LD (F2 ) = LD (F1 ∧ F2 ).  () Let ∈ LD (F1 ∧ F2 ) = LD (F1 ) ∩ LD (F2 ), by the induction hypothesis we obtain  I , D × [0, t] |= F1 ∧ F2 .  Case ¬F1 . () Suppose that I , D × [0, t] |= ¬F1 . By deﬁnition I , D × [0, t]  |= F1 . By the induction  hypothesis for () ∈ LD (F1 ) and henceforth we obtain ∈ F (D)∗ \ LD (F1 ) =  LD (¬F1 ).  () Let ∈ LD (¬F1 ) = F (D)∗ \ LD (F1 ). By the induction hypothesis for () holds  I , D × [0, t]  |= F1 and henceforth I , D × [0, t] |= ¬F1 .  Case F1 et  F2 (temporalchop). () Assume I , D × [0, t] |= F1 et  F2 . By deﬁnition of chop, there  is an t  ∈ [0, t] such that I , D × [0, t  ] |= F1 and I , D × [t  , t] |=  F2 . The interpretation I  which is obtained by left-shifting I  by t  satisﬁes I  , D × [0, t − t  ] |= F2 . The induction hypothesis yields 1 ∈ LD (F1 ) and 2 ∈ LD (F2 ) and therefore 1 2 ∈  LD (F1 ) ◦ LD (F2 ).  () Let ∈ LD (F1 et  F2 ). By deﬁnition = 1 2 for 1 ∈ LD (F1 )  and 2 ∈ LD (F2 ). By the induction hypothesis the two corresponding interpretations I1 and I2 satisfy I1 , D × [0, t1 ] |= F1 and  I2 , D × [0, t2 ] |= F2 . By deﬁnition of I holds    I1 (X)(x, t)  if t ≤ t1  .  I (X)(x, t) =  I2 (X)(x, t − t1 ) otherwise  and so I , D × [0, t1 + t2 ] |= F1 et  F2  Case F1 ei  F2 (spatialchop). () Assume I , D × [0, t] |= F1 ei  F2 . By deﬁnition there is an r ∈  [bi , fi ] such that I , (D ≺i r) × [0, t] |= F1 and I , (D i r) × [0, t]  |= F2 . By the induction hypothesis the words 1 and 2 obtained  from I on the spatial intervals D ≺i r and D i r satisfy  1  ∈ LD≺i r (F1 ) and  2  ∈ LD  ir  (F2 ).  As is derived from I for space D and 1 is derived from the same  interpretation for a space (D ≺i r) ⊆ D, they describe the same  spatial conﬁgurations for (D ≺i r) ⊆ D, i.e., hD→D≺i r ( ) = 1 .  For 2 we obtain hD→D i r ( ) = 2 , respectively.  −1  Therefore ∈ h−1  D→D≺i r ( 1 ) ∩ hD→D i r ( 2 ) as required.  () Let ∈ LD (F1 ei  Fi ). There is an r ∈ [bi , fi ] such that  ∈ h−1  D→D≺i r (LD≺i r (F1 )) and  ∈ h−1  D→D  ir  (LD  ir  (F2 )).  Hence  1  = hD→D≺i r ( ) ∈ LD≺i r (F1 ) and  2 hD→D  ir  ( ) ∈ LD  ir  (F2 ).  58  A. Schäfer / Information and Computation 205 (2007) 25–64  Applying the induction hypothesis, yields that the two interpretations I1 and I2 obtained from 1 and 2 satisfy I1 ,  (D ≺i r) × [0, t] |= F1 and I2 , (D i r) × [0, t] |= F2 . The  function I obtained from coincides with I1 on (D ≺i r) ×  [bn , fn ] and with I2 on (D i r) × [0, t] and therefore I , D ×  [0, t] |= F1 ei  F2 .    Lemma 27. Let F be an SCnAlt formula of type (F) = n.  () Assume I k for k  n to be a k-dimensional interpretation and D a k-dimensional interval such  df  that I k , D |= F . Deﬁne I k→k+1 as a k + 1-dimensional interpretation by I k→k+1 (X)(x, y) = I k (x).  Then any interval [b, f] satisﬁes I k→k+1 , D × [b, f] |= F.  () Conversely, assume I k+1 , D × [b, b + 1] |= F for b ∈ ⺞, then for an interpretation I k+1→k (X)(x)  df  = I k+1 (x, b) we obtain I k+1→k , D |= F.  () Let I , I  be two n-dimensional interpretations, [0, f] a one-dimensional interval and D, D two  (n − 1)-dimensional intervals such that  I , D × [j, j + 1] |= F n−1 ∧ en = 1 iff I  , D × [j, j + 1] |= F n−1 ∧ en = 1  for all subformulae F n−1 of type (n − 1) occurring in F and all j ∈ [0, f). Then I , D × [0, f] |=  F iff I  , D × [0, f] |= F  Proof  () Proof by structural induction.  From the assumption we deduce I [[]](x) = 1 for all x ∈ D. By construction of I k→k+1 we obtain for all x ∈ D × [b, f] that I k→k+1 [[]](x )  = 1 and therefore I k→k+1 , D × [b, f] |=  as required.  Case F1 ∧ F2 , ¬F1 .  These cases are clear from the deﬁnition.  Case F1 ei  F2 , i  k. By deﬁnition of chop there is an r such that  Case   .  I k , D ≺i r |= F1 and I k , D  i  r |= F2 .  Applying the induction hypothesis, yields  I k→k+1 , (D ≺i r) × [b, f] |= F1 and I k→k+1 , (D  i  r) × [b, f] |= F2 .  Henceforth, I k→k+1 , D × [b, f] |= F1 ei  F2 .  () Similar to (), note that I is assumed to be constant on [n, n + 1) for all n ∈ ⺞.  () Proof by structural induction.  Case F n−1 ∧ en = 1. This case is obvious from the assumptions.  A. Schäfer / Information and Computation 205 (2007) 25–64  59  Case F1n ∧ F2n .  I , D × [0, f] |= F1n ∧ F2n  ⇐⇒ I , D × [0, f] |= F1n and I , D × [0, f] |= F2n  { By (IH)} ⇐⇒ I  , D × [0, f] |= F1n and I  , D × [0, f] |= F2n  ⇐⇒ I  , D × [0, f] |= F1n ∧ F2n  Case ¬F1n .  Follows directly from the deﬁnition and induction hypothesis.  Case F1n en  F2n .  “only if” Assuming I , D × [0, f] |= F1n en  F2n , there is an m ∈ [0, f] such that I , D ×    [0, m] |= F1n and I , D × [m, f] |= F2n . Let I ←m and I ←m be the functions obtained from I , respectively I  by left-shifting by m in the nth dimension. Then  I ←m , D × [0, f − m] |= F2n and for all j ∈ [0, f − m) and all subformulae F n−1  I ←m , D × [j, j + 1] |= F n−1 ∧ en = 1  iff    I ←m , D × [j, j + 1] |= F n−1 ∧ en = 1  Applying the induction hypothesis on this yields    I ←m , D × [0, f − m] |= F2n  and therefore I  , D × [0, f] |= F1n en  F2n  “if” similar.   Lemma 32. Let F be an n-dimensional SCnAlt formula.  () A subset ⊆ nnA (F) is consistent iff for every w = a0 . . . ak ∈ ∗ there is an n-dimensional interpretation I , an (n − 1)-dimensional interval D such that I , D × [j, j + 1) |= G ⇐⇒ G ∈ aj  holds for every j ∈ [0, k] and every G ∈ Subn−1 (F).  () I , D × [0, f] |= F implies wI ∈ LnnA (F).  () w ∈ LnnA (F) implies [w] =  / ∅ and ∀ (I , D) ∈ [w] : I , D × [0, |w|] |= F  Proof. We simultaneously prove ()-() by induction on the structure of F .  Case  (F) = 1  “only if ”  “if”  ()  As all ⊂ 1nA are consistent, let be be an arbitrary subset and  w = a0 . . . ak ∈ ∗ . The interpretation I given by    1 if X ∈ ai  I [[X ]](i) =  0 otherwise  has the required property.  As every subset of 1nA is consistent there is nothing to show.  60  A. Schäfer / Information and Computation 205 (2007) 25–64  (, ) These cases are clear from the classical construction for duration calculus.  Case F n ∧ en+1 = 1  ()  The proof of () is essentially the same for all the other cases.  “only if”  n  Let n+1 ⊆ n+1  nA (F ∧ en+1 = 1) be a consistent alphabet and w = a0 . . . ak ∈  n+1  ∗  (  ) . By deﬁnition 30 there is a consistent alphabet n and for each letter  ai , 0  i  k there is a word ui = ui (0)...ui (l) ∈ L(ai ) ∩ ( n )∗ such that all  words have the same length, i.e., |ui | = l. The concatenation of all u0 . . . uk  is still a word in ( n )∗ and therefore the induction hypothesis is applicable yielding an n-dimensional interpretation I  and an (n − 1)-dimensional  interval D such that for all subformulae G occurring in u1 . . . uk the condition I  , D × [i · l + j, i · l + j + 1] |= G  ⇐⇒ G  ∈ ui (j) holds. The interpretation I  obtained from “folding” I  deﬁned by I  (X)(x, i, j) = I  (X)(x, i ·  l + j) still satisﬁes  I  , D × [i, i + 1] × [j, j + 1] |= G  ⇐⇒ G  ∈ ui (j).  (A.4)  We show that this interpretation I  satisﬁes for all subformulae G of type n  I  , D × [i, i + 1] × [0, i] |= G ⇐⇒ G ∈ ai .  (A.5)  Applying the induction hypothesis for () on each ui ∈ L(ai ), we obtain interpretations and intervals (Ii , Di ) satisfying for all subformulae G  of type  n−1  Ii , Di × [j, j + 1] |= G  ⇐⇒ G  ∈ ui (j).  “if”  and additionally all formulae given in ai . Using Lemma 27 (), we then obtain that I  satisﬁes all formulae given in ai , thus Eq. (A.5) and hence I  is  the required interpretation.  Let n+1 be an alphabet, w = a0 . . . ak ∈ ( n+1 )∗ be a word, I be the interpretation and D the n-dimensional interval satisfying for all subformula  G that I , D × [j, j + 1) |= G ⇐⇒ G ∈ aj . Then for every j the restrictions  given by Ijn+1→n (X)(x) = I (x, j) satisfy Ijn+1→n , D |= G ⇐⇒ G ∈ aj due to  n+1→n  have the same length by construcLemma 27 (). Then all words wIj  tion and are in L(aj ) by the induction hypothesis (). Deﬁning  to be the  n+1→n (X)  j and applying the induction hycommon alphabet of all words wI  pothesis for part () yields consistency of  from which we can conclude  the consistency of .  A. Schäfer / Information and Computation 205 (2007) 25–64  ()  ()  61  Let I , D × [0, f] |= F n ∧ en +1 = 1. From en+1 = 1 we obtain f = 1. Therefore wI = aI0  and F n ∈ aI0 and wI ∈ L (F n ∧ en+1 = 1) due to deﬁnition 31. The consistency of =  {aI0 } is a consequence of ().  n  n  n+1 (F n ∧  Let w ∈ Ln+1  nA (F ∧ en+1 =1). By deﬁnition w = a and F ∈ a holds. As L  en+1 = 1) is non-empty, {a} is consistent and () yields an interpretation I n and  interval D such that I n , D |= F n . Therefore [w] =  / ∅. Any interpretation I n satisfyn  n  ing I , D |= F can be extended by Lemma 27 () to I n→n+1 such that I n→n+1 , D ×  [0, 1] |= F n ∧ en = 1.  Case F1n+1 ∧ F2n+1 . ()  ()  Case ¬F1n+1 . ()  ()  Let I , D × [0, f] |= F1n+1 ∧ F2n+1 . By deﬁnition of conjunction and  n+1  the induction hypothesis, we obtain wI ∈ Ln+1  ) and wI ∈  nA (F1  n+1 n+1  n+1 n+1  I  LnA (F2 ) and consistency. Therefore holds w ∈ LnA (F1 ∧ F1n+1 )  as required.  n+1  n+1  Let w ∈ Ln+1  ∧ F2n+1 ). By construction w ∈ Ln+1  ) and w ∈  nA (F1  nA (F1  n+1 n+1  LnA (F2 ). Applying the induction hypothesis yields [w] =  / ∅ and for  every interpretation I and interval D corresponding to w the relation  I , D × [0, |w|] |= F1n+1 ∧ F2n+1 holds as required.  Let I , D × [0, f] |= ¬F1n+1 , so I , D × [0, f]  |= F1n+1 . Applying the inducn+1  tion hypothesis for (), we obtain wI  ∈ Ln+1  ) and therefore wI ∈  nA (F1  n+1  L (¬F1 ). By deﬁnition 31 the righthand side of () is satisﬁed yielding  n+1  ).  consistency. Hence, wI ∈ Ln+1  nA (¬F1  n+1  n+1  / ∅. Assume [w] = ∅.  Let w ∈ LnA (¬F1 ). At ﬁrst we show [w] =  Then for all (I , D) with wI = wI , D × [0, |w|]  |= ¬F1 and therefore  I , D × [0, |w|] |= F1 . But then, applying the induction hypothesis yields  n+1  n+1  w ∈ Ln+1  ). Therefore [w] =  / ∅. The  nA (F) contradicting w ∈ LnA (¬F1  second proposition is a direct consequence of the induction hypothesis for ().  Case F1n+1 en+1  F2n+1 . ()Let I , D × [0, f] |= F1n+1 en+1  F2n+1 . By deﬁnition there is an m ∈ [0, f]  such that I , D × [0, m] |= F1n+1 and I , D × [m, f] |= F2n+1 . The interpretation I  deﬁned by left-shifting I by m along dimension (n + 1) satisﬁes I  , D × [0, f − m] |= F2n+1 . Applying the induction hypothesis twice    yields two words w1I ∈ L(F1n+1 ) and w2I ∈ L(F2n+1 ) corresponding to I on  D × [0, m] and I  on D × [0, f − m], respectively. By construction wI =    w1I w2I holds and henceforth wI ∈ L (F1n+1 en+1  F2n+1 ). Consistency is a  consequence of ().  n+1  () Let w = a0 . . . a|w|−1 ∈ Ln+1  en+1  F2n+1 ). By deﬁnition w = w1 w2  nA (F1  n+1 n+1  n+1  such that w1 ∈ LnA (F1 ) and w2 ∈ Ln+1  nA (F2 ). The induction hypothesis yields two pairs (I1 , D1 ) and (I2 , D2 ) such that  I1 , D1 × [0, |w1 |] |= F1n+1 and  (A.6)  62  A. Schäfer / Information and Computation 205 (2007) 25–64  I2 , D1 × [0, |w2 |] |= F2n+1  (A.7)  From consistency of the alphabet and () we obtain an interpretation I   and n-dimensional interval D such that for all j ∈ [0, |w| − 1] and for all  subformulae F n of type n holds I  , D × [j, j + 1] |= F n ⇐⇒ F n ∈ aj . By  Deﬁnition 31  I1 , D1 × [j, j + 1] |= F n ⇐⇒ F n ∈ aj for j ∈ [0, |w1 |) and  I2 , D2 × [j − |w1 |, j − |w1 | + 1] |=  F n ⇐⇒ F n ∈ aj for j ∈ [|w1 |, |w1 | + |w2 |).  (A.8)  (A.9)  Applying Lemma 27 () on equations (A.6), (A.7),(A.8) and (A.10), we  conclude I  , D × [0, |w1 |] |= F1n+1 and I  , D × [|w1 |, |w1 | + |w2 |] |= F2n+1 .  Therefore I  , D × [0, |w|] |= F1n+1 en+1  F2n+1 . The second part follows  from Lemma 27 ().    References  [1] M. Aiello, H. van Benthem, A Modal Walk Through Space, Tech. rep., Institute for Logic, Language and Computation, University of Amsterdam, 2001.  [2] R. Alur, D.L. Dill, A theory of timed automata, Theor. Comput. Sci. 126 (2) (1994) 183–235.  [3] R. Alur, T.A. Henzinger, A really temporal logic, J. ACM 41 (1) (1994) 181–204.  [4] G. Behrmann, A. David, K.G. Larsen, A tutorial on uppaal, in: M. Bernardo, F. Corradini (Eds. ), Formal Methods  for the Design of Real-Time Systems: 4th International School on Formal Methods for the Design of Computer,  Communication, and Software Systems, SFM-RT 2004, Lecture Notes in Computer Science, vol. 3185, Springer-Verlag, Berlin, 2004, pp. 200–236.  [5] J. Bengtsson, W. Yi, Timed automata: semantics, algorithms and tools, in: J. Desel, W. Reisig, G. Rozenberg (Eds. ),  Lectures on Concurrency and Petri Nets, Lecture Notes in Computer Science, vol. 3098, Springer, Berlin, 2003, pp.  87–124.  [6] B. Bennett, A. Cohn, F. Wolter, M. Zakharyaschev, Multi-dimensional multi-modal logics as a framework for  spatio-temporal reasoning, Appl. Intell. 17 (3) (2002) 239–251.  [7] P. Blackburn, J. Seligman, Hybrid languages, J. Logic Lang. Inform. 4 (1995) 251–272.  [8] M. Bozga, C. Daws, O. Maler, A. Olivero, S. Tripakis, S. Yovine, Kronos: a model-checking tool for real-time  systems, in: in: A.J. Hu, M.Y. Vardi (Eds. ), Proceedings of the 10th International Conference on Computer Aided  Veriﬁcation, Vancouver, Canada, vol. 1427, Springer-Verlag, Berlin, 1998, pp. 546–550.  [9] L. Caires, L. Cardelli, A spatial logic for concurrency, Inform. Comput. 186 (2) (2003) 194–235.  [10] L. Cardelli, A.D. Gordon, Mobile ambients, Theor. Comput. Sci. 240 (1) (2000) 177–213.  [11] L. Cardelli, A.D. Gordon, Anytime, anywhere: modal logics for mobile ambients, in: POPL 2000, ACM Press, 2000,  pp. 365–377.  [12] Zhou Chaochen, C. Hoare, A. Ravn, A calculus of durations, IPL 40 (5) (1991) 269–276.  [13] Z. Chaochen, A. Ravn, M. Hansen, An extended duration calculus for hybrid real-time systems, in: R.L. Grossman,  A. Nerode, A.P. Ravn, H. Rischel (Eds. ), Hybrid Systems, Lecture Notes in Computer Science, vol. 736, Springer,  Berlin, 1993, pp. 36–59.  [14] W. Charatonik, J.-M. Talbot, The decidability of model checking mobile ambients, in: L. Fribourg (Ed. ), CSL,  Lecture Notes in Computer Science, vol. 2142, Springer, Berlin, 2001, pp. 339–354.  A. Schäfer / Information and Computation 205 (2007) 25–64  63  [15] W. Charatonik, S. Dal-Zilio, A.D. Gordon, S. Mukhopadhyay, J.-M. Talbot, The complexity of model checking mobile ambients, in: F. Honsell, M. Miculan (Eds. ), FoSSaCS, Lecture Notes in Computer Science, vol. 2030, Springer,  Berlin, 2001, pp. 152–167.  [16] W. Charatonik, S. Dal-Zilio, A.D. Gordon, S. Mukhopadhyay, J.-M. Talbot, Model checking mobile ambients,  Theor. Comput. Sci. 308 (1–3) (2003) 277–331.  [17] W. Craig, On axiomatizability within a system, J. Symb. Log. 18 (1) (1953) 30–32.  [18] H. Dierks, Speciﬁcation and Veriﬁcation of Polling Real-Time Systems, Ph.D. thesis, University of Oldenburg (Jul.  1999).  [19] H. Dierks, PLC-automata: a new class of implementable real-time automata, Theor. Comput. Sci. 253 (1) (2000)  61–93.  [20] B. Dutertre, Complete proof systems for ﬁrst order interval temporal logic, in: LICS, IEEE Computer Society, 1995,  pp. 36–43.  [21] M. Franceschet, A. Montanari, M. de Rijke, Model checking for combined logics with an application to mobile  systems, Autom. Softw. Eng. 11 (3) (2004) 289–321.  [22] M. Fränzle, Model-checking dense-time duration calculus, Formal Asp. Comput. 16 (2) (2004) 121–139.  [23] D.M. Gabbay, Fibring Logics, Oxford University Press, Oxford, 1999.  [24] D. Gabbay, A. Kurucz, F. Wolter, M. Zakharyaschev, Many-Dimensional Modal Logics: Theory and Applications,  Elsevier, Amsterdam, 2003.  [25] A. Galton, Towards a qualitative theory of movement, in: Spatial Information Theory, 1995, pp. 377–396.  [26] D. Giammarresi, A. Restivo, Handbook of formal languages—beyond words, in: Two-Dimensional Languages,  vol. 3, Springer, Berlin, 1997, pp. 215–267.  [27] M.R. Hansen, Zhou Chaochen, Duration calculus: logical foundations, Formal Asp. Comput. 9 (1997) 283–330.  [28] M. R. Hansen, Zhou Chaochen, Duration Calculus: A Formal Approach to Real-Time Systems, EATCS: Monographs in Theoretical Computer Science, Springer, Berlin, 2004.  [29] K. Havelund, A. Skou, K. G. Larsen, K. Lund, Formal modeling and analysis of an audio/video protocol: an  industrial case study using uppaa., in: IEEE Real-Time Systems Symposium, IEEE Computer Society, 1997, pp.  2–13.  [30] T.A. Henzinger, X. Nicollin, J. Sifakis, S. Yovine, Symbolic model checking for real-time systems, in: LICS, IEEE  Computer Society, 1992, pp. 394–406.  [31] N. Klarlund, A. Møller, MONA Version 1.4 User Manual, Tech. rep., Department of Computer Science, University  of Aarhus (January 2001).  [32] B. Krieg-Brückner, J. Peleska, E.-R. Olderog, A. Baer, The UniForM Workbench, a universal development environment for formal methods, in: J. Wing, J. Woodcock, J. Davies (Eds. ), FM’99—Formal Methods, Lecture Notes  in Computer Science, vol. 1709, Springer, Berlin, 1999, pp. 1186–1205.  [33] M. Lindahl, P. Pettersson, W. Yi, Formal design and analysis of a gear controller, in: B. Steffen (Ed. ), TACAS,  Lecture Notes in Computer Science, vol. 1384, Springer, Berlin, 1998, pp. 281–297.  [34] S. Merz, M. Wirsing, J. Zappe, A spatio-temporal logic for the speciﬁcation and reﬁnement of mobile systems, in:  M. Pezzè (Ed. ), FASE 2003, Warsaw, Poland, Lecture Notes in Computer Science, vol. 2621, Springer, Berlin, 2003,  pp. 87–1014.  [35] R. Milner, Communicating and mobile systems: the -calculus, Cambridge University Press, Cambridge, 1999.  [36] P. Pandya, Specifying and deciding quantiﬁed discrete-time duration calculus formulae using dcvalid, Tech. rep.,  Tata Institute of Fundamental Research (2000).  [37] P. K. Pandya, D. V. Hung, Duration calculus of weakly monotonic time, in: A.P. Ravn, H. Rischel  (Eds. ), FTRTFT’98, Lyngby, Denmark, vol. 1998, Lecture Notes in Computer Science, Springer, Berlin, 1998,  pp. 55–64.  [38] J.-D. Quesel, MoDiShCa: Model-Checking discrete Shape Calculus, Minor Thesis, University of Oldenburg (August  2005).  [39] D.A. Randell, Z. Cui, A. Cohn, A spatial logic based on regions and connection, in: B. Nebel, C. Rich, W. Swartout  (Eds. ), KR’92, Morgan Kaufmann, San Mateo, California, 1992, pp. 165–176.  [40] J.H. Reif, A.P. Sistla, A multiprocess network logic with temporal and spatial modalities, J. Comput. Syst. Sci. 30  (1) (1985) 41–53.  64  A. Schäfer / Information and Computation 205 (2007) 25–64  [41] W. Rudin, Principles of Mathematical Analysis, McGraw-Hill, New York, 1964.  [42] A. Schäfer, A calculus for shapes in time and space, in: Z. Liu, K. Araki (Eds. ), Theoretical Aspects of Computing,  ICTAC 2004, Lecture Notes in Computer Science, vol. 3407, Springer, 2005, pp. 463–478.  [43] A. Schäfer, Axiomatisation and decidability of multi-dimensional duration calculus, in: J. Chomicki, D. Toman  (Eds. ), Proceedings of the 12th International Symposium on Temporal Representation and Reasoning, TIME 2005,  IEEE Computer Society, 2005, pp. 122–130.  [44] H. Vieira, L. Caires, The spatial logic model checker user’s manual, Tech. rep., Departamento de Informatica,  FCT/UNL, tR-DI/FCT/UNL-03/2004 (2005). 