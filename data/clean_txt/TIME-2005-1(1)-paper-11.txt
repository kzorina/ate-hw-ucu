L OLA: Runtime Monitoring of Synchronous  Systems  Ben DÃ¢Â€Â™Angelo Ã¢ÂˆÂ—  Sriram Sankaranarayanan  Bernd Finkbeiner Ã¢Â€  Henny B. Sipma Ã¢ÂˆÂ—  Ã¢ÂˆÂ—  CeÄšÂsar SaÄšÂnchez Ã¢ÂˆÂ—  Sandeep Mehrotra Ã¢Â€Ä„  Will Robinson  Zohar Manna  Ã¢ÂˆÂ—  Ã¢ÂˆÂ—  Ã¢ÂˆÂ—  Computer Science Department, Stanford University, Stanford, CA 94305  {bdangelo,srirams,cesar,sipma,manna}@theory.stanford.edu  Ã¢Â€  Department of Computer Science, Saarland University  finkbeiner@cs.uni-sb.de  AbstractÃ¢Â€Â” We present a specification language and algorithms for the online and offline monitoring of synchronous  systems including circuits and embedded systems. Such  monitoring is useful not only for testing, but also under  actual deployment. The specification language is simple  and expressive; it can describe both correctness/failure  assertions along with interesting statistical measures that  are useful for system profiling and coverage analysis.  The algorithm for online monitoring of queries in this  language follows a partial evaluation strategy: it incrementally constructs output streams from input streams,  while maintaining a store of partially evaluated expressions  for forward references. We identify a class of specifications, characterized syntactically, for which the algorithmÃ¢Â€Â™s  memory requirement is independent of the length of the  input streams. Being able to bound memory requirements  is especially important in online monitoring of large input  streams. We extend the concepts used in the online algorithm to construct an efficient offline monitoring algorithm  for large traces.  We have implemented our algorithm and applied it to  two industrial systems, the PCI bus protocol and a memory  controller. The results demonstrate that our algorithms are  practical and that our specification language is sufficiently  expressive to handle specifications of interest to industry.  I. I NTRODUCTION  Monitoring synchronous programs for safety and liveness properties is an important aspect of ensuring their  proper runtime behavior. An offline monitor analyzes  traces of a system post-simulation to spot violations of  This research was supported in part by NSF grants CCR-0121403, CCR-02-20134, CCR-02-09237, CNS-0411363, and CCF0430102, by ARO grant DAAD19-01-1-0723, by NAVY/ONR contract N00014-03-1-0939, by the Siebel Graduate Fellowship, and by  the BMBF grant 01 IS C38 B as part of the Verisoft project.  Ã¢Â€Ä„  Synopsys, Inc.  the specification. Offline monitoring is critical for testing  large systems before deployment. An online monitor  processes the system trace while it is being generated.  Online monitoring is used to detect violations of the  specification when the system is in operation so that  they can be handled before they translate into observable  and cascading failures, and to adaptively optimize system  performance.  Runtime monitoring has received growing attention in  recent years [1], [2], [3]. While static verification intends  to show that every (infinite) run of a system satisfies  the specification, runtime monitoring is concerned only  with a single (finite) trace. Runtime monitoring can be  viewed as an extension of testing with more powerful  specification languages.  The offline monitoring problem is known to be easy  for purely past or purely future properties. It is well  known that for past properties, the online monitoring  problem can be solved efficiently using constant space  and linear time in the trace size. For future properties, on  the other hand, the space requirement generally depends  on the length of the trace, which suggests that online  monitoring may quickly become intractable in practical  applications with traces exceeding 106 simulation steps.  In this paper, we present a specification language,  intended for industrial use. The language can express  properties involving both the past and the future. It is a  functional stream computation language like L USTRE [4]  and E STEREL [5], with features that are relevant to our  problem at hand. It is parsimonious in its number of  operators (expressions are constructed from three basic  operators), but the resulting expressiveness surpasses  temporal logics and many other existing formalisms  including finite-state automata.  We provide a syntactic characterization of efficiently  monitorable specifications, for which the space requirement of the online monitoring algorithm is independent  of the size of the trace, and linear in the specification  size. An analysis of some industrial specifications provided by Synopsys, Inc. showed that a large majority  of these specifications lie in this efficiently monitorable  class. For the offline monitoring problem, we demonstrate an efficient monitoring strategy in the presence of  mixed past/future properties.  We have implemented our algorithm and specification  language in a system called L OLA. L OLA accepts a  specification in the form of a set of stream expressions,  and is then run on a set of input streams. Two types  of specifications are supported: properties that specify  correct behavior, and properties that specify statistical  measures that allow profiling the system that produces  the input streams. An execution of L OLA computes  arithmetic and logical expressions over the finite input  and intermediate streams to produce an output consisting  of error reports and the desired statistical information.  A. Related Work  Much of the initial work on runtime monitoring (cf.  [6], [7], [8]) was based on temporal logic [9]. In [10],  non-deterministic automata are built from LTL to check  violations of formulas over finite traces and the complexity of these problems is studied. LTL based specifications  have already been pursued in tools such as the Temporal  Rover [7] and Java PathExplorer [11]. One limitation of  this approach is that the logic must be adapted to handle  truncated traces. The approach taken in [12] considers  extensions of LTL for the case of truncated paths with  different interpretations (weak and strong) of the next  operator at the end of the trace. The choice of handling  success/failure on a finite trace frequently depends on  the situation being modeled.  Another important difference between runtime verification and static verification is that liveness properties  can never be violated on a finite trace. An appealing  solution is to extend the specification language to compute quantitative measures based on the trace. Temporal  properties can be specified in L OLA, but one of the  main goals is to go beyond property checking to the  collection of numerical statistics. For example, instead  of checking the property Ã¢Â€Âœthere are only finitely many  retransmissions of each package,Ã¢Â€Â which is vacuously  true over finite traces, we desire to evaluate queries like  Ã¢Â€Âœwhat is the average number of retransmissions.Ã¢Â€Â Our  first approach to combine the property proving with data  collection appeared in [13]. Following this trend, runtime verifiers can be used not only for bug-finding, but  also for profiling, coverage, vacuity and numerous other  analyses.  L OLA models runtime verification as a stream computation. The definition of L OLA output streams in  terms of other streams resembles synchronous programming languages (notably L USTRE [4], E STEREL [5],  Signal [14]), but there is a significant difference: these  languages are designed primarily for the construction of  synchronous systems. Therefore, output values for a time  instant are computed directly from values at the same and  previous instants. This assumption makes perfect sense  if we desire that the systems we specify be executable,  and therefore be causal. However, runtime specifications  are descriptive in nature. They include future formulas  whose evaluation may have to be delayed until future  values arrive. This requires stronger expressiveness in the  language and the corresponding evaluation strategies.  Other efforts in run-time verification include [15],  which studies the efficient generation of monitors from  specifications written as extended regular expressions,  and [16], which studies rewriting techniques for the  efficient evaluation of LTL formulas on finite execution  traces, both online and offline. In [8], an efficient method  for the online evaluation of past LTL properties is  presented. This method exploits that past LTL can be  recursively defined using only values in the previous  state of the computation. Our efficiently monitorable  specifications generalize this idea, and apply it uniformly  to both verification and data collection.  The system that most closely resembles L OLA is  Eagle [17]. Eagle allows the description of monitors  based on greatest and least fixed points of recursive  definitions. Many logical formalisms used to describe  properties, including past and future LTL formulas, can  be translated to Eagle specifications. These are then  compiled into a set of rules that implements the monitor.  L OLA differs from Eagle in the descriptive nature of the  language, and in that L OLA is not restricted to checking  logical formulas, but can also express numerical queries.  II. L OLA OVERVIEW  In this section we describe the specification language.  The monitoring algorithms will be presented in Section III.  A. Specification Language: Syntax  A L OLA specification describes the computation of  output streams from a given set of input streams. A  stream ÄÂƒ of type T is a finite sequence of values from  T . We let ÄÂƒ(i), i Ã¢Â‰Ä½ 0 denote the value of the stream at  time step i.  Definition 1 (L OLA specification) A L OLA specification is a set of equations over typed stream variables,  of the form  s1 = e1 (t1 , . . . , tm , s1 , . . . , sn )  ..  ..  .  .  sn = en (t1 , . . . , tm , s1 , . . . , sn ),  where s1 , . . . , sn are called the dependent variables  and t1 , . . . , tm are called the independent variables,  and e1 , . . . , en are stream expressions over s1 , . . . , sn  and t1 , . . . , tm . Independent variables refer to input  streams and dependent variables refer to output streams Ã¢ÂˆÂ— .  A L OLA specification can also declare certain output  boolean variables as triggers. Triggers generate notifications at instants when their corresponding values become  true . Triggers are specified in L OLA as  trigger ÄÂ•  where ÄÂ• is a boolan expression over streams.  A stream expression is constructed as follows:  Ã¢Â€Ë˜ If c is a constant of type T , then c is an atomic  stream expression of type T ;  Ã¢Â€Ë˜ If s is a stream variable of type T , then s is an  atomic stream expression of type T ;  Ã¢Â€Ë˜ Let f : T1 Ä‚Â—T2 Ä‚Â—Ã‚Ë‡ Ã‚Ë‡ Ã‚Ë‡Ä‚Â—Tk 7Ã¢Â†Â’ T be a k -ary operator.  If for 1 Ã¢Â‰Â¤ i Ã¢Â‰Â¤ k , ei is an expression of type Ti , then  f (e1 , . . . , ek ) is a stream expression of type T ;  Ã¢Â€Ë˜ If b is a boolean stream expression and e1 , e2 are  stream expressions of type T , then ite(b, e1 , e2 )  is a stream expression of type T ; note that ite  abbreviates if-then-else.  Ã¢Â€Ë˜ If e is a stream expression of type T , c is a constant  of type T , and i is an integer, then e[i, c] is a stream  expression of type T . Informally, e[i, c] refers to the  value of the expression e offset i positions from the  current position. The constant c indicates the default  value to be provided, in case an offset of i takes us  past the end or before the beginning of the stream.  Ã¢ÂˆÂ—  In our implementation we partition the dependent variables into  output variables and intermediate variables to distinguish streams that  are of interest to the user and those that are used only to facilitate  the computation of other streams. However, for the description of  the semantics and the algorithm this distinction is not important, and  hence we will ignore it in this paper.  Example 1 Let t1 , t2 be stream variables of type  boolean and t3 be a stream variable of type integer. The  following is an example of a L OLA specification with  t1 , t2 and t3 as independent variables:  s1  s2  s3  s4  s5  s6  s7  s8  s9  s10  =  =  =  =  =  =  =  =  =  =  true  t3  t1 Ã¢ÂˆÂ¨ (t3 Ã¢Â‰Â¤ 1)  ((t3 )2 + 7) mod 15  ite(s3 , s4 , s4 + 1)  ite(t1 , t3 Ã¢Â‰Â¤ s4 , Ã‚Å¹s3 )  t1 [+1, false]  t1 [Ã¢ÂˆÂ’1, true]  s9 [Ã¢ÂˆÂ’1, 0] + (t3 mod 2)  t2 Ã¢ÂˆÂ¨ (t1 Ã¢ÂˆÂ§ s10 [1, true])  Stream variable s1 denotes a stream whose value is  true at all positions, while s2 denotes a stream whose  values are the same at all positions as those in t3 . The  values of the streams corresponding to s3 , . . . , s6 are  obtained by evaluating their defining expressions placewise at each position. The stream corresponding to s7  is obtained by taking at each position i the value of  the stream corresponding to t1 at position i + 1, except  at the last position, which assumes the default value  false. Similarly for the stream for s8 , whose values are  equal to the values of the stream for t1 shifted by one  position, except that the value at the first position is the  default value true. The stream specified by s9 counts  the number of odd entries in the stream assigned to t3 by  accumulating (t3 mod 2). Finally, s10 denotes the stream  that gives at each position the value of the temporal  formula t1 Until t2 with the stipulation that unresolved  eventualities be regarded as satisfied at the end of the  trace.  B. Specification Language: Semantics  The semantics of L OLA specifications is defined in  terms of evaluation models, which describe the relation  between input streams and output streams.  Definition 2 (Evaluation Models) Let ÄÂ• be a L OLA  specification over independent variables t1 , . . . , tm with  types T1 , . . . , Tm , and dependent variables s1 , . . . , sn  with types Tm+1 , . . . , Tm+n . Let ÄÂ„1 , . . . , ÄÂ„m be streams  of length N +1, with ÄÂ„i of type Ti . The tuple hÄÂƒ1 , . . . , ÄÂƒn i  of streams of length N + 1 with appropriate types is  called an evaluation model, if for each equation in ÄÂ•  si = ei (t1 , . . . , tm , s1 , . . . , sn ),  hÄÂƒ1 , . . . , ÄÂƒn i satisfies the following associated equations:  ÄÂƒi (j) = val (ei )(j)  for 0 Ã¢Â‰Â¤ j Ã¢Â‰Â¤ N  where val (e)(j) is defined as follows. For the base cases:  val (c)(j) = c .  val (ti )(j) = ÄÂ„i (j) .  val (si )(j) = ÄÂƒi (j) .  For the inductive cases:  val (f (e1 , . . . , ek )(j) =  f (val (e1 )(j), . . . , val (ek )(j)) .  val (ite(b, e1 , e2 ))(j) =  if val (b)(j) then val (e1 )(j) else val (e2 )(j) .  val (e[k,  ( c])(j) =  val (e)(j + k) if 0 Ã¢Â‰Â¤ j + k Ã¢Â‰Â¤ N,  c  otherwise .  The set of all equations associated with ÄÂ• is denoted by  ÄÂ•ÄÂƒ .  Example 2 Consider the L OLA specification  is not well-defined, but for this specification the reason  is that it has no evaluation models.  To avoid ill-defined specifications we define a syntactic restriction on L OLA specifications guaranteeing that  any well-formed L OLA expression is also well-defined.  Definition 3 (Dependency Graph) Let ÄÂ• be a L OLA  specification. A dependency graph for ÄÂ• is a weighted  and directed multi-graph G = hV, Ei, with vertex set  V = {s1 , . . . , sn , t1 , . . . , tm }. An edge e : hsi , sk , wi  labeled with a weight w is in E iff the equation for  ÄÂƒi (j) in ÄÂ•ÄÂƒ contains ÄÂƒk (j + w) as a subexpression of  the RHS, for some j (or e : hsi , tk , wi for subexpression  ÄÂ„k (j +w)). Intuitively, the edge records the fact that si at  a particular position depends on the value of sk , offset  by w positions. Note that there can be multiple edges  between si and sk with different weights on each edge.  Vertices labeled by ti do not have outgoing edges.  ÄÂ• : s = t1 [1, 0] + ite(t2 [Ã¢ÂˆÂ’1, true], t3 , t4 + t5 ).  The associated equations ÄÂ•ÄÂƒ are  ÄÅÅ›  ÄÅÅ¤  ÄÅÄ…  ÄÂ„  (j  Ã¢ÂˆÂ’  1),  ÄÅÂ´  2  ÄÅÂ´  ÄÅÂ´  ÄÅË‡  ÄÅÅ¹  ÄÅÂ´  ÄÅÂ´  ÄÂ„1 (j + 1) + ite ÄÅÂ­ ÄÂ„3 (j),  ÄÅÂ¸ j Ã¢ÂˆÂˆ [1, N ),  ÄÅÂ´  ÄÅÂ´  ÄÅÂ´  ÄÅÂ´  ÄÅÂ´  ÄÂ„4 (j) + ÄÂ„5 (j)  ÄÅË›  ÄÅÅ¤  ÄÅÅ›  ÄÂƒ(j) =  ÄÂ„2 (N Ã¢ÂˆÂ’ 1),  ÄÅÂ´  ÄÅÅ¹  ÄÅË‡  ÄÅÂ´  ÄÅÂ´  ite ÄÅÂ­ ÄÂ„3 (N ),  j = N,  ÄÅÂ¸  ÄÅÂ´  ÄÅÂ´  ÄÅÂ´  ÄÅÂ´  ÄÅÂ´  ÄÂ„  (N  )  +  ÄÂ„  (N  )  ÄÅÂ´  4  5  ÄÅÂ´  ÄÅÅ‚  ÄÂ„1 (1) + ÄÂ„3 (0)  j = 0.  A L OLA specification is well-defined if for any set of  appropriately typed input streams, all of the same length,  it has exactly one evaluation model.  Example 3 Consider the L OLA specification  ÄÂ•1 : s1 = (t1 Ã¢Â‰Â¤ 10).  For the stream ÄÂ„1 : 0, . . . , 100, the associated equations  are ÄÂƒ1 (j) = (ÄÂ„1 (j) Ã¢Â‰Â¤ 10). The only evaluation model  of ÄÂ•1 is the stream ÄÂƒ1 (i) = true iff i Ã¢Â‰Â¤ 10. In fact,  this L OLA specification is well-defined, since it defines  a unique output for each possible input. However, the  specification  ÄÂ•2 : s2 = s2 Ã¢ÂˆÂ§ (t1 Ã¢Â‰Â¤ 10)  is not well-defined, because there are many streams ÄÂƒ2  that satisfy ÄÂ•2,ÄÂƒ for some input stream. Similarly, the  specification  ÄÂ•3 : s3 = Ã‚Å¹s3  Example 4 Consider the L OLA specification over independent integer variables t1 , t2 :  ÄÅÅ›  ÄÅÅ¤  s2 [Ã¢ÂˆÂ’1, 7] Ã¢Â‰Â¤ t1 [1, 0],  ÄÅÂ¸.  s1 = s2 [1, 0] + ite ÄÅÂ­ s2 [Ã¢ÂˆÂ’1, 0],  s2  s2 = (s1 + t2 [Ã¢ÂˆÂ’2, 1]).  Its dependency graph, shown in Figure 1, has three edges  from s1 to s2 , with weights 1, 0, Ã¢ÂˆÂ’1, and one zero  weighted edge from s2 back to s1 . There is one edge  from s1 to t1 , and one from s2 to t2 .  A walk of a graph is a sequence v1 , . . . , vk+1 of  vertices, for k Ã¢Â‰Ä½ 1, and edges e1 , . . . , ek , such that  ei : hvi , vi+1 , wi i. The walk is closed iff v1 = vk+1 .  The total weight of a walk is the sum of weights of its  edges.  Definition 4 (Well-Formed Specifications) A L OLA  specification is well-formed if there is no closed-walk  with total weight zero in its dependency graph.  Theorem 1 Every well-formed L OLA specification is  well-defined.  All proofs will be available in an extended version of this  document. The following alternative characterization of  well-formedness is useful for algorithmic purposes and  for the offline monitoring algorithm.  @ABC  GFED  t1 o  1  @ABC  GFED  s1 l  1,0,Ã¢ÂˆÂ’1  @ABC  GFED  , s  2  0  Ã¢ÂˆÂ’2  @ABC  GFED  / t2  Fig. 1: Dependency graph for the specification of Example 4.  Theorem 2 A L OLA specification is well-formed iff no  strongly connected component in G has both a positive  and a negative weighted cycle.  The converse of Theorem 1 is not true: not every welldefined L OLA specification need be well-formed. For  instance, the specification s = s Ã¢ÂˆÂ§ Ã‚Å¹s is well-defined,  but not well-formed.  C. Statistics and Context-free Properties  We shall now demonstrate the use of our specification  language for computing statistical properties over trace  data. Numerical properties over traces are essential as  (1) components of correctness properties that involve  counts, maxima or minima over trace data, and (2)  estimating performance and coverage metrics in the form  of averages.  L OLA can be used to compute incremental statistics,  i.e., measures that are defined using an update function  fÃÄ… (v, u) where u represents the measure thus far, and  v represents the new incoming data. Given a sequence  of values v1 , . . . , vn , with a special default value d, the  statistic over the data is defined in the reverse sense as  v = fÃÄ… (v1 , fÃÄ… (v2 , . . . , fÃÄ… (vn , d)))  or in the forward sense as  v = fÃÄ… (vn , fÃÄ… (vnÃ¢ÂˆÂ’1 , . . . , fÃÄ… (v1 , d)))  Examples of such statistical measures include count with  fcount (v, u) = u+1, sum with fsum (v, u) = v +u, max  with fmax (u, v) = max (u, v), among many others; the  statistical average can be incrementally defined as a pair  consisting of the sum and the count.  Given an update function fÃÄ… and a data-stream v ,  the following L OLA queries compute the statistic in the  forward and reverse senses respectively:  stat f = fÃÄ… (stat f [Ã¢ÂˆÂ’1, d], v) ,  stat r = fÃÄ… (stat r [1, d], v) .  For most common incremental statistical measures, either of these L OLA queries compute the same result.  The choice of a monitoring strategy can dictate the use  of one over another as will be evident in the subsequent  section.  The use of numeric data also increases the expressiveness of the language; it enables the expression of  context-free properties. Commonly encountered contextfree properties include properties such as Ã¢Â€Âœevery request  has a matching grant.Ã¢Â€Â In programs, we may use such  properties to verify that every lock acquired has been released, or that every memory cell allocated is eventually  freed exactly once.  Example 5 Consider the property: Ã¢Â€Âœthe number of aÃ¢Â€Â™s  must always be no less than the number of bÃ¢Â€Â™s.Ã¢Â€Â This  property can be expressed in L OLA as  s = s[Ã¢ÂˆÂ’1, 0] + ite((a Ã¢ÂˆÂ§ Ã‚Å¹b), 1, 0)  + ite((b Ã¢ÂˆÂ§ Ã‚Å¹a), Ã¢ÂˆÂ’1, 0)  trigger(s Ã¢Â‰Â¤ 0)  Integer streams in a L OLA specification enable the  expression of context-free properties by being used as  counters to model stacks. For instance, a two alphabet  stack with alphabet symbols 0 and 1 can be modelled  by a counter. Each pop is implemented by dividing the  counter by 2, thereby eliminating the least significant bit.  Each push is modelled by a multiplication by 2 followed  by addition, thereby setting the least significant bit. Thus,  with one (unbounded) counter, a L OLA specification can  express context-free properties.  It can be shown that L OLA specifications with only  boolean streams cannot express context-free properties.  III. M ONITORING A LGORITHM  In this section, we first describe the setting for  the monitoring problem considered in the paper. We  then describe our monitoring algorithm using partial  evaluation of the equational semantics.  A. Monitoring Setup  We distinguish two situations for monitoring Ã¢Â€Â” online  and offline monitoring. With online monitoring, system  behaviors are observed as the system is run under a  test/real-life setting. In a simulation setting, we can  assume that the monitor is working in tandem with  the simulator, with the monitor processing a few trace  positions while the simulator waits, and then the monitor  waiting while the simulation proceeds to produce the  next few positions. On the other hand, offline monitoring  assumes that the system has been run to completion,  and the trace data was dumped to a storage device. This  leads to the following restriction for online monitoring:  the traces are available a few points at a time starting  from time 0 onwards, and need to be processed online to  make way for more incoming data. In particular, random  access to the traces is not available.  B. Online Monitoring Algorithm  In online monitoring we assume that the trace is  available one position at a time, starting from time 0.  The length of the trace is assumed to be unknown and  large.  Let t1 , . . . , tm be independent (input) stream variables,  and s1 , . . . , sn be dependent (output) stream variables.  Let j Ã¢Â‰Ä½ 0 be the current position where the latest trace  data is available from all the input streams.  Evaluation Algorithm: The evaluation algorithm  maintains two stores of equations:  Ã¢Â€Ë˜ Resolved equations R of the form ÄÂƒi (j) = c, or  ÄÂ„i (j) = c, for constant c.  Ã¢Â€Ë˜ Unresolved equations U of the form ÄÂƒi (j) = ei for  all other stream expressions ei .  Initially both stores are empty. At the arrival of input  stream data for a particular position j , 0 Ã¢Â‰Â¤ j Ã¢Â‰Â¤ N ,  that is, when ÄÂ„1 (j), . . . , ÄÂ„m (j) become available, the  following steps are carried out:  1) The equations ÄÂ„1 (j) = c1 , . . . , ÄÂ„m (j) = cm are  added to R,  2) The associated equations for ÄÂƒ1 (j), . . . , ÄÂƒn (j) are  added to U ,  3) The equations in U are simplified as much as  possible; if an equation becomes of the form  ÄÂƒi (j) = c, it is removed from U and added to R. If  c is true and the corresponding output variable si  is marked as a trigger, then a violation is reported.  4) For each stream ti ( also si ), there is a non-negative  constant ki such that ÄÂ„i (j Ã¢ÂˆÂ’ki ), if present in R can  be safely removed. The constant ki Ã¢Â‰Ä½ 0 is defined  as      k is non-negative and  .  ki = max k  ti [Ã¢ÂˆÂ’k, d] is a subexpression.  Intuitively, for any position j , j + ki is the latest  value in the future whose computation requires the  value of ÄÂ„i (j).  Example 6 To illustrate the last point, consider the  specification,  s = s[Ã¢ÂˆÂ’3, 0] + t.  Let ÄÂ„ be the input stream. The value of ki for s is 3  and for t is zero. This indicates that for any input stream  ÄÂ„ , the value ÄÂ„ (j) can be removed from R at position j  itself. Similarly any ÄÂƒ(j) Ã¢ÂˆÂˆ R may be removed from R  at (or after) position j + 3.  Equations in U are simplified using the following  rules:  1) Partial evaluation rules for function applications  such as,  true Ã¢ÂˆÂ§ e Ã¢Â†Â’ e, 0 + x Ã¢Â†Â’ x Ã‚Ë‡ Ã‚Ë‡ Ã‚Ë‡  2) Rewrite rules for if-then,  ite(true, e1 , e2 ) Ã¢Â†Â’ e1 Ã‚Ë‡ Ã‚Ë‡ Ã‚Ë‡  3) Substitution of resolved positions from R. If  ÄÂƒi (j) = c Ã¢ÂˆÂˆ R, then every occurrence of ÄÂƒi (j)  in U is substituted by c and possibly simplified  further.  We illustrate the operation of the algorithm on a simple  example.  Example 7 Let t1 , t2 be two input boolean stream variables. Consider the specification  ÄÂ• : s = t2 Ã¢ÂˆÂ¨ (t1 Ã¢ÂˆÂ§ s[1, false]),  which computes t1 Until t2 . The associated equations  for ÄÂ• are:  (  ÄÂ„2 (j) Ã¢ÂˆÂ¨ (ÄÂ„1 (j) Ã¢ÂˆÂ§ ÄÂƒ(j + 1)) j + 1 Ã¢Â‰Â¤ N  ÄÂƒ(j) =  ÄÂ„2 (j)  otherwise.  Let the input streams, ÄÂ„1 and ÄÂ„2 be given by  ÄÂ„1  ÄÂ„2  false  true  false  false  true  false  true  false  true  false  true  false  true  false  At position 0, we encounter hfalse, truei. The equation for ÄÂƒ(0) is  ÄÂƒ(0)  = ÄÂ„2 (0) Ã¢ÂˆÂ¨ (ÄÂ„1 (0) Ã¢ÂˆÂ§ ÄÂƒ(1))  Ã¢Â†Â’ true Ã¢ÂˆÂ¨ (false Ã¢ÂˆÂ§ ÄÂƒ(1))  Ã¢Â†Â’ true  and thus ÄÂƒ(0) = true is added to the resolved store R.  At position 1, we encounter hfalse, falsei and thus we  can set ÄÂƒ(1) = false , which is also added to R. From  j = 2 until j = 5, we encounter htrue, falsei. At each of  these positions the equations ÄÂƒ(j) = ÄÂƒ(j + 1) are added  to U . The equation store U now has the equations  ÄÂƒ(2) = ÄÂƒ(3), ÄÂƒ(3) = ÄÂƒ(4), . . . , ÄÂƒ(5) = ÄÂƒ(6).  At position 6, we encounter htrue, falsei with the added  information that the trace has ended. We set ÄÂƒ(6) = false  and add it to R. This lets us resolve the equations in U  and set all the positions from 2 to 6 to false .  Note that the equation associated with ÄÂƒi (j) on the  LHS is added only after the current position reaches  j , even if the term ÄÂƒi (j) appears on the RHS of some  equation before position j is reached.  The algorithm above works in time and space that  is linear in the length of the trace and the size of the  specification. Since the memory usage can be as large  as the length of the trace in the worst-case, the method  may not work for long simulations and large traces.  Example 8 Consider the following L OLA specification:  ended = false[1, true]  s = ite(ended , t, s[1, true])  in which the output stream ÄÂƒ takes the same value  everywhere that the input stream ÄÂ„ takes at the end of  the trace. The partial evaluation algorithm maintains the  unresolved ÄÂƒ(0), . . . , ÄÂƒ(N ). Such specifications cannot  be monitored efficiently. Furthermore, if the variable  s appears in other expressions, the evaluation of the  corresponding streams need to be delayed until ÄÂƒ can  be resolved.  In the next section we characterize an efficiently monitorable set of L OLA specifications based on the properties of their dependency graphs. The partial evaluation  algorithm will be shown to work efficiently for such  specifications.  C. Efficiently Monitorable Specifications  We present a class of specifications that are efficiently  monitorable. These specifications are guaranteed to limit  the number of unresolved equations in the memory to a  pre-determined constant that depends only on the size of  the specification and not on the size of the trace.  Definition 5 (Efficiently Monitorable Specifications)  A L OLA specification is efficiently monitorable (EM) if  its worst case memory requirement under our online  monitoring algorithm is constant in the size of the trace.  Example 9 Consider the specification Ã¢Â€ÂœEvery request  must be eventually followed by a grant before the trace  endsÃ¢Â€Â, which can be expressed as follows:  reqgrant = ite(request, evgrant, true)  evgrant = grant Ã¢ÂˆÂ¨ evgrant[1, false]  trigger (Ã‚Å¹ reqgrant)  The specification encodes the temporal assertion  (request Ã¢Â†Â’ Ã¢Â™Åš(grant)). Another way that produces  the same result is  waitgrant =    Ã‚Å¹grant Ã¢ÂˆÂ§    request Ã¢ÂˆÂ¨  waitgrant[Ã¢ÂˆÂ’1, false]  trigger ended Ã¢ÂˆÂ§ waitgrant     The stream waitgrant records if the monitor is currently  waiting for a grant. The monitor waits for a grant  whenever it encounters a request and stops waiting if  there is a grant . If the trace ends while the monitor is  still waiting, it triggers an error. The latter formulation  is efficiently monitorable, while the former is not. For  instance, at every time instance, waitgrant(i) is instantly  resolved given its previous value, and those of the input  streams. Thus, the simple partial evaluation algorithm  monitors the latter with very little, constant, buffering.  The following theorem characterizes efficiently monitorable L OLA specifications.  Theorem 3 If the dependency graph of a L OLA query  has no positive cycles then it is efficiently monitorable.  The converse of the theorem above does not hold  in general. However, in the absence of an alternative  syntactic characterization of EM specification, we shall  henceforth use the term EM specification to denote  queries whose dependency graphs do not contain positive  cycles.  Given graph G, that does not have any positive weight  cycles, we construct a graph G+ , obtained by removing  all negative weight edges from G. Furthermore, among  all the edges in G between two nodes si and sj , we  choose to add only that edge to G+ which has the  maximum positive weight. The graph G+ has no self  loops or multiple edges, and hence is a weighted directed  acyclic graph (DAG). For each node si Ã¢ÂˆÂˆ G+ , we define  Ã¢ÂˆÂ†i as follows:  ÄÅÄ…  ,  ÄÅÂ´  ÄÅË›0, if( there is no outgoing edge from si)  w(ej )  Ã¢ÂˆÂ†i =  ej : si Ã¢ÂˆÂ’Ã¢ÂˆÂ’Ã¢ÂˆÂ’Ã¢Â†Â’ sj  ÄÅÂ´  , ow .  ÄÅÅ‚max Ã¢ÂˆÂ†j + w(ej )  is an edge in G+  Example  tion:  s1  s2  s3  10 Consider the following L OLA specifica= t1 [1, false] Ã¢ÂˆÂ§ s3 [Ã¢ÂˆÂ’7, false]  = ite(s1 [2, true], t2 [2, 0], t2 [Ã¢ÂˆÂ’1, 2])  = (s2 [4, true] Ã¢Â‰Â¤ 5)  The dependency graph G is shown in Figure 2. The  values of the Ã¢ÂˆÂ† function are as follows:  Ã¢ÂˆÂ†(t1 ) = Ã¢ÂˆÂ†(t2 ) = 0, Ã¢ÂˆÂ†(s1 ) = 1, Ã¢ÂˆÂ†(s2 ) = 3, Ã¢ÂˆÂ†(s3 ) = 7.  Ã¢ÂˆÂ’7  v  @ABC  GFED  s3  4  @ABC  GFED  / s2  2  @ABC  GFED  / s1  2,Ã¢ÂˆÂ’1  1    @ABC  GFED  t2    @ABC  GFED  t1  (a) Dependency graph G.  @ABC  GFED  s3  4  @ABC  GFED  / s2  2  @ABC  GFED  / s1  2  1    @ABC  GFED  t2    @ABC  GFED  t1  (b) Derived graph G+ .  Fig. 2: The dependency graph G for Example 10 and its derived graph G+ .  The significance of the Ã¢ÂˆÂ† function is clear through the  following theorem.  Theorem 4 The partial evaluation algorithm resolves  any trace position ÄÂƒi (j) before time j + Ã¢ÂˆÂ†i .  The memory requirement is therefore constant in N  for an efficient specification. This number of unresolved  positions in U is upper-bounded by O(Ã¢ÂˆÂ†1 + Ã‚Ë‡ Ã‚Ë‡ Ã‚Ë‡ + Ã¢ÂˆÂ†n ).  For instance, computing the Ã¢ÂˆÂ† values for the queries  in Example 9, we find that Ã¢ÂˆÂ†(waitgrant) = 0. This  shows that the value of waitgrant resolves immediately,  given its previous value and the inputs. Our experimental  results in the subsequent section show that requiring  specifications to be efficiently monitorable is not unreasonable in practice. Furthermore, streams involved  in positive cycles can be discarded or even rewritten  (as shown in Example 9) for the purposes of online  monitoring.  The framework developed generalizes naturally to an  offline monitoring algorithm. Please refer to the full  version of this paper available online.  IV. A PPLICATIONS  There are numerous applications of this formalism. In  this section, we describe two such applications obtained  directly from the industry. Synopsys, Inc. provided some  circuit simulation dumps, along with specifications written in the industry standard System Verilog Assertions  (SVA)[18]. We were able to hand-translate the SVA  queries directly into L OLA specifications, a process that  is potentially mechanizable.  Our OC AML-based implementation of L OLA reads a  trace file and the specification file. It implements the  online monitoring algorithm described in Section III with  some direct optimizations. We have incorporated facilities for displaying dependency graphs of specifications.  The following two case studies were considered:  a) Memory Controller: A Verilog model for a  memory controller was simulated yielding 13 input  streams. The corresponding SVA assertions were handtranslated into a L OLA specification. The specification  had 21 intermediate streams and 15 output streams, all  of which were declared triggers. Properties enforced  included mutual exclusion of signals, correct transfers of  address and data, and timing specifications (e.g. signal  stability for 3 or 4 cycles). The specifications were not  EM : the dependency graph had three positive-sum cycles,  each encoding a temporal until operator. Figure 3 shows  the performance of L OLA on these traces.  b) PCI: We hand translated SVA assertions describing the PCI 2.2 specifications for the master. A circuit  implementing the master was simulated for varying times  to produce a set of traces to plot the performance. The  specification had 15 input streams, 161 output streams  and 87 trigger streams. Our initial implementation contained three positive weight cycles. We were able to  remove these by rewriting the queries carefully. Running  times can also be found in Figure 3. Bugs were deliberately introduced into the circuit in order to evaluate  the effectiveness of runtime verification. L OLA reports  numerous useful trigger violations for the longest trace.  V. C ONCLUSIONS  We have presented L OLA, a formalism for runtime  verification based on a functional language over finite streams equipped with a partial evaluation-based  strategy for online evaluation. Our formalism combines  runtime verification of boolean temporal specifications  with statistical measures to estimate coverage and specify  complex temporal patterns. By evaluating our system on  industrial strength specifications, we have demonstrated  that L OLA can express relevant properties. Using dependency graphs, we have characterized efficiently monitorable queries that can be monitored online efficiently  in terms of space. Based on our case-studies so far, the  restriction to efficiently monitorable specifications seems  # simulation steps  5000  10000  20000  50000  100000  200000  500000  1000000  Controller example  # clock pos. edges time (sec)  250  0.18  500  0.35  1000  0.71  2500  1.78  5000  3.47  10000  6.83  25000  17.02  50000  33.70  PCI example  # clock pos. edges  834  1667  3334  8334  16667  33334  83334  166667  time  4.62  8.87  19.04  29.47  52.53  99.17  236.96  467.98  Fig. 3: Running times for both examples. All timings were measured on an Intel Xeon Processor running Linux  2.4 with 2Gb RAM.  practical.  In the future, we intend to study automatic techniques  for rewriting non-EM specifications into efficiently monitorable ones where possible, and in further collaboration  with industry study the applicability of these techniques  for larger case studies. We expect that for such use  some syntactic sugar needs to be added to L OLA to  facilitate specification of common constructs. Also the  error reporting needs to be improved by synthesizing  explanations for each violation. Extensions to handle  synchronous systems with many clocks, asynchronous  systems, and distributed systems are also under consideration.  R EFERENCES  [1] K. Havelund and G. RosÄšÂ§u, Eds., Runtime Verification 2001  (RVÃ¢Â€Â™01), ser. ENTCS, vol. 55. Elsevier, 2001.  [2] Ã¢Â€Â”Ã¢Â€Â”, Runtime Verification 2002 (RVÃ¢Â€Â™02), ser. ENTCS, vol. 70,  no. 4. Elsevier, 2001.  [3] O. Sokolsky and M. Viswanathan, Eds., Runtime Verification  2002 (RVÃ¢Â€Â™03), ser. ENTCS, vol. 89, no. 2. Elsevier, 2003.  [4] N. Halbwachs, P. Caspi, P. Raymond, and D. Pilaud, Ã¢Â€ÂœThe  synchronous data-flow programming language LUSTRE,Ã¢Â€Â Proc.  of IEEE, vol. 79, no. 9, pp. 1305Ã¢Â€Â“1320, 1991.  [5] G. Berry, Proof, language, and interaction: essays in honour  of Robin Milner. MIT Press, 2000, ch. The foundations of  Esterel, pp. 425Ã¢Â€Â“454.  [6] I. Lee, S. Kannan, M. Kim, O. Sokolsky, and M. Viswanathan,  Ã¢Â€ÂœRuntime Assurance Based on Formal Specifications,Ã¢Â€Â in Proc.  of the International Conference on Parallel and Distributed  Processing Techniques and Applications, 1999.  [7] D. Drusinsky, Ã¢Â€ÂœThe temporal rover and the ATG rover,Ã¢Â€Â in SPIN  Model Cheking and Software Verification, 2000, pp. 323Ã¢Â€Â“330.  [8] K. Havelund and G. RosÄšÂ§u, Ã¢Â€ÂœSynthesizing monitors for safety  properties,Ã¢Â€Â in Proc. of TACASÃ¢Â€Â™02. Springer, 2002, pp. 342Ã¢Â€Â“  356.  [9] Z. Manna and A. Pnueli, Temporal Verification of Reactive  Systems: Safety. New York: Springer, 1995.  [10] O. Kupferman and M. Y. Vardi, Ã¢Â€ÂœModel checking of safety  properties,Ã¢Â€Â Formal Methods in System Design, vol. 19, no. 3,  pp. 291Ã¢Â€Â“314, 2001.  [11] K. Havelund and G. RosÄšÂ§u, Ã¢Â€ÂœAn overview of the runtime  verification tool java pathexplorer,Ã¢Â€Â Formal Methods for Systems  Design, vol. 24, no. 2, pp. 189Ã¢Â€Â“215, 2004.  [12] C. Eisner, D. Fisman, J. Havlicek, Y. Lustig, A. McIsaac,  and D. V. Campenhout, Ã¢Â€ÂœReasoning with temporal logic on  truncated paths,Ã¢Â€Â in Proc. of CAVÃ¢Â€Â™03, ser. LNCS, vol. 2725.  Springer, 2003, pp. 27Ã¢Â€Â“39.  [13] B. Finkbeiner, S. Sankaranarayanan, and H. B. Sipma, Ã¢Â€ÂœCollecting statistics over runtime executions,Ã¢Â€Â in [2].  [14] T. Gautier, P. Le Guernic, and L. Besnard, Ã¢Â€ÂœSIGNAL: A  declarative language for synchronous programming of realtime systems,Ã¢Â€Â in Proc. Conference on Functional Programming  Languages and Computer Architecture. Springer, 1987, pp.  257Ã¢Â€Â“277.  [15] K. Sen and G. RosÄšÂ§u, Ã¢Â€ÂœGenerating optimal monitors for extended  regular expressions,Ã¢Â€Â in [3].  [16] G. RosÄšÂ§u and K. Havelund, Ã¢Â€ÂœRewriting-based techniques for runtime verification,Ã¢Â€Â Journal of Automated Software Engineering  (to appear).  [17] H. Barringer, A. Goldberg, K. Havelund, and K. Sen, Ã¢Â€ÂœRulebased runtime verification,Ã¢Â€Â in Proc. of 5th International Conference VMCAIÃ¢Â€Â™04, ser. LNCS, vol. 2937. Springer, 2004, pp.  44Ã¢Â€Â“57.  [18] Ã¢Â€ÂœSystem verilog assertion homepage,Ã¢Â€Â 2003, [Online] Available:  http://www.eda.org/sv-ac. 